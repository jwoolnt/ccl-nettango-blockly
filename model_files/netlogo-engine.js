tortoise_require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){(function (){
'use strict';

var possibleNames = [
	'BigInt64Array',
	'BigUint64Array',
	'Float32Array',
	'Float64Array',
	'Int16Array',
	'Int32Array',
	'Int8Array',
	'Uint16Array',
	'Uint32Array',
	'Uint8Array',
	'Uint8ClampedArray'
];

var g = typeof globalThis === 'undefined' ? global : globalThis;

module.exports = function availableTypedArrays() {
	var out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],2:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":2,"buffer":4,"ieee754":22}],5:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var callBind = require('./');

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};

},{"./":6,"get-intrinsic":16}],6:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var GetIntrinsic = require('get-intrinsic');

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}

},{"function-bind":15,"get-intrinsic":16}],7:[function(require,module,exports){
(function (global){(function (){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory();
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define([], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory();
	}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native crypto in web worker (Browser)
	    if (typeof self !== 'undefined' && self.crypto) {
	        crypto = self.crypto;
	    }

	    // Native crypto from worker
	    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
	        crypto = globalThis.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof global !== 'undefined' && global.crypto) {
	        crypto = global.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && typeof require === 'function') {
	        try {
	            crypto = require('crypto');
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }());

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var j = 0; j < thatSigBytes; j += 4) {
	                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"crypto":3}],8:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));
},{"./core":7}],9:[function(require,module,exports){
(function (Buffer){(function (){


class ResizeableBuffer{
  constructor(size=100){
    this.size = size
    this.length = 0
    this.buf = Buffer.alloc(size)
  }
  prepend(val){
    if(Buffer.isBuffer(val)){
      const length = this.length + val.length
      if(length >= this.size){
        this.resize()
        if(length >= this.size){
          throw Error('INVALID_BUFFER_STATE')
        }
      }
      const buf = this.buf
      this.buf = Buffer.alloc(this.size)
      val.copy(this.buf, 0)
      buf.copy(this.buf, val.length)
      this.length += val.length
    }else{
      const length = this.length++
      if(length === this.size){
        this.resize()
      }
      const buf = this.clone()
      this.buf[0] = val
      buf.copy(this.buf,1, 0, length)
    }
  }
  append(val){
    const length = this.length++
    if(length === this.size){
      this.resize()
    }
    this.buf[length] = val
  }
  clone(){
    return Buffer.from(this.buf.slice(0, this.length))
  }
  resize(){
    const length = this.length
    this.size = this.size * 2
    const buf = Buffer.alloc(this.size)
    this.buf.copy(buf,0, 0, length)
    this.buf = buf
  }
  toString(encoding){
    if(encoding){
      return this.buf.slice(0, this.length).toString(encoding)
    }else{
      return Uint8Array.prototype.slice.call(this.buf.slice(0, this.length))
    }
  }
  toJSON(){
    return this.toString('utf8')
  }
  reset(){
    this.length = 0
  }
}

module.exports = ResizeableBuffer

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":4}],10:[function(require,module,exports){
(function (Buffer,setImmediate){(function (){

/*
CSV Parse

Please look at the [project documentation](https://csv.js.org/parse/) for
additional information.
*/

const { Transform } = require('stream')
const ResizeableBuffer = require('./ResizeableBuffer')

// white space characters
// https://en.wikipedia.org/wiki/Whitespace_character
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types
// \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff
const tab = 9
const nl = 10 // \n, 0x0A in hexadecimal, 10 in decimal
const np = 12
const cr = 13 // \r, 0x0D in hexadcimal, 13 in decimal
const space = 32
const boms = {
  // Note, the following are equals:
  // Buffer.from("\ufeff")
  // Buffer.from([239, 187, 191])
  // Buffer.from('EFBBBF', 'hex')
  'utf8': Buffer.from([239, 187, 191]),
  // Note, the following are equals:
  // Buffer.from "\ufeff", 'utf16le
  // Buffer.from([255, 254])
  'utf16le': Buffer.from([255, 254])
}

class Parser extends Transform {
  constructor(opts = {}){
    super({...{readableObjectMode: true}, ...opts, encoding: null})
    this.__originalOptions = opts
    this.__normalizeOptions(opts)
  }
  __normalizeOptions(opts){
    const options = {}
    // Merge with user options
    for(let opt in opts){
      options[underscore(opt)] = opts[opt]
    }
    // Normalize option `encoding`
    // Note: defined first because other options depends on it
    // to convert chars/strings into buffers.
    if(options.encoding === undefined || options.encoding === true){
      options.encoding = 'utf8'
    }else if(options.encoding === null || options.encoding === false){
      options.encoding = null
    }else if(typeof options.encoding !== 'string' && options.encoding !== null){
      throw new CsvError('CSV_INVALID_OPTION_ENCODING', [
        'Invalid option encoding:',
        'encoding must be a string or null to return a buffer,',
        `got ${JSON.stringify(options.encoding)}`
      ], options)
    }
    // Normalize option `bom`
    if(options.bom === undefined || options.bom === null || options.bom === false){
      options.bom = false
    }else if(options.bom !== true){
      throw new CsvError('CSV_INVALID_OPTION_BOM', [
        'Invalid option bom:', 'bom must be true,',
        `got ${JSON.stringify(options.bom)}`
      ], options)
    }
    // Normalize option `cast`
    let fnCastField = null
    if(options.cast === undefined || options.cast === null || options.cast === false || options.cast === ''){
      options.cast = undefined
    }else if(typeof options.cast === 'function'){
      fnCastField = options.cast
      options.cast = true
    }else if(options.cast !== true){
      throw new CsvError('CSV_INVALID_OPTION_CAST', [
        'Invalid option cast:', 'cast must be true or a function,',
        `got ${JSON.stringify(options.cast)}`
      ], options)
    }
    // Normalize option `cast_date`
    if(options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === ''){
      options.cast_date = false
    }else if(options.cast_date === true){
      options.cast_date = function(value){
        const date = Date.parse(value)
        return !isNaN(date) ? new Date(date) : value
      }
    }else{
      throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', [
        'Invalid option cast_date:', 'cast_date must be true or a function,',
        `got ${JSON.stringify(options.cast_date)}`
      ], options)
    }
    // Normalize option `columns`
    let fnFirstLineToHeaders = null
    if(options.columns === true){
      // Fields in the first line are converted as-is to columns
      fnFirstLineToHeaders = undefined
    }else if(typeof options.columns === 'function'){
      fnFirstLineToHeaders = options.columns
      options.columns = true
    }else if(Array.isArray(options.columns)){
      options.columns = normalizeColumnsArray(options.columns)
    }else if(options.columns === undefined || options.columns === null || options.columns === false){
      options.columns = false
    }else{
      throw new CsvError('CSV_INVALID_OPTION_COLUMNS', [
        'Invalid option columns:',
        'expect an array, a function or true,',
        `got ${JSON.stringify(options.columns)}`
      ], options)
    }
    // Normalize option `columns_duplicates_to_array`
    if(options.columns_duplicates_to_array === undefined || options.columns_duplicates_to_array === null || options.columns_duplicates_to_array === false){
      options.columns_duplicates_to_array = false
    }else if(options.columns_duplicates_to_array !== true){
      throw new CsvError('CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY', [
        'Invalid option columns_duplicates_to_array:',
        'expect an boolean,',
        `got ${JSON.stringify(options.columns_duplicates_to_array)}`
      ], options)
    }else if(options.columns === false){
      throw new CsvError('CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY', [
        'Invalid option columns_duplicates_to_array:',
        'the `columns` mode must be activated.'
      ], options)
    }
    // Normalize option `comment`
    if(options.comment === undefined || options.comment === null || options.comment === false || options.comment === ''){
      options.comment = null
    }else{
      if(typeof options.comment === 'string'){
        options.comment = Buffer.from(options.comment, options.encoding)
      }
      if(!Buffer.isBuffer(options.comment)){
        throw new CsvError('CSV_INVALID_OPTION_COMMENT', [
          'Invalid option comment:',
          'comment must be a buffer or a string,',
          `got ${JSON.stringify(options.comment)}`
        ], options)
      }
    }
    // Normalize option `delimiter`
    const delimiter_json = JSON.stringify(options.delimiter)
    if(!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter]
    if(options.delimiter.length === 0){
      throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [
        'Invalid option delimiter:',
        'delimiter must be a non empty string or buffer or array of string|buffer,',
        `got ${delimiter_json}`
      ], options)
    }
    options.delimiter = options.delimiter.map(function(delimiter){
      if(delimiter === undefined || delimiter === null || delimiter === false){
        return Buffer.from(',', options.encoding)
      }
      if(typeof delimiter === 'string'){
        delimiter = Buffer.from(delimiter, options.encoding)
      }
      if( !Buffer.isBuffer(delimiter) || delimiter.length === 0){
        throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [
          'Invalid option delimiter:',
          'delimiter must be a non empty string or buffer or array of string|buffer,',
          `got ${delimiter_json}`
        ], options)
      }
      return delimiter
    })
    // Normalize option `escape`
    if(options.escape === undefined || options.escape === true){
      options.escape = Buffer.from('"', options.encoding)
    }else if(typeof options.escape === 'string'){
      options.escape = Buffer.from(options.escape, options.encoding)
    }else if (options.escape === null || options.escape === false){
      options.escape = null
    }
    if(options.escape !== null){
      if(!Buffer.isBuffer(options.escape)){
        throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`)
      }
    }
    // Normalize option `from`
    if(options.from === undefined || options.from === null){
      options.from = 1
    }else{
      if(typeof options.from === 'string' && /\d+/.test(options.from)){
        options.from = parseInt(options.from)
      }
      if(Number.isInteger(options.from)){
        if(options.from < 0){
          throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`)
        }
      }else{
        throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`)
      }
    }
    // Normalize option `from_line`
    if(options.from_line === undefined || options.from_line === null){
      options.from_line = 1
    }else{
      if(typeof options.from_line === 'string' && /\d+/.test(options.from_line)){
        options.from_line = parseInt(options.from_line)
      }
      if(Number.isInteger(options.from_line)){
        if(options.from_line <= 0){
          throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`)
        }
      }else{
        throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`)
      }
    }
    // Normalize options `ignore_last_delimiters`
    if(options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null){
      options.ignore_last_delimiters = false
    }else if(typeof options.ignore_last_delimiters === 'number'){
      options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters)
      if(options.ignore_last_delimiters === 0){
        options.ignore_last_delimiters = false
      }
    }else if(typeof options.ignore_last_delimiters !== 'boolean'){
      throw new CsvError('CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS', [
        'Invalid option `ignore_last_delimiters`:',
        'the value must be a boolean value or an integer,',
        `got ${JSON.stringify(options.ignore_last_delimiters)}`
      ], options)
    }
    if(options.ignore_last_delimiters === true && options.columns === false){
      throw new CsvError('CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS', [
        'The option `ignore_last_delimiters`',
        'requires the activation of the `columns` option'
      ], options)
    }
    // Normalize option `info`
    if(options.info === undefined || options.info === null || options.info === false){
      options.info = false
    }else if(options.info !== true){
      throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`)
    }
    // Normalize option `max_record_size`
    if(options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false){
      options.max_record_size = 0
    }else if(Number.isInteger(options.max_record_size) && options.max_record_size >= 0){
      // Great, nothing to do
    }else if(typeof options.max_record_size === 'string' && /\d+/.test(options.max_record_size)){
      options.max_record_size = parseInt(options.max_record_size)
    }else{
      throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`)
    }
    // Normalize option `objname`
    if(options.objname === undefined || options.objname === null || options.objname === false){
      options.objname = undefined
    }else if(Buffer.isBuffer(options.objname)){
      if(options.objname.length === 0){
        throw new Error(`Invalid Option: objname must be a non empty buffer`)
      }
      if(options.encoding === null){
        // Don't call `toString`, leave objname as a buffer
      }else{
        options.objname = options.objname.toString(options.encoding)
      }
    }else if(typeof options.objname === 'string'){
      if(options.objname.length === 0){
        throw new Error(`Invalid Option: objname must be a non empty string`)
      }
      // Great, nothing to do
    }else{
      throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`)
    }
    // Normalize option `on_record`
    if(options.on_record === undefined || options.on_record === null){
      options.on_record = undefined
    }else if(typeof options.on_record !== 'function'){
      throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', [
        'Invalid option `on_record`:',
        'expect a function,',
        `got ${JSON.stringify(options.on_record)}`
      ], options)
    }
    // Normalize option `quote`
    if(options.quote === null || options.quote === false || options.quote === ''){
      options.quote = null
    }else{
      if(options.quote === undefined || options.quote === true){
        options.quote = Buffer.from('"', options.encoding)
      }else if(typeof options.quote === 'string'){
        options.quote = Buffer.from(options.quote, options.encoding)
      }
      if(!Buffer.isBuffer(options.quote)){
        throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`)
      }
    }
    // Normalize option `raw`
    if(options.raw === undefined || options.raw === null || options.raw === false){
      options.raw = false
    }else if(options.raw !== true){
      throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`)
    }
    // Normalize option `record_delimiter`
    if(!options.record_delimiter){
      options.record_delimiter = []
    }else if(!Array.isArray(options.record_delimiter)){
      options.record_delimiter = [options.record_delimiter]
    }
    options.record_delimiter = options.record_delimiter.map( function(rd){
      if(typeof rd === 'string'){
        rd = Buffer.from(rd, options.encoding)
      }
      return rd
    })
    // Normalize option `relax`
    if(typeof options.relax === 'boolean'){
      // Great, nothing to do
    }else if(options.relax === undefined || options.relax === null){
      options.relax = false
    }else{
      throw new Error(`Invalid Option: relax must be a boolean, got ${JSON.stringify(options.relax)}`)
    }
    // Normalize option `relax_column_count`
    if(typeof options.relax_column_count === 'boolean'){
      // Great, nothing to do
    }else if(options.relax_column_count === undefined || options.relax_column_count === null){
      options.relax_column_count = false
    }else{
      throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`)
    }
    if(typeof options.relax_column_count_less === 'boolean'){
      // Great, nothing to do
    }else if(options.relax_column_count_less === undefined || options.relax_column_count_less === null){
      options.relax_column_count_less = false
    }else{
      throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`)
    }
    if(typeof options.relax_column_count_more === 'boolean'){
      // Great, nothing to do
    }else if(options.relax_column_count_more === undefined || options.relax_column_count_more === null){
      options.relax_column_count_more = false
    }else{
      throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`)
    }
    // Normalize option `skip_empty_lines`
    if(typeof options.skip_empty_lines === 'boolean'){
      // Great, nothing to do
    }else if(options.skip_empty_lines === undefined || options.skip_empty_lines === null){
      options.skip_empty_lines = false
    }else{
      throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`)
    }
    // Normalize option `skip_lines_with_empty_values`
    if(typeof options.skip_lines_with_empty_values === 'boolean'){
      // Great, nothing to do
    }else if(options.skip_lines_with_empty_values === undefined || options.skip_lines_with_empty_values === null){
      options.skip_lines_with_empty_values = false
    }else{
      throw new Error(`Invalid Option: skip_lines_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_lines_with_empty_values)}`)
    }
    // Normalize option `skip_lines_with_error`
    if(typeof options.skip_lines_with_error === 'boolean'){
      // Great, nothing to do
    }else if(options.skip_lines_with_error === undefined || options.skip_lines_with_error === null){
      options.skip_lines_with_error = false
    }else{
      throw new Error(`Invalid Option: skip_lines_with_error must be a boolean, got ${JSON.stringify(options.skip_lines_with_error)}`)
    }
    // Normalize option `rtrim`
    if(options.rtrim === undefined || options.rtrim === null || options.rtrim === false){
      options.rtrim = false
    }else if(options.rtrim !== true){
      throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`)
    }
    // Normalize option `ltrim`
    if(options.ltrim === undefined || options.ltrim === null || options.ltrim === false){
      options.ltrim = false
    }else if(options.ltrim !== true){
      throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`)
    }
    // Normalize option `trim`
    if(options.trim === undefined || options.trim === null || options.trim === false){
      options.trim = false
    }else if(options.trim !== true){
      throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`)
    }
    // Normalize options `trim`, `ltrim` and `rtrim`
    if(options.trim === true && opts.ltrim !== false){
      options.ltrim = true
    }else if(options.ltrim !== true){
      options.ltrim = false
    }
    if(options.trim === true && opts.rtrim !== false){
      options.rtrim = true
    }else if(options.rtrim !== true){
      options.rtrim = false
    }
    // Normalize option `to`
    if(options.to === undefined || options.to === null){
      options.to = -1
    }else{
      if(typeof options.to === 'string' && /\d+/.test(options.to)){
        options.to = parseInt(options.to)
      }
      if(Number.isInteger(options.to)){
        if(options.to <= 0){
          throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`)
        }
      }else{
        throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`)
      }
    }
    // Normalize option `to_line`
    if(options.to_line === undefined || options.to_line === null){
      options.to_line = -1
    }else{
      if(typeof options.to_line === 'string' && /\d+/.test(options.to_line)){
        options.to_line = parseInt(options.to_line)
      }
      if(Number.isInteger(options.to_line)){
        if(options.to_line <= 0){
          throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`)
        }
      }else{
        throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`)
      }
    }
    this.info = {
      bytes: 0,
      comment_lines: 0,
      empty_lines: 0,
      invalid_field_length: 0,
      lines: 1,
      records: 0
    }
    this.options = options
    this.state = {
      bomSkipped: false,
      bufBytesStart: 0,
      castField: fnCastField,
      commenting: false,
      // Current error encountered by a record
      error: undefined,
      enabled: options.from_line === 1,
      escaping: false,
      // escapeIsQuote: options.escape === options.quote,
      escapeIsQuote: Buffer.isBuffer(options.escape) && Buffer.isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,
      // columns can be `false`, `true`, `Array`
      expectedRecordLength: Array.isArray(options.columns) ? options.columns.length : undefined,
      field: new ResizeableBuffer(20),
      firstLineToHeaders: fnFirstLineToHeaders,
      needMoreDataSize: Math.max(
        // Skip if the remaining buffer smaller than comment
        options.comment !== null ? options.comment.length : 0,
        // Skip if the remaining buffer can be delimiter
        ...options.delimiter.map( (delimiter) => delimiter.length),
        // Skip if the remaining buffer can be escape sequence
        options.quote !== null ? options.quote.length : 0,
      ),
      previousBuf: undefined,
      quoting: false,
      stop: false,
      rawBuffer: new ResizeableBuffer(100),
      record: [],
      recordHasError: false,
      record_length: 0,
      recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 2 : Math.max(...options.record_delimiter.map( (v) => v.length)),
      trimChars: [Buffer.from(' ', options.encoding)[0], Buffer.from('\t', options.encoding)[0]],
      wasQuoting: false,
      wasRowDelimiter: false
    }
  }
  // Implementation of `Transform._transform`
  _transform(buf, encoding, callback){
    if(this.state.stop === true){
      return
    }
    const err = this.__parse(buf, false)
    if(err !== undefined){
      this.state.stop = true
    }
    callback(err)
  }
  // Implementation of `Transform._flush`
  _flush(callback){
    if(this.state.stop === true){
      return
    }
    const err = this.__parse(undefined, true)
    callback(err)
  }
  // Central parser implementation
  __parse(nextBuf, end){
    const {bom, comment, escape, from_line, ltrim, max_record_size, quote, raw, relax, rtrim, skip_empty_lines, to, to_line} = this.options
    let {record_delimiter} = this.options
    const {bomSkipped, previousBuf, rawBuffer, escapeIsQuote} = this.state
    let buf
    if(previousBuf === undefined){
      if(nextBuf === undefined){
        // Handle empty string
        this.push(null)
        return
      }else{
        buf = nextBuf
      }
    }else if(previousBuf !== undefined && nextBuf === undefined){
      buf = previousBuf
    }else{
      buf = Buffer.concat([previousBuf, nextBuf])
    }
    // Handle UTF BOM
    if(bomSkipped === false){
      if(bom === false){
        this.state.bomSkipped = true
      }else if(buf.length < 3){
        // No enough data
        if(end === false){
          // Wait for more data
          this.state.previousBuf = buf
          return
        }
      }else{
        for(let encoding in boms){
          if(boms[encoding].compare(buf, 0, boms[encoding].length) === 0){
            // Skip BOM
            let bomLength = boms[encoding].length
            this.state.bufBytesStart += bomLength
            buf = buf.slice(bomLength)
            // Renormalize original options with the new encoding
            this.__normalizeOptions({...this.__originalOptions, encoding: encoding})
            break
          }
        }
        this.state.bomSkipped = true
      }
    }
    const bufLen = buf.length
    let pos
    for(pos = 0; pos < bufLen; pos++){
      // Ensure we get enough space to look ahead
      // There should be a way to move this out of the loop
      if(this.__needMoreData(pos, bufLen, end)){
        break
      }
      if(this.state.wasRowDelimiter === true){
        this.info.lines++
        this.state.wasRowDelimiter = false
      }
      if(to_line !== -1 && this.info.lines > to_line){
        this.state.stop = true
        this.push(null)
        return
      }
      // Auto discovery of record_delimiter, unix, mac and windows supported
      if(this.state.quoting === false && record_delimiter.length === 0){
        const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos)
        if(record_delimiterCount){
          record_delimiter = this.options.record_delimiter
        }
      }
      const chr = buf[pos]
      if(raw === true){
        rawBuffer.append(chr)
      }
      if((chr === cr || chr === nl) && this.state.wasRowDelimiter === false ){
        this.state.wasRowDelimiter = true
      }
      // Previous char was a valid escape char
      // treat the current char as a regular char
      if(this.state.escaping === true){
        this.state.escaping = false
      }else{
        // Escape is only active inside quoted fields
        // We are quoting, the char is an escape chr and there is a chr to escape
        // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){
        if(escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen){
          if(escapeIsQuote){
            if(this.__isQuote(buf, pos+escape.length)){
              this.state.escaping = true
              pos += escape.length - 1
              continue
            }
          }else{
            this.state.escaping = true
            pos += escape.length - 1
            continue
          }
        }
        // Not currently escaping and chr is a quote
        // TODO: need to compare bytes instead of single char
        if(this.state.commenting === false && this.__isQuote(buf, pos)){
          if(this.state.quoting === true){
            const nextChr = buf[pos+quote.length]
            const isNextChrTrimable = rtrim && this.__isCharTrimable(nextChr)
            const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos+quote.length, nextChr)
            const isNextChrDelimiter = this.__isDelimiter(buf, pos+quote.length, nextChr)
            const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos+quote.length) : this.__isRecordDelimiter(nextChr, buf, pos+quote.length)
            // Escape a quote
            // Treat next char as a regular character
            if(escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)){
              pos += escape.length - 1
            }else if(!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable){
              this.state.quoting = false
              this.state.wasQuoting = true
              pos += quote.length - 1
              continue
            }else if(relax === false){
              const err = this.__error(
                new CsvError('CSV_INVALID_CLOSING_QUOTE', [
                  'Invalid Closing Quote:',
                  `got "${String.fromCharCode(nextChr)}"`,
                  `at line ${this.info.lines}`,
                  'instead of delimiter, record delimiter, trimable character',
                  '(if activated) or comment',
                ], this.options, this.__infoField())
              )
              if(err !== undefined) return err
            }else{
              this.state.quoting = false
              this.state.wasQuoting = true
              this.state.field.prepend(quote)
              pos += quote.length - 1
            }
          }else{
            if(this.state.field.length !== 0){
              // In relax mode, treat opening quote preceded by chrs as regular
              if( relax === false ){
                const err = this.__error(
                  new CsvError('INVALID_OPENING_QUOTE', [
                    'Invalid Opening Quote:',
                    `a quote is found inside a field at line ${this.info.lines}`,
                  ], this.options, this.__infoField(), {
                    field: this.state.field,
                  })
                )
                if(err !== undefined) return err
              }
            }else{
              this.state.quoting = true
              pos += quote.length - 1
              continue
            }
          }
        }
        if(this.state.quoting === false){
          let recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos)
          if(recordDelimiterLength !== 0){
            // Do not emit comments which take a full line
            const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0)
            if(skipCommentLine){
              this.info.comment_lines++
              // Skip full comment line
            }else{
              // Activate records emition if above from_line
              if(this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1: 0) >= from_line){
                this.state.enabled = true
                this.__resetField()
                this.__resetRecord()
                pos += recordDelimiterLength - 1
                continue
              }
              // Skip if line is empty and skip_empty_lines activated
              if(skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0){
                this.info.empty_lines++
                pos += recordDelimiterLength - 1
                continue
              }
              this.info.bytes = this.state.bufBytesStart + pos;
              const errField = this.__onField()
              if(errField !== undefined) return errField
              this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;
              const errRecord = this.__onRecord()
              if(errRecord !== undefined) return errRecord
              if(to !== -1 && this.info.records >= to){
                this.state.stop = true
                this.push(null)
                return
              }
            }
            this.state.commenting = false
            pos += recordDelimiterLength - 1
            continue
          }
          if(this.state.commenting){
            continue
          }
          const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr)
          if(commentCount !== 0){
            this.state.commenting = true
            continue
          }
          let delimiterLength = this.__isDelimiter(buf, pos, chr)
          if(delimiterLength !== 0){
            this.info.bytes = this.state.bufBytesStart + pos;
            const errField = this.__onField()
            if(errField !== undefined) return errField
            pos += delimiterLength - 1
            continue
          }
        }
      }
      if(this.state.commenting === false){
        if(max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size){
          const err = this.__error(
            new CsvError('CSV_MAX_RECORD_SIZE', [
              'Max Record Size:',
              'record exceed the maximum number of tolerated bytes',
              `of ${max_record_size}`,
              `at line ${this.info.lines}`,
            ], this.options, this.__infoField())
          )
          if(err !== undefined) return err
        }
      }
      const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(chr)
      // rtrim in non quoting is handle in __onField
      const rappend = rtrim === false || this.state.wasQuoting === false
      if( lappend === true && rappend === true ){
        this.state.field.append(chr)
      }else if(rtrim === true && !this.__isCharTrimable(chr)){
        const err = this.__error(
          new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', [
            'Invalid Closing Quote:',
            'found non trimable byte after quote',
            `at line ${this.info.lines}`,
          ], this.options, this.__infoField())
        )
        if(err !== undefined) return err
      }
    }
    if(end === true){
      // Ensure we are not ending in a quoting state
      if(this.state.quoting === true){
        const err = this.__error(
          new CsvError('CSV_QUOTE_NOT_CLOSED', [
            'Quote Not Closed:',
            `the parsing is finished with an opening quote at line ${this.info.lines}`,
          ], this.options, this.__infoField())
        )
        if(err !== undefined) return err
      }else{
        // Skip last line if it has no characters
        if(this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0){
          this.info.bytes = this.state.bufBytesStart + pos;
          const errField = this.__onField()
          if(errField !== undefined) return errField
          const errRecord = this.__onRecord()
          if(errRecord !== undefined) return errRecord
        }else if(this.state.wasRowDelimiter === true){
          this.info.empty_lines++
        }else if(this.state.commenting === true){
          this.info.comment_lines++
        }
      }
    }else{
      this.state.bufBytesStart += pos
      this.state.previousBuf = buf.slice(pos)
    }
    if(this.state.wasRowDelimiter === true){
      this.info.lines++
      this.state.wasRowDelimiter = false
    }
  }
  __onRecord(){
    const {columns, columns_duplicates_to_array, encoding, info, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_lines_with_empty_values} = this.options
    const {enabled, record} = this.state
    if(enabled === false){
      return this.__resetRecord()
    }
    // Convert the first line into column names
    const recordLength = record.length
    if(columns === true){
      if(skip_lines_with_empty_values === true && isRecordEmpty(record)){
        this.__resetRecord()
        return
      }
      return this.__firstLineToColumns(record)
    }
    if(columns === false && this.info.records === 0){
      this.state.expectedRecordLength = recordLength
    }
    if(recordLength !== this.state.expectedRecordLength){
      const err = columns === false ?
        // Todo: rename CSV_INCONSISTENT_RECORD_LENGTH to
        // CSV_RECORD_INCONSISTENT_FIELDS_LENGTH
        new CsvError('CSV_INCONSISTENT_RECORD_LENGTH', [
          'Invalid Record Length:',
          `expect ${this.state.expectedRecordLength},`,
          `got ${recordLength} on line ${this.info.lines}`,
        ], this.options, this.__infoField(), {
          record: record,
        })
      :
        // Todo: rename CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH to
        // CSV_RECORD_INCONSISTENT_COLUMNS
        new CsvError('CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH', [
          'Invalid Record Length:',
          `columns length is ${columns.length},`, // rename columns
          `got ${recordLength} on line ${this.info.lines}`,
        ], this.options, this.__infoField(), {
          record: record,
        })
      if(relax_column_count === true ||
        (relax_column_count_less === true && recordLength < this.state.expectedRecordLength) ||
        (relax_column_count_more === true && recordLength > this.state.expectedRecordLength) ){
        this.info.invalid_field_length++
        this.state.error = err
      // Error is undefined with skip_lines_with_error
      }else{
        const finalErr = this.__error(err)
        if(finalErr) return finalErr
      }
    }
    if(skip_lines_with_empty_values === true && isRecordEmpty(record)){
      this.__resetRecord()
      return
    }
    if(this.state.recordHasError === true){
      this.__resetRecord()
      this.state.recordHasError = false
      return
    }
    this.info.records++
    if(from === 1 || this.info.records >= from){
      // With columns, records are object
      if(columns !== false){
        const obj = {}
        // Transform record array to an object
        for(let i = 0, l = record.length; i < l; i++){
          if(columns[i] === undefined || columns[i].disabled) continue
          // Turn duplicate columns into an array
          if (columns_duplicates_to_array === true && obj[columns[i].name] !== undefined) {
            if (Array.isArray(obj[columns[i].name])) {
              obj[columns[i].name] = obj[columns[i].name].concat(record[i])
            } else {
              obj[columns[i].name] = [obj[columns[i].name], record[i]]
            }
          } else {
            obj[columns[i].name] = record[i]
          }
        }
        const {objname} = this.options
        // Without objname (default)
        if(objname === undefined){
          if(raw === true || info === true){
            const err = this.__push(Object.assign(
              {record: obj},
              (raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {}),
              (info === true ? {info: this.__infoRecord()}: {})
            ))
            if(err){
              return err
            }
          }else{
            const err = this.__push(obj)
            if(err){
              return err
            }
          }
        // With objname (default)
        }else{
          if(raw === true || info === true){
            const err = this.__push(Object.assign(
              {record: [obj[objname], obj]},
              raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {},
              info === true ? {info: this.__infoRecord()}: {}
            ))
            if(err){
              return err
            }
          }else{
            const err = this.__push([obj[objname], obj])
            if(err){
              return err
            }
          }
        }
      // Without columns, records are array
      }else{
        if(raw === true || info === true){
          const err = this.__push(Object.assign(
            {record: record},
            raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {},
            info === true ? {info: this.__infoRecord()}: {}
          ))
          if(err){
            return err
          }
        }else{
          const err = this.__push(record)
          if(err){
            return err
          }
        }
      }
    }
    this.__resetRecord()
  }
  __firstLineToColumns(record){
    const {firstLineToHeaders} = this.state
    try{
      const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record)
      if(!Array.isArray(headers)){
        return this.__error(
          new CsvError('CSV_INVALID_COLUMN_MAPPING', [
            'Invalid Column Mapping:',
            'expect an array from column function,',
            `got ${JSON.stringify(headers)}`
          ], this.options, this.__infoField(), {
            headers: headers,
          })
        )
      }
      const normalizedHeaders = normalizeColumnsArray(headers)
      this.state.expectedRecordLength = normalizedHeaders.length
      this.options.columns = normalizedHeaders
      this.__resetRecord()
      return
    }catch(err){
      return err
    }
  }
  __resetRecord(){
    if(this.options.raw === true){
      this.state.rawBuffer.reset()
    }
    this.state.error = undefined
    this.state.record = []
    this.state.record_length = 0
  }
  __onField(){
    const {cast, encoding, rtrim, max_record_size} = this.options
    const {enabled, wasQuoting} = this.state
    // Short circuit for the from_line options
    if(enabled === false){
      return this.__resetField()
    }
    let field = this.state.field.toString(encoding)
    if(rtrim === true && wasQuoting === false){
      field = field.trimRight()
    }
    if(cast === true){
      const [err, f] = this.__cast(field)
      if(err !== undefined) return err
      field = f
    }
    this.state.record.push(field)
    // Increment record length if record size must not exceed a limit
    if(max_record_size !== 0 && typeof field === 'string'){
      this.state.record_length += field.length
    }
    this.__resetField()
  }
  __resetField(){
    this.state.field.reset()
    this.state.wasQuoting = false
  }
  __push(record){
    const {on_record} = this.options
    if(on_record !== undefined){
      const info = this.__infoRecord()
      try{
        record = on_record.call(null, record, info)
      }catch(err){
        return err
      }
      if(record === undefined || record === null){ return }
    }
    this.push(record)
  }
  // Return a tuple with the error and the casted value
  __cast(field){
    const {columns, relax_column_count} = this.options
    const isColumns = Array.isArray(columns)
    // Dont loose time calling cast
    // because the final record is an object
    // and this field can't be associated to a key present in columns
    if( isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length ){
      return [undefined, undefined]
    }
    if(this.state.castField !== null){
      try{
        const info = this.__infoField()
        return [undefined, this.state.castField.call(null, field, info)]
      }catch(err){
        return [err]
      }
    }
    if(this.__isFloat(field)){
      return [undefined, parseFloat(field)]
    }else if(this.options.cast_date !== false){
      const info = this.__infoField()
      return [undefined, this.options.cast_date.call(null, field, info)]
    }
    return [undefined, field]
  }
  // Helper to test if a character is a space or a line delimiter
  __isCharTrimable(chr){
    return chr === space || chr === tab || chr === cr || chr === nl || chr === np
  }
  // Keep it in case we implement the `cast_int` option
  // __isInt(value){
  //   // return Number.isInteger(parseInt(value))
  //   // return !isNaN( parseInt( obj ) );
  //   return /^(\-|\+)?[1-9][0-9]*$/.test(value)
  // }
  __isFloat(value){
    return (value - parseFloat( value ) + 1) >= 0 // Borrowed from jquery
  }
  __compareBytes(sourceBuf, targetBuf, targetPos, firstByte){
    if(sourceBuf[0] !== firstByte) return 0
    const sourceLength = sourceBuf.length
    for(let i = 1; i < sourceLength; i++){
      if(sourceBuf[i] !== targetBuf[targetPos+i]) return 0
    }
    return sourceLength
  }
  __needMoreData(i, bufLen, end){
    if(end) return false
    const {quote} = this.options
    const {quoting, needMoreDataSize, recordDelimiterMaxLength} = this.state
    const numOfCharLeft = bufLen - i - 1
    const requiredLength = Math.max(
      needMoreDataSize,
      // Skip if the remaining buffer smaller than record delimiter
      recordDelimiterMaxLength,
      // Skip if the remaining buffer can be record delimiter following the closing quote
      // 1 is for quote.length
      quoting ? (quote.length + recordDelimiterMaxLength) : 0,
    )
    return numOfCharLeft < requiredLength
  }
  __isDelimiter(buf, pos, chr){
    const {delimiter, ignore_last_delimiters} = this.options
    if(ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1){
      return 0
    }else if(ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1){
      return 0
    }
    loop1: for(let i = 0; i < delimiter.length; i++){
      const del = delimiter[i]
      if(del[0] === chr){
        for(let j = 1; j < del.length; j++){
          if(del[j] !== buf[pos+j]) continue loop1
        }
        return del.length
      }
    }
    return 0
  }
  __isRecordDelimiter(chr, buf, pos){
    const {record_delimiter} = this.options
    const recordDelimiterLength = record_delimiter.length
    loop1: for(let i = 0; i < recordDelimiterLength; i++){
      const rd = record_delimiter[i]
      const rdLength = rd.length
      if(rd[0] !== chr){
        continue
      }
      for(let j = 1; j < rdLength; j++){
        if(rd[j] !== buf[pos+j]){
          continue loop1
        }
      }
      return rd.length
    }
    return 0
  }
  __isEscape(buf, pos, chr){
    const {escape} = this.options
    if(escape === null) return false
    const l = escape.length
    if(escape[0] === chr){
      for(let i = 0; i < l; i++){
        if(escape[i] !== buf[pos+i]){
          return false
        }
      }
      return true
    }
    return false
  }
  __isQuote(buf, pos){
    const {quote} = this.options
    if(quote === null) return false
    const l = quote.length
    for(let i = 0; i < l; i++){
      if(quote[i] !== buf[pos+i]){
        return false
      }
    }
    return true
  }
  __autoDiscoverRecordDelimiter(buf, pos){
    const {encoding} = this.options
    const chr = buf[pos]
    if(chr === cr){
      if(buf[pos+1] === nl){
        this.options.record_delimiter.push(Buffer.from('\r\n', encoding))
        this.state.recordDelimiterMaxLength = 2
        return 2
      }else{
        this.options.record_delimiter.push(Buffer.from('\r', encoding))
        this.state.recordDelimiterMaxLength = 1
        return 1
      }
    }else if(chr === nl){
      this.options.record_delimiter.push(Buffer.from('\n', encoding))
      this.state.recordDelimiterMaxLength = 1
      return 1
    }
    return 0
  }
  __error(msg){
    const {skip_lines_with_error} = this.options
    const err = typeof msg === 'string' ? new Error(msg) : msg
    if(skip_lines_with_error){
      this.state.recordHasError = true
      this.emit('skip', err)
      return undefined
    }else{
      return err
    }
  }
  __infoDataSet(){
    return {
      ...this.info,
      columns: this.options.columns
    }
  }
  __infoRecord(){
    const {columns} = this.options
    return {
      ...this.__infoDataSet(),
      error: this.state.error,
      header: columns === true,
      index: this.state.record.length,
    }
  }
  __infoField(){
    const {columns} = this.options
    const isColumns = Array.isArray(columns)
    return {
      ...this.__infoRecord(),
      column: isColumns === true ?
        ( columns.length > this.state.record.length ?
          columns[this.state.record.length].name :
          null
        ) :
        this.state.record.length,
      quoting: this.state.wasQuoting,
    }
  }
}

const parse = function(){
  let data, options, callback
  for(let i in arguments){
    const argument = arguments[i]
    const type = typeof argument
    if(data === undefined && (typeof argument === 'string' || Buffer.isBuffer(argument))){
      data = argument
    }else if(options === undefined && isObject(argument)){
      options = argument
    }else if(callback === undefined && type === 'function'){
      callback = argument
    }else{
      throw new CsvError('CSV_INVALID_ARGUMENT', [
        'Invalid argument:',
        `got ${JSON.stringify(argument)} at index ${i}`
      ], options || {})
    }
  }
  const parser = new Parser(options)
  if(callback){
    const records = options === undefined || options.objname === undefined ? [] : {}
    parser.on('readable', function(){
      let record
      while((record = this.read()) !== null){
        if(options === undefined || options.objname === undefined){
          records.push(record)
        }else{
          records[record[0]] = record[1]
        }
      }
    })
    parser.on('error', function(err){
      callback(err, undefined, parser.__infoDataSet())
    })
    parser.on('end', function(){
      callback(undefined, records, parser.__infoDataSet())
    })
  }
  if(data !== undefined){
    // Give a chance for events to be registered later
    if(typeof setImmediate === 'function'){
      setImmediate(function(){
        parser.write(data)
        parser.end()
      })
    }else{
      parser.write(data)
      parser.end()
    }
  }
  return parser
}

class CsvError extends Error {
  constructor(code, message, options, ...contexts) {
    if(Array.isArray(message)) message = message.join(' ')
    super(message)
    if(Error.captureStackTrace !== undefined){
      Error.captureStackTrace(this, CsvError)
    }
    this.code = code
    for(const context of contexts){
      for(const key in context){
        const value = context[key]
        this[key] = Buffer.isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value))
      }
    }
  }
}

parse.Parser = Parser

parse.CsvError = CsvError

module.exports = parse

const underscore = function(str){
  return str.replace(/([A-Z])/g, function(_, match){
    return '_' + match.toLowerCase()
  })
}

const isObject = function(obj){
  return (typeof obj === 'object' && obj !== null && !Array.isArray(obj))
}

const isRecordEmpty = function(record){
  return record.every( (field) => field == null || field.toString && field.toString().trim() === '' )
}

const normalizeColumnsArray = function(columns){
  const normalizedColumns = [];
  for(let i = 0, l = columns.length; i < l; i++){
    const column = columns[i]
    if(column === undefined || column === null || column === false){
      normalizedColumns[i] = { disabled: true }
    }else if(typeof column === 'string'){
      normalizedColumns[i] = { name: column }
    }else if(isObject(column)){
      if(typeof column.name !== 'string'){
        throw new CsvError('CSV_OPTION_COLUMNS_MISSING_NAME', [
          'Option columns missing name:',
          `property "name" is required at position ${i}`,
          'when column is an object literal'
        ])
      }
      normalizedColumns[i] = column
    }else{
      throw new CsvError('CSV_INVALID_COLUMN_DEFINITION', [
        'Invalid column definition:',
        'expect a string or a literal object,',
        `got ${JSON.stringify(column)} at position ${i}`
      ])
    }
  }
  return normalizedColumns;
}

}).call(this)}).call(this,require("buffer").Buffer,require("timers").setImmediate)
},{"./ResizeableBuffer":9,"buffer":4,"stream":35,"timers":51}],11:[function(require,module,exports){
(function (Buffer){(function (){

const parse = require('.')

module.exports = function(data, options={}){
  if(typeof data === 'string'){
    data = Buffer.from(data)
  }
  const records = options && options.objname ? {} : []
  const parser = new parse.Parser(options)
  parser.push = function(record){
    if(record === null){
      return
    }
    if(options.objname === undefined)
      records.push(record)
    else{
      records[record[0]] = record[1]
    }
  }
  const err1 = parser.__parse(data, false)
  if(err1 !== undefined) throw err1
  const err2 = parser.__parse(undefined, true)
  if(err2 !== undefined) throw err2
  return records
}

}).call(this)}).call(this,require("buffer").Buffer)
},{".":10,"buffer":4}],12:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],13:[function(require,module,exports){
'use strict';

var isCallable = require('is-callable');

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

var forEachArray = function forEachArray(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};

var forEachString = function forEachString(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};

var forEachObject = function forEachObject(object, iterator, receiver) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};

var forEach = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }

    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }

    if (toStr.call(list) === '[object Array]') {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};

module.exports = forEach;

},{"is-callable":30}],14:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],15:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":14}],16:[function(require,module,exports){
'use strict';

var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');
var hasOwn = require('has');
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};

},{"function-bind":15,"has":21,"has-symbols":18}],17:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;

},{"get-intrinsic":16}],18:[function(require,module,exports){
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

},{"./shams":19}],19:[function(require,module,exports){
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

},{}],20:[function(require,module,exports){
'use strict';

var hasSymbols = require('has-symbols/shams');

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};

},{"has-symbols/shams":19}],21:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":15}],22:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],23:[function(require,module,exports){
var structuredClone = require('./structured-clone');
var HELLO_INTERVAL_LENGTH = 200;
var HELLO_TIMEOUT_LENGTH = 60000;

function IFrameEndpoint() {
  var listeners = {};
  var isInitialized = false;
  var connected = false;
  var postMessageQueue = [];
  var helloInterval;

  function postToParent(message) {
    // See http://dev.opera.com/articles/view/window-postmessage-messagechannel/#crossdoc
    //     https://github.com/Modernizr/Modernizr/issues/388
    //     http://jsfiddle.net/ryanseddon/uZTgD/2/
    if (structuredClone.supported()) {
      window.parent.postMessage(message, '*');
    } else {
      window.parent.postMessage(JSON.stringify(message), '*');
    }
  }

  function post(type, content) {
    var message;
    // Message object can be constructed from 'type' and 'content' arguments or it can be passed
    // as the first argument.
    if (arguments.length === 1 && typeof type === 'object' && typeof type.type === 'string') {
      message = type;
    } else {
      message = {
        type: type,
        content: content
      };
    }
    if (connected) {
      postToParent(message);
    } else {
      postMessageQueue.push(message);
    }
  }

  function postHello() {
    postToParent({
      type: 'hello'
    });
  }

  function addListener(type, fn) {
    listeners[type] = fn;
  }

  function removeListener(type) {
    delete listeners[type];
  }

  function removeAllListeners() {
    listeners = {};
  }

  function getListenerNames() {
    return Object.keys(listeners);
  }

  function messageListener(message) {
    // Anyone can send us a message. Only pay attention to messages from parent.
    if (message.source !== window.parent) return;
    var messageData = message.data;
    if (typeof messageData === 'string') messageData = JSON.parse(messageData);

    if (!connected && messageData.type === 'hello') {
      connected = true;
      stopPostingHello();
      while (postMessageQueue.length > 0) {
        post(postMessageQueue.shift());
      }
    }

    if (connected && listeners[messageData.type]) {
      listeners[messageData.type](messageData.content);
    }
  }

  function disconnect() {
    connected = false;
    stopPostingHello();
    removeAllListeners();
    window.removeEventListener('message', messageListener);
  }

  /**
    Initialize communication with the parent frame. This should not be called until the app's custom
    listeners are registered (via our 'addListener' public method) because, once we open the
    communication, the parent window may send any messages it may have queued. Messages for which
    we don't have handlers will be silently ignored.
  */
  function initialize() {
    if (isInitialized) {
      return;
    }
    isInitialized = true;
    if (window.parent === window) return;

    // We kick off communication with the parent window by sending a "hello" message. Then we wait
    // for a handshake (another "hello" message) from the parent window.
    startPostingHello();
    window.addEventListener('message', messageListener, false);
  }

  function startPostingHello() {
    if (helloInterval) {
      stopPostingHello();
    }
    helloInterval = window.setInterval(postHello, HELLO_INTERVAL_LENGTH);
    window.setTimeout(stopPostingHello, HELLO_TIMEOUT_LENGTH);
    // Post the first msg immediately.
    postHello();
  }

  function stopPostingHello() {
    window.clearInterval(helloInterval);
    helloInterval = null;
  }

  // Public API.
  return {
    initialize: initialize,
    getListenerNames: getListenerNames,
    addListener: addListener,
    removeListener: removeListener,
    removeAllListeners: removeAllListeners,
    disconnect: disconnect,
    post: post
  };
}

var instance = null;

// IFrameEndpoint is a singleton, as iframe can't have multiple parents anyway.
module.exports = function getIFrameEndpoint() {
  if (!instance) {
    instance = new IFrameEndpoint();
  }
  return instance;
};

},{"./structured-clone":26}],24:[function(require,module,exports){
var ParentEndpoint = require('./parent-endpoint');
var getIFrameEndpoint = require('./iframe-endpoint');

// Not a real UUID as there's an RFC for that (needed for proper distributed computing).
// But in this fairly parochial situation, we just need to be fairly sure to avoid repeats.
function getPseudoUUID() {
  var chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
  var len = chars.length;
  var ret = [];

  for (var i = 0; i < 10; i++) {
    ret.push(chars[Math.floor(Math.random() * len)]);
  }
  return ret.join('');
}

module.exports = function IframePhoneRpcEndpoint(handler, namespace, targetWindow, targetOrigin, phone) {
  var pendingCallbacks = Object.create({});

  // if it's a non-null object, rather than a function, 'handler' is really an options object
  if (handler && typeof handler === 'object') {
    namespace = handler.namespace;
    targetWindow = handler.targetWindow;
    targetOrigin = handler.targetOrigin;
    phone = handler.phone;
    handler = handler.handler;
  }

  if (!phone) {
    if (targetWindow === window.parent) {
      phone = getIFrameEndpoint();
      phone.initialize();
    } else {
      phone = new ParentEndpoint(targetWindow, targetOrigin);
    }
  }

  phone.addListener(namespace, function (message) {
    var callbackObj;

    if (message.messageType === 'call' && typeof this.handler === 'function') {
      this.handler.call(undefined, message.value, function (returnValue) {
        phone.post(namespace, {
          messageType: 'returnValue',
          uuid: message.uuid,
          value: returnValue
        });
      });
    } else if (message.messageType === 'returnValue') {
      callbackObj = pendingCallbacks[message.uuid];

      if (callbackObj) {
        window.clearTimeout(callbackObj.timeout);
        if (callbackObj.callback) {
          callbackObj.callback.call(undefined, message.value);
        }
        pendingCallbacks[message.uuid] = null;
      }
    }
  }.bind(this));

  function call(message, callback) {
    var uuid = getPseudoUUID();

    pendingCallbacks[uuid] = {
      callback: callback,
      timeout: window.setTimeout(function () {
        if (callback) {
          callback(undefined, new Error("IframePhone timed out waiting for reply"));
        }
      }, 2000)
    };

    phone.post(namespace, {
      messageType: 'call',
      uuid: uuid,
      value: message
    });
  }

  function disconnect() {
    phone.disconnect();
  }

  this.handler = handler;
  this.call = call.bind(this);
  this.disconnect = disconnect.bind(this);
};

},{"./iframe-endpoint":23,"./parent-endpoint":25}],25:[function(require,module,exports){
var structuredClone = require('./structured-clone');

/**
  Call as:
    new ParentEndpoint(targetWindow, targetOrigin, afterConnectedCallback)
      targetWindow is a WindowProxy object. (Messages will be sent to it)

      targetOrigin is the origin of the targetWindow. (Messages will be restricted to this origin)

      afterConnectedCallback is an optional callback function to be called when the connection is
        established.

  OR (less secure):
    new ParentEndpoint(targetIframe, afterConnectedCallback)

      targetIframe is a DOM object (HTMLIframeElement); messages will be sent to its contentWindow.

      afterConnectedCallback is an optional callback function

    In this latter case, targetOrigin will be inferred from the value of the src attribute of the
    provided DOM object at the time of the constructor invocation. This is less secure because the
    iframe might have been navigated to an unexpected domain before constructor invocation.

  Note that it is important to specify the expected origin of the iframe's content to safeguard
  against sending messages to an unexpected domain. This might happen if our iframe is navigated to
  a third-party URL unexpectedly. Furthermore, having a reference to Window object (as in the first
  form of the constructor) does not protect against sending a message to the wrong domain. The
  window object is actualy a WindowProxy which transparently proxies the Window object of the
  underlying iframe, so that when the iframe is navigated, the "same" WindowProxy now references a
  completely differeent Window object, possibly controlled by a hostile domain.

  See http://www.esdiscuss.org/topic/a-dom-use-case-that-can-t-be-emulated-with-direct-proxies for
  more about this weird behavior of WindowProxies (the type returned by <iframe>.contentWindow).
*/

module.exports = function ParentEndpoint(targetWindowOrIframeEl, targetOrigin, afterConnectedCallback) {
  var postMessageQueue = [];
  var connected = false;
  var handlers = {};
  var targetWindowIsIframeElement;

  function getIframeOrigin(iframe) {
    return iframe.src.match(/(.*?\/\/.*?)\//)[1];
  }

  function post(type, content) {
    var message;
    // Message object can be constructed from 'type' and 'content' arguments or it can be passed
    // as the first argument.
    if (arguments.length === 1 && typeof type === 'object' && typeof type.type === 'string') {
      message = type;
    } else {
      message = {
        type: type,
        content: content
      };
    }
    if (connected) {
      var tWindow = getTargetWindow();
      // if we are laready connected ... send the message
      // See http://dev.opera.com/articles/view/window-postmessage-messagechannel/#crossdoc
      //     https://github.com/Modernizr/Modernizr/issues/388
      //     http://jsfiddle.net/ryanseddon/uZTgD/2/
      if (structuredClone.supported()) {
        tWindow.postMessage(message, targetOrigin);
      } else {
        tWindow.postMessage(JSON.stringify(message), targetOrigin);
      }
    } else {
      // else queue up the messages to send after connection complete.
      postMessageQueue.push(message);
    }
  }

  function addListener(messageName, func) {
    handlers[messageName] = func;
  }

  function removeListener(messageName) {
    delete handlers[messageName];
  }

  function removeAllListeners() {
    handlers = {};
  }

  // Note that this function can't be used when IFrame element hasn't been added to DOM yet
  // (.contentWindow would be null). At the moment risk is purely theoretical, as the parent endpoint
  // only listens for an incoming 'hello' message and the first time we call this function
  // is in #receiveMessage handler (so iframe had to be initialized before, as it could send 'hello').
  // It would become important when we decide to refactor the way how communication is initialized.
  function getTargetWindow() {
    if (targetWindowIsIframeElement) {
      var tWindow = targetWindowOrIframeEl.contentWindow;
      if (!tWindow) {
        throw "IFrame element needs to be added to DOM before communication " +
              "can be started (.contentWindow is not available)";
      }
      return tWindow;
    }
    return targetWindowOrIframeEl;
  }

  function receiveMessage(message) {
    var messageData;
    if (message.source === getTargetWindow() && (targetOrigin === '*' || message.origin === targetOrigin)) {
      messageData = message.data;
      if (typeof messageData === 'string') {
        messageData = JSON.parse(messageData);
      }
      if (handlers[messageData.type]) {
        handlers[messageData.type](messageData.content);
      } else {
        console.log("cant handle type: " + messageData.type);
      }
    }
  }

  function disconnect() {
    connected = false;
    removeAllListeners();
    window.removeEventListener('message', receiveMessage);
  }

  // handle the case that targetWindowOrIframeEl is actually an <iframe> rather than a Window(Proxy) object
  // Note that if it *is* a WindowProxy, this probe will throw a SecurityException, but in that case
  // we also don't need to do anything
  try {
    targetWindowIsIframeElement = targetWindowOrIframeEl.constructor === HTMLIFrameElement;
  } catch (e) {
    targetWindowIsIframeElement = false;
  }

  if (targetWindowIsIframeElement) {
    // Infer the origin ONLY if the user did not supply an explicit origin, i.e., if the second
    // argument is empty or is actually a callback (meaning it is supposed to be the
    // afterConnectionCallback)
    if (!targetOrigin || targetOrigin.constructor === Function) {
      afterConnectedCallback = targetOrigin;
      targetOrigin = getIframeOrigin(targetWindowOrIframeEl);
    }
  }

  // Handle pages served through file:// protocol. Behaviour varies in different browsers. Safari sets origin
  // to 'file://' and everything works fine, but Chrome and Safari set message.origin to null.
  // Also, https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage says:
  //  > Lastly, posting a message to a page at a file: URL currently requires that the targetOrigin argument be "*".
  //  > file:// cannot be used as a security restriction; this restriction may be modified in the future.
  // So, using '*' seems like the only possible solution.
  if (targetOrigin === 'file://') {
    targetOrigin = '*';
  }

  // when we receive 'hello':
  addListener('hello', function () {
    connected = true;

    // send hello response
    post({
      type: 'hello',
      // `origin` property isn't used by IframeEndpoint anymore (>= 1.2.0), but it's being sent to be
      // backward compatible with old IframeEndpoint versions (< v1.2.0).
      origin: window.location.href.match(/(.*?\/\/.*?)\//)[1]
    });

    // give the user a chance to do things now that we are connected
    // note that is will happen before any queued messages
    if (afterConnectedCallback && typeof afterConnectedCallback === "function") {
      afterConnectedCallback();
    }

    // Now send any messages that have been queued up ...
    while (postMessageQueue.length > 0) {
      post(postMessageQueue.shift());
    }
  });

  window.addEventListener('message', receiveMessage, false);

  // Public API.
  return {
    post: post,
    addListener: addListener,
    removeListener: removeListener,
    removeAllListeners: removeAllListeners,
    disconnect: disconnect,
    getTargetWindow: getTargetWindow,
    targetOrigin: targetOrigin
  };
};

},{"./structured-clone":26}],26:[function(require,module,exports){
var featureSupported = {
  'structuredClones': 0
};

(function () {
  var result = 0;

  if (!!window.postMessage) {
    try {
      // Spec states you can't transmit DOM nodes and it will throw an error
      // postMessage implementations that support cloned data will throw.
      window.postMessage(document.createElement("a"), "*");
    } catch (e) {
      // BBOS6 throws but doesn't pass through the correct exception
      // so check error message
      result = (e.DATA_CLONE_ERR || e.message === "Cannot post cyclic structures.") ? 1 : 0;
      featureSupported = {
        'structuredClones': result
      };
    }
  }
}());

exports.supported = function supported() {
  return featureSupported && featureSupported.structuredClones > 0;
};

},{}],27:[function(require,module,exports){
module.exports = {
  /**
   * Allows to communicate with an iframe.
   */
  ParentEndpoint:  require('./lib/parent-endpoint'),
  /**
   * Allows to communicate with a parent page.
   * IFrameEndpoint is a singleton, as iframe can't have multiple parents anyway.
   */
  getIFrameEndpoint: require('./lib/iframe-endpoint'),
  structuredClone: require('./lib/structured-clone'),

  // TODO: May be misnamed
  IframePhoneRpcEndpoint: require('./lib/iframe-phone-rpc-endpoint')

};

},{"./lib/iframe-endpoint":23,"./lib/iframe-phone-rpc-endpoint":24,"./lib/parent-endpoint":25,"./lib/structured-clone":26}],28:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],29:[function(require,module,exports){
'use strict';

var hasToStringTag = require('has-tostringtag/shams')();
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{"call-bind/callBound":5,"has-tostringtag/shams":20}],30:[function(require,module,exports){
'use strict';

var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
		// eslint-disable-next-line no-throw-literal
		reflectApply(function () { throw 42; }, null, badArrayLike);
	} catch (_) {
		if (_ !== isCallableMarker) {
			reflectApply = null;
		}
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

var isDDA = function isDocumentDotAll() { return false; };
if (typeof document === 'object') {
	// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
	var all = document.all;
	if (toStr.call(all) === toStr.call(document.all)) {
		isDDA = function isDocumentDotAll(value) {
			/* globals document: false */
			// in IE 6-8, typeof document.all is "object" and it's truthy
			if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
				try {
					var str = toStr.call(value);
					return (
						str === ddaClass
						|| str === ddaClass2
						|| str === ddaClass3 // opera 12.16
						|| str === objectClass // IE 6-8
					) && value('') == null; // eslint-disable-line eqeqeq
				} catch (e) { /**/ }
			}
			return false;
		};
	}
}

module.exports = reflectApply
	? function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value) && tryFunctionObject(value);
	}
	: function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		if (strClass !== fnClass && strClass !== genClass && !(/^\[object HTML/).test(strClass)) { return false; }
		return tryFunctionObject(value);
	};

},{}],31:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = require('has-tostringtag/shams')();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var GeneratorFunction;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
	}
	return getProto(fn) === GeneratorFunction;
};

},{"has-tostringtag/shams":20}],32:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('for-each');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();
var gOPD = require('gopd');

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr) {
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			toStrTags[typedArray] = descriptor.get;
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var anyTrue = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!anyTrue) {
			try {
				anyTrue = getter.call(value) === typedArray;
			} catch (e) { /**/ }
		}
	});
	return anyTrue;
};

module.exports = function isTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) {
		var tag = $slice($toString(value), 8, -1);
		return $indexOf(typedArrays, tag) > -1;
	}
	if (!gOPD) { return false; }
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"available-typed-arrays":1,"call-bind/callBound":5,"for-each":13,"gopd":17,"has-tostringtag/shams":20}],33:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],34:[function(require,module,exports){
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":4}],35:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/lib/_stream_readable.js');
Stream.Writable = require('readable-stream/lib/_stream_writable.js');
Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
Stream.Transform = require('readable-stream/lib/_stream_transform.js');
Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js')
Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js')

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":12,"inherits":28,"readable-stream/lib/_stream_duplex.js":37,"readable-stream/lib/_stream_passthrough.js":38,"readable-stream/lib/_stream_readable.js":39,"readable-stream/lib/_stream_transform.js":40,"readable-stream/lib/_stream_writable.js":41,"readable-stream/lib/internal/streams/end-of-stream.js":45,"readable-stream/lib/internal/streams/pipeline.js":47}],36:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],37:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))
},{"./_stream_readable":39,"./_stream_writable":41,"_process":33,"inherits":28}],38:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":40,"inherits":28}],39:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":36,"./_stream_duplex":37,"./internal/streams/async_iterator":42,"./internal/streams/buffer_list":43,"./internal/streams/destroy":44,"./internal/streams/from":46,"./internal/streams/state":48,"./internal/streams/stream":49,"_process":33,"buffer":4,"events":12,"inherits":28,"string_decoder/":50,"util":3}],40:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":36,"./_stream_duplex":37,"inherits":28}],41:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":36,"./_stream_duplex":37,"./internal/streams/destroy":44,"./internal/streams/state":48,"./internal/streams/stream":49,"_process":33,"buffer":4,"inherits":28,"util-deprecate":53}],42:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))
},{"./end-of-stream":45,"_process":33}],43:[function(require,module,exports){
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
},{"buffer":4,"util":3}],44:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))
},{"_process":33}],45:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
},{"../../../errors":36}],46:[function(require,module,exports){
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

},{}],47:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
},{"../../../errors":36,"./end-of-stream":45}],48:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":36}],49:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":12}],50:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":34}],51:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":33,"timers":51}],52:[function(require,module,exports){
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.Tone=e():t.Tone=e()}("undefined"!=typeof self?self:this,(function(){return function(t){var e={};function s(n){if(e[n])return e[n].exports;var i=e[n]={i:n,l:!1,exports:{}};return t[n].call(i.exports,i,i.exports,s),i.l=!0,i.exports}return s.m=t,s.c=e,s.d=function(t,e,n){s.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},s.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},s.t=function(t,e){if(1&e&&(t=s(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(s.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)s.d(n,i,function(e){return t[e]}.bind(null,i));return n},s.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return s.d(e,"a",e),e},s.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},s.p="",s(s.s=9)}([function(t,e,s){!function(t,e,s,n){"use strict";function i(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var o=i(e),r=i(s),a=i(n),c=function(t,e,s){return{endTime:e,insertTime:s,type:"exponentialRampToValue",value:t}},h=function(t,e,s){return{endTime:e,insertTime:s,type:"linearRampToValue",value:t}},u=function(t,e){return{startTime:e,type:"setValue",value:t}},l=function(t,e,s){return{duration:s,startTime:e,type:"setValueCurve",values:t}},p=function(t,e,s){var n=s.startTime,i=s.target,o=s.timeConstant;return i+(e-i)*Math.exp((n-t)/o)},d=function(t){return"exponentialRampToValue"===t.type},f=function(t){return"linearRampToValue"===t.type},_=function(t){return d(t)||f(t)},m=function(t){return"setValue"===t.type},g=function(t){return"setValueCurve"===t.type},v=function t(e,s,n,i){var o=e[s];return void 0===o?i:_(o)||m(o)?o.value:g(o)?o.values[o.values.length-1]:p(n,t(e,s-1,o.startTime,i),o)},y=function(t,e,s,n,i){return void 0===s?[n.insertTime,i]:_(s)?[s.endTime,s.value]:m(s)?[s.startTime,s.value]:g(s)?[s.startTime+s.duration,s.values[s.values.length-1]]:[s.startTime,v(t,e-1,s.startTime,i)]},x=function(t){return"cancelAndHold"===t.type},w=function(t){return"cancelScheduledValues"===t.type},b=function(t){return x(t)||w(t)?t.cancelTime:d(t)||f(t)?t.endTime:t.startTime},T=function(t,e,s,n){var i=n.endTime,o=n.value;return s===o?o:0<s&&0<o||s<0&&o<0?s*Math.pow(o/s,(t-e)/(i-e)):0},S=function(t,e,s,n){return s+(t-e)/(n.endTime-e)*(n.value-s)},k=function(t,e){var s=e.duration,n=e.startTime,i=e.values;return function(t,e){var s=Math.floor(e),n=Math.ceil(e);return s===n?t[s]:(1-(e-s))*t[s]+(1-(n-e))*t[n]}(i,(t-n)/s*(i.length-1))},C=function(t){return"setTarget"===t.type},A=function(){function t(e){r.default(this,t),this._automationEvents=[],this._currenTime=0,this._defaultValue=e}return a.default(t,[{key:Symbol.iterator,value:function(){return this._automationEvents[Symbol.iterator]()}},{key:"add",value:function(t){var e=b(t);if(x(t)||w(t)){var s=this._automationEvents.findIndex((function(s){return w(t)&&g(s)?s.startTime+s.duration>=e:b(s)>=e})),n=this._automationEvents[s];if(-1!==s&&(this._automationEvents=this._automationEvents.slice(0,s)),x(t)){var i=this._automationEvents[this._automationEvents.length-1];if(void 0!==n&&_(n)){if(C(i))throw new Error("The internal list is malformed.");var o=g(i)?i.startTime+i.duration:b(i),r=g(i)?i.values[i.values.length-1]:i.value,a=d(n)?T(e,o,r,n):S(e,o,r,n),p=d(n)?c(a,e,this._currenTime):h(a,e,this._currenTime);this._automationEvents.push(p)}void 0!==i&&C(i)&&this._automationEvents.push(u(this.getValue(e),e)),void 0!==i&&g(i)&&i.startTime+i.duration>e&&(this._automationEvents[this._automationEvents.length-1]=l(new Float32Array([6,7]),i.startTime,e-i.startTime))}}else{var m=this._automationEvents.findIndex((function(t){return b(t)>e})),v=-1===m?this._automationEvents[this._automationEvents.length-1]:this._automationEvents[m-1];if(void 0!==v&&g(v)&&b(v)+v.duration>e)return!1;var y=d(t)?c(t.value,t.endTime,this._currenTime):f(t)?h(t.value,e,this._currenTime):t;if(-1===m)this._automationEvents.push(y);else{if(g(t)&&e+t.duration>b(this._automationEvents[m]))return!1;this._automationEvents.splice(m,0,y)}}return!0}},{key:"flush",value:function(t){var e=this._automationEvents.findIndex((function(e){return b(e)>t}));if(e>1){var s=this._automationEvents.slice(e-1),n=s[0];C(n)&&s.unshift(u(v(this._automationEvents,e-2,n.startTime,this._defaultValue),n.startTime)),this._automationEvents=s}}},{key:"getValue",value:function(t){if(0===this._automationEvents.length)return this._defaultValue;var e=this._automationEvents[this._automationEvents.length-1],s=this._automationEvents.findIndex((function(e){return b(e)>t})),n=this._automationEvents[s],i=b(e)<=t?e:this._automationEvents[s-1];if(void 0!==i&&C(i)&&(void 0===n||!_(n)||n.insertTime>t))return p(t,v(this._automationEvents,s-2,i.startTime,this._defaultValue),i);if(void 0!==i&&m(i)&&(void 0===n||!_(n)))return i.value;if(void 0!==i&&g(i)&&(void 0===n||!_(n)||i.startTime+i.duration>t))return t<i.startTime+i.duration?k(t,i):i.values[i.values.length-1];if(void 0!==i&&_(i)&&(void 0===n||!_(n)))return i.value;if(void 0!==n&&d(n)){var r=y(this._automationEvents,s-1,i,n,this._defaultValue),a=o.default(r,2),c=a[0],h=a[1];return T(t,c,h,n)}if(void 0!==n&&f(n)){var u=y(this._automationEvents,s-1,i,n,this._defaultValue),l=o.default(u,2),x=l[0],w=l[1];return S(t,x,w,n)}return this._defaultValue}}]),t}();t.AutomationEventList=A,t.createCancelAndHoldAutomationEvent=function(t){return{cancelTime:t,type:"cancelAndHold"}},t.createCancelScheduledValuesAutomationEvent=function(t){return{cancelTime:t,type:"cancelScheduledValues"}},t.createExponentialRampToValueAutomationEvent=function(t,e){return{endTime:e,type:"exponentialRampToValue",value:t}},t.createLinearRampToValueAutomationEvent=function(t,e){return{endTime:e,type:"linearRampToValue",value:t}},t.createSetTargetAutomationEvent=function(t,e,s){return{startTime:e,target:t,timeConstant:s,type:"setTarget"}},t.createSetValueAutomationEvent=u,t.createSetValueCurveAutomationEvent=l,Object.defineProperty(t,"__esModule",{value:!0})}(e,s(1),s(7),s(8))},function(t,e,s){var n=s(2),i=s(3),o=s(4),r=s(6);t.exports=function(t,e){return n(t)||i(t,e)||o(t,e)||r()}},function(t,e){t.exports=function(t){if(Array.isArray(t))return t}},function(t,e){t.exports=function(t,e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(t)){var s=[],n=!0,i=!1,o=void 0;try{for(var r,a=t[Symbol.iterator]();!(n=(r=a.next()).done)&&(s.push(r.value),!e||s.length!==e);n=!0);}catch(t){i=!0,o=t}finally{try{n||null==a.return||a.return()}finally{if(i)throw o}}return s}}},function(t,e,s){var n=s(5);t.exports=function(t,e){if(t){if("string"==typeof t)return n(t,e);var s=Object.prototype.toString.call(t).slice(8,-1);return"Object"===s&&t.constructor&&(s=t.constructor.name),"Map"===s||"Set"===s?Array.from(t):"Arguments"===s||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(s)?n(t,e):void 0}}},function(t,e){t.exports=function(t,e){(null==e||e>t.length)&&(e=t.length);for(var s=0,n=new Array(e);s<e;s++)n[s]=t[s];return n}},function(t,e){t.exports=function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}},function(t,e){t.exports=function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}},function(t,e){function s(t,e){for(var s=0;s<e.length;s++){var n=e[s];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}t.exports=function(t,e,n){return e&&s(t.prototype,e),n&&s(t,n),t}},function(t,e,s){"use strict";s.r(e),s.d(e,"getContext",(function(){return Ji})),s.d(e,"setContext",(function(){return Ki})),s.d(e,"Clock",(function(){return qo})),s.d(e,"Context",(function(){return Gi})),s.d(e,"BaseContext",(function(){return Wi})),s.d(e,"Delay",(function(){return Fo})),s.d(e,"Gain",(function(){return ko})),s.d(e,"Offline",(function(){return Io})),s.d(e,"OfflineContext",(function(){return Yi})),s.d(e,"Param",(function(){return xo})),s.d(e,"ToneAudioBuffer",(function(){return Xi})),s.d(e,"ToneAudioBuffers",(function(){return Vo})),s.d(e,"ToneAudioNode",(function(){return wo})),s.d(e,"connectSeries",(function(){return bo})),s.d(e,"connect",(function(){return To})),s.d(e,"disconnect",(function(){return So})),s.d(e,"FrequencyClass",(function(){return lo})),s.d(e,"Frequency",(function(){return _o})),s.d(e,"MidiClass",(function(){return No})),s.d(e,"Midi",(function(){return Po})),s.d(e,"TimeClass",(function(){return ho})),s.d(e,"Time",(function(){return uo})),s.d(e,"TicksClass",(function(){return jo})),s.d(e,"Ticks",(function(){return Lo})),s.d(e,"TransportTimeClass",(function(){return mo})),s.d(e,"TransportTime",(function(){return go})),s.d(e,"Emitter",(function(){return Bi})),s.d(e,"IntervalTimeline",(function(){return Bo})),s.d(e,"StateTimeline",(function(){return yo})),s.d(e,"Timeline",(function(){return Ni})),s.d(e,"isUndef",(function(){return ai})),s.d(e,"isDefined",(function(){return ci})),s.d(e,"isFunction",(function(){return hi})),s.d(e,"isNumber",(function(){return ui})),s.d(e,"isObject",(function(){return li})),s.d(e,"isBoolean",(function(){return pi})),s.d(e,"isArray",(function(){return di})),s.d(e,"isString",(function(){return fi})),s.d(e,"isNote",(function(){return _i})),s.d(e,"dbToGain",(function(){return eo})),s.d(e,"gainToDb",(function(){return so})),s.d(e,"intervalToFrequencyRatio",(function(){return no})),s.d(e,"ftom",(function(){return oo})),s.d(e,"mtof",(function(){return ao})),s.d(e,"optionsFromArguments",(function(){return Di})),s.d(e,"defaultArg",(function(){return Oi})),s.d(e,"Unit",(function(){return i})),s.d(e,"debug",(function(){return n})),s.d(e,"Noise",(function(){return Jo})),s.d(e,"UserMedia",(function(){return er})),s.d(e,"Oscillator",(function(){return ir})),s.d(e,"AMOscillator",(function(){return hr})),s.d(e,"FMOscillator",(function(){return ur})),s.d(e,"PulseOscillator",(function(){return lr})),s.d(e,"FatOscillator",(function(){return pr})),s.d(e,"PWMOscillator",(function(){return dr})),s.d(e,"OmniOscillator",(function(){return _r})),s.d(e,"ToneOscillatorNode",(function(){return nr})),s.d(e,"LFO",(function(){return yr})),s.d(e,"ToneBufferSource",(function(){return $o})),s.d(e,"Player",(function(){return br})),s.d(e,"Players",(function(){return Tr})),s.d(e,"GrainPlayer",(function(){return Sr})),s.d(e,"Add",(function(){return mr})),s.d(e,"Abs",(function(){return kr})),s.d(e,"AudioToGain",(function(){return ar})),s.d(e,"GainToAudio",(function(){return Cr})),s.d(e,"GreaterThan",(function(){return Mr})),s.d(e,"GreaterThanZero",(function(){return Or})),s.d(e,"Multiply",(function(){return cr})),s.d(e,"Negate",(function(){return Ar})),s.d(e,"Pow",(function(){return Er})),s.d(e,"Signal",(function(){return Do})),s.d(e,"connectSignal",(function(){return Oo})),s.d(e,"Scale",(function(){return gr})),s.d(e,"ScaleExp",(function(){return Rr})),s.d(e,"Subtract",(function(){return Dr})),s.d(e,"SyncedSignal",(function(){return qr})),s.d(e,"WaveShaper",(function(){return rr})),s.d(e,"Zero",(function(){return vr})),s.d(e,"AMSynth",(function(){return zr})),s.d(e,"DuoSynth",(function(){return Qr})),s.d(e,"FMSynth",(function(){return Zr})),s.d(e,"MetalSynth",(function(){return Yr})),s.d(e,"MembraneSynth",(function(){return Hr})),s.d(e,"MonoSynth",(function(){return Ur})),s.d(e,"NoiseSynth",(function(){return $r})),s.d(e,"PluckSynth",(function(){return oa})),s.d(e,"PolySynth",(function(){return ra})),s.d(e,"Sampler",(function(){return aa})),s.d(e,"Synth",(function(){return jr})),s.d(e,"Loop",(function(){return ha})),s.d(e,"Part",(function(){return ua})),s.d(e,"Pattern",(function(){return xa})),s.d(e,"Sequence",(function(){return wa})),s.d(e,"ToneEvent",(function(){return ca})),s.d(e,"AutoFilter",(function(){return ka})),s.d(e,"AutoPanner",(function(){return Aa})),s.d(e,"AutoWah",(function(){return Oa})),s.d(e,"BitCrusher",(function(){return Ma})),s.d(e,"Chebyshev",(function(){return Ra})),s.d(e,"Chorus",(function(){return Na})),s.d(e,"Distortion",(function(){return Pa})),s.d(e,"FeedbackDelay",(function(){return La})),s.d(e,"FrequencyShifter",(function(){return Ba})),s.d(e,"Freeverb",(function(){return Ua})),s.d(e,"JCReverb",(function(){return Ya})),s.d(e,"PingPongDelay",(function(){return $a})),s.d(e,"PitchShift",(function(){return Ja})),s.d(e,"Phaser",(function(){return Ka})),s.d(e,"Reverb",(function(){return tc})),s.d(e,"StereoWidener",(function(){return ic})),s.d(e,"Tremolo",(function(){return oc})),s.d(e,"Vibrato",(function(){return rc})),s.d(e,"Analyser",(function(){return ac})),s.d(e,"Meter",(function(){return hc})),s.d(e,"FFT",(function(){return uc})),s.d(e,"DCMeter",(function(){return lc})),s.d(e,"Waveform",(function(){return pc})),s.d(e,"Follower",(function(){return Da})),s.d(e,"Channel",(function(){return _c})),s.d(e,"CrossFade",(function(){return ba})),s.d(e,"Merge",(function(){return Fa})),s.d(e,"MidSideMerge",(function(){return sc})),s.d(e,"MidSideSplit",(function(){return ec})),s.d(e,"Mono",(function(){return mc})),s.d(e,"MultibandSplit",(function(){return gc})),s.d(e,"Panner",(function(){return Ca})),s.d(e,"Panner3D",(function(){return yc})),s.d(e,"PanVol",(function(){return fc})),s.d(e,"Recorder",(function(){return xc})),s.d(e,"Solo",(function(){return dc})),s.d(e,"Split",(function(){return qa})),s.d(e,"Volume",(function(){return Go})),s.d(e,"Compressor",(function(){return wc})),s.d(e,"Gate",(function(){return bc})),s.d(e,"Limiter",(function(){return Tc})),s.d(e,"MidSideCompressor",(function(){return Sc})),s.d(e,"MultibandCompressor",(function(){return kc})),s.d(e,"AmplitudeEnvelope",(function(){return Pr})),s.d(e,"Envelope",(function(){return Fr})),s.d(e,"FrequencyEnvelope",(function(){return Gr})),s.d(e,"EQ3",(function(){return Cc})),s.d(e,"Filter",(function(){return Wr})),s.d(e,"OnePoleFilter",(function(){return na})),s.d(e,"FeedbackCombFilter",(function(){return sa})),s.d(e,"LowpassCombFilter",(function(){return ia})),s.d(e,"Convolver",(function(){return Ac})),s.d(e,"BiquadFilter",(function(){return Br})),s.d(e,"version",(function(){return o})),s.d(e,"start",(function(){return to})),s.d(e,"supported",(function(){return Kn})),s.d(e,"now",(function(){return Dc})),s.d(e,"immediate",(function(){return Oc})),s.d(e,"Transport",(function(){return Mc})),s.d(e,"getTransport",(function(){return Ec})),s.d(e,"Destination",(function(){return Rc})),s.d(e,"Master",(function(){return qc})),s.d(e,"getDestination",(function(){return Fc})),s.d(e,"Listener",(function(){return Ic})),s.d(e,"getListener",(function(){return Vc})),s.d(e,"Draw",(function(){return Nc})),s.d(e,"getDraw",(function(){return Pc})),s.d(e,"context",(function(){return jc})),s.d(e,"loaded",(function(){return Lc})),s.d(e,"Buffer",(function(){return zc})),s.d(e,"Buffers",(function(){return Bc})),s.d(e,"BufferSource",(function(){return Wc}));var n={};s.r(n),s.d(n,"assert",(function(){return ti})),s.d(n,"assertRange",(function(){return ei})),s.d(n,"assertContextRunning",(function(){return si})),s.d(n,"setLogger",(function(){return ii})),s.d(n,"log",(function(){return oi})),s.d(n,"warn",(function(){return ri}));var i={};s.r(i);const o="14.7.77";var r=s(0);const a=new WeakSet,c=new WeakMap,h=new WeakMap,u=new WeakMap,l=new WeakMap,p=new WeakMap,d=new WeakMap,f=new WeakMap,_=new WeakMap,m=new WeakMap,g={construct:()=>g},v=/^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/,y=(t,e)=>{const s=[];let n=t.replace(/^[\s]+/,""),i=n.match(v);for(;null!==i;){const t=i[1].slice(1,-1),o=i[0].replace(/([\s]+)?;?$/,"").replace(t,new URL(t,e).toString());s.push(o),n=n.slice(i[0].length).replace(/^[\s]+/,""),i=n.match(v)}return[s.join(";"),n]},x=t=>{if(void 0!==t&&!Array.isArray(t))throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.")},w=t=>{if(!(t=>{try{new new Proxy(t,g)}catch{return!1}return!0})(t))throw new TypeError("The given value for processorCtor should be a constructor.");if(null===t.prototype||"object"!=typeof t.prototype)throw new TypeError("The given value for processorCtor should have a prototype.")},b=(t,e)=>{const s=t.get(e);if(void 0===s)throw new Error("A value with the given key could not be found.");return s},T=(t,e)=>{const s=Array.from(t).filter(e);if(s.length>1)throw Error("More than one element was found.");if(0===s.length)throw Error("No element was found.");const[n]=s;return t.delete(n),n},S=(t,e,s,n)=>{const i=b(t,e),o=T(i,t=>t[0]===s&&t[1]===n);return 0===i.size&&t.delete(e),o},k=t=>b(d,t),C=t=>{if(a.has(t))throw new Error("The AudioNode is already stored.");a.add(t),k(t).forEach(t=>t(!0))},A=t=>"port"in t,D=t=>{if(!a.has(t))throw new Error("The AudioNode is not stored.");a.delete(t),k(t).forEach(t=>t(!1))},O=(t,e)=>{!A(t)&&e.every(t=>0===t.size)&&D(t)},M={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",fftSize:2048,maxDecibels:-30,minDecibels:-100,smoothingTimeConstant:.8},E=(t,e)=>t.context===e,R=t=>{try{t.copyToChannel(new Float32Array(1),0,-1)}catch{return!1}return!0},q=()=>new DOMException("","IndexSizeError"),F=t=>{var e;t.getChannelData=(e=t.getChannelData,s=>{try{return e.call(t,s)}catch(t){if(12===t.code)throw q();throw t}})},I={numberOfChannels:1},V=-34028234663852886e22,N=-V,P=t=>a.has(t),j={buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1},L=t=>b(c,t),z=t=>b(u,t),B=(t,e)=>{const{activeInputs:s}=L(t);s.forEach(s=>s.forEach(([s])=>{e.includes(t)||B(s,[...e,t])}));const n=(t=>"playbackRate"in t)(t)?[t.playbackRate]:A(t)?Array.from(t.parameters.values()):(t=>"frequency"in t&&"gain"in t)(t)?[t.Q,t.detune,t.frequency,t.gain]:(t=>"offset"in t)(t)?[t.offset]:(t=>!("frequency"in t)&&"gain"in t)(t)?[t.gain]:(t=>"detune"in t&&"frequency"in t)(t)?[t.detune,t.frequency]:(t=>"pan"in t)(t)?[t.pan]:[];for(const t of n){const s=z(t);void 0!==s&&s.activeInputs.forEach(([t])=>B(t,e))}P(t)&&D(t)},W=t=>{B(t.destination,[])},G=t=>void 0===t||"number"==typeof t||"string"==typeof t&&("balanced"===t||"interactive"===t||"playback"===t),U=t=>"context"in t,Q=t=>U(t[0]),Z=(t,e,s,n)=>{for(const e of t)if(s(e)){if(n)return!1;throw Error("The set contains at least one similar element.")}return t.add(e),!0},X=(t,e,[s,n],i)=>{Z(t,[e,s,n],t=>t[0]===e&&t[1]===s,i)},Y=(t,[e,s,n],i)=>{const o=t.get(e);void 0===o?t.set(e,new Set([[s,n]])):Z(o,[s,n],t=>t[0]===s,i)},H=t=>"inputs"in t,$=(t,e,s,n)=>{if(H(e)){const i=e.inputs[n];return t.connect(i,s,0),[i,s,0]}return t.connect(e,s,n),[e,s,n]},J=(t,e,s)=>{for(const n of t)if(n[0]===e&&n[1]===s)return t.delete(n),n;return null},K=(t,e)=>{if(!k(t).delete(e))throw new Error("Missing the expected event listener.")},tt=(t,e,s)=>{const n=b(t,e),i=T(n,t=>t[0]===s);return 0===n.size&&t.delete(e),i},et=(t,e,s,n)=>{H(e)?t.disconnect(e.inputs[n],s,0):t.disconnect(e,s,n)},st=t=>b(h,t),nt=t=>b(l,t),it=t=>f.has(t),ot=t=>!a.has(t),rt=t=>new Promise(e=>{const s=t.createScriptProcessor(256,1,1),n=t.createGain(),i=t.createBuffer(1,2,44100),o=i.getChannelData(0);o[0]=1,o[1]=1;const r=t.createBufferSource();r.buffer=i,r.loop=!0,r.connect(s).connect(t.destination),r.connect(n),r.disconnect(n),s.onaudioprocess=n=>{const i=n.inputBuffer.getChannelData(0);Array.prototype.some.call(i,t=>1===t)?e(!0):e(!1),r.stop(),s.onaudioprocess=null,r.disconnect(s),s.disconnect(t.destination)},r.start()}),at=(t,e)=>{const s=new Map;for(const e of t)for(const t of e){const e=s.get(t);s.set(t,void 0===e?1:e+1)}s.forEach((t,s)=>e(s,t))},ct=t=>"context"in t,ht=(t,e,s,n)=>{const{activeInputs:i,passiveInputs:o}=z(e),{outputs:r}=L(t),a=k(t),c=r=>{const a=st(t),c=nt(e);if(r){const e=tt(o,t,s);X(i,t,e,!1),n||it(t)||a.connect(c,s)}else{const e=((t,e,s)=>T(t,t=>t[0]===e&&t[1]===s))(i,t,s);Y(o,e,!1),n||it(t)||a.disconnect(c,s)}};return!!Z(r,[e,s],t=>t[0]===e&&t[1]===s,!0)&&(a.add(c),P(t)?X(i,t,[s,c],!0):Y(o,[t,s,c],!0),!0)},ut=(t,e,s,n,i)=>{const[o,r]=((t,e,s,n)=>{const{activeInputs:i,passiveInputs:o}=L(e),r=J(i[n],t,s);if(null===r){return[S(o,t,s,n)[2],!1]}return[r[2],!0]})(t,s,n,i);if(null!==o&&(K(t,o),!r||e||it(t)||et(st(t),st(s),n,i)),P(s)){const{activeInputs:t}=L(s);O(s,t)}},lt=(t,e,s,n)=>{const[i,o]=((t,e,s)=>{const{activeInputs:n,passiveInputs:i}=z(e),o=J(n,t,s);if(null===o){return[tt(i,t,s)[1],!1]}return[o[2],!0]})(t,s,n);null!==i&&(K(t,i),!o||e||it(t)||st(t).disconnect(nt(s),n))};class pt{constructor(t){this._map=new Map(t)}get size(){return this._map.size}entries(){return this._map.entries()}forEach(t,e=null){return this._map.forEach((s,n)=>t.call(e,s,n,this))}get(t){return this._map.get(t)}has(t){return this._map.has(t)}keys(){return this._map.keys()}values(){return this._map.values()}}const dt={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:1,numberOfOutputs:1,parameterData:{},processorOptions:{}};function ft(t,e,s,n,i){if("function"==typeof t.copyFromChannel)0===e[s].byteLength&&(e[s]=new Float32Array(128)),t.copyFromChannel(e[s],n,i);else{const o=t.getChannelData(n);if(0===e[s].byteLength)e[s]=o.slice(i,i+128);else{const t=new Float32Array(o.buffer,i*Float32Array.BYTES_PER_ELEMENT,128);e[s].set(t)}}}const _t=(t,e,s,n,i)=>{"function"==typeof t.copyToChannel?0!==e[s].byteLength&&t.copyToChannel(e[s],n,i):0!==e[s].byteLength&&t.getChannelData(n).set(e[s],i)},mt=(t,e)=>{const s=[];for(let n=0;n<t;n+=1){const t=[],i="number"==typeof e?e:e[n];for(let e=0;e<i;e+=1)t.push(new Float32Array(128));s.push(t)}return s},gt=async(t,e,s,n,i,o,r)=>{const a=null===e?128*Math.ceil(t.context.length/128):e.length,c=n.channelCount*n.numberOfInputs,h=i.reduce((t,e)=>t+e,0),u=0===h?null:s.createBuffer(h,a,s.sampleRate);if(void 0===o)throw new Error("Missing the processor constructor.");const l=L(t),p=await((t,e)=>{const s=b(m,t),n=st(e);return b(s,n)})(s,t),d=mt(n.numberOfInputs,n.channelCount),f=mt(n.numberOfOutputs,i),_=Array.from(t.parameters.keys()).reduce((t,e)=>({...t,[e]:new Float32Array(128)}),{});for(let h=0;h<a;h+=128){if(n.numberOfInputs>0&&null!==e)for(let t=0;t<n.numberOfInputs;t+=1)for(let s=0;s<n.channelCount;s+=1)ft(e,d[t],s,s,h);void 0!==o.parameterDescriptors&&null!==e&&o.parameterDescriptors.forEach(({name:t},s)=>{ft(e,_,t,c+s,h)});for(let t=0;t<n.numberOfInputs;t+=1)for(let e=0;e<i[t];e+=1)0===f[t][e].byteLength&&(f[t][e]=new Float32Array(128));try{const t=d.map((t,e)=>0===l.activeInputs[e].size?[]:t),e=r(h/s.sampleRate,s.sampleRate,()=>p.process(t,f,_));if(null!==u)for(let t=0,e=0;t<n.numberOfOutputs;t+=1){for(let s=0;s<i[t];s+=1)_t(u,f[t],s,e+s,h);e+=i[t]}if(!e)break}catch(e){t.dispatchEvent(new ErrorEvent("processorerror",{colno:e.colno,filename:e.filename,lineno:e.lineno,message:e.message}));break}}return u},vt={Q:1,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",detune:0,frequency:350,gain:0,type:"lowpass"},yt={channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:6},xt={channelCount:6,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:6},wt={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",offset:1},bt={buffer:null,channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",disableNormalization:!1},Tt={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",delayTime:0,maxDelayTime:1},St=(t,e,s)=>{const n=e[s];if(void 0===n)throw t();return n},kt={attack:.003,channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",knee:30,ratio:12,release:.25,threshold:-24},Ct={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",gain:1},At=()=>new DOMException("","InvalidStateError"),Dt=()=>new DOMException("","InvalidAccessError"),Ot={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers"},Mt=(t,e,s,n,i,o,r,a,c,h,u)=>{const l=h.length;let p=a;for(let a=0;a<l;a+=1){let l=s[0]*h[a];for(let e=1;e<i;e+=1){const n=p-e&c-1;l+=s[e]*o[n],l-=t[e]*r[n]}for(let t=i;t<n;t+=1)l+=s[t]*o[p-t&c-1];for(let s=i;s<e;s+=1)l-=t[s]*r[p-s&c-1];o[p]=h[a],r[p]=l,p=p+1&c-1,u[a]=l}return p},Et={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers"},Rt=t=>{const e=new Uint32Array([1179011410,40,1163280727,544501094,16,131073,44100,176400,1048580,1635017060,4,0]);try{const s=t.decodeAudioData(e.buffer,()=>{});return void 0!==s&&(s.catch(()=>{}),!0)}catch{}return!1},qt={numberOfChannels:1},Ft=(t,e,s)=>{const n=e[s];void 0!==n&&n!==t[s]&&(t[s]=n)},It=(t,e)=>{Ft(t,e,"channelCount"),Ft(t,e,"channelCountMode"),Ft(t,e,"channelInterpretation")},Vt=t=>"function"==typeof t.getFloatTimeDomainData,Nt=(t,e,s)=>{const n=e[s];void 0!==n&&n!==t[s].value&&(t[s].value=n)},Pt=t=>{var e;t.start=(e=t.start,(s=0,n=0,i)=>{if("number"==typeof i&&i<0||n<0||s<0)throw new RangeError("The parameters can't be negative.");e.call(t,s,n,i)})},jt=t=>{var e;t.stop=(e=t.stop,(s=0)=>{if(s<0)throw new RangeError("The parameter can't be negative.");e.call(t,s)})},Lt=(t,e)=>null===t?512:Math.max(512,Math.min(16384,Math.pow(2,Math.round(Math.log2(t*e))))),zt=async(t,e)=>new t(await(t=>new Promise((e,s)=>{const{port1:n,port2:i}=new MessageChannel;n.onmessage=({data:t})=>{n.close(),i.close(),e(t)},n.onmessageerror=({data:t})=>{n.close(),i.close(),s(t)},i.postMessage(t)}))(e)),Bt=(t,e)=>{const s=t.createBiquadFilter();return It(s,e),Nt(s,e,"Q"),Nt(s,e,"detune"),Nt(s,e,"frequency"),Nt(s,e,"gain"),Ft(s,e,"type"),s},Wt=(t,e)=>{const s=t.createChannelSplitter(e.numberOfOutputs);return It(s,e),(t=>{const e=t.numberOfOutputs;Object.defineProperty(t,"channelCount",{get:()=>e,set:t=>{if(t!==e)throw At()}}),Object.defineProperty(t,"channelCountMode",{get:()=>"explicit",set:t=>{if("explicit"!==t)throw At()}}),Object.defineProperty(t,"channelInterpretation",{get:()=>"discrete",set:t=>{if("discrete"!==t)throw At()}})})(s),s},Gt=(t,e)=>(t.connect=e.connect.bind(e),t.disconnect=e.disconnect.bind(e),t),Ut=(t,e)=>{const s=t.createDelay(e.maxDelayTime);return It(s,e),Nt(s,e,"delayTime"),s},Qt=(t,e)=>{const s=t.createGain();return It(s,e),Nt(s,e,"gain"),s};function Zt(t,e){const s=e[0]*e[0]+e[1]*e[1];return[(t[0]*e[0]+t[1]*e[1])/s,(t[1]*e[0]-t[0]*e[1])/s]}function Xt(t,e){let s=[0,0];for(let o=t.length-1;o>=0;o-=1)i=e,s=[(n=s)[0]*i[0]-n[1]*i[1],n[0]*i[1]+n[1]*i[0]],s[0]+=t[o];var n,i;return s}const Yt=(t,e,s,n)=>t.createScriptProcessor(e,s,n),Ht=()=>new DOMException("","NotSupportedError"),$t={numberOfChannels:1},Jt={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",detune:0,frequency:440,periodicWave:void 0,type:"sine"},Kt={channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",coneInnerAngle:360,coneOuterAngle:360,coneOuterGain:0,distanceModel:"inverse",maxDistance:1e4,orientationX:1,orientationY:0,orientationZ:0,panningModel:"equalpower",positionX:0,positionY:0,positionZ:0,refDistance:1,rolloffFactor:1},te={disableNormalization:!1},ee={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers",pan:0},se=()=>new DOMException("","UnknownError"),ne={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",curve:null,oversample:"none"},ie=t=>{if(null===t)return!1;const e=t.length;return e%2!=0?0!==t[Math.floor(e/2)]:t[e/2-1]+t[e/2]!==0},oe=(t,e,s,n)=>{let i=Object.getPrototypeOf(t);for(;!i.hasOwnProperty(e);)i=Object.getPrototypeOf(i);const{get:o,set:r}=Object.getOwnPropertyDescriptor(i,e);Object.defineProperty(t,e,{get:s(o),set:n(r)})},re=(t,e,s)=>{try{t.setValueAtTime(e,s)}catch(n){if(9!==n.code)throw n;re(t,e,s+1e-7)}},ae=t=>{const e=t.createOscillator();try{e.start(-1)}catch(t){return t instanceof RangeError}return!1},ce=t=>{const e=t.createBuffer(1,1,44100),s=t.createBufferSource();s.buffer=e,s.start(),s.stop();try{return s.stop(),!0}catch{return!1}},he=t=>{const e=t.createOscillator();try{e.stop(-1)}catch(t){return t instanceof RangeError}return!1},ue=()=>{try{new DOMException}catch{return!1}return!0},le=()=>new Promise(t=>{const e=new ArrayBuffer(0),{port1:s,port2:n}=new MessageChannel;s.onmessage=({data:e})=>t(null!==e),n.postMessage(e,[e])}),pe=(t,e)=>{const s=e.createGain();t.connect(s);const n=(i=t.disconnect,()=>{i.call(t,s),t.removeEventListener("ended",n)});var i;t.addEventListener("ended",n),Gt(t,s),t.stop=(e=>{let n=!1;return(i=0)=>{if(n)try{e.call(t,i)}catch{s.gain.setValueAtTime(0,i)}else e.call(t,i),n=!0}})(t.stop)},de=(t,e)=>s=>{const n={value:t};return Object.defineProperties(s,{currentTarget:n,target:n}),"function"==typeof e?e.call(t,s):e.handleEvent.call(t,s)},fe=(_e=Z,(t,e,[s,n,i],o)=>{_e(t[n],[e,s,i],t=>t[0]===e&&t[1]===s,o)});var _e;const me=(t=>(e,s,[n,i,o],r)=>{const a=e.get(n);void 0===a?e.set(n,new Set([[i,s,o]])):t(a,[i,s,o],t=>t[0]===i&&t[1]===s,r)})(Z),ge=(t=>(e,s,n,i)=>t(e[i],t=>t[0]===s&&t[1]===n))(T),ve=new WeakMap,ye=(t=>e=>{var s;return null!==(s=t.get(e))&&void 0!==s?s:0})(ve),xe=(we=new Map,be=new WeakMap,(t,e)=>{const s=be.get(t);if(void 0!==s)return s;const n=we.get(t);if(void 0!==n)return n;try{const s=e();return s instanceof Promise?(we.set(t,s),s.catch(()=>!1).then(e=>(we.delete(t),be.set(t,e),e))):(be.set(t,s),s)}catch{return be.set(t,!1),!1}});var we,be;const Te="undefined"==typeof window?null:window,Se=(ke=xe,Ce=q,(t,e)=>{const s=t.createAnalyser();if(It(s,e),!(e.maxDecibels>e.minDecibels))throw Ce();return Ft(s,e,"fftSize"),Ft(s,e,"maxDecibels"),Ft(s,e,"minDecibels"),Ft(s,e,"smoothingTimeConstant"),ke(Vt,()=>Vt(s))||(t=>{t.getFloatTimeDomainData=e=>{const s=new Uint8Array(e.length);t.getByteTimeDomainData(s);const n=Math.max(s.length,t.fftSize);for(let t=0;t<n;t+=1)e[t]=.0078125*(s[t]-128);return e}})(s),s});var ke,Ce;const Ae=(De=L,t=>{const e=De(t);if(null===e.renderer)throw new Error("Missing the renderer of the given AudioNode in the audio graph.");return e.renderer});var De;const Oe=((t,e,s)=>async(n,i,o,r)=>{const a=t(n),c=[...r,n];await Promise.all(a.activeInputs.map((t,r)=>Array.from(t).filter(([t])=>!c.includes(t)).map(async([t,a])=>{const h=e(t),u=await h.render(t,i,c),l=n.context.destination;s(t)||n===l&&s(n)||u.connect(o,a,r)})).reduce((t,e)=>[...t,...e],[]))})(L,Ae,it),Me=(Ee=Se,Re=st,qe=Oe,()=>{const t=new WeakMap;return{render(e,s,n){const i=t.get(s);return void 0!==i?Promise.resolve(i):(async(e,s,n)=>{let i=Re(e);if(!E(i,s)){const t={channelCount:i.channelCount,channelCountMode:i.channelCountMode,channelInterpretation:i.channelInterpretation,fftSize:i.fftSize,maxDecibels:i.maxDecibels,minDecibels:i.minDecibels,smoothingTimeConstant:i.smoothingTimeConstant};i=Ee(s,t)}return t.set(s,i),await qe(e,s,i,n),i})(e,s,n)}}});var Ee,Re,qe;const Fe=(Ie=p,t=>{const e=Ie.get(t);if(void 0===e)throw At();return e});var Ie;const Ve=(t=>null===t?null:t.hasOwnProperty("OfflineAudioContext")?t.OfflineAudioContext:t.hasOwnProperty("webkitOfflineAudioContext")?t.webkitOfflineAudioContext:null)(Te),Ne=(Pe=Ve,t=>null!==Pe&&t instanceof Pe);var Pe;const je=new WeakMap,Le=(ze=de,class{constructor(t){this._nativeEventTarget=t,this._listeners=new WeakMap}addEventListener(t,e,s){if(null!==e){let n=this._listeners.get(e);void 0===n&&(n=ze(this,e),"function"==typeof e&&this._listeners.set(e,n)),this._nativeEventTarget.addEventListener(t,n,s)}}dispatchEvent(t){return this._nativeEventTarget.dispatchEvent(t)}removeEventListener(t,e,s){const n=null===e?void 0:this._listeners.get(e);this._nativeEventTarget.removeEventListener(t,void 0===n?null:n,s)}});var ze;const Be=(t=>null===t?null:t.hasOwnProperty("AudioContext")?t.AudioContext:t.hasOwnProperty("webkitAudioContext")?t.webkitAudioContext:null)(Te),We=(Ge=Be,t=>null!==Ge&&t instanceof Ge);var Ge;const Ue=(t=>e=>null!==t&&"function"==typeof t.AudioNode&&e instanceof t.AudioNode)(Te),Qe=(t=>e=>null!==t&&"function"==typeof t.AudioParam&&e instanceof t.AudioParam)(Te),Ze=((t,e,s,n,i,o,r,a,c,u,l,p,f,_,m)=>class extends u{constructor(e,n,i,o){super(i),this._context=e,this._nativeAudioNode=i;const r=l(e);p(r)&&!0!==s(rt,()=>rt(r))&&(t=>{const e=new Map;var s,n;t.connect=(s=t.connect.bind(t),(t,n=0,i=0)=>{const o=ct(t)?s(t,n,i):s(t,n),r=e.get(t);return void 0===r?e.set(t,[{input:i,output:n}]):r.every(t=>t.input!==i||t.output!==n)&&r.push({input:i,output:n}),o}),t.disconnect=(n=t.disconnect,(s,i,o)=>{if(n.apply(t),void 0===s)e.clear();else if("number"==typeof s)for(const[t,n]of e){const i=n.filter(t=>t.output!==s);0===i.length?e.delete(t):e.set(t,i)}else if(e.has(s))if(void 0===i)e.delete(s);else{const t=e.get(s);if(void 0!==t){const n=t.filter(t=>t.output!==i&&(t.input!==o||void 0===o));0===n.length?e.delete(s):e.set(s,n)}}for(const[s,n]of e)n.forEach(e=>{ct(s)?t.connect(s,e.output,e.input):t.connect(s,e.output)})})})(i),h.set(this,i),d.set(this,new Set),"closed"!==e.state&&n&&C(this),t(this,o,i)}get channelCount(){return this._nativeAudioNode.channelCount}set channelCount(t){this._nativeAudioNode.channelCount=t}get channelCountMode(){return this._nativeAudioNode.channelCountMode}set channelCountMode(t){this._nativeAudioNode.channelCountMode=t}get channelInterpretation(){return this._nativeAudioNode.channelInterpretation}set channelInterpretation(t){this._nativeAudioNode.channelInterpretation=t}get context(){return this._context}get numberOfInputs(){return this._nativeAudioNode.numberOfInputs}get numberOfOutputs(){return this._nativeAudioNode.numberOfOutputs}connect(t,s=0,a=0){if(s<0||s>=this._nativeAudioNode.numberOfOutputs)throw i();const h=l(this._context),u=m(h);if(f(t)||_(t))throw o();if(U(t)){const i=st(t);try{const e=$(this._nativeAudioNode,i,s,a),n=ot(this);(u||n)&&this._nativeAudioNode.disconnect(...e),"closed"!==this.context.state&&!n&&ot(t)&&C(t)}catch(t){if(12===t.code)throw o();throw t}if(e(this,t,s,a,u)){const e=c([this],t);at(e,n(u))}return t}const p=nt(t);if("playbackRate"===p.name)throw r();try{this._nativeAudioNode.connect(p,s),(u||ot(this))&&this._nativeAudioNode.disconnect(p,s)}catch(t){if(12===t.code)throw o();throw t}if(ht(this,t,s,u)){const e=c([this],t);at(e,n(u))}}disconnect(t,e,s){let n;const r=l(this._context),h=m(r);if(void 0===t)n=((t,e)=>{const s=L(t),n=[];for(const i of s.outputs)Q(i)?ut(t,e,...i):lt(t,e,...i),n.push(i[0]);return s.outputs.clear(),n})(this,h);else if("number"==typeof t){if(t<0||t>=this.numberOfOutputs)throw i();n=((t,e,s)=>{const n=L(t),i=[];for(const o of n.outputs)o[1]===s&&(Q(o)?ut(t,e,...o):lt(t,e,...o),i.push(o[0]),n.outputs.delete(o));return i})(this,h,t)}else{if(void 0!==e&&(e<0||e>=this.numberOfOutputs))throw i();if(U(t)&&void 0!==s&&(s<0||s>=t.numberOfInputs))throw i();if(n=((t,e,s,n,i)=>{const o=L(t);return Array.from(o.outputs).filter(t=>!(t[0]!==s||void 0!==n&&t[1]!==n||void 0!==i&&t[2]!==i)).map(s=>(Q(s)?ut(t,e,...s):lt(t,e,...s),o.outputs.delete(s),s[0]))})(this,h,t,e,s),0===n.length)throw o()}for(const t of n){const e=c([this],t);at(e,a)}}})((Xe=c,(t,e,s)=>{const n=[];for(let t=0;t<s.numberOfInputs;t+=1)n.push(new Set);Xe.set(t,{activeInputs:n,outputs:new Set,passiveInputs:new WeakMap,renderer:e})}),((t,e,s,n,i,o,r,a,c,h,u,l,p)=>(d,f,_,m,g)=>{const{activeInputs:v,passiveInputs:y}=o(f),{outputs:x}=o(d),w=a(d),b=o=>{const a=c(f),h=c(d);if(o){const e=S(y,d,_,m);t(v,d,e,!1),g||l(d)||s(h,a,_,m),p(f)&&C(f)}else{const t=n(v,d,_,m);e(y,m,t,!1),g||l(d)||i(h,a,_,m);const s=r(f);0===s?u(f)&&O(f,v):setTimeout(()=>{u(f)&&O(f,v)},1e3*s)}};return!!h(x,[f,_,m],t=>t[0]===f&&t[1]===_&&t[2]===m,!0)&&(w.add(b),u(d)?t(v,d,[_,m,b],!0):e(y,m,[d,_,b],!0),!0)})(fe,me,$,ge,et,L,ye,k,st,Z,P,it,ot),xe,((t,e,s,n,i,o)=>r=>(a,c)=>{const h=t.get(a);if(void 0===h){if(!r&&o(a)){const t=n(a),{outputs:o}=s(a);for(const s of o)if(Q(s)){const i=n(s[0]);e(t,i,s[1],s[2])}else{const e=i(s[0]);t.disconnect(e,s[1])}}t.set(a,c)}else t.set(a,h+c)})(f,et,L,st,nt,P),q,Dt,Ht,((t,e,s,n,i,o,r,a)=>(c,h)=>{const u=e.get(c);if(void 0===u)throw new Error("Missing the expected cycle count.");const l=o(c.context),p=a(l);if(u===h){if(e.delete(c),!p&&r(c)){const e=n(c),{outputs:o}=s(c);for(const s of o)if(Q(s)){const i=n(s[0]);t(e,i,s[1],s[2])}else{const t=i(s[0]);e.connect(t,s[1])}}}else e.set(c,u-h)})($,f,L,st,nt,Fe,P,Ne),((t,e,s)=>function n(i,o){const r=U(o)?o:s(t,o);if((t=>"delayTime"in t)(r))return[];if(i[0]===r)return[i];if(i.includes(r))return[];const{outputs:a}=e(r);return Array.from(a).map(t=>n([...i,r],t[0])).reduce((t,e)=>t.concat(e),[])})(je,L,b),Le,Fe,We,Ue,Qe,Ne);var Xe;const Ye=((t,e,s,n,i,o)=>class extends t{constructor(t,s){const r=i(t),a={...M,...s},c=n(r,a);super(t,!1,c,o(r)?e():null),this._nativeAnalyserNode=c}get fftSize(){return this._nativeAnalyserNode.fftSize}set fftSize(t){this._nativeAnalyserNode.fftSize=t}get frequencyBinCount(){return this._nativeAnalyserNode.frequencyBinCount}get maxDecibels(){return this._nativeAnalyserNode.maxDecibels}set maxDecibels(t){const e=this._nativeAnalyserNode.maxDecibels;if(this._nativeAnalyserNode.maxDecibels=t,!(t>this._nativeAnalyserNode.minDecibels))throw this._nativeAnalyserNode.maxDecibels=e,s()}get minDecibels(){return this._nativeAnalyserNode.minDecibels}set minDecibels(t){const e=this._nativeAnalyserNode.minDecibels;if(this._nativeAnalyserNode.minDecibels=t,!(this._nativeAnalyserNode.maxDecibels>t))throw this._nativeAnalyserNode.minDecibels=e,s()}get smoothingTimeConstant(){return this._nativeAnalyserNode.smoothingTimeConstant}set smoothingTimeConstant(t){this._nativeAnalyserNode.smoothingTimeConstant=t}getByteFrequencyData(t){this._nativeAnalyserNode.getByteFrequencyData(t)}getByteTimeDomainData(t){this._nativeAnalyserNode.getByteTimeDomainData(t)}getFloatFrequencyData(t){this._nativeAnalyserNode.getFloatFrequencyData(t)}getFloatTimeDomainData(t){this._nativeAnalyserNode.getFloatTimeDomainData(t)}})(Ze,Me,q,Se,Fe,Ne),He=new WeakSet,$e=(t=>null===t?null:t.hasOwnProperty("AudioBuffer")?t.AudioBuffer:null)(Te),Je=(Ke=new Uint32Array(1),t=>(Ke[0]=t,Ke[0]));var Ke;const ts=((t,e)=>s=>{s.copyFromChannel=(n,i,o=0)=>{const r=t(o),a=t(i);if(a>=s.numberOfChannels)throw e();const c=s.length,h=s.getChannelData(a),u=n.length;for(let t=r<0?-r:0;t+r<c&&t<u;t+=1)n[t]=h[t+r]},s.copyToChannel=(n,i,o=0)=>{const r=t(o),a=t(i);if(a>=s.numberOfChannels)throw e();const c=s.length,h=s.getChannelData(a),u=n.length;for(let t=r<0?-r:0;t+r<c&&t<u;t+=1)h[t+r]=n[t]}})(Je,q),es=(t=>e=>{e.copyFromChannel=(s=>(n,i,o=0)=>{const r=t(o),a=t(i);if(r<e.length)return s.call(e,n,a,r)})(e.copyFromChannel),e.copyToChannel=(s=>(n,i,o=0)=>{const r=t(o),a=t(i);if(r<e.length)return s.call(e,n,a,r)})(e.copyToChannel)})(Je),ss=((t,e,s,n,i,o,r,a)=>{let c=null;return class h{constructor(h){if(null===i)throw new Error("Missing the native OfflineAudioContext constructor.");const{length:u,numberOfChannels:l,sampleRate:p}={...I,...h};null===c&&(c=new i(1,1,44100));const d=null!==n&&e(o,o)?new n({length:u,numberOfChannels:l,sampleRate:p}):c.createBuffer(l,u,p);if(0===d.numberOfChannels)throw s();return"function"!=typeof d.copyFromChannel?(r(d),F(d)):e(R,()=>R(d))||a(d),t.add(d),d}static[Symbol.hasInstance](e){return null!==e&&"object"==typeof e&&Object.getPrototypeOf(e)===h.prototype||t.has(e)}}})(He,xe,Ht,$e,Ve,(ns=$e,()=>{if(null===ns)return!1;try{new ns({length:1,sampleRate:44100})}catch{return!1}return!0}),ts,es);var ns;const is=(os=Qt,(t,e)=>{const s=os(t,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});e.connect(s).connect(t.destination);const n=()=>{e.removeEventListener("ended",n),e.disconnect(s),s.disconnect()};e.addEventListener("ended",n)});var os;const rs=((t,e,s)=>async(n,i,o,r)=>{const a=e(n);await Promise.all(Array.from(a.activeInputs).map(async([e,n])=>{const a=t(e),c=await a.render(e,i,r);s(e)||c.connect(o,n)}))})(Ae,z,it),as=(t=>(e,s,n,i)=>t(s,e,n,i))(rs),cs=((t,e,s,n,i,o,r,a,c,h,u)=>(l,p)=>{const d=l.createBufferSource();return It(d,p),Nt(d,p,"playbackRate"),Ft(d,p,"buffer"),Ft(d,p,"loop"),Ft(d,p,"loopEnd"),Ft(d,p,"loopStart"),e(s,()=>s(l))||(t=>{t.start=(e=>{let s=!1;return(n=0,i=0,o)=>{if(s)throw At();e.call(t,n,i,o),s=!0}})(t.start)})(d),e(n,()=>n(l))||c(d),e(i,()=>i(l))||h(d,l),e(o,()=>o(l))||Pt(d),e(r,()=>r(l))||u(d,l),e(a,()=>a(l))||jt(d),t(l,d),d})(is,xe,t=>{const e=t.createBufferSource();e.start();try{e.start()}catch{return!0}return!1},t=>{const e=t.createBufferSource(),s=t.createBuffer(1,1,44100);e.buffer=s;try{e.start(0,1)}catch{return!1}return!0},t=>{const e=t.createBufferSource();e.start();try{e.stop()}catch{return!1}return!0},ae,ce,he,t=>{var e;t.start=(e=t.start,(s=0,n=0,i)=>{const o=t.buffer,r=null===o?n:Math.min(o.duration,n);null!==o&&r>o.duration-.5/t.context.sampleRate?e.call(t,s,0,0):e.call(t,s,r,i)})},(hs=oe,(t,e)=>{const s=e.createBuffer(1,1,44100);null===t.buffer&&(t.buffer=s),hs(t,"buffer",e=>()=>{const n=e.call(t);return n===s?null:n},e=>n=>e.call(t,null===n?s:n))}),pe);var hs;const us=((t,e)=>(s,n,i,o)=>(t(n).replay(i),e(n,s,i,o)))((t=>e=>{const s=t(e);if(null===s.renderer)throw new Error("Missing the renderer of the given AudioParam in the audio graph.");return s.renderer})(z),rs),ls=((t,e,s,n,i)=>()=>{const o=new WeakMap;let r=null,a=null;return{set start(t){r=t},set stop(t){a=t},render(c,h,u){const l=o.get(h);return void 0!==l?Promise.resolve(l):(async(c,h,u)=>{let l=s(c);const p=E(l,h);if(!p){const t={buffer:l.buffer,channelCount:l.channelCount,channelCountMode:l.channelCountMode,channelInterpretation:l.channelInterpretation,loop:l.loop,loopEnd:l.loopEnd,loopStart:l.loopStart,playbackRate:l.playbackRate.value};l=e(h,t),null!==r&&l.start(...r),null!==a&&l.stop(a)}return o.set(h,l),p?await t(h,c.playbackRate,l.playbackRate,u):await n(h,c.playbackRate,l.playbackRate,u),await i(c,h,l,u),l})(c,h,u)}}})(as,cs,st,us,Oe),ps=((t,e,s,n,i,o,a,c,h,u,l,p,d)=>(f,_,m,g=null,v=null)=>{const y=new r.AutomationEventList(m.defaultValue),x=_?n(y):null,w={get defaultValue(){return m.defaultValue},get maxValue(){return null===g?m.maxValue:g},get minValue(){return null===v?m.minValue:v},get value(){return m.value},set value(t){m.value=t,w.setValueAtTime(t,f.context.currentTime)},cancelAndHoldAtTime(t){if("function"==typeof m.cancelAndHoldAtTime)null===x&&y.flush(f.context.currentTime),y.add(i(t)),m.cancelAndHoldAtTime(t);else{const e=Array.from(y).pop();null===x&&y.flush(f.context.currentTime),y.add(i(t));const s=Array.from(y).pop();m.cancelScheduledValues(t),e!==s&&void 0!==s&&("exponentialRampToValue"===s.type?m.exponentialRampToValueAtTime(s.value,s.endTime):"linearRampToValue"===s.type?m.linearRampToValueAtTime(s.value,s.endTime):"setValue"===s.type?m.setValueAtTime(s.value,s.startTime):"setValueCurve"===s.type&&m.setValueCurveAtTime(s.values,s.startTime,s.duration))}return w},cancelScheduledValues:t=>(null===x&&y.flush(f.context.currentTime),y.add(o(t)),m.cancelScheduledValues(t),w),exponentialRampToValueAtTime(t,e){if(0===t)throw new RangeError;if(!Number.isFinite(e)||e<0)throw new RangeError;return null===x&&y.flush(f.context.currentTime),y.add(a(t,e)),m.exponentialRampToValueAtTime(t,e),w},linearRampToValueAtTime:(t,e)=>(null===x&&y.flush(f.context.currentTime),y.add(c(t,e)),m.linearRampToValueAtTime(t,e),w),setTargetAtTime:(t,e,s)=>(null===x&&y.flush(f.context.currentTime),y.add(h(t,e,s)),m.setTargetAtTime(t,e,s),w),setValueAtTime:(t,e)=>(null===x&&y.flush(f.context.currentTime),y.add(u(t,e)),m.setValueAtTime(t,e),w),setValueCurveAtTime(t,e,s){const n=t instanceof Float32Array?t:new Float32Array(t);if(null!==p&&"webkitAudioContext"===p.name){const t=e+s,i=f.context.sampleRate,o=Math.ceil(e*i),r=Math.floor(t*i),a=r-o,c=new Float32Array(a);for(let t=0;t<a;t+=1){const r=(n.length-1)/s*((o+t)/i-e),a=Math.floor(r),h=Math.ceil(r);c[t]=a===h?n[a]:(1-(r-a))*n[a]+(1-(h-r))*n[h]}null===x&&y.flush(f.context.currentTime),y.add(l(c,e,s)),m.setValueCurveAtTime(c,e,s);const h=r/i;h<t&&d(w,c[c.length-1],h),d(w,n[n.length-1],t)}else null===x&&y.flush(f.context.currentTime),y.add(l(n,e,s)),m.setValueCurveAtTime(n,e,s);return w}};return s.set(w,m),e.set(w,f),t(w,x),w})((ds=u,(t,e)=>{ds.set(t,{activeInputs:new Set,passiveInputs:new WeakMap,renderer:e})}),je,l,t=>({replay(e){for(const s of t)if("exponentialRampToValue"===s.type){const{endTime:t,value:n}=s;e.exponentialRampToValueAtTime(n,t)}else if("linearRampToValue"===s.type){const{endTime:t,value:n}=s;e.linearRampToValueAtTime(n,t)}else if("setTarget"===s.type){const{startTime:t,target:n,timeConstant:i}=s;e.setTargetAtTime(n,t,i)}else if("setValue"===s.type){const{startTime:t,value:n}=s;e.setValueAtTime(n,t)}else{if("setValueCurve"!==s.type)throw new Error("Can't apply an unknown automation.");{const{duration:t,startTime:n,values:i}=s;e.setValueCurveAtTime(i,n,t)}}}}),r.createCancelAndHoldAutomationEvent,r.createCancelScheduledValuesAutomationEvent,r.createExponentialRampToValueAutomationEvent,r.createLinearRampToValueAutomationEvent,r.createSetTargetAutomationEvent,r.createSetValueAutomationEvent,r.createSetValueCurveAutomationEvent,Be,re);var ds;const fs=((t,e,s,n,i,o,r,a)=>class extends t{constructor(t,n){const a=o(t),c={...j,...n},h=i(a,c),u=r(a),l=u?e():null;super(t,!1,h,l),this._audioBufferSourceNodeRenderer=l,this._isBufferNullified=!1,this._isBufferSet=null!==c.buffer,this._nativeAudioBufferSourceNode=h,this._onended=null,this._playbackRate=s(this,u,h.playbackRate,N,V)}get buffer(){return this._isBufferNullified?null:this._nativeAudioBufferSourceNode.buffer}set buffer(t){if(this._nativeAudioBufferSourceNode.buffer=t,null!==t){if(this._isBufferSet)throw n();this._isBufferSet=!0}}get loop(){return this._nativeAudioBufferSourceNode.loop}set loop(t){this._nativeAudioBufferSourceNode.loop=t}get loopEnd(){return this._nativeAudioBufferSourceNode.loopEnd}set loopEnd(t){this._nativeAudioBufferSourceNode.loopEnd=t}get loopStart(){return this._nativeAudioBufferSourceNode.loopStart}set loopStart(t){this._nativeAudioBufferSourceNode.loopStart=t}get onended(){return this._onended}set onended(t){const e="function"==typeof t?a(this,t):null;this._nativeAudioBufferSourceNode.onended=e;const s=this._nativeAudioBufferSourceNode.onended;this._onended=null!==s&&s===e?t:s}get playbackRate(){return this._playbackRate}start(t=0,e=0,s){if(this._nativeAudioBufferSourceNode.start(t,e,s),null!==this._audioBufferSourceNodeRenderer&&(this._audioBufferSourceNodeRenderer.start=void 0===s?[t,e]:[t,e,s]),"closed"!==this.context.state){C(this);const t=()=>{this._nativeAudioBufferSourceNode.removeEventListener("ended",t),P(this)&&D(this)};this._nativeAudioBufferSourceNode.addEventListener("ended",t)}}stop(t=0){this._nativeAudioBufferSourceNode.stop(t),null!==this._audioBufferSourceNodeRenderer&&(this._audioBufferSourceNodeRenderer.stop=t)}})(Ze,ls,ps,At,cs,Fe,Ne,de),_s=((t,e,s,n,i,o,r,a)=>class extends t{constructor(t,s){const n=o(t),c=r(n),h=i(n,s,c);super(t,!1,h,c?e(a):null),this._isNodeOfNativeOfflineAudioContext=c,this._nativeAudioDestinationNode=h}get channelCount(){return this._nativeAudioDestinationNode.channelCount}set channelCount(t){if(this._isNodeOfNativeOfflineAudioContext)throw n();if(t>this._nativeAudioDestinationNode.maxChannelCount)throw s();this._nativeAudioDestinationNode.channelCount=t}get channelCountMode(){return this._nativeAudioDestinationNode.channelCountMode}set channelCountMode(t){if(this._isNodeOfNativeOfflineAudioContext)throw n();this._nativeAudioDestinationNode.channelCountMode=t}get maxChannelCount(){return this._nativeAudioDestinationNode.maxChannelCount}})(Ze,t=>{let e=null;return{render:(s,n,i)=>(null===e&&(e=(async(e,s,n)=>{const i=s.destination;return await t(e,s,i,n),i})(s,n,i)),e)}},q,At,((t,e)=>(s,n,i)=>{const o=s.destination;if(o.channelCount!==n)try{o.channelCount=n}catch{}i&&"explicit"!==o.channelCountMode&&(o.channelCountMode="explicit"),0===o.maxChannelCount&&Object.defineProperty(o,"maxChannelCount",{value:n});const r=t(s,{channelCount:n,channelCountMode:o.channelCountMode,channelInterpretation:o.channelInterpretation,gain:1});return e(r,"channelCount",t=>()=>t.call(r),t=>e=>{t.call(r,e);try{o.channelCount=e}catch(t){if(e>o.maxChannelCount)throw t}}),e(r,"channelCountMode",t=>()=>t.call(r),t=>e=>{t.call(r,e),o.channelCountMode=e}),e(r,"channelInterpretation",t=>()=>t.call(r),t=>e=>{t.call(r,e),o.channelInterpretation=e}),Object.defineProperty(r,"maxChannelCount",{get:()=>o.maxChannelCount}),r.connect(o),r})(Qt,oe),Fe,Ne,Oe),ms=((t,e,s,n,i)=>()=>{const o=new WeakMap;return{render(r,a,c){const h=o.get(a);return void 0!==h?Promise.resolve(h):(async(r,a,c)=>{let h=s(r);const u=E(h,a);if(!u){const t={Q:h.Q.value,channelCount:h.channelCount,channelCountMode:h.channelCountMode,channelInterpretation:h.channelInterpretation,detune:h.detune.value,frequency:h.frequency.value,gain:h.gain.value,type:h.type};h=e(a,t)}return o.set(a,h),u?(await t(a,r.Q,h.Q,c),await t(a,r.detune,h.detune,c),await t(a,r.frequency,h.frequency,c),await t(a,r.gain,h.gain,c)):(await n(a,r.Q,h.Q,c),await n(a,r.detune,h.detune,c),await n(a,r.frequency,h.frequency,c),await n(a,r.gain,h.gain,c)),await i(r,a,h,c),h})(r,a,c)}}})(as,Bt,st,us,Oe),gs=(t=>(e,s)=>t.set(e,s))(ve),vs=(ys=Ze,xs=ps,ws=ms,bs=Dt,Ts=Bt,Ss=Fe,ks=Ne,Cs=gs,class extends ys{constructor(t,e){const s=Ss(t),n={...vt,...e},i=Ts(s,n),o=ks(s);super(t,!1,i,o?ws():null),this._Q=xs(this,o,i.Q,N,V),this._detune=xs(this,o,i.detune,1200*Math.log2(N),-1200*Math.log2(N)),this._frequency=xs(this,o,i.frequency,t.sampleRate/2,0),this._gain=xs(this,o,i.gain,40*Math.log10(N),V),this._nativeBiquadFilterNode=i,Cs(this,1)}get detune(){return this._detune}get frequency(){return this._frequency}get gain(){return this._gain}get Q(){return this._Q}get type(){return this._nativeBiquadFilterNode.type}set type(t){this._nativeBiquadFilterNode.type=t}getFrequencyResponse(t,e,s){try{this._nativeBiquadFilterNode.getFrequencyResponse(t,e,s)}catch(t){if(11===t.code)throw bs();throw t}if(t.length!==e.length||e.length!==s.length)throw bs()}});var ys,xs,ws,bs,Ts,Ss,ks,Cs;const As=((t,e)=>(s,n,i)=>{const o=new Set;var r,a;return s.connect=(r=s.connect,(i,a=0,c=0)=>{const h=0===o.size;if(e(i))return r.call(s,i,a,c),t(o,[i,a,c],t=>t[0]===i&&t[1]===a&&t[2]===c,!0),h&&n(),i;r.call(s,i,a),t(o,[i,a],t=>t[0]===i&&t[1]===a,!0),h&&n()}),s.disconnect=(a=s.disconnect,(t,n,r)=>{const c=o.size>0;if(void 0===t)a.apply(s),o.clear();else if("number"==typeof t){a.call(s,t);for(const e of o)e[1]===t&&o.delete(e)}else{e(t)?a.call(s,t,n,r):a.call(s,t,n);for(const e of o)e[0]!==t||void 0!==n&&e[1]!==n||void 0!==r&&e[2]!==r||o.delete(e)}const h=0===o.size;c&&h&&i()}),s})(Z,Ue),Ds=(Os=At,Ms=As,(t,e)=>{e.channelCount=1,e.channelCountMode="explicit",Object.defineProperty(e,"channelCount",{get:()=>1,set:()=>{throw Os()}}),Object.defineProperty(e,"channelCountMode",{get:()=>"explicit",set:()=>{throw Os()}});const s=t.createBufferSource();Ms(e,()=>{const t=e.numberOfInputs;for(let n=0;n<t;n+=1)s.connect(e,0,n)},()=>s.disconnect(e))});var Os,Ms;const Es=((t,e)=>(s,n)=>{const i=s.createChannelMerger(n.numberOfInputs);return null!==t&&"webkitAudioContext"===t.name&&e(s,i),It(i,n),i})(Be,Ds),Rs=((t,e,s,n,i)=>class extends t{constructor(t,o){const r=n(t),a={...yt,...o};super(t,!1,s(r,a),i(r)?e():null)}})(Ze,((t,e,s)=>()=>{const n=new WeakMap;return{render(i,o,r){const a=n.get(o);return void 0!==a?Promise.resolve(a):(async(i,o,r)=>{let a=e(i);if(!E(a,o)){const e={channelCount:a.channelCount,channelCountMode:a.channelCountMode,channelInterpretation:a.channelInterpretation,numberOfInputs:a.numberOfInputs};a=t(o,e)}return n.set(o,a),await s(i,o,a,r),a})(i,o,r)}}})(Es,st,Oe),Es,Fe,Ne),qs=((t,e,s,n,i,o)=>class extends t{constructor(t,r){const a=n(t),c=o({...xt,...r});super(t,!1,s(a,c),i(a)?e():null)}})(Ze,((t,e,s)=>()=>{const n=new WeakMap;return{render(i,o,r){const a=n.get(o);return void 0!==a?Promise.resolve(a):(async(i,o,r)=>{let a=e(i);if(!E(a,o)){const e={channelCount:a.channelCount,channelCountMode:a.channelCountMode,channelInterpretation:a.channelInterpretation,numberOfOutputs:a.numberOfOutputs};a=t(o,e)}return n.set(o,a),await s(i,o,a,r),a})(i,o,r)}}})(Wt,st,Oe),Wt,Fe,Ne,t=>({...t,channelCount:t.numberOfOutputs})),Fs=((t,e,s,n)=>(i,{offset:o,...r})=>{const a=i.createBuffer(1,2,44100),c=e(i,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}),h=s(i,{...r,gain:o}),u=a.getChannelData(0);u[0]=1,u[1]=1,c.buffer=a,c.loop=!0;const l={get bufferSize(){},get channelCount(){return h.channelCount},set channelCount(t){h.channelCount=t},get channelCountMode(){return h.channelCountMode},set channelCountMode(t){h.channelCountMode=t},get channelInterpretation(){return h.channelInterpretation},set channelInterpretation(t){h.channelInterpretation=t},get context(){return h.context},get inputs(){return[]},get numberOfInputs(){return c.numberOfInputs},get numberOfOutputs(){return h.numberOfOutputs},get offset(){return h.gain},get onended(){return c.onended},set onended(t){c.onended=t},addEventListener:(...t)=>c.addEventListener(t[0],t[1],t[2]),dispatchEvent:(...t)=>c.dispatchEvent(t[0]),removeEventListener:(...t)=>c.removeEventListener(t[0],t[1],t[2]),start(t=0){c.start.call(c,t)},stop(t=0){c.stop.call(c,t)}};return t(i,c),n(Gt(l,h),()=>c.connect(h),()=>c.disconnect(h))})(is,cs,Qt,As),Is=((t,e,s,n,i)=>(o,r)=>{if(void 0===o.createConstantSource)return s(o,r);const a=o.createConstantSource();return It(a,r),Nt(a,r,"offset"),e(n,()=>n(o))||Pt(a),e(i,()=>i(o))||jt(a),t(o,a),a})(is,xe,Fs,ae,he),Vs=((t,e,s,n,i,o,r)=>class extends t{constructor(t,r){const a=i(t),c={...wt,...r},h=n(a,c),u=o(a),l=u?s():null;super(t,!1,h,l),this._constantSourceNodeRenderer=l,this._nativeConstantSourceNode=h,this._offset=e(this,u,h.offset,N,V),this._onended=null}get offset(){return this._offset}get onended(){return this._onended}set onended(t){const e="function"==typeof t?r(this,t):null;this._nativeConstantSourceNode.onended=e;const s=this._nativeConstantSourceNode.onended;this._onended=null!==s&&s===e?t:s}start(t=0){if(this._nativeConstantSourceNode.start(t),null!==this._constantSourceNodeRenderer&&(this._constantSourceNodeRenderer.start=t),"closed"!==this.context.state){C(this);const t=()=>{this._nativeConstantSourceNode.removeEventListener("ended",t),P(this)&&D(this)};this._nativeConstantSourceNode.addEventListener("ended",t)}}stop(t=0){this._nativeConstantSourceNode.stop(t),null!==this._constantSourceNodeRenderer&&(this._constantSourceNodeRenderer.stop=t)}})(Ze,ps,((t,e,s,n,i)=>()=>{const o=new WeakMap;let r=null,a=null;return{set start(t){r=t},set stop(t){a=t},render(c,h,u){const l=o.get(h);return void 0!==l?Promise.resolve(l):(async(c,h,u)=>{let l=s(c);const p=E(l,h);if(!p){const t={channelCount:l.channelCount,channelCountMode:l.channelCountMode,channelInterpretation:l.channelInterpretation,offset:l.offset.value};l=e(h,t),null!==r&&l.start(r),null!==a&&l.stop(a)}return o.set(h,l),p?await t(h,c.offset,l.offset,u):await n(h,c.offset,l.offset,u),await i(c,h,l,u),l})(c,h,u)}}})(as,Is,st,us,Oe),Is,Fe,Ne,de),Ns=((t,e)=>(s,n)=>{const i=s.createConvolver();if(It(i,n),n.disableNormalization===i.normalize&&(i.normalize=!n.disableNormalization),Ft(i,n,"buffer"),n.channelCount>2)throw t();if(e(i,"channelCount",t=>()=>t.call(i),e=>s=>{if(s>2)throw t();return e.call(i,s)}),"max"===n.channelCountMode)throw t();return e(i,"channelCountMode",t=>()=>t.call(i),e=>s=>{if("max"===s)throw t();return e.call(i,s)}),i})(Ht,oe),Ps=((t,e,s,n,i,o)=>class extends t{constructor(t,r){const a=n(t),c={...bt,...r},h=s(a,c);super(t,!1,h,i(a)?e():null),this._isBufferNullified=!1,this._nativeConvolverNode=h,null!==c.buffer&&o(this,c.buffer.duration)}get buffer(){return this._isBufferNullified?null:this._nativeConvolverNode.buffer}set buffer(t){if(this._nativeConvolverNode.buffer=t,null===t&&null!==this._nativeConvolverNode.buffer){const t=this._nativeConvolverNode.context;this._nativeConvolverNode.buffer=t.createBuffer(1,1,44100),this._isBufferNullified=!0,o(this,0)}else this._isBufferNullified=!1,o(this,null===this._nativeConvolverNode.buffer?0:this._nativeConvolverNode.buffer.duration)}get normalize(){return this._nativeConvolverNode.normalize}set normalize(t){this._nativeConvolverNode.normalize=t}})(Ze,((t,e,s)=>()=>{const n=new WeakMap;return{render(i,o,r){const a=n.get(o);return void 0!==a?Promise.resolve(a):(async(i,o,r)=>{let a=e(i);if(!E(a,o)){const e={buffer:a.buffer,channelCount:a.channelCount,channelCountMode:a.channelCountMode,channelInterpretation:a.channelInterpretation,disableNormalization:!a.normalize};a=t(o,e)}return n.set(o,a),H(a)?await s(i,o,a.inputs[0],r):await s(i,o,a,r),a})(i,o,r)}}})(Ns,st,Oe),Ns,Fe,Ne,gs),js=((t,e,s,n,i,o,r)=>class extends t{constructor(t,a){const c=i(t),h={...Tt,...a},u=n(c,h),l=o(c);super(t,!1,u,l?s(h.maxDelayTime):null),this._delayTime=e(this,l,u.delayTime),r(this,h.maxDelayTime)}get delayTime(){return this._delayTime}})(Ze,ps,((t,e,s,n,i)=>o=>{const r=new WeakMap;return{render(a,c,h){const u=r.get(c);return void 0!==u?Promise.resolve(u):(async(a,c,h)=>{let u=s(a);const l=E(u,c);if(!l){const t={channelCount:u.channelCount,channelCountMode:u.channelCountMode,channelInterpretation:u.channelInterpretation,delayTime:u.delayTime.value,maxDelayTime:o};u=e(c,t)}return r.set(c,u),l?await t(c,a.delayTime,u.delayTime,h):await n(c,a.delayTime,u.delayTime,h),await i(a,c,u,h),u})(a,c,h)}}})(as,Ut,st,us,Oe),Ut,Fe,Ne,gs),Ls=(zs=Ht,(t,e)=>{const s=t.createDynamicsCompressor();if(It(s,e),e.channelCount>2)throw zs();if("max"===e.channelCountMode)throw zs();return Nt(s,e,"attack"),Nt(s,e,"knee"),Nt(s,e,"ratio"),Nt(s,e,"release"),Nt(s,e,"threshold"),s});var zs;const Bs=((t,e,s,n,i,o,r,a)=>class extends t{constructor(t,i){const c=o(t),h={...kt,...i},u=n(c,h),l=r(c);super(t,!1,u,l?s():null),this._attack=e(this,l,u.attack),this._knee=e(this,l,u.knee),this._nativeDynamicsCompressorNode=u,this._ratio=e(this,l,u.ratio),this._release=e(this,l,u.release),this._threshold=e(this,l,u.threshold),a(this,.006)}get attack(){return this._attack}get channelCount(){return this._nativeDynamicsCompressorNode.channelCount}set channelCount(t){const e=this._nativeDynamicsCompressorNode.channelCount;if(this._nativeDynamicsCompressorNode.channelCount=t,t>2)throw this._nativeDynamicsCompressorNode.channelCount=e,i()}get channelCountMode(){return this._nativeDynamicsCompressorNode.channelCountMode}set channelCountMode(t){const e=this._nativeDynamicsCompressorNode.channelCountMode;if(this._nativeDynamicsCompressorNode.channelCountMode=t,"max"===t)throw this._nativeDynamicsCompressorNode.channelCountMode=e,i()}get knee(){return this._knee}get ratio(){return this._ratio}get reduction(){return"number"==typeof this._nativeDynamicsCompressorNode.reduction.value?this._nativeDynamicsCompressorNode.reduction.value:this._nativeDynamicsCompressorNode.reduction}get release(){return this._release}get threshold(){return this._threshold}})(Ze,ps,((t,e,s,n,i)=>()=>{const o=new WeakMap;return{render(r,a,c){const h=o.get(a);return void 0!==h?Promise.resolve(h):(async(r,a,c)=>{let h=s(r);const u=E(h,a);if(!u){const t={attack:h.attack.value,channelCount:h.channelCount,channelCountMode:h.channelCountMode,channelInterpretation:h.channelInterpretation,knee:h.knee.value,ratio:h.ratio.value,release:h.release.value,threshold:h.threshold.value};h=e(a,t)}return o.set(a,h),u?(await t(a,r.attack,h.attack,c),await t(a,r.knee,h.knee,c),await t(a,r.ratio,h.ratio,c),await t(a,r.release,h.release,c),await t(a,r.threshold,h.threshold,c)):(await n(a,r.attack,h.attack,c),await n(a,r.knee,h.knee,c),await n(a,r.ratio,h.ratio,c),await n(a,r.release,h.release,c),await n(a,r.threshold,h.threshold,c)),await i(r,a,h,c),h})(r,a,c)}}})(as,Ls,st,us,Oe),Ls,Ht,Fe,Ne,gs),Ws=((t,e,s,n,i,o)=>class extends t{constructor(t,r){const a=i(t),c={...Ct,...r},h=n(a,c),u=o(a);super(t,!1,h,u?s():null),this._gain=e(this,u,h.gain,N,V)}get gain(){return this._gain}})(Ze,ps,((t,e,s,n,i)=>()=>{const o=new WeakMap;return{render(r,a,c){const h=o.get(a);return void 0!==h?Promise.resolve(h):(async(r,a,c)=>{let h=s(r);const u=E(h,a);if(!u){const t={channelCount:h.channelCount,channelCountMode:h.channelCountMode,channelInterpretation:h.channelInterpretation,gain:h.gain.value};h=e(a,t)}return o.set(a,h),u?await t(a,r.gain,h.gain,c):await n(a,r.gain,h.gain,c),await i(r,a,h,c),h})(r,a,c)}}})(as,Qt,st,us,Oe),Qt,Fe,Ne),Gs=((t,e,s,n)=>(i,o,{channelCount:r,channelCountMode:a,channelInterpretation:c,feedback:h,feedforward:u})=>{const l=Lt(o,i.sampleRate),p=h instanceof Float64Array?h:new Float64Array(h),d=u instanceof Float64Array?u:new Float64Array(u),f=p.length,_=d.length,m=Math.min(f,_);if(0===f||f>20)throw n();if(0===p[0])throw e();if(0===_||_>20)throw n();if(0===d[0])throw e();if(1!==p[0]){for(let t=0;t<_;t+=1)d[t]/=p[0];for(let t=1;t<f;t+=1)p[t]/=p[0]}const g=s(i,l,r,r);g.channelCount=r,g.channelCountMode=a,g.channelInterpretation=c;const v=[],y=[],x=[];for(let t=0;t<r;t+=1){v.push(0);const t=new Float32Array(32),e=new Float32Array(32);t.fill(0),e.fill(0),y.push(t),x.push(e)}g.onaudioprocess=t=>{const e=t.inputBuffer,s=t.outputBuffer,n=e.numberOfChannels;for(let t=0;t<n;t+=1){const n=e.getChannelData(t),i=s.getChannelData(t);v[t]=Mt(p,f,d,_,m,y[t],x[t],v[t],32,n,i)}};const w=i.sampleRate/2;return Gt({get bufferSize(){return l},get channelCount(){return g.channelCount},set channelCount(t){g.channelCount=t},get channelCountMode(){return g.channelCountMode},set channelCountMode(t){g.channelCountMode=t},get channelInterpretation(){return g.channelInterpretation},set channelInterpretation(t){g.channelInterpretation=t},get context(){return g.context},get inputs(){return[g]},get numberOfInputs(){return g.numberOfInputs},get numberOfOutputs(){return g.numberOfOutputs},addEventListener:(...t)=>g.addEventListener(t[0],t[1],t[2]),dispatchEvent:(...t)=>g.dispatchEvent(t[0]),getFrequencyResponse(e,s,n){if(e.length!==s.length||s.length!==n.length)throw t();const i=e.length;for(let t=0;t<i;t+=1){const i=-Math.PI*(e[t]/w),o=[Math.cos(i),Math.sin(i)],r=Zt(Xt(d,o),Xt(p,o));s[t]=Math.sqrt(r[0]*r[0]+r[1]*r[1]),n[t]=Math.atan2(r[1],r[0])}},removeEventListener:(...t)=>g.removeEventListener(t[0],t[1],t[2])},g)})(Dt,At,Yt,Ht),Us=((t,e,s,n)=>i=>t(Rt,()=>Rt(i))?Promise.resolve(t(n,n)).then(t=>{if(!t){const t=s(i,512,0,1);i.oncomplete=()=>{t.onaudioprocess=null,t.disconnect()},t.onaudioprocess=()=>i.currentTime,t.connect(i.destination)}return i.startRendering()}):new Promise(t=>{const s=e(i,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});i.oncomplete=e=>{s.disconnect(),t(e.renderedBuffer)},s.connect(i.destination),i.startRendering()}))(xe,Qt,Yt,((t,e)=>()=>{if(null===e)return Promise.resolve(!1);const s=new e(1,1,44100),n=t(s,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});return new Promise(t=>{s.oncomplete=()=>{n.disconnect(),t(0!==s.currentTime)},s.startRendering()})})(Qt,Ve)),Qs=((t,e,s,n,i)=>(o,r)=>{const a=new WeakMap;let c=null;const h=async(h,u,l)=>{let p=null,d=e(h);const f=E(d,u);if(void 0===u.createIIRFilter?p=t(u,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}):f||(d=u.createIIRFilter(r,o)),a.set(u,null===p?d:p),null!==p){if(null===c){if(null===s)throw new Error("Missing the native OfflineAudioContext constructor.");const t=new s(h.context.destination.channelCount,h.context.length,u.sampleRate);c=(async()=>{await n(h,t,t.destination,l);return((t,e,s,n)=>{const i=s instanceof Float64Array?s:new Float64Array(s),o=n instanceof Float64Array?n:new Float64Array(n),r=i.length,a=o.length,c=Math.min(r,a);if(1!==i[0]){for(let t=0;t<r;t+=1)o[t]/=i[0];for(let t=1;t<a;t+=1)i[t]/=i[0]}const h=new Float32Array(32),u=new Float32Array(32),l=e.createBuffer(t.numberOfChannels,t.length,t.sampleRate),p=t.numberOfChannels;for(let e=0;e<p;e+=1){const s=t.getChannelData(e),n=l.getChannelData(e);h.fill(0),u.fill(0),Mt(i,r,o,a,c,h,u,0,32,s,n)}return l})(await i(t),u,o,r)})()}const t=await c;return p.buffer=t,p.start(0),p}return await n(h,u,d,l),d};return{render(t,e,s){const n=a.get(e);return void 0!==n?Promise.resolve(n):h(t,e,s)}}})(cs,st,Ve,Oe,Us);var Zs;const Xs=((t,e,s,n,i,o)=>class extends t{constructor(t,r){const a=n(t),c=i(a),h={...Ot,...r},u=e(a,c?null:t.baseLatency,h);super(t,!1,u,c?s(h.feedback,h.feedforward):null),(t=>{var e;t.getFrequencyResponse=(e=t.getFrequencyResponse,(s,n,i)=>{if(s.length!==n.length||n.length!==i.length)throw Dt();return e.call(t,s,n,i)})})(u),this._nativeIIRFilterNode=u,o(this,1)}getFrequencyResponse(t,e,s){return this._nativeIIRFilterNode.getFrequencyResponse(t,e,s)}})(Ze,(Zs=Gs,(t,e,s)=>{if(void 0===t.createIIRFilter)return Zs(t,e,s);const n=t.createIIRFilter(s.feedforward,s.feedback);return It(n,s),n}),Qs,Fe,Ne,gs),Ys=((t,e,s,n,i)=>(o,r)=>{const a=r.listener,{forwardX:c,forwardY:h,forwardZ:u,positionX:l,positionY:p,positionZ:d,upX:f,upY:_,upZ:m}=void 0===a.forwardX?(()=>{const c=e(r,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:9}),h=i(r),u=n(r,256,9,0),l=(e,n)=>{const i=s(r,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:n});return i.connect(c,0,e),i.start(),Object.defineProperty(i.offset,"defaultValue",{get:()=>n}),t({context:o},h,i.offset,N,V)};let p=[0,0,-1,0,1,0],d=[0,0,0];return u.onaudioprocess=({inputBuffer:t})=>{const e=[t.getChannelData(0)[0],t.getChannelData(1)[0],t.getChannelData(2)[0],t.getChannelData(3)[0],t.getChannelData(4)[0],t.getChannelData(5)[0]];e.some((t,e)=>t!==p[e])&&(a.setOrientation(...e),p=e);const s=[t.getChannelData(6)[0],t.getChannelData(7)[0],t.getChannelData(8)[0]];s.some((t,e)=>t!==d[e])&&(a.setPosition(...s),d=s)},c.connect(u),{forwardX:l(0,0),forwardY:l(1,0),forwardZ:l(2,-1),positionX:l(6,0),positionY:l(7,0),positionZ:l(8,0),upX:l(3,0),upY:l(4,1),upZ:l(5,0)}})():a;return{get forwardX(){return c},get forwardY(){return h},get forwardZ(){return u},get positionX(){return l},get positionY(){return p},get positionZ(){return d},get upX(){return f},get upY(){return _},get upZ(){return m}}})(ps,Es,Is,Yt,Ne),Hs=new WeakMap,$s=((t,e,s,n,i,o)=>class extends s{constructor(s,o){super(s),this._nativeContext=s,p.set(this,s),n(s)&&i.set(s,new Set),this._destination=new t(this,o),this._listener=e(this,s),this._onstatechange=null}get currentTime(){return this._nativeContext.currentTime}get destination(){return this._destination}get listener(){return this._listener}get onstatechange(){return this._onstatechange}set onstatechange(t){const e="function"==typeof t?o(this,t):null;this._nativeContext.onstatechange=e;const s=this._nativeContext.onstatechange;this._onstatechange=null!==s&&s===e?t:s}get sampleRate(){return this._nativeContext.sampleRate}get state(){return this._nativeContext.state}})(_s,Ys,Le,Ne,Hs,de),Js=((t,e,s,n,i,o)=>(r,a)=>{const c=r.createOscillator();return It(c,a),Nt(c,a,"detune"),Nt(c,a,"frequency"),void 0!==a.periodicWave?c.setPeriodicWave(a.periodicWave):Ft(c,a,"type"),e(s,()=>s(r))||Pt(c),e(n,()=>n(r))||o(c,r),e(i,()=>i(r))||jt(c),t(r,c),c})(is,xe,ae,ce,he,pe),Ks=((t,e,s,n,i,o,r)=>class extends t{constructor(t,r){const a=i(t),c={...Jt,...r},h=s(a,c),u=o(a),l=u?n():null,p=t.sampleRate/2;super(t,!1,h,l),this._detune=e(this,u,h.detune,153600,-153600),this._frequency=e(this,u,h.frequency,p,-p),this._nativeOscillatorNode=h,this._onended=null,this._oscillatorNodeRenderer=l,null!==this._oscillatorNodeRenderer&&void 0!==c.periodicWave&&(this._oscillatorNodeRenderer.periodicWave=c.periodicWave)}get detune(){return this._detune}get frequency(){return this._frequency}get onended(){return this._onended}set onended(t){const e="function"==typeof t?r(this,t):null;this._nativeOscillatorNode.onended=e;const s=this._nativeOscillatorNode.onended;this._onended=null!==s&&s===e?t:s}get type(){return this._nativeOscillatorNode.type}set type(t){this._nativeOscillatorNode.type=t,null!==this._oscillatorNodeRenderer&&(this._oscillatorNodeRenderer.periodicWave=null)}setPeriodicWave(t){this._nativeOscillatorNode.setPeriodicWave(t),null!==this._oscillatorNodeRenderer&&(this._oscillatorNodeRenderer.periodicWave=t)}start(t=0){if(this._nativeOscillatorNode.start(t),null!==this._oscillatorNodeRenderer&&(this._oscillatorNodeRenderer.start=t),"closed"!==this.context.state){C(this);const t=()=>{this._nativeOscillatorNode.removeEventListener("ended",t),P(this)&&D(this)};this._nativeOscillatorNode.addEventListener("ended",t)}}stop(t=0){this._nativeOscillatorNode.stop(t),null!==this._oscillatorNodeRenderer&&(this._oscillatorNodeRenderer.stop=t)}})(Ze,ps,Js,((t,e,s,n,i)=>()=>{const o=new WeakMap;let r=null,a=null,c=null;return{set periodicWave(t){r=t},set start(t){a=t},set stop(t){c=t},render(h,u,l){const p=o.get(u);return void 0!==p?Promise.resolve(p):(async(h,u,l)=>{let p=s(h);const d=E(p,u);if(!d){const t={channelCount:p.channelCount,channelCountMode:p.channelCountMode,channelInterpretation:p.channelInterpretation,detune:p.detune.value,frequency:p.frequency.value,periodicWave:null===r?void 0:r,type:p.type};p=e(u,t),null!==a&&p.start(a),null!==c&&p.stop(c)}return o.set(u,p),d?(await t(u,h.detune,p.detune,l),await t(u,h.frequency,p.frequency,l)):(await n(u,h.detune,p.detune,l),await n(u,h.frequency,p.frequency,l)),await i(h,u,p,l),p})(h,u,l)}}})(as,Js,st,us,Oe),Fe,Ne,de),tn=(en=cs,(t,e)=>{const s=en(t,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}),n=t.createBuffer(1,2,44100);return s.buffer=n,s.loop=!0,s.connect(e),s.start(),()=>{s.stop(),s.disconnect(e)}});var en;const sn=((t,e,s,n,i)=>(o,{curve:r,oversample:a,...c})=>{const h=o.createWaveShaper(),u=o.createWaveShaper();It(h,c),It(u,c);const l=s(o,{...c,gain:1}),p=s(o,{...c,gain:-1}),d=s(o,{...c,gain:1}),f=s(o,{...c,gain:-1});let _=null,m=!1,g=null;const v={get bufferSize(){},get channelCount(){return h.channelCount},set channelCount(t){l.channelCount=t,p.channelCount=t,h.channelCount=t,d.channelCount=t,u.channelCount=t,f.channelCount=t},get channelCountMode(){return h.channelCountMode},set channelCountMode(t){l.channelCountMode=t,p.channelCountMode=t,h.channelCountMode=t,d.channelCountMode=t,u.channelCountMode=t,f.channelCountMode=t},get channelInterpretation(){return h.channelInterpretation},set channelInterpretation(t){l.channelInterpretation=t,p.channelInterpretation=t,h.channelInterpretation=t,d.channelInterpretation=t,u.channelInterpretation=t,f.channelInterpretation=t},get context(){return h.context},get curve(){return g},set curve(s){if(null!==s&&s.length<2)throw e();if(null===s)h.curve=s,u.curve=s;else{const t=s.length,e=new Float32Array(t+2-t%2),n=new Float32Array(t+2-t%2);e[0]=s[0],n[0]=-s[t-1];const i=Math.ceil((t+1)/2),o=(t+1)/2-1;for(let r=1;r<i;r+=1){const a=r/i*o,c=Math.floor(a),h=Math.ceil(a);e[r]=c===h?s[c]:(1-(a-c))*s[c]+(1-(h-a))*s[h],n[r]=c===h?-s[t-1-c]:-(1-(a-c))*s[t-1-c]-(1-(h-a))*s[t-1-h]}e[i]=t%2==1?s[i-1]:(s[i-2]+s[i-1])/2,h.curve=e,u.curve=n}g=s,m&&(n(g)&&null===_?_=t(o,l):null!==_&&(_(),_=null))},get inputs(){return[l]},get numberOfInputs(){return h.numberOfInputs},get numberOfOutputs(){return h.numberOfOutputs},get oversample(){return h.oversample},set oversample(t){h.oversample=t,u.oversample=t},addEventListener:(...t)=>l.addEventListener(t[0],t[1],t[2]),dispatchEvent:(...t)=>l.dispatchEvent(t[0]),removeEventListener:(...t)=>l.removeEventListener(t[0],t[1],t[2])};null!==r&&(v.curve=r instanceof Float32Array?r:new Float32Array(r)),a!==v.oversample&&(v.oversample=a);return i(Gt(v,d),()=>{l.connect(h).connect(d),l.connect(p).connect(u).connect(f).connect(d),m=!0,n(g)&&(_=t(o,l))},()=>{l.disconnect(h),h.disconnect(d),l.disconnect(p),p.disconnect(u),u.disconnect(f),f.disconnect(d),m=!1,null!==_&&(_(),_=null)})})(tn,At,Qt,ie,As),nn=((t,e,s,n,i,o,r)=>(a,c)=>{const h=a.createWaveShaper();if(null!==o&&"webkitAudioContext"===o.name&&void 0===a.createGain().gain.automationRate)return s(a,c);It(h,c);const u=null===c.curve||c.curve instanceof Float32Array?c.curve:new Float32Array(c.curve);if(null!==u&&u.length<2)throw e();Ft(h,{curve:u},"curve"),Ft(h,c,"oversample");let l=null,p=!1;r(h,"curve",t=>()=>t.call(h),e=>s=>(e.call(h,s),p&&(n(s)&&null===l?l=t(a,h):n(s)||null===l||(l(),l=null)),s));return i(h,()=>{p=!0,n(h.curve)&&(l=t(a,h))},()=>{p=!1,null!==l&&(l(),l=null)})})(tn,At,sn,ie,As,Be,oe),on=((t,e,s,n,i,o,r,a,c)=>(h,{coneInnerAngle:u,coneOuterAngle:l,coneOuterGain:p,distanceModel:d,maxDistance:f,orientationX:_,orientationY:m,orientationZ:g,panningModel:v,positionX:y,positionY:x,positionZ:w,refDistance:b,rolloffFactor:T,...S})=>{const k=h.createPanner();if(S.channelCount>2)throw r();if("max"===S.channelCountMode)throw r();It(k,S);const C={channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete"},A=s(h,{...C,channelInterpretation:"speakers",numberOfInputs:6}),D=n(h,{...S,gain:1}),O=n(h,{...C,gain:1}),M=n(h,{...C,gain:0}),E=n(h,{...C,gain:0}),R=n(h,{...C,gain:0}),q=n(h,{...C,gain:0}),F=n(h,{...C,gain:0}),I=i(h,256,6,1),V=o(h,{...C,curve:new Float32Array([1,1]),oversample:"none"});let N=[_,m,g],P=[y,x,w];I.onaudioprocess=({inputBuffer:t})=>{const e=[t.getChannelData(0)[0],t.getChannelData(1)[0],t.getChannelData(2)[0]];e.some((t,e)=>t!==N[e])&&(k.setOrientation(...e),N=e);const s=[t.getChannelData(3)[0],t.getChannelData(4)[0],t.getChannelData(5)[0]];s.some((t,e)=>t!==P[e])&&(k.setPosition(...s),P=s)},Object.defineProperty(M.gain,"defaultValue",{get:()=>0}),Object.defineProperty(E.gain,"defaultValue",{get:()=>0}),Object.defineProperty(R.gain,"defaultValue",{get:()=>0}),Object.defineProperty(q.gain,"defaultValue",{get:()=>0}),Object.defineProperty(F.gain,"defaultValue",{get:()=>0});const j={get bufferSize(){},get channelCount(){return k.channelCount},set channelCount(t){if(t>2)throw r();D.channelCount=t,k.channelCount=t},get channelCountMode(){return k.channelCountMode},set channelCountMode(t){if("max"===t)throw r();D.channelCountMode=t,k.channelCountMode=t},get channelInterpretation(){return k.channelInterpretation},set channelInterpretation(t){D.channelInterpretation=t,k.channelInterpretation=t},get coneInnerAngle(){return k.coneInnerAngle},set coneInnerAngle(t){k.coneInnerAngle=t},get coneOuterAngle(){return k.coneOuterAngle},set coneOuterAngle(t){k.coneOuterAngle=t},get coneOuterGain(){return k.coneOuterGain},set coneOuterGain(t){if(t<0||t>1)throw e();k.coneOuterGain=t},get context(){return k.context},get distanceModel(){return k.distanceModel},set distanceModel(t){k.distanceModel=t},get inputs(){return[D]},get maxDistance(){return k.maxDistance},set maxDistance(t){if(t<0)throw new RangeError;k.maxDistance=t},get numberOfInputs(){return k.numberOfInputs},get numberOfOutputs(){return k.numberOfOutputs},get orientationX(){return O.gain},get orientationY(){return M.gain},get orientationZ(){return E.gain},get panningModel(){return k.panningModel},set panningModel(t){k.panningModel=t},get positionX(){return R.gain},get positionY(){return q.gain},get positionZ(){return F.gain},get refDistance(){return k.refDistance},set refDistance(t){if(t<0)throw new RangeError;k.refDistance=t},get rolloffFactor(){return k.rolloffFactor},set rolloffFactor(t){if(t<0)throw new RangeError;k.rolloffFactor=t},addEventListener:(...t)=>D.addEventListener(t[0],t[1],t[2]),dispatchEvent:(...t)=>D.dispatchEvent(t[0]),removeEventListener:(...t)=>D.removeEventListener(t[0],t[1],t[2])};u!==j.coneInnerAngle&&(j.coneInnerAngle=u),l!==j.coneOuterAngle&&(j.coneOuterAngle=l),p!==j.coneOuterGain&&(j.coneOuterGain=p),d!==j.distanceModel&&(j.distanceModel=d),f!==j.maxDistance&&(j.maxDistance=f),_!==j.orientationX.value&&(j.orientationX.value=_),m!==j.orientationY.value&&(j.orientationY.value=m),g!==j.orientationZ.value&&(j.orientationZ.value=g),v!==j.panningModel&&(j.panningModel=v),y!==j.positionX.value&&(j.positionX.value=y),x!==j.positionY.value&&(j.positionY.value=x),w!==j.positionZ.value&&(j.positionZ.value=w),b!==j.refDistance&&(j.refDistance=b),T!==j.rolloffFactor&&(j.rolloffFactor=T),1===N[0]&&0===N[1]&&0===N[2]||k.setOrientation(...N),0===P[0]&&0===P[1]&&0===P[2]||k.setPosition(...P);return c(Gt(j,k),()=>{D.connect(k),t(D,V,0,0),V.connect(O).connect(A,0,0),V.connect(M).connect(A,0,1),V.connect(E).connect(A,0,2),V.connect(R).connect(A,0,3),V.connect(q).connect(A,0,4),V.connect(F).connect(A,0,5),A.connect(I).connect(h.destination)},()=>{D.disconnect(k),a(D,V,0,0),V.disconnect(O),O.disconnect(A),V.disconnect(M),M.disconnect(A),V.disconnect(E),E.disconnect(A),V.disconnect(R),R.disconnect(A),V.disconnect(q),q.disconnect(A),V.disconnect(F),F.disconnect(A),A.disconnect(I),I.disconnect(h.destination)})})($,At,Es,Qt,Yt,nn,Ht,et,As),rn=(an=on,(t,e)=>{const s=t.createPanner();return void 0===s.orientationX?an(t,e):(It(s,e),Nt(s,e,"orientationX"),Nt(s,e,"orientationY"),Nt(s,e,"orientationZ"),Nt(s,e,"positionX"),Nt(s,e,"positionY"),Nt(s,e,"positionZ"),Ft(s,e,"coneInnerAngle"),Ft(s,e,"coneOuterAngle"),Ft(s,e,"coneOuterGain"),Ft(s,e,"distanceModel"),Ft(s,e,"maxDistance"),Ft(s,e,"panningModel"),Ft(s,e,"refDistance"),Ft(s,e,"rolloffFactor"),s)});var an;const cn=((t,e,s,n,i,o,r)=>class extends t{constructor(t,a){const c=i(t),h={...Kt,...a},u=s(c,h),l=o(c);super(t,!1,u,l?n():null),this._nativePannerNode=u,this._orientationX=e(this,l,u.orientationX,N,V),this._orientationY=e(this,l,u.orientationY,N,V),this._orientationZ=e(this,l,u.orientationZ,N,V),this._positionX=e(this,l,u.positionX,N,V),this._positionY=e(this,l,u.positionY,N,V),this._positionZ=e(this,l,u.positionZ,N,V),r(this,1)}get coneInnerAngle(){return this._nativePannerNode.coneInnerAngle}set coneInnerAngle(t){this._nativePannerNode.coneInnerAngle=t}get coneOuterAngle(){return this._nativePannerNode.coneOuterAngle}set coneOuterAngle(t){this._nativePannerNode.coneOuterAngle=t}get coneOuterGain(){return this._nativePannerNode.coneOuterGain}set coneOuterGain(t){this._nativePannerNode.coneOuterGain=t}get distanceModel(){return this._nativePannerNode.distanceModel}set distanceModel(t){this._nativePannerNode.distanceModel=t}get maxDistance(){return this._nativePannerNode.maxDistance}set maxDistance(t){this._nativePannerNode.maxDistance=t}get orientationX(){return this._orientationX}get orientationY(){return this._orientationY}get orientationZ(){return this._orientationZ}get panningModel(){return this._nativePannerNode.panningModel}set panningModel(t){this._nativePannerNode.panningModel=t}get positionX(){return this._positionX}get positionY(){return this._positionY}get positionZ(){return this._positionZ}get refDistance(){return this._nativePannerNode.refDistance}set refDistance(t){this._nativePannerNode.refDistance=t}get rolloffFactor(){return this._nativePannerNode.rolloffFactor}set rolloffFactor(t){this._nativePannerNode.rolloffFactor=t}})(Ze,ps,rn,((t,e,s,n,i,o,r,a,c,h)=>()=>{const u=new WeakMap;let l=null;return{render(p,d,f){const _=u.get(d);return void 0!==_?Promise.resolve(_):(async(p,d,f)=>{let _=null,m=o(p);const g={channelCount:m.channelCount,channelCountMode:m.channelCountMode,channelInterpretation:m.channelInterpretation},v={...g,coneInnerAngle:m.coneInnerAngle,coneOuterAngle:m.coneOuterAngle,coneOuterGain:m.coneOuterGain,distanceModel:m.distanceModel,maxDistance:m.maxDistance,panningModel:m.panningModel,refDistance:m.refDistance,rolloffFactor:m.rolloffFactor},y=E(m,d);if("bufferSize"in m)_=n(d,{...g,gain:1});else if(!y){const t={...v,orientationX:m.orientationX.value,orientationY:m.orientationY.value,orientationZ:m.orientationZ.value,positionX:m.positionX.value,positionY:m.positionY.value,positionZ:m.positionZ.value};m=i(d,t)}if(u.set(d,null===_?m:_),null!==_){if(null===l){if(null===r)throw new Error("Missing the native OfflineAudioContext constructor.");const t=new r(6,p.context.length,d.sampleRate),n=e(t,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:6});n.connect(t.destination),l=(async()=>{const e=await Promise.all([p.orientationX,p.orientationY,p.orientationZ,p.positionX,p.positionY,p.positionZ].map(async(e,n)=>{const i=s(t,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:0===n?1:0});return await a(t,e,i.offset,f),i}));for(let t=0;t<6;t+=1)e[t].connect(n,0,t),e[t].start(0);return h(t)})()}const t=await l,o=n(d,{...g,gain:1});await c(p,d,o,f);const u=[];for(let e=0;e<t.numberOfChannels;e+=1)u.push(t.getChannelData(e));let m=[u[0][0],u[1][0],u[2][0]],y=[u[3][0],u[4][0],u[5][0]],x=n(d,{...g,gain:1}),w=i(d,{...v,orientationX:m[0],orientationY:m[1],orientationZ:m[2],positionX:y[0],positionY:y[1],positionZ:y[2]});o.connect(x).connect(w.inputs[0]),w.connect(_);for(let e=128;e<t.length;e+=128){const t=[u[0][e],u[1][e],u[2][e]],s=[u[3][e],u[4][e],u[5][e]];if(t.some((t,e)=>t!==m[e])||s.some((t,e)=>t!==y[e])){m=t,y=s;const r=e/d.sampleRate;x.gain.setValueAtTime(0,r),x=n(d,{...g,gain:0}),w=i(d,{...v,orientationX:m[0],orientationY:m[1],orientationZ:m[2],positionX:y[0],positionY:y[1],positionZ:y[2]}),x.gain.setValueAtTime(1,r),o.connect(x).connect(w.inputs[0]),w.connect(_)}}return _}return y?(await t(d,p.orientationX,m.orientationX,f),await t(d,p.orientationY,m.orientationY,f),await t(d,p.orientationZ,m.orientationZ,f),await t(d,p.positionX,m.positionX,f),await t(d,p.positionY,m.positionY,f),await t(d,p.positionZ,m.positionZ,f)):(await a(d,p.orientationX,m.orientationX,f),await a(d,p.orientationY,m.orientationY,f),await a(d,p.orientationZ,m.orientationZ,f),await a(d,p.positionX,m.positionX,f),await a(d,p.positionY,m.positionY,f),await a(d,p.positionZ,m.positionZ,f)),H(m)?await c(p,d,m.inputs[0],f):await c(p,d,m,f),m})(p,d,f)}}})(as,Es,Is,Qt,rn,st,Ve,us,Oe,Us),Fe,Ne,gs),hn=((t,e,s,n)=>class i{constructor(i,o){const r=e(i),a=n({...te,...o}),c=t(r,a);return s.add(c),c}static[Symbol.hasInstance](t){return null!==t&&"object"==typeof t&&Object.getPrototypeOf(t)===i.prototype||s.has(t)}})((t=>(e,{disableNormalization:s,imag:n,real:i})=>{const o=n instanceof Float32Array?n:new Float32Array(n),r=i instanceof Float32Array?i:new Float32Array(i),a=e.createPeriodicWave(r,o,{disableNormalization:s});if(Array.from(n).length<2)throw t();return a})(q),Fe,new WeakSet,t=>{const{imag:e,real:s}=t;return void 0===e?void 0===s?{...t,imag:[0,0],real:[0,0]}:{...t,imag:Array.from(s,()=>0),real:s}:void 0===s?{...t,imag:e,real:Array.from(e,()=>0)}:{...t,imag:e,real:s}}),un=((t,e)=>(s,n)=>{const i=n.channelCountMode;if("clamped-max"===i)throw e();if(void 0===s.createStereoPanner)return t(s,n);const o=s.createStereoPanner();return It(o,n),Nt(o,n,"pan"),Object.defineProperty(o,"channelCountMode",{get:()=>i,set:t=>{if(t!==i)throw e()}}),o})(((t,e,s,n,i,o)=>{const r=new Float32Array([1,1]),a=Math.PI/2,c={channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete"},h={...c,oversample:"none"},u=(t,o,u,l,p)=>{if(1===o)return((t,e,i,o)=>{const u=new Float32Array(16385),l=new Float32Array(16385);for(let t=0;t<16385;t+=1){const e=t/16384*a;u[t]=Math.cos(e),l[t]=Math.sin(e)}const p=s(t,{...c,gain:0}),d=n(t,{...h,curve:u}),f=n(t,{...h,curve:r}),_=s(t,{...c,gain:0}),m=n(t,{...h,curve:l});return{connectGraph(){e.connect(p),e.connect(void 0===f.inputs?f:f.inputs[0]),e.connect(_),f.connect(i),i.connect(void 0===d.inputs?d:d.inputs[0]),i.connect(void 0===m.inputs?m:m.inputs[0]),d.connect(p.gain),m.connect(_.gain),p.connect(o,0,0),_.connect(o,0,1)},disconnectGraph(){e.disconnect(p),e.disconnect(void 0===f.inputs?f:f.inputs[0]),e.disconnect(_),f.disconnect(i),i.disconnect(void 0===d.inputs?d:d.inputs[0]),i.disconnect(void 0===m.inputs?m:m.inputs[0]),d.disconnect(p.gain),m.disconnect(_.gain),p.disconnect(o,0,0),_.disconnect(o,0,1)}}})(t,u,l,p);if(2===o)return((t,i,o,u)=>{const l=new Float32Array(16385),p=new Float32Array(16385),d=new Float32Array(16385),f=new Float32Array(16385),_=Math.floor(8192.5);for(let t=0;t<16385;t+=1)if(t>_){const e=(t-_)/(16384-_)*a;l[t]=Math.cos(e),p[t]=Math.sin(e),d[t]=0,f[t]=1}else{const e=t/(16384-_)*a;l[t]=1,p[t]=0,d[t]=Math.cos(e),f[t]=Math.sin(e)}const m=e(t,{channelCount:2,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:2}),g=s(t,{...c,gain:0}),v=n(t,{...h,curve:l}),y=s(t,{...c,gain:0}),x=n(t,{...h,curve:p}),w=n(t,{...h,curve:r}),b=s(t,{...c,gain:0}),T=n(t,{...h,curve:d}),S=s(t,{...c,gain:0}),k=n(t,{...h,curve:f});return{connectGraph(){i.connect(m),i.connect(void 0===w.inputs?w:w.inputs[0]),m.connect(g,0),m.connect(y,0),m.connect(b,1),m.connect(S,1),w.connect(o),o.connect(void 0===v.inputs?v:v.inputs[0]),o.connect(void 0===x.inputs?x:x.inputs[0]),o.connect(void 0===T.inputs?T:T.inputs[0]),o.connect(void 0===k.inputs?k:k.inputs[0]),v.connect(g.gain),x.connect(y.gain),T.connect(b.gain),k.connect(S.gain),g.connect(u,0,0),b.connect(u,0,0),y.connect(u,0,1),S.connect(u,0,1)},disconnectGraph(){i.disconnect(m),i.disconnect(void 0===w.inputs?w:w.inputs[0]),m.disconnect(g,0),m.disconnect(y,0),m.disconnect(b,1),m.disconnect(S,1),w.disconnect(o),o.disconnect(void 0===v.inputs?v:v.inputs[0]),o.disconnect(void 0===x.inputs?x:x.inputs[0]),o.disconnect(void 0===T.inputs?T:T.inputs[0]),o.disconnect(void 0===k.inputs?k:k.inputs[0]),v.disconnect(g.gain),x.disconnect(y.gain),T.disconnect(b.gain),k.disconnect(S.gain),g.disconnect(u,0,0),b.disconnect(u,0,0),y.disconnect(u,0,1),S.disconnect(u,0,1)}}})(t,u,l,p);throw i()};return(e,{channelCount:n,channelCountMode:r,pan:a,...c})=>{if("max"===r)throw i();const h=t(e,{...c,channelCount:1,channelCountMode:r,numberOfInputs:2}),l=s(e,{...c,channelCount:n,channelCountMode:r,gain:1}),p=s(e,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:a});let{connectGraph:d,disconnectGraph:f}=u(e,n,l,p,h);Object.defineProperty(p.gain,"defaultValue",{get:()=>0}),Object.defineProperty(p.gain,"maxValue",{get:()=>1}),Object.defineProperty(p.gain,"minValue",{get:()=>-1});const _={get bufferSize(){},get channelCount(){return l.channelCount},set channelCount(t){l.channelCount!==t&&(m&&f(),({connectGraph:d,disconnectGraph:f}=u(e,t,l,p,h)),m&&d()),l.channelCount=t},get channelCountMode(){return l.channelCountMode},set channelCountMode(t){if("clamped-max"===t||"max"===t)throw i();l.channelCountMode=t},get channelInterpretation(){return l.channelInterpretation},set channelInterpretation(t){l.channelInterpretation=t},get context(){return l.context},get inputs(){return[l]},get numberOfInputs(){return l.numberOfInputs},get numberOfOutputs(){return l.numberOfOutputs},get pan(){return p.gain},addEventListener:(...t)=>l.addEventListener(t[0],t[1],t[2]),dispatchEvent:(...t)=>l.dispatchEvent(t[0]),removeEventListener:(...t)=>l.removeEventListener(t[0],t[1],t[2])};let m=!1;return o(Gt(_,h),()=>{d(),m=!0},()=>{f(),m=!1})}})(Es,Wt,Qt,nn,Ht,As),Ht),ln=((t,e,s,n,i,o)=>class extends t{constructor(t,r){const a=i(t),c={...ee,...r},h=s(a,c),u=o(a);super(t,!1,h,u?n():null),this._pan=e(this,u,h.pan)}get pan(){return this._pan}})(Ze,ps,un,((t,e,s,n,i)=>()=>{const o=new WeakMap;return{render(r,a,c){const h=o.get(a);return void 0!==h?Promise.resolve(h):(async(r,a,c)=>{let h=s(r);const u=E(h,a);if(!u){const t={channelCount:h.channelCount,channelCountMode:h.channelCountMode,channelInterpretation:h.channelInterpretation,pan:h.pan.value};h=e(a,t)}return o.set(a,h),u?await t(a,r.pan,h.pan,c):await n(a,r.pan,h.pan,c),H(h)?await i(r,a,h.inputs[0],c):await i(r,a,h,c),h})(r,a,c)}}})(as,un,st,us,Oe),Fe,Ne),pn=((t,e,s)=>()=>{const n=new WeakMap;return{render(i,o,r){const a=n.get(o);return void 0!==a?Promise.resolve(a):(async(i,o,r)=>{let a=e(i);if(!E(a,o)){const e={channelCount:a.channelCount,channelCountMode:a.channelCountMode,channelInterpretation:a.channelInterpretation,curve:a.curve,oversample:a.oversample};a=t(o,e)}return n.set(o,a),H(a)?await s(i,o,a.inputs[0],r):await s(i,o,a,r),a})(i,o,r)}}})(nn,st,Oe),dn=((t,e,s,n,i,o,r)=>class extends t{constructor(t,e){const a=i(t),c={...ne,...e},h=s(a,c);super(t,!0,h,o(a)?n():null),this._isCurveNullified=!1,this._nativeWaveShaperNode=h,r(this,1)}get curve(){return this._isCurveNullified?null:this._nativeWaveShaperNode.curve}set curve(t){if(null===t)this._isCurveNullified=!0,this._nativeWaveShaperNode.curve=new Float32Array([0,0]);else{if(t.length<2)throw e();this._isCurveNullified=!1,this._nativeWaveShaperNode.curve=t}}get oversample(){return this._nativeWaveShaperNode.oversample}set oversample(t){this._nativeWaveShaperNode.oversample=t}})(Ze,At,nn,pn,Fe,Ne,gs),fn=(t=>null!==t&&t.isSecureContext)(Te),_n=(t=>(e,s,n)=>{Object.defineProperties(t,{currentFrame:{configurable:!0,get:()=>Math.round(e*s)},currentTime:{configurable:!0,get:()=>e}});try{return n()}finally{null!==t&&(delete t.currentFrame,delete t.currentTime)}})(Te),mn=new WeakMap,gn=((t,e)=>s=>{let n=t.get(s);if(void 0!==n)return n;if(null===e)throw new Error("Missing the native OfflineAudioContext constructor.");return n=new e(1,1,8e3),t.set(s,n),n})(mn,Ve),vn=(t=>null===t?null:t.hasOwnProperty("AudioWorkletNode")?t.AudioWorkletNode:null)(Te),yn=fn?((t,e,s,n,i,o,r,a,c,h,u,l)=>(p,d,f={credentials:"omit"})=>{const m=o(p);if(void 0!==m.audioWorklet)return Promise.all([i(d),Promise.resolve(t(u,u))]).then(([[t,e],s])=>{const[n,i]=y(t,e),o=s?i:i.replace(/\s+extends\s+AudioWorkletProcessor\s*{/," extends (class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}){"),c=new Blob([`${n};(registerProcessor=>{${o}\n})((n,p)=>registerProcessor(n,class extends p{${s?"":"__c = (a) => a.forEach(e=>this.__b.add(e.buffer));"}process(i,o,p){${s?"":"i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));"}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}))`],{type:"application/javascript; charset=utf-8"}),h=URL.createObjectURL(c);return m.audioWorklet.addModule(h,f).then(()=>{if(a(m))return;return r(m).audioWorklet.addModule(h,f)}).finally(()=>URL.revokeObjectURL(h))});const g=h.get(p);if(void 0!==g&&g.has(d))return Promise.resolve();const v=c.get(p);if(void 0!==v){const t=v.get(d);if(void 0!==t)return t}const b=i(d).then(([t,e])=>{const[n,i]=y(t,e);return s(`${n};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${i}\n})})(window,'_AWGS')`)}).then(()=>{const t=l._AWGS.pop();if(void 0===t)throw new SyntaxError;n(m.currentTime,m.sampleRate,()=>t(class{},void 0,(t,s)=>{if(""===t.trim())throw e();const n=_.get(m);if(void 0!==n){if(n.has(t))throw e();w(s),x(s.parameterDescriptors),n.set(t,s)}else w(s),x(s.parameterDescriptors),_.set(m,new Map([[t,s]]))},m.sampleRate,void 0,void 0))});return void 0===v?c.set(p,new Map([[d,b]])):v.set(d,b),b.then(()=>{const t=h.get(p);void 0===t?h.set(p,new Set([d])):t.add(d)}).finally(()=>{const t=c.get(p);void 0!==t&&t.delete(d)}),b})(xe,Ht,(t=>e=>new Promise((s,n)=>{if(null===t)return void n(new SyntaxError);const i=t.document.head;if(null===i)n(new SyntaxError);else{const o=t.document.createElement("script"),r=new Blob([e],{type:"application/javascript"}),a=URL.createObjectURL(r),c=t.onerror,h=()=>{t.onerror=c,URL.revokeObjectURL(a)};t.onerror=(e,s,i,o,r)=>s===a||s===t.location.href&&1===i&&1===o?(h(),n(r),!1):null!==c?c(e,s,i,o,r):void 0,o.onerror=()=>{h(),n(new SyntaxError)},o.onload=()=>{h(),s()},o.src=a,o.type="module",i.appendChild(o)}}))(Te),_n,(t=>async e=>{try{const t=await fetch(e);if(t.ok)return[await t.text(),t.url]}catch{}throw t()})(()=>new DOMException("","AbortError")),Fe,gn,Ne,new WeakMap,new WeakMap,((t,e)=>async()=>{if(null===t)return!0;if(null===e)return!1;const s=new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'],{type:"application/javascript; charset=utf-8"}),n=new e(1,128,8e3),i=URL.createObjectURL(s);let o=!1,r=!1;try{await n.audioWorklet.addModule(i);const e=new t(n,"a",{numberOfOutputs:0}),s=n.createOscillator();e.port.onmessage=()=>o=!0,e.onprocessorerror=()=>r=!0,s.connect(e),await n.startRendering()}catch{}finally{URL.revokeObjectURL(i)}return o&&!r})(vn,Ve),Te):void 0,xn=((t,e)=>s=>t(s)||e(s))(We,Ne),wn=((t,e,s,n,i,o,r,a,c,h,u,l,p,d,f,_,m,g,v,y)=>class extends f{constructor(e,s){super(e,s),this._nativeContext=e,this._audioWorklet=void 0===t?void 0:{addModule:(e,s)=>t(this,e,s)}}get audioWorklet(){return this._audioWorklet}createAnalyser(){return new e(this)}createBiquadFilter(){return new i(this)}createBuffer(t,e,n){return new s({length:e,numberOfChannels:t,sampleRate:n})}createBufferSource(){return new n(this)}createChannelMerger(t=6){return new o(this,{numberOfInputs:t})}createChannelSplitter(t=6){return new r(this,{numberOfOutputs:t})}createConstantSource(){return new a(this)}createConvolver(){return new c(this)}createDelay(t=1){return new u(this,{maxDelayTime:t})}createDynamicsCompressor(){return new l(this)}createGain(){return new p(this)}createIIRFilter(t,e){return new d(this,{feedback:e,feedforward:t})}createOscillator(){return new _(this)}createPanner(){return new m(this)}createPeriodicWave(t,e,s={disableNormalization:!1}){return new g(this,{...s,imag:e,real:t})}createStereoPanner(){return new v(this)}createWaveShaper(){return new y(this)}decodeAudioData(t,e,s){return h(this._nativeContext,t).then(t=>("function"==typeof e&&e(t),t)).catch(t=>{throw"function"==typeof s&&s(t),t})}})(yn,Ye,ss,fs,vs,Rs,qs,Vs,Ps,((t,e,s,n,i,o,r,a,c,h,u)=>(l,p)=>{const d=r(l)?l:o(l);if(i.has(p)){const t=s();return Promise.reject(t)}try{i.add(p)}catch{}return e(c,()=>c(d))?d.decodeAudioData(p).then(s=>(e(a,()=>a(s))||u(s),t.add(s),s)):new Promise((e,s)=>{const i=()=>{try{(t=>{const{port1:e}=new MessageChannel;e.postMessage(t,[t])})(p)}catch{}},o=t=>{s(t),i()};try{d.decodeAudioData(p,s=>{"function"!=typeof s.copyFromChannel&&(h(s),F(s)),t.add(s),i(),e(s)},t=>{o(null===t?n():t)})}catch(t){o(t)}})})(He,xe,()=>new DOMException("","DataCloneError"),()=>new DOMException("","EncodingError"),new WeakSet,Fe,xn,R,Rt,ts,es),js,Bs,Ws,Xs,$s,Ks,cn,hn,ln,dn),bn=((t,e,s,n)=>class extends t{constructor(t,i){const o=s(t),r=e(o,i);if(n(o))throw TypeError();super(t,!0,r,null),this._nativeMediaElementAudioSourceNode=r}get mediaElement(){return this._nativeMediaElementAudioSourceNode.mediaElement}})(Ze,(t,e)=>t.createMediaElementSource(e.mediaElement),Fe,Ne),Tn=((t,e,s,n)=>class extends t{constructor(t,i){const o=s(t);if(n(o))throw new TypeError;const r={...Et,...i},a=e(o,r);super(t,!1,a,null),this._nativeMediaStreamAudioDestinationNode=a}get stream(){return this._nativeMediaStreamAudioDestinationNode.stream}})(Ze,(t,e)=>{const s=t.createMediaStreamDestination();return It(s,e),1===s.numberOfOutputs&&Object.defineProperty(s,"numberOfOutputs",{get:()=>0}),s},Fe,Ne),Sn=((t,e,s,n)=>class extends t{constructor(t,i){const o=s(t),r=e(o,i);if(n(o))throw new TypeError;super(t,!0,r,null),this._nativeMediaStreamAudioSourceNode=r}get mediaStream(){return this._nativeMediaStreamAudioSourceNode.mediaStream}})(Ze,(t,{mediaStream:e})=>{const s=e.getAudioTracks();s.sort((t,e)=>t.id<e.id?-1:t.id>e.id?1:0);const n=s.slice(0,1),i=t.createMediaStreamSource(new MediaStream(n));return Object.defineProperty(i,"mediaStream",{value:e}),i},Fe,Ne),kn=((t,e,s)=>class extends t{constructor(t,n){const i=s(t);super(t,!0,e(i,n),null)}})(Ze,((t,e)=>(s,{mediaStreamTrack:n})=>{if("function"==typeof s.createMediaStreamTrackSource)return s.createMediaStreamTrackSource(n);const i=new MediaStream([n]),o=s.createMediaStreamSource(i);if("audio"!==n.kind)throw t();if(e(s))throw new TypeError;return o})(At,Ne),Fe),Cn=((t,e,s,n,i,o,r,a,c)=>class extends t{constructor(t={}){if(null===c)throw new Error("Missing the native AudioContext constructor.");const e=new c(t);if(null===e)throw n();if(!G(t.latencyHint))throw new TypeError(`The provided value '${t.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);if(void 0!==t.sampleRate&&e.sampleRate!==t.sampleRate)throw s();super(e,2);const{latencyHint:i}=t,{sampleRate:o}=e;if(this._baseLatency="number"==typeof e.baseLatency?e.baseLatency:"balanced"===i?512/o:"interactive"===i||void 0===i?256/o:"playback"===i?1024/o:128*Math.max(2,Math.min(128,Math.round(i*o/128)))/o,this._nativeAudioContext=e,"webkitAudioContext"===c.name?(this._nativeGainNode=e.createGain(),this._nativeOscillatorNode=e.createOscillator(),this._nativeGainNode.gain.value=1e-37,this._nativeOscillatorNode.connect(this._nativeGainNode).connect(e.destination),this._nativeOscillatorNode.start()):(this._nativeGainNode=null,this._nativeOscillatorNode=null),this._state=null,"running"===e.state){this._state="suspended";const t=()=>{"suspended"===this._state&&(this._state=null),e.removeEventListener("statechange",t)};e.addEventListener("statechange",t)}}get baseLatency(){return this._baseLatency}get state(){return null!==this._state?this._state:this._nativeAudioContext.state}close(){return"closed"===this.state?this._nativeAudioContext.close().then(()=>{throw e()}):("suspended"===this._state&&(this._state=null),this._nativeAudioContext.close().then(()=>{null!==this._nativeGainNode&&null!==this._nativeOscillatorNode&&(this._nativeOscillatorNode.stop(),this._nativeGainNode.disconnect(),this._nativeOscillatorNode.disconnect()),W(this)}))}createMediaElementSource(t){return new i(this,{mediaElement:t})}createMediaStreamDestination(){return new o(this)}createMediaStreamSource(t){return new r(this,{mediaStream:t})}createMediaStreamTrackSource(t){return new a(this,{mediaStreamTrack:t})}resume(){return"suspended"===this._state?new Promise((t,e)=>{const s=()=>{this._nativeAudioContext.removeEventListener("statechange",s),"running"===this._nativeAudioContext.state?t():this.resume().then(t,e)};this._nativeAudioContext.addEventListener("statechange",s)}):this._nativeAudioContext.resume().catch(t=>{if(void 0===t||15===t.code)throw e();throw t})}suspend(){return this._nativeAudioContext.suspend().catch(t=>{if(void 0===t)throw e();throw t})}})(wn,At,Ht,se,bn,Tn,Sn,kn,Be),An=(Dn=Hs,t=>{const e=Dn.get(t);if(void 0===e)throw new Error("The context has no set of AudioWorkletNodes.");return e});var Dn;const On=(Mn=An,(t,e)=>{Mn(t).add(e)});var Mn;const En=(t=>(e,s,n=0,i=0)=>{const o=e[n];if(void 0===o)throw t();return ct(s)?o.connect(s,0,i):o.connect(s,0)})(q),Rn=(t=>(e,s)=>{t(e).delete(s)})(An),qn=(t=>(e,s,n,i=0)=>void 0===s?e.forEach(t=>t.disconnect()):"number"==typeof s?St(t,e,s).disconnect():ct(s)?void 0===n?e.forEach(t=>t.disconnect(s)):void 0===i?St(t,e,n).disconnect(s,0):St(t,e,n).disconnect(s,0,i):void 0===n?e.forEach(t=>t.disconnect(s)):St(t,e,n).disconnect(s,0))(q),Fn=new WeakMap,In=((t,e)=>s=>e(t,s))(Fn,b),Vn=((t,e,s,n,i,o,r,a,c,h,u,l,p)=>(d,f,_,g)=>{if(0===g.numberOfInputs&&0===g.numberOfOutputs)throw c();const v=Array.isArray(g.outputChannelCount)?g.outputChannelCount:Array.from(g.outputChannelCount);if(v.some(t=>t<1))throw c();if(v.length!==g.numberOfOutputs)throw e();if("explicit"!==g.channelCountMode)throw c();const y=g.channelCount*g.numberOfInputs,x=v.reduce((t,e)=>t+e,0),w=void 0===_.parameterDescriptors?0:_.parameterDescriptors.length;if(y+w>6||x>6)throw c();const b=new MessageChannel,T=[],S=[];for(let t=0;t<g.numberOfInputs;t+=1)T.push(r(d,{channelCount:g.channelCount,channelCountMode:g.channelCountMode,channelInterpretation:g.channelInterpretation,gain:1})),S.push(i(d,{channelCount:g.channelCount,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:g.channelCount}));const k=[];if(void 0!==_.parameterDescriptors)for(const{defaultValue:t,maxValue:e,minValue:s,name:n}of _.parameterDescriptors){const i=o(d,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:void 0!==g.parameterData[n]?g.parameterData[n]:void 0===t?0:t});Object.defineProperties(i.offset,{defaultValue:{get:()=>void 0===t?0:t},maxValue:{get:()=>void 0===e?N:e},minValue:{get:()=>void 0===s?V:s}}),k.push(i)}const C=n(d,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:Math.max(1,y+w)}),A=Lt(f,d.sampleRate),D=a(d,A,y+w,Math.max(1,x)),O=i(d,{channelCount:Math.max(1,x),channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:Math.max(1,x)}),M=[];for(let t=0;t<g.numberOfOutputs;t+=1)M.push(n(d,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:v[t]}));for(let t=0;t<g.numberOfInputs;t+=1){T[t].connect(S[t]);for(let e=0;e<g.channelCount;e+=1)S[t].connect(C,e,t*g.channelCount+e)}const E=new pt(void 0===_.parameterDescriptors?[]:_.parameterDescriptors.map(({name:t},e)=>{const s=k[e];return s.connect(C,0,y+e),s.start(0),[t,s.offset]}));C.connect(D);let R=g.channelInterpretation,q=null;const F=0===g.numberOfOutputs?[D]:M,I={get bufferSize(){return A},get channelCount(){return g.channelCount},set channelCount(t){throw s()},get channelCountMode(){return g.channelCountMode},set channelCountMode(t){throw s()},get channelInterpretation(){return R},set channelInterpretation(t){for(const e of T)e.channelInterpretation=t;R=t},get context(){return D.context},get inputs(){return T},get numberOfInputs(){return g.numberOfInputs},get numberOfOutputs(){return g.numberOfOutputs},get onprocessorerror(){return q},set onprocessorerror(t){"function"==typeof q&&I.removeEventListener("processorerror",q),q="function"==typeof t?t:null,"function"==typeof q&&I.addEventListener("processorerror",q)},get parameters(){return E},get port(){return b.port2},addEventListener:(...t)=>D.addEventListener(t[0],t[1],t[2]),connect:t.bind(null,F),disconnect:h.bind(null,F),dispatchEvent:(...t)=>D.dispatchEvent(t[0]),removeEventListener:(...t)=>D.removeEventListener(t[0],t[1],t[2])},P=new Map;var j,L;b.port1.addEventListener=(j=b.port1.addEventListener,(...t)=>{if("message"===t[0]){const e="function"==typeof t[1]?t[1]:"object"==typeof t[1]&&null!==t[1]&&"function"==typeof t[1].handleEvent?t[1].handleEvent:null;if(null!==e){const s=P.get(t[1]);void 0!==s?t[1]=s:(t[1]=t=>{u(d.currentTime,d.sampleRate,()=>e(t))},P.set(e,t[1]))}}return j.call(b.port1,t[0],t[1],t[2])}),b.port1.removeEventListener=(L=b.port1.removeEventListener,(...t)=>{if("message"===t[0]){const e=P.get(t[1]);void 0!==e&&(P.delete(t[1]),t[1]=e)}return L.call(b.port1,t[0],t[1],t[2])});let z=null;Object.defineProperty(b.port1,"onmessage",{get:()=>z,set:t=>{"function"==typeof z&&b.port1.removeEventListener("message",z),z="function"==typeof t?t:null,"function"==typeof z&&(b.port1.addEventListener("message",z),b.port1.start())}}),_.prototype.port=b.port1;let B=null;((t,e,s,n)=>{let i=m.get(t);void 0===i&&(i=new WeakMap,m.set(t,i));const o=zt(s,n);return i.set(e,o),o})(d,I,_,g).then(t=>B=t);const W=mt(g.numberOfInputs,g.channelCount),G=mt(g.numberOfOutputs,v),U=void 0===_.parameterDescriptors?[]:_.parameterDescriptors.reduce((t,{name:e})=>({...t,[e]:new Float32Array(128)}),{});let Q=!0;const Z=()=>{g.numberOfOutputs>0&&D.disconnect(O);for(let t=0,e=0;t<g.numberOfOutputs;t+=1){const s=M[t];for(let n=0;n<v[t];n+=1)O.disconnect(s,e+n,n);e+=v[t]}},X=new Map;D.onaudioprocess=({inputBuffer:t,outputBuffer:e})=>{if(null!==B){const s=l(I);for(let n=0;n<A;n+=128){for(let e=0;e<g.numberOfInputs;e+=1)for(let s=0;s<g.channelCount;s+=1)ft(t,W[e],s,s,n);void 0!==_.parameterDescriptors&&_.parameterDescriptors.forEach(({name:e},s)=>{ft(t,U,e,y+s,n)});for(let t=0;t<g.numberOfInputs;t+=1)for(let e=0;e<v[t];e+=1)0===G[t][e].byteLength&&(G[t][e]=new Float32Array(128));try{const t=W.map((t,e)=>{if(s[e].size>0)return X.set(e,A/128),t;const n=X.get(e);return void 0===n?[]:(t.every(t=>t.every(t=>0===t))&&(1===n?X.delete(e):X.set(e,n-1)),t)}),i=u(d.currentTime+n/d.sampleRate,d.sampleRate,()=>B.process(t,G,U));Q=i;for(let t=0,s=0;t<g.numberOfOutputs;t+=1){for(let i=0;i<v[t];i+=1)_t(e,G[t],i,s+i,n);s+=v[t]}}catch(t){Q=!1,I.dispatchEvent(new ErrorEvent("processorerror",{colno:t.colno,filename:t.filename,lineno:t.lineno,message:t.message}))}if(!Q){for(let t=0;t<g.numberOfInputs;t+=1){T[t].disconnect(S[t]);for(let e=0;e<g.channelCount;e+=1)S[n].disconnect(C,e,t*g.channelCount+e)}if(void 0!==_.parameterDescriptors){const t=_.parameterDescriptors.length;for(let e=0;e<t;e+=1){const t=k[e];t.disconnect(C,0,y+e),t.stop()}}C.disconnect(D),D.onaudioprocess=null,Y?Z():J();break}}}};let Y=!1;const H=r(d,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0}),$=()=>D.connect(H).connect(d.destination),J=()=>{D.disconnect(H),H.disconnect()};return $(),p(I,()=>{if(Q){J(),g.numberOfOutputs>0&&D.connect(O);for(let t=0,e=0;t<g.numberOfOutputs;t+=1){const s=M[t];for(let n=0;n<v[t];n+=1)O.connect(s,e+n,n);e+=v[t]}}Y=!0},()=>{Q&&($(),Z()),Y=!1})})(En,q,At,Es,Wt,Is,Qt,Yt,Ht,qn,_n,In,As),Nn=((t,e,s,n,i)=>(o,r,a,c,h,u)=>{if(null!==a)try{const e=new a(o,c,u),n=new Map;let r=null;if(Object.defineProperties(e,{channelCount:{get:()=>u.channelCount,set:()=>{throw t()}},channelCountMode:{get:()=>"explicit",set:()=>{throw t()}},onprocessorerror:{get:()=>r,set:t=>{"function"==typeof r&&e.removeEventListener("processorerror",r),r="function"==typeof t?t:null,"function"==typeof r&&e.addEventListener("processorerror",r)}}}),e.addEventListener=(p=e.addEventListener,(...t)=>{if("processorerror"===t[0]){const e="function"==typeof t[1]?t[1]:"object"==typeof t[1]&&null!==t[1]&&"function"==typeof t[1].handleEvent?t[1].handleEvent:null;if(null!==e){const s=n.get(t[1]);void 0!==s?t[1]=s:(t[1]=s=>{"error"===s.type?(Object.defineProperties(s,{type:{value:"processorerror"}}),e(s)):e(new ErrorEvent(t[0],{...s}))},n.set(e,t[1]))}}return p.call(e,"error",t[1],t[2]),p.call(e,...t)}),e.removeEventListener=(l=e.removeEventListener,(...t)=>{if("processorerror"===t[0]){const e=n.get(t[1]);void 0!==e&&(n.delete(t[1]),t[1]=e)}return l.call(e,"error",t[1],t[2]),l.call(e,t[0],t[1],t[2])}),0!==u.numberOfOutputs){const t=s(o,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});e.connect(t).connect(o.destination);return i(e,()=>t.disconnect(),()=>t.connect(o.destination))}return e}catch(t){if(11===t.code)throw n();throw t}var l,p;if(void 0===h)throw n();return(t=>{const{port1:e}=new MessageChannel;try{e.postMessage(t)}finally{e.close()}})(u),e(o,r,h,u)})(At,Vn,Qt,Ht,As),Pn=((t,e,s,n,i,o,r,a,c,h,u,l,p,d,f,_)=>(m,g,v)=>{const y=new WeakMap;let x=null;return{render(w,b,T){a(b,w);const S=y.get(b);return void 0!==S?Promise.resolve(S):(async(a,w,b)=>{let T=u(a),S=null;const k=E(T,w),C=Array.isArray(g.outputChannelCount)?g.outputChannelCount:Array.from(g.outputChannelCount);if(null===l){const t=C.reduce((t,e)=>t+e,0),s=i(w,{channelCount:Math.max(1,t),channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:Math.max(1,t)}),o=[];for(let t=0;t<a.numberOfOutputs;t+=1)o.push(n(w,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:C[t]}));const h=r(w,{channelCount:g.channelCount,channelCountMode:g.channelCountMode,channelInterpretation:g.channelInterpretation,gain:1});h.connect=e.bind(null,o),h.disconnect=c.bind(null,o),S=[s,o,h]}else k||(T=new l(w,m));if(y.set(w,null===S?T:S[2]),null!==S){if(null===x){if(void 0===v)throw new Error("Missing the processor constructor.");if(null===p)throw new Error("Missing the native OfflineAudioContext constructor.");const t=a.channelCount*a.numberOfInputs,e=void 0===v.parameterDescriptors?0:v.parameterDescriptors.length,s=t+e,c=async()=>{const c=new p(s,128*Math.ceil(a.context.length/128),w.sampleRate),h=[],u=[];for(let t=0;t<g.numberOfInputs;t+=1)h.push(r(c,{channelCount:g.channelCount,channelCountMode:g.channelCountMode,channelInterpretation:g.channelInterpretation,gain:1})),u.push(i(c,{channelCount:g.channelCount,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:g.channelCount}));const l=await Promise.all(Array.from(a.parameters.values()).map(async t=>{const e=o(c,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:t.value});return await d(c,t,e.offset,b),e})),m=n(c,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:Math.max(1,t+e)});for(let t=0;t<g.numberOfInputs;t+=1){h[t].connect(u[t]);for(let e=0;e<g.channelCount;e+=1)u[t].connect(m,e,t*g.channelCount+e)}for(const[e,s]of l.entries())s.connect(m,0,t+e),s.start(0);return m.connect(c.destination),await Promise.all(h.map(t=>f(a,c,t,b))),_(c)};x=gt(a,0===s?null:await c(),w,g,C,v,h)}const t=await x,e=s(w,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}),[c,u,l]=S;null!==t&&(e.buffer=t,e.start(0)),e.connect(c);for(let t=0,e=0;t<a.numberOfOutputs;t+=1){const s=u[t];for(let n=0;n<C[t];n+=1)c.connect(s,e+n,n);e+=C[t]}return l}if(k)for(const[e,s]of a.parameters.entries())await t(w,s,T.parameters.get(e),b);else for(const[t,e]of a.parameters.entries())await d(w,e,T.parameters.get(t),b);return await f(a,w,T,b),T})(w,b,T)}}})(as,En,cs,Es,Wt,Is,Qt,Rn,qn,_n,st,vn,Ve,us,Oe,Us),jn=(t=>e=>t.get(e))(mn),Ln=(t=>(e,s)=>{t.set(e,s)})(Fn),zn=fn?((t,e,s,n,i,o,r,a,c,h,u,l,p)=>class extends e{constructor(e,p,d){var f;const m=a(e),g=c(m),v=u({...dt,...d}),y=_.get(m),x=null==y?void 0:y.get(p),w=g||"closed"!==m.state?m:null!==(f=r(m))&&void 0!==f?f:m,b=i(w,g?null:e.baseLatency,h,p,x,v);super(e,!0,b,g?n(p,v,x):null);const T=[];b.parameters.forEach((t,e)=>{const n=s(this,g,t);T.push([e,n])}),this._nativeAudioWorkletNode=b,this._onprocessorerror=null,this._parameters=new pt(T),g&&t(m,this);const{activeInputs:S}=o(this);l(b,S)}get onprocessorerror(){return this._onprocessorerror}set onprocessorerror(t){const e="function"==typeof t?p(this,t):null;this._nativeAudioWorkletNode.onprocessorerror=e;const s=this._nativeAudioWorkletNode.onprocessorerror;this._onprocessorerror=null!==s&&s===e?t:s}get parameters(){return null===this._parameters?this._nativeAudioWorkletNode.parameters:this._parameters}get port(){return this._nativeAudioWorkletNode.port}})(On,Ze,ps,Pn,Nn,L,jn,Fe,Ne,vn,t=>({...t,outputChannelCount:void 0!==t.outputChannelCount?t.outputChannelCount:1===t.numberOfInputs&&1===t.numberOfOutputs?[t.channelCount]:Array.from({length:t.numberOfOutputs},()=>1)}),Ln,de):void 0,Bn=(((t,e,s,n,i)=>{})(At,Ht,se,$s,Be),((t,e)=>(s,n,i)=>{if(null===e)throw new Error("Missing the native OfflineAudioContext constructor.");try{return new e(s,n,i)}catch(e){if("SyntaxError"===e.name)throw t();throw e}})(Ht,Ve)),Wn=((t,e,s,n,i,o,r,a)=>{const c=[];return(h,u)=>s(h).render(h,u,c).then(()=>Promise.all(Array.from(n(u)).map(t=>s(t).render(t,u,c)))).then(()=>i(u)).then(s=>("function"!=typeof s.copyFromChannel?(r(s),F(s)):e(o,()=>o(s))||a(s),t.add(s),s))})(He,xe,Ae,An,Us,R,ts,es),Gn=(((t,e,s,n,i)=>{})(xe,At,Bn,$s,Wn),((t,e,s,n,i)=>class extends t{constructor(t,s,i){let o;if("number"==typeof t&&void 0!==s&&void 0!==i)o={length:s,numberOfChannels:t,sampleRate:i};else{if("object"!=typeof t)throw new Error("The given parameters are not valid.");o=t}const{length:r,numberOfChannels:a,sampleRate:c}={...$t,...o},h=n(a,r,c);e(Rt,()=>Rt(h))||h.addEventListener("statechange",(()=>{let t=0;const e=s=>{"running"===this._state&&(t>0?(h.removeEventListener("statechange",e),s.stopImmediatePropagation(),this._waitForThePromiseToSettle(s)):t+=1)};return e})()),super(h,a),this._length=r,this._nativeOfflineAudioContext=h,this._state=null}get length(){return void 0===this._nativeOfflineAudioContext.length?this._length:this._nativeOfflineAudioContext.length}get state(){return null===this._state?this._nativeOfflineAudioContext.state:this._state}startRendering(){return"running"===this._state?Promise.reject(s()):(this._state="running",i(this.destination,this._nativeOfflineAudioContext).finally(()=>{this._state=null,W(this)}))}_waitForThePromiseToSettle(t){null===this._state?this._nativeOfflineAudioContext.dispatchEvent(t):setTimeout(()=>this._waitForThePromiseToSettle(t))}})(wn,xe,At,Bn,Wn)),Un=((t,e)=>s=>{const n=t.get(s);return e(n)||e(s)})(p,We),Qn=(Zn=h,Xn=Ue,t=>Zn.has(t)||Xn(t));var Zn,Xn;const Yn=(Hn=l,$n=Qe,t=>Hn.has(t)||$n(t));var Hn,$n;const Jn=((t,e)=>s=>{const n=t.get(s);return e(n)||e(s)})(p,Ne),Kn=()=>(async(t,e,s,n,i,o,r,a,c,h,u,l,p,d,f,_)=>{if(t(e,e)&&t(s,s)&&t(i,i)&&t(o,o)&&t(a,a)&&t(c,c)&&t(h,h)&&t(u,u)&&t(l,l)&&t(p,p)&&t(d,d)){return(await Promise.all([t(n,n),t(r,r),t(f,f),t(_,_)])).every(t=>t)}return!1})(xe,(t=>()=>{if(null===t)return!1;const e=new t(1,1,44100).createBuffer(1,1,44100);if(void 0===e.copyToChannel)return!0;const s=new Float32Array(2);try{e.copyFromChannel(s,0,0)}catch{return!1}return!0})(Ve),(t=>()=>{if(null===t)return!1;if(void 0!==t.prototype&&void 0!==t.prototype.close)return!0;const e=new t,s=void 0!==e.close;try{e.close()}catch{}return s})(Be),(t=>()=>{if(null===t)return Promise.resolve(!1);const e=new t(1,1,44100);return new Promise(t=>{let s=!0;const n=n=>{s&&(s=!1,e.startRendering(),t(n instanceof TypeError))};let i;try{i=e.decodeAudioData(null,()=>{},n)}catch(t){n(t)}void 0!==i&&i.catch(n)})})(Ve),(t=>()=>{if(null===t)return!1;let e;try{e=new t({latencyHint:"balanced"})}catch{return!1}return e.close(),!0})(Be),(t=>()=>{if(null===t)return!1;const e=new t(1,1,44100).createGain(),s=e.connect(e)===e;return e.disconnect(e),s})(Ve),((t,e)=>async()=>{if(null===t)return!0;if(null===e)return!1;const s=new Blob(['class A extends AudioWorkletProcessor{process(){this.port.postMessage(0)}}registerProcessor("a",A)'],{type:"application/javascript; charset=utf-8"}),n=new e(1,128,8e3),i=URL.createObjectURL(s);let o=!1;try{await n.audioWorklet.addModule(i);const e=new t(n,"a",{numberOfOutputs:0}),s=n.createOscillator();e.port.onmessage=()=>o=!0,s.connect(e),s.start(0),await n.startRendering(),o||await new Promise(t=>setTimeout(t,5))}catch{}finally{URL.revokeObjectURL(i)}return o})(vn,Ve),(t=>()=>{if(null===t)return!1;const e=new t(1,1,44100).createChannelMerger();if("max"===e.channelCountMode)return!0;try{e.channelCount=2}catch{return!0}return!1})(Ve),(t=>()=>{if(null===t)return!1;const e=new t(1,1,44100);if(void 0===e.createConstantSource)return!0;return e.createConstantSource().offset.maxValue!==Number.POSITIVE_INFINITY})(Ve),(t=>()=>{if(null===t)return!1;const e=new t(1,1,44100),s=e.createConvolver();s.buffer=e.createBuffer(1,1,e.sampleRate);try{s.buffer=e.createBuffer(1,1,e.sampleRate)}catch{return!1}return!0})(Ve),(t=>()=>{if(null===t)return!1;const e=new t(1,1,44100).createConvolver();try{e.channelCount=1}catch{return!1}return!0})(Ve),ue,(t=>()=>null!==t&&t.hasOwnProperty("isSecureContext"))(Te),(t=>()=>{if(null===t)return!1;const e=new t;try{return e.createMediaStreamSource(new MediaStream),!1}catch(t){return!0}})(Be),(t=>()=>{if(null===t)return Promise.resolve(!1);const e=new t(1,1,44100);if(void 0===e.createStereoPanner)return Promise.resolve(!0);if(void 0===e.createConstantSource)return Promise.resolve(!0);const s=e.createConstantSource(),n=e.createStereoPanner();return s.channelCount=1,s.offset.value=1,n.channelCount=1,s.start(),s.connect(n).connect(e.destination),e.startRendering().then(t=>1!==t.getChannelData(0)[0])})(Ve),le);function ti(t,e){if(!t)throw new Error(e)}function ei(t,e,s=1/0){if(!(e<=t&&t<=s))throw new RangeError(`Value must be within [${e}, ${s}], got: ${t}`)}function si(t){t.isOffline||"running"===t.state||ri('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.')}let ni=console;function ii(t){ni=t}function oi(...t){ni.log(...t)}function ri(...t){ni.warn(...t)}function ai(t){return void 0===t}function ci(t){return!ai(t)}function hi(t){return"function"==typeof t}function ui(t){return"number"==typeof t}function li(t){return"[object Object]"===Object.prototype.toString.call(t)&&t.constructor===Object}function pi(t){return"boolean"==typeof t}function di(t){return Array.isArray(t)}function fi(t){return"string"==typeof t}function _i(t){return fi(t)&&/^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(t)}const mi="object"==typeof self?self:null,gi=mi&&(mi.hasOwnProperty("AudioContext")||mi.hasOwnProperty("webkitAudioContext"));function vi(t,e,s,n){var i,o=arguments.length,r=o<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,s):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)r=Reflect.decorate(t,e,s,n);else for(var a=t.length-1;a>=0;a--)(i=t[a])&&(r=(o<3?i(r):o>3?i(e,s,r):i(e,s))||r);return o>3&&r&&Object.defineProperty(e,s,r),r}function yi(t,e,s,n){return new(s||(s=Promise))((function(i,o){function r(t){try{c(n.next(t))}catch(t){o(t)}}function a(t){try{c(n.throw(t))}catch(t){o(t)}}function c(t){var e;t.done?i(t.value):(e=t.value,e instanceof s?e:new s((function(t){t(e)}))).then(r,a)}c((n=n.apply(t,e||[])).next())}))}Object.create;Object.create;class xi{constructor(t,e,s){this._callback=t,this._type=e,this._updateInterval=s,this._createClock()}_createWorker(){const t=new Blob([`\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(1e3*this._updateInterval).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`],{type:"text/javascript"}),e=URL.createObjectURL(t),s=new Worker(e);s.onmessage=this._callback.bind(this),this._worker=s}_createTimeout(){this._timeout=setTimeout(()=>{this._createTimeout(),this._callback()},1e3*this._updateInterval)}_createClock(){if("worker"===this._type)try{this._createWorker()}catch(t){this._type="timeout",this._createClock()}else"timeout"===this._type&&this._createTimeout()}_disposeClock(){this._timeout&&(clearTimeout(this._timeout),this._timeout=0),this._worker&&(this._worker.terminate(),this._worker.onmessage=null)}get updateInterval(){return this._updateInterval}set updateInterval(t){this._updateInterval=Math.max(t,128/44100),"worker"===this._type&&this._worker.postMessage(Math.max(1e3*t,1))}get type(){return this._type}set type(t){this._disposeClock(),this._type=t,this._createClock()}dispose(){this._disposeClock()}}function wi(t){return Yn(t)}function bi(t){return Qn(t)}function Ti(t){return Jn(t)}function Si(t){return Un(t)}function ki(t){return t instanceof AudioBuffer}function Ci(t,e){return"value"===t||wi(e)||bi(e)||ki(e)}function Ai(t,...e){if(!e.length)return t;const s=e.shift();if(li(t)&&li(s))for(const e in s)Ci(e,s[e])?t[e]=s[e]:li(s[e])?(t[e]||Object.assign(t,{[e]:{}}),Ai(t[e],s[e])):Object.assign(t,{[e]:s[e]});return Ai(t,...e)}function Di(t,e,s=[],n){const i={},o=Array.from(e);if(li(o[0])&&n&&!Reflect.has(o[0],n)){Object.keys(o[0]).some(e=>Reflect.has(t,e))||(Ai(i,{[n]:o[0]}),s.splice(s.indexOf(n),1),o.shift())}if(1===o.length&&li(o[0]))Ai(i,o[0]);else for(let t=0;t<s.length;t++)ci(o[t])&&(i[s[t]]=o[t]);return Ai(t,i)}function Oi(t,e){return ai(t)?e:t}function Mi(t,e){return e.forEach(e=>{Reflect.has(t,e)&&delete t[e]}),t}
/**
 * Tone.js
 * @author Yotam Mann
 * @license http://opensource.org/licenses/MIT MIT License
 * @copyright 2014-2019 Yotam Mann
 */class Ei{constructor(){this.debug=!1,this._wasDisposed=!1}static getDefaults(){return{}}log(...t){(this.debug||mi&&this.toString()===mi.TONE_DEBUG_CLASS)&&oi(this,...t)}dispose(){return this._wasDisposed=!0,this}get disposed(){return this._wasDisposed}toString(){return this.name}}Ei.version=o;function Ri(t,e){return t>e+1e-6}function qi(t,e){return Ri(t,e)||Ii(t,e)}function Fi(t,e){return t+1e-6<e}function Ii(t,e){return Math.abs(t-e)<1e-6}function Vi(t,e,s){return Math.max(Math.min(t,s),e)}class Ni extends Ei{constructor(){super(),this.name="Timeline",this._timeline=[];const t=Di(Ni.getDefaults(),arguments,["memory"]);this.memory=t.memory,this.increasing=t.increasing}static getDefaults(){return{memory:1/0,increasing:!1}}get length(){return this._timeline.length}add(t){if(ti(Reflect.has(t,"time"),"Timeline: events must have a time attribute"),t.time=t.time.valueOf(),this.increasing&&this.length){const e=this._timeline[this.length-1];ti(qi(t.time,e.time),"The time must be greater than or equal to the last scheduled time"),this._timeline.push(t)}else{const e=this._search(t.time);this._timeline.splice(e+1,0,t)}if(this.length>this.memory){const t=this.length-this.memory;this._timeline.splice(0,t)}return this}remove(t){const e=this._timeline.indexOf(t);return-1!==e&&this._timeline.splice(e,1),this}get(t,e="time"){const s=this._search(t,e);return-1!==s?this._timeline[s]:null}peek(){return this._timeline[0]}shift(){return this._timeline.shift()}getAfter(t,e="time"){const s=this._search(t,e);return s+1<this._timeline.length?this._timeline[s+1]:null}getBefore(t){const e=this._timeline.length;if(e>0&&this._timeline[e-1].time<t)return this._timeline[e-1];const s=this._search(t);return s-1>=0?this._timeline[s-1]:null}cancel(t){if(this._timeline.length>1){let e=this._search(t);if(e>=0)if(Ii(this._timeline[e].time,t)){for(let s=e;s>=0&&Ii(this._timeline[s].time,t);s--)e=s;this._timeline=this._timeline.slice(0,e)}else this._timeline=this._timeline.slice(0,e+1);else this._timeline=[]}else 1===this._timeline.length&&qi(this._timeline[0].time,t)&&(this._timeline=[]);return this}cancelBefore(t){const e=this._search(t);return e>=0&&(this._timeline=this._timeline.slice(e+1)),this}previousEvent(t){const e=this._timeline.indexOf(t);return e>0?this._timeline[e-1]:null}_search(t,e="time"){if(0===this._timeline.length)return-1;let s=0;const n=this._timeline.length;let i=n;if(n>0&&this._timeline[n-1][e]<=t)return n-1;for(;s<i;){let n=Math.floor(s+(i-s)/2);const o=this._timeline[n],r=this._timeline[n+1];if(Ii(o[e],t)){for(let s=n;s<this._timeline.length;s++){if(!Ii(this._timeline[s][e],t))break;n=s}return n}if(Fi(o[e],t)&&Ri(r[e],t))return n;Ri(o[e],t)?i=n:s=n+1}return-1}_iterate(t,e=0,s=this._timeline.length-1){this._timeline.slice(e,s+1).forEach(t)}forEach(t){return this._iterate(t),this}forEachBefore(t,e){const s=this._search(t);return-1!==s&&this._iterate(e,0,s),this}forEachAfter(t,e){const s=this._search(t);return this._iterate(e,s+1),this}forEachBetween(t,e,s){let n=this._search(t),i=this._search(e);return-1!==n&&-1!==i?(this._timeline[n].time!==t&&(n+=1),this._timeline[i].time===e&&(i-=1),this._iterate(s,n,i)):-1===n&&this._iterate(s,0,i),this}forEachFrom(t,e){let s=this._search(t);for(;s>=0&&this._timeline[s].time>=t;)s--;return this._iterate(e,s+1),this}forEachAtTime(t,e){const s=this._search(t);if(-1!==s&&Ii(this._timeline[s].time,t)){let n=s;for(let e=s;e>=0&&Ii(this._timeline[e].time,t);e--)n=e;this._iterate(t=>{e(t)},n,s)}return this}dispose(){return super.dispose(),this._timeline=[],this}}const Pi=[];function ji(t){Pi.push(t)}const Li=[];function zi(t){Li.push(t)}class Bi extends Ei{constructor(){super(...arguments),this.name="Emitter"}on(t,e){return t.split(/\W+/).forEach(t=>{ai(this._events)&&(this._events={}),this._events.hasOwnProperty(t)||(this._events[t]=[]),this._events[t].push(e)}),this}once(t,e){const s=(...n)=>{e(...n),this.off(t,s)};return this.on(t,s),this}off(t,e){return t.split(/\W+/).forEach(s=>{if(ai(this._events)&&(this._events={}),this._events.hasOwnProperty(t))if(ai(e))this._events[t]=[];else{const s=this._events[t];for(let t=s.length-1;t>=0;t--)s[t]===e&&s.splice(t,1)}}),this}emit(t,...e){if(this._events&&this._events.hasOwnProperty(t)){const s=this._events[t].slice(0);for(let t=0,n=s.length;t<n;t++)s[t].apply(this,e)}return this}static mixin(t){["on","once","off","emit"].forEach(e=>{const s=Object.getOwnPropertyDescriptor(Bi.prototype,e);Object.defineProperty(t.prototype,e,s)})}dispose(){return super.dispose(),this._events=void 0,this}}class Wi extends Bi{constructor(){super(...arguments),this.isOffline=!1}toJSON(){return{}}}class Gi extends Wi{constructor(){super(),this.name="Context",this._constants=new Map,this._timeouts=new Ni,this._timeoutIds=0,this._initialized=!1,this.isOffline=!1,this._workletModules=new Map;const t=Di(Gi.getDefaults(),arguments,["context"]);t.context?this._context=t.context:this._context=function(t){return new Cn(t)}({latencyHint:t.latencyHint}),this._ticker=new xi(this.emit.bind(this,"tick"),t.clockSource,t.updateInterval),this.on("tick",this._timeoutLoop.bind(this)),this._context.onstatechange=()=>{this.emit("statechange",this.state)},this._setLatencyHint(t.latencyHint),this.lookAhead=t.lookAhead}static getDefaults(){return{clockSource:"worker",latencyHint:"interactive",lookAhead:.1,updateInterval:.05}}initialize(){var t;return this._initialized||(t=this,Pi.forEach(e=>e(t)),this._initialized=!0),this}createAnalyser(){return this._context.createAnalyser()}createOscillator(){return this._context.createOscillator()}createBufferSource(){return this._context.createBufferSource()}createBiquadFilter(){return this._context.createBiquadFilter()}createBuffer(t,e,s){return this._context.createBuffer(t,e,s)}createChannelMerger(t){return this._context.createChannelMerger(t)}createChannelSplitter(t){return this._context.createChannelSplitter(t)}createConstantSource(){return this._context.createConstantSource()}createConvolver(){return this._context.createConvolver()}createDelay(t){return this._context.createDelay(t)}createDynamicsCompressor(){return this._context.createDynamicsCompressor()}createGain(){return this._context.createGain()}createIIRFilter(t,e){return this._context.createIIRFilter(t,e)}createPanner(){return this._context.createPanner()}createPeriodicWave(t,e,s){return this._context.createPeriodicWave(t,e,s)}createStereoPanner(){return this._context.createStereoPanner()}createWaveShaper(){return this._context.createWaveShaper()}createMediaStreamSource(t){ti(Si(this._context),"Not available if OfflineAudioContext");return this._context.createMediaStreamSource(t)}createMediaElementSource(t){ti(Si(this._context),"Not available if OfflineAudioContext");return this._context.createMediaElementSource(t)}createMediaStreamDestination(){ti(Si(this._context),"Not available if OfflineAudioContext");return this._context.createMediaStreamDestination()}decodeAudioData(t){return this._context.decodeAudioData(t)}get currentTime(){return this._context.currentTime}get state(){return this._context.state}get sampleRate(){return this._context.sampleRate}get listener(){return this.initialize(),this._listener}set listener(t){ti(!this._initialized,"The listener cannot be set after initialization."),this._listener=t}get transport(){return this.initialize(),this._transport}set transport(t){ti(!this._initialized,"The transport cannot be set after initialization."),this._transport=t}get draw(){return this.initialize(),this._draw}set draw(t){ti(!this._initialized,"Draw cannot be set after initialization."),this._draw=t}get destination(){return this.initialize(),this._destination}set destination(t){ti(!this._initialized,"The destination cannot be set after initialization."),this._destination=t}createAudioWorkletNode(t,e){return function(t,e,s){return ti(ci(zn),"This node only works in a secure context (https or localhost)"),new zn(t,e,s)}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */(this.rawContext,t,e)}addAudioWorkletModule(t,e){return yi(this,void 0,void 0,(function*(){ti(ci(this.rawContext.audioWorklet),"AudioWorkletNode is only available in a secure context (https or localhost)"),this._workletModules.has(e)||this._workletModules.set(e,this.rawContext.audioWorklet.addModule(t)),yield this._workletModules.get(e)}))}workletsAreReady(){return yi(this,void 0,void 0,(function*(){const t=[];this._workletModules.forEach(e=>t.push(e)),yield Promise.all(t)}))}get updateInterval(){return this._ticker.updateInterval}set updateInterval(t){this._ticker.updateInterval=t}get clockSource(){return this._ticker.type}set clockSource(t){this._ticker.type=t}get latencyHint(){return this._latencyHint}_setLatencyHint(t){let e=0;if(this._latencyHint=t,fi(t))switch(t){case"interactive":e=.1;break;case"playback":e=.5;break;case"balanced":e=.25}this.lookAhead=e,this.updateInterval=e/2}get rawContext(){return this._context}now(){return this._context.currentTime+this.lookAhead}immediate(){return this._context.currentTime}resume(){return Si(this._context)?this._context.resume():Promise.resolve()}close(){return yi(this,void 0,void 0,(function*(){var t;Si(this._context)&&(yield this._context.close()),this._initialized&&(t=this,Li.forEach(e=>e(t)))}))}getConstant(t){if(this._constants.has(t))return this._constants.get(t);{const e=this._context.createBuffer(1,128,this._context.sampleRate),s=e.getChannelData(0);for(let e=0;e<s.length;e++)s[e]=t;const n=this._context.createBufferSource();return n.channelCount=1,n.channelCountMode="explicit",n.buffer=e,n.loop=!0,n.start(0),this._constants.set(t,n),n}}dispose(){return super.dispose(),this._ticker.dispose(),this._timeouts.dispose(),Object.keys(this._constants).map(t=>this._constants[t].disconnect()),this}_timeoutLoop(){const t=this.now();let e=this._timeouts.peek();for(;this._timeouts.length&&e&&e.time<=t;)e.callback(),this._timeouts.shift(),e=this._timeouts.peek()}setTimeout(t,e){this._timeoutIds++;const s=this.now();return this._timeouts.add({callback:t,id:this._timeoutIds,time:s+e}),this._timeoutIds}clearTimeout(t){return this._timeouts.forEach(e=>{e.id===t&&this._timeouts.remove(e)}),this}clearInterval(t){return this.clearTimeout(t)}setInterval(t,e){const s=++this._timeoutIds,n=()=>{const i=this.now();this._timeouts.add({callback:()=>{t(),n()},id:s,time:i+e})};return n(),s}}function Ui(t,e){di(e)?e.forEach(e=>Ui(t,e)):Object.defineProperty(t,e,{enumerable:!0,writable:!1})}function Qi(t,e){di(e)?e.forEach(e=>Qi(t,e)):Object.defineProperty(t,e,{writable:!0})}const Zi=()=>{};class Xi extends Ei{constructor(){super(),this.name="ToneAudioBuffer",this.onload=Zi;const t=Di(Xi.getDefaults(),arguments,["url","onload","onerror"]);this.reverse=t.reverse,this.onload=t.onload,t.url&&ki(t.url)||t.url instanceof Xi?this.set(t.url):fi(t.url)&&this.load(t.url).catch(t.onerror)}static getDefaults(){return{onerror:Zi,onload:Zi,reverse:!1}}get sampleRate(){return this._buffer?this._buffer.sampleRate:Ji().sampleRate}set(t){return t instanceof Xi?t.loaded?this._buffer=t.get():t.onload=()=>{this.set(t),this.onload(this)}:this._buffer=t,this._reversed&&this._reverse(),this}get(){return this._buffer}load(t){return yi(this,void 0,void 0,(function*(){const e=Xi.load(t).then(t=>{this.set(t),this.onload(this)});Xi.downloads.push(e);try{yield e}finally{const t=Xi.downloads.indexOf(e);Xi.downloads.splice(t,1)}return this}))}dispose(){return super.dispose(),this._buffer=void 0,this}fromArray(t){const e=di(t)&&t[0].length>0,s=e?t.length:1,n=e?t[0].length:t.length,i=Ji(),o=i.createBuffer(s,n,i.sampleRate),r=e||1!==s?t:[t];for(let t=0;t<s;t++)o.copyToChannel(r[t],t);return this._buffer=o,this}toMono(t){if(ui(t))this.fromArray(this.toArray(t));else{let t=new Float32Array(this.length);const e=this.numberOfChannels;for(let s=0;s<e;s++){const e=this.toArray(s);for(let s=0;s<e.length;s++)t[s]+=e[s]}t=t.map(t=>t/e),this.fromArray(t)}return this}toArray(t){if(ui(t))return this.getChannelData(t);if(1===this.numberOfChannels)return this.toArray(0);{const t=[];for(let e=0;e<this.numberOfChannels;e++)t[e]=this.getChannelData(e);return t}}getChannelData(t){return this._buffer?this._buffer.getChannelData(t):new Float32Array(0)}slice(t,e=this.duration){const s=Math.floor(t*this.sampleRate),n=Math.floor(e*this.sampleRate);ti(s<n,"The start time must be less than the end time");const i=n-s,o=Ji().createBuffer(this.numberOfChannels,i,this.sampleRate);for(let t=0;t<this.numberOfChannels;t++)o.copyToChannel(this.getChannelData(t).subarray(s,n),t);return new Xi(o)}_reverse(){if(this.loaded)for(let t=0;t<this.numberOfChannels;t++)this.getChannelData(t).reverse();return this}get loaded(){return this.length>0}get duration(){return this._buffer?this._buffer.duration:0}get length(){return this._buffer?this._buffer.length:0}get numberOfChannels(){return this._buffer?this._buffer.numberOfChannels:0}get reverse(){return this._reversed}set reverse(t){this._reversed!==t&&(this._reversed=t,this._reverse())}static fromArray(t){return(new Xi).fromArray(t)}static fromUrl(t){return yi(this,void 0,void 0,(function*(){const e=new Xi;return yield e.load(t)}))}static load(t){return yi(this,void 0,void 0,(function*(){const e=t.match(/\[([^\]\[]+\|.+)\]$/);if(e){const s=e[1].split("|");let n=s[0];for(const t of s)if(Xi.supportsType(t)){n=t;break}t=t.replace(e[0],n)}const s=""===Xi.baseUrl||Xi.baseUrl.endsWith("/")?Xi.baseUrl:Xi.baseUrl+"/",n=yield fetch(s+t);if(!n.ok)throw new Error("could not load url: "+t);const i=yield n.arrayBuffer();return yield Ji().decodeAudioData(i)}))}static supportsType(t){const e=t.split("."),s=e[e.length-1];return""!==document.createElement("audio").canPlayType("audio/"+s)}static loaded(){return yi(this,void 0,void 0,(function*(){for(yield Promise.resolve();Xi.downloads.length;)yield Xi.downloads[0]}))}}Xi.baseUrl="",Xi.downloads=[];class Yi extends Gi{constructor(){var t,e,s;super({clockSource:"offline",context:Ti(arguments[0])?arguments[0]:(t=arguments[0],e=arguments[1]*arguments[2],s=arguments[2],new Gn(t,e,s)),lookAhead:0,updateInterval:Ti(arguments[0])?128/arguments[0].sampleRate:128/arguments[2]}),this.name="OfflineContext",this._currentTime=0,this.isOffline=!0,this._duration=Ti(arguments[0])?arguments[0].length/arguments[0].sampleRate:arguments[1]}now(){return this._currentTime}get currentTime(){return this._currentTime}_renderClock(t){return yi(this,void 0,void 0,(function*(){let e=0;for(;this._duration-this._currentTime>=0;){this.emit("tick"),this._currentTime+=128/this.sampleRate,e++;const s=Math.floor(this.sampleRate/128);t&&e%s==0&&(yield new Promise(t=>setTimeout(t,1)))}}))}render(t=!0){return yi(this,void 0,void 0,(function*(){yield this.workletsAreReady(),yield this._renderClock(t);const e=yield this._context.startRendering();return new Xi(e)}))}close(){return Promise.resolve()}}const Hi=new class extends Wi{constructor(){super(...arguments),this.lookAhead=0,this.latencyHint=0,this.isOffline=!1}createAnalyser(){return{}}createOscillator(){return{}}createBufferSource(){return{}}createBiquadFilter(){return{}}createBuffer(t,e,s){return{}}createChannelMerger(t){return{}}createChannelSplitter(t){return{}}createConstantSource(){return{}}createConvolver(){return{}}createDelay(t){return{}}createDynamicsCompressor(){return{}}createGain(){return{}}createIIRFilter(t,e){return{}}createPanner(){return{}}createPeriodicWave(t,e,s){return{}}createStereoPanner(){return{}}createWaveShaper(){return{}}createMediaStreamSource(t){return{}}createMediaElementSource(t){return{}}createMediaStreamDestination(){return{}}decodeAudioData(t){return Promise.resolve({})}createAudioWorkletNode(t,e){return{}}get rawContext(){return{}}addAudioWorkletModule(t,e){return yi(this,void 0,void 0,(function*(){return Promise.resolve()}))}resume(){return Promise.resolve()}setTimeout(t,e){return 0}clearTimeout(t){return this}setInterval(t,e){return 0}clearInterval(t){return this}getConstant(t){return{}}get currentTime(){return 0}get state(){return{}}get sampleRate(){return 0}get listener(){return{}}get transport(){return{}}get draw(){return{}}set draw(t){}get destination(){return{}}set destination(t){}now(){return 0}immediate(){return 0}};let $i=Hi;function Ji(){return $i===Hi&&gi&&Ki(new Gi),$i}function Ki(t){$i=Si(t)?new Gi(t):Ti(t)?new Yi(t):t}function to(){return $i.resume()}if(mi&&!mi.TONE_SILENCE_LOGGING){let t="v";"dev"===o&&(t="");const e=` * Tone.js ${t}${o} * `;console.log("%c"+e,"background: #000; color: #fff")}function eo(t){return Math.pow(10,t/20)}function so(t){return Math.log(t)/Math.LN10*20}function no(t){return Math.pow(2,t/12)}let io=440;function oo(t){return Math.round(ro(t))}function ro(t){return 69+12*Math.log2(t/io)}function ao(t){return io*Math.pow(2,(t-69)/12)}class co extends Ei{constructor(t,e,s){super(),this.defaultUnits="s",this._val=e,this._units=s,this.context=t,this._expressions=this._getExpressions()}_getExpressions(){return{hz:{method:t=>this._frequencyToUnits(parseFloat(t)),regexp:/^(\d+(?:\.\d+)?)hz$/i},i:{method:t=>this._ticksToUnits(parseInt(t,10)),regexp:/^(\d+)i$/i},m:{method:t=>this._beatsToUnits(parseInt(t,10)*this._getTimeSignature()),regexp:/^(\d+)m$/i},n:{method:(t,e)=>{const s=parseInt(t,10),n="."===e?1.5:1;return 1===s?this._beatsToUnits(this._getTimeSignature())*n:this._beatsToUnits(4/s)*n},regexp:/^(\d+)n(\.?)$/i},number:{method:t=>this._expressions[this.defaultUnits].method.call(this,t),regexp:/^(\d+(?:\.\d+)?)$/},s:{method:t=>this._secondsToUnits(parseFloat(t)),regexp:/^(\d+(?:\.\d+)?)s$/},samples:{method:t=>parseInt(t,10)/this.context.sampleRate,regexp:/^(\d+)samples$/},t:{method:t=>{const e=parseInt(t,10);return this._beatsToUnits(8/(3*Math.floor(e)))},regexp:/^(\d+)t$/i},tr:{method:(t,e,s)=>{let n=0;return t&&"0"!==t&&(n+=this._beatsToUnits(this._getTimeSignature()*parseFloat(t))),e&&"0"!==e&&(n+=this._beatsToUnits(parseFloat(e))),s&&"0"!==s&&(n+=this._beatsToUnits(parseFloat(s)/4)),n},regexp:/^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/}}}valueOf(){if(this._val instanceof co&&this.fromType(this._val),ai(this._val))return this._noArg();if(fi(this._val)&&ai(this._units)){for(const t in this._expressions)if(this._expressions[t].regexp.test(this._val.trim())){this._units=t;break}}else if(li(this._val)){let t=0;for(const e in this._val)if(ci(this._val[e])){const s=this._val[e];t+=new this.constructor(this.context,e).valueOf()*s}return t}if(ci(this._units)){const t=this._expressions[this._units],e=this._val.toString().trim().match(t.regexp);return e?t.method.apply(this,e.slice(1)):t.method.call(this,this._val)}return fi(this._val)?parseFloat(this._val):this._val}_frequencyToUnits(t){return 1/t}_beatsToUnits(t){return 60/this._getBpm()*t}_secondsToUnits(t){return t}_ticksToUnits(t){return t*this._beatsToUnits(1)/this._getPPQ()}_noArg(){return this._now()}_getBpm(){return this.context.transport.bpm.value}_getTimeSignature(){return this.context.transport.timeSignature}_getPPQ(){return this.context.transport.PPQ}fromType(t){switch(this._units=void 0,this.defaultUnits){case"s":this._val=t.toSeconds();break;case"i":this._val=t.toTicks();break;case"hz":this._val=t.toFrequency();break;case"midi":this._val=t.toMidi()}return this}toFrequency(){return 1/this.toSeconds()}toSamples(){return this.toSeconds()*this.context.sampleRate}toMilliseconds(){return 1e3*this.toSeconds()}}class ho extends co{constructor(){super(...arguments),this.name="TimeClass"}_getExpressions(){return Object.assign(super._getExpressions(),{now:{method:t=>this._now()+new this.constructor(this.context,t).valueOf(),regexp:/^\+(.+)/},quantize:{method:t=>{const e=new ho(this.context,t).valueOf();return this._secondsToUnits(this.context.transport.nextSubdivision(e))},regexp:/^@(.+)/}})}quantize(t,e=1){const s=new this.constructor(this.context,t).valueOf(),n=this.valueOf();return n+(Math.round(n/s)*s-n)*e}toNotation(){const t=this.toSeconds(),e=["1m"];for(let t=1;t<9;t++){const s=Math.pow(2,t);e.push(s+"n."),e.push(s+"n"),e.push(s+"t")}e.push("0");let s=e[0],n=new ho(this.context,e[0]).toSeconds();return e.forEach(e=>{const i=new ho(this.context,e).toSeconds();Math.abs(i-t)<Math.abs(n-t)&&(s=e,n=i)}),s}toBarsBeatsSixteenths(){const t=this._beatsToUnits(1);let e=this.valueOf()/t;e=parseFloat(e.toFixed(4));const s=Math.floor(e/this._getTimeSignature());let n=e%1*4;e=Math.floor(e)%this._getTimeSignature();const i=n.toString();i.length>3&&(n=parseFloat(parseFloat(i).toFixed(3)));return[s,e,n].join(":")}toTicks(){const t=this._beatsToUnits(1),e=this.valueOf()/t;return Math.round(e*this._getPPQ())}toSeconds(){return this.valueOf()}toMidi(){return oo(this.toFrequency())}_now(){return this.context.now()}}function uo(t,e){return new ho(Ji(),t,e)}class lo extends ho{constructor(){super(...arguments),this.name="Frequency",this.defaultUnits="hz"}static get A4(){return io}static set A4(t){!function(t){io=t}(t)}_getExpressions(){return Object.assign({},super._getExpressions(),{midi:{regexp:/^(\d+(?:\.\d+)?midi)/,method(t){return"midi"===this.defaultUnits?t:lo.mtof(t)}},note:{regexp:/^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,method(t,e){const s=po[t.toLowerCase()]+12*(parseInt(e,10)+1);return"midi"===this.defaultUnits?s:lo.mtof(s)}},tr:{regexp:/^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,method(t,e,s){let n=1;return t&&"0"!==t&&(n*=this._beatsToUnits(this._getTimeSignature()*parseFloat(t))),e&&"0"!==e&&(n*=this._beatsToUnits(parseFloat(e))),s&&"0"!==s&&(n*=this._beatsToUnits(parseFloat(s)/4)),n}}})}transpose(t){return new lo(this.context,this.valueOf()*no(t))}harmonize(t){return t.map(t=>this.transpose(t))}toMidi(){return oo(this.valueOf())}toNote(){const t=this.toFrequency(),e=Math.log2(t/lo.A4);let s=Math.round(12*e)+57;const n=Math.floor(s/12);n<0&&(s+=-12*n);return fo[s%12]+n.toString()}toSeconds(){return 1/super.toSeconds()}toTicks(){const t=this._beatsToUnits(1),e=this.valueOf()/t;return Math.floor(e*this._getPPQ())}_noArg(){return 0}_frequencyToUnits(t){return t}_ticksToUnits(t){return 1/(60*t/(this._getBpm()*this._getPPQ()))}_beatsToUnits(t){return 1/super._beatsToUnits(t)}_secondsToUnits(t){return 1/t}static mtof(t){return ao(t)}static ftom(t){return oo(t)}}const po={cbb:-2,cb:-1,c:0,"c#":1,cx:2,dbb:0,db:1,d:2,"d#":3,dx:4,ebb:2,eb:3,e:4,"e#":5,ex:6,fbb:3,fb:4,f:5,"f#":6,fx:7,gbb:5,gb:6,g:7,"g#":8,gx:9,abb:7,ab:8,a:9,"a#":10,ax:11,bbb:9,bb:10,b:11,"b#":12,bx:13},fo=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];function _o(t,e){return new lo(Ji(),t,e)}class mo extends ho{constructor(){super(...arguments),this.name="TransportTime"}_now(){return this.context.transport.seconds}}function go(t,e){return new mo(Ji(),t,e)}class vo extends Ei{constructor(){super();const t=Di(vo.getDefaults(),arguments,["context"]);this.defaultContext?this.context=this.defaultContext:this.context=t.context}static getDefaults(){return{context:Ji()}}now(){return this.context.currentTime+this.context.lookAhead}immediate(){return this.context.currentTime}get sampleTime(){return 1/this.context.sampleRate}get blockTime(){return 128/this.context.sampleRate}toSeconds(t){return new ho(this.context,t).toSeconds()}toFrequency(t){return new lo(this.context,t).toFrequency()}toTicks(t){return new mo(this.context,t).toTicks()}_getPartialProperties(t){const e=this.get();return Object.keys(e).forEach(s=>{ai(t[s])&&delete e[s]}),e}get(){const t=this.constructor.getDefaults();return Object.keys(t).forEach(e=>{if(Reflect.has(this,e)){const s=this[e];ci(s)&&ci(s.value)&&ci(s.setValueAtTime)?t[e]=s.value:s instanceof vo?t[e]=s._getPartialProperties(t[e]):di(s)||ui(s)||fi(s)||pi(s)?t[e]=s:delete t[e]}}),t}set(t){return Object.keys(t).forEach(e=>{Reflect.has(this,e)&&ci(this[e])&&(this[e]&&ci(this[e].value)&&ci(this[e].setValueAtTime)?this[e].value!==t[e]&&(this[e].value=t[e]):this[e]instanceof vo?this[e].set(t[e]):this[e]=t[e])}),this}}class yo extends Ni{constructor(t="stopped"){super(),this.name="StateTimeline",this._initial=t,this.setStateAtTime(this._initial,0)}getValueAtTime(t){const e=this.get(t);return null!==e?e.state:this._initial}setStateAtTime(t,e,s){return ei(e,0),this.add(Object.assign({},s,{state:t,time:e})),this}getLastState(t,e){for(let s=this._search(e);s>=0;s--){const e=this._timeline[s];if(e.state===t)return e}}getNextState(t,e){const s=this._search(e);if(-1!==s)for(let e=s;e<this._timeline.length;e++){const s=this._timeline[e];if(s.state===t)return s}}}class xo extends vo{constructor(){super(Di(xo.getDefaults(),arguments,["param","units","convert"])),this.name="Param",this.overridden=!1,this._minOutput=1e-7;const t=Di(xo.getDefaults(),arguments,["param","units","convert"]);for(ti(ci(t.param)&&(wi(t.param)||t.param instanceof xo),"param must be an AudioParam");!wi(t.param);)t.param=t.param._param;this._swappable=!!ci(t.swappable)&&t.swappable,this._swappable?(this.input=this.context.createGain(),this._param=t.param,this.input.connect(this._param)):this._param=this.input=t.param,this._events=new Ni(1e3),this._initialValue=this._param.defaultValue,this.units=t.units,this.convert=t.convert,this._minValue=t.minValue,this._maxValue=t.maxValue,ci(t.value)&&t.value!==this._toType(this._initialValue)&&this.setValueAtTime(t.value,0)}static getDefaults(){return Object.assign(vo.getDefaults(),{convert:!0,units:"number"})}get value(){const t=this.now();return this.getValueAtTime(t)}set value(t){this.cancelScheduledValues(this.now()),this.setValueAtTime(t,this.now())}get minValue(){return ci(this._minValue)?this._minValue:"time"===this.units||"frequency"===this.units||"normalRange"===this.units||"positive"===this.units||"transportTime"===this.units||"ticks"===this.units||"bpm"===this.units||"hertz"===this.units||"samples"===this.units?0:"audioRange"===this.units?-1:"decibels"===this.units?-1/0:this._param.minValue}get maxValue(){return ci(this._maxValue)?this._maxValue:"normalRange"===this.units||"audioRange"===this.units?1:this._param.maxValue}_is(t,e){return this.units===e}_assertRange(t){return ci(this.maxValue)&&ci(this.minValue)&&ei(t,this._fromType(this.minValue),this._fromType(this.maxValue)),t}_fromType(t){return this.convert&&!this.overridden?this._is(t,"time")?this.toSeconds(t):this._is(t,"decibels")?eo(t):this._is(t,"frequency")?this.toFrequency(t):t:this.overridden?0:t}_toType(t){return this.convert&&"decibels"===this.units?so(t):t}setValueAtTime(t,e){const s=this.toSeconds(e),n=this._fromType(t);return ti(isFinite(n)&&isFinite(s),`Invalid argument(s) to setValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(e)}`),this._assertRange(n),this.log(this.units,"setValueAtTime",t,s),this._events.add({time:s,type:"setValueAtTime",value:n}),this._param.setValueAtTime(n,s),this}getValueAtTime(t){const e=Math.max(this.toSeconds(t),0),s=this._events.getAfter(e),n=this._events.get(e);let i=this._initialValue;if(null===n)i=this._initialValue;else if("setTargetAtTime"!==n.type||null!==s&&"setValueAtTime"!==s.type)if(null===s)i=n.value;else if("linearRampToValueAtTime"===s.type||"exponentialRampToValueAtTime"===s.type){let t=n.value;if("setTargetAtTime"===n.type){const e=this._events.getBefore(n.time);t=null===e?this._initialValue:e.value}i="linearRampToValueAtTime"===s.type?this._linearInterpolate(n.time,t,s.time,s.value,e):this._exponentialInterpolate(n.time,t,s.time,s.value,e)}else i=n.value;else{const t=this._events.getBefore(n.time);let s;s=null===t?this._initialValue:t.value,"setTargetAtTime"===n.type&&(i=this._exponentialApproach(n.time,s,n.value,n.constant,e))}return this._toType(i)}setRampPoint(t){t=this.toSeconds(t);let e=this.getValueAtTime(t);return this.cancelAndHoldAtTime(t),0===this._fromType(e)&&(e=this._toType(this._minOutput)),this.setValueAtTime(e,t),this}linearRampToValueAtTime(t,e){const s=this._fromType(t),n=this.toSeconds(e);return ti(isFinite(s)&&isFinite(n),`Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(e)}`),this._assertRange(s),this._events.add({time:n,type:"linearRampToValueAtTime",value:s}),this.log(this.units,"linearRampToValueAtTime",t,n),this._param.linearRampToValueAtTime(s,n),this}exponentialRampToValueAtTime(t,e){let s=this._fromType(t);s=Ii(s,0)?this._minOutput:s,this._assertRange(s);const n=this.toSeconds(e);return ti(isFinite(s)&&isFinite(n),`Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(e)}`),this._events.add({time:n,type:"exponentialRampToValueAtTime",value:s}),this.log(this.units,"exponentialRampToValueAtTime",t,n),this._param.exponentialRampToValueAtTime(s,n),this}exponentialRampTo(t,e,s){return s=this.toSeconds(s),this.setRampPoint(s),this.exponentialRampToValueAtTime(t,s+this.toSeconds(e)),this}linearRampTo(t,e,s){return s=this.toSeconds(s),this.setRampPoint(s),this.linearRampToValueAtTime(t,s+this.toSeconds(e)),this}targetRampTo(t,e,s){return s=this.toSeconds(s),this.setRampPoint(s),this.exponentialApproachValueAtTime(t,s,e),this}exponentialApproachValueAtTime(t,e,s){e=this.toSeconds(e),s=this.toSeconds(s);const n=Math.log(s+1)/Math.log(200);return this.setTargetAtTime(t,e,n),this.cancelAndHoldAtTime(e+.9*s),this.linearRampToValueAtTime(t,e+s),this}setTargetAtTime(t,e,s){const n=this._fromType(t);ti(isFinite(s)&&s>0,"timeConstant must be a number greater than 0");const i=this.toSeconds(e);return this._assertRange(n),ti(isFinite(n)&&isFinite(i),`Invalid argument(s) to setTargetAtTime: ${JSON.stringify(t)}, ${JSON.stringify(e)}`),this._events.add({constant:s,time:i,type:"setTargetAtTime",value:n}),this.log(this.units,"setTargetAtTime",t,i,s),this._param.setTargetAtTime(n,i,s),this}setValueCurveAtTime(t,e,s,n=1){s=this.toSeconds(s),e=this.toSeconds(e);const i=this._fromType(t[0])*n;this.setValueAtTime(this._toType(i),e);const o=s/(t.length-1);for(let s=1;s<t.length;s++){const i=this._fromType(t[s])*n;this.linearRampToValueAtTime(this._toType(i),e+s*o)}return this}cancelScheduledValues(t){const e=this.toSeconds(t);return ti(isFinite(e),"Invalid argument to cancelScheduledValues: "+JSON.stringify(t)),this._events.cancel(e),this._param.cancelScheduledValues(e),this.log(this.units,"cancelScheduledValues",e),this}cancelAndHoldAtTime(t){const e=this.toSeconds(t),s=this._fromType(this.getValueAtTime(e));ti(isFinite(e),"Invalid argument to cancelAndHoldAtTime: "+JSON.stringify(t)),this.log(this.units,"cancelAndHoldAtTime",e,"value="+s);const n=this._events.get(e),i=this._events.getAfter(e);return n&&Ii(n.time,e)?i?(this._param.cancelScheduledValues(i.time),this._events.cancel(i.time)):(this._param.cancelAndHoldAtTime(e),this._events.cancel(e+this.sampleTime)):i&&(this._param.cancelScheduledValues(i.time),this._events.cancel(i.time),"linearRampToValueAtTime"===i.type?this.linearRampToValueAtTime(this._toType(s),e):"exponentialRampToValueAtTime"===i.type&&this.exponentialRampToValueAtTime(this._toType(s),e)),this._events.add({time:e,type:"setValueAtTime",value:s}),this._param.setValueAtTime(s,e),this}rampTo(t,e=.1,s){return"frequency"===this.units||"bpm"===this.units||"decibels"===this.units?this.exponentialRampTo(t,e,s):this.linearRampTo(t,e,s),this}apply(t){const e=this.context.currentTime;t.setValueAtTime(this.getValueAtTime(e),e);const s=this._events.get(e);if(s&&"setTargetAtTime"===s.type){const n=this._events.getAfter(s.time),i=n?n.time:e+2,o=(i-e)/10;for(let s=e;s<i;s+=o)t.linearRampToValueAtTime(this.getValueAtTime(s),s)}return this._events.forEachAfter(this.context.currentTime,e=>{"cancelScheduledValues"===e.type?t.cancelScheduledValues(e.time):"setTargetAtTime"===e.type?t.setTargetAtTime(e.value,e.time,e.constant):t[e.type](e.value,e.time)}),this}setParam(t){ti(this._swappable,"The Param must be assigned as 'swappable' in the constructor");const e=this.input;return e.disconnect(this._param),this.apply(t),this._param=t,e.connect(this._param),this}dispose(){return super.dispose(),this._events.dispose(),this}get defaultValue(){return this._toType(this._param.defaultValue)}_exponentialApproach(t,e,s,n,i){return s+(e-s)*Math.exp(-(i-t)/n)}_linearInterpolate(t,e,s,n,i){return e+(i-t)/(s-t)*(n-e)}_exponentialInterpolate(t,e,s,n,i){return e*Math.pow(n/e,(i-t)/(s-t))}}class wo extends vo{constructor(){super(...arguments),this.name="ToneAudioNode",this._internalChannels=[]}get numberOfInputs(){return ci(this.input)?wi(this.input)||this.input instanceof xo?1:this.input.numberOfInputs:0}get numberOfOutputs(){return ci(this.output)?this.output.numberOfOutputs:0}_isAudioNode(t){return ci(t)&&(t instanceof wo||bi(t))}_getInternalNodes(){const t=this._internalChannels.slice(0);return this._isAudioNode(this.input)&&t.push(this.input),this._isAudioNode(this.output)&&this.input!==this.output&&t.push(this.output),t}_setChannelProperties(t){this._getInternalNodes().forEach(e=>{e.channelCount=t.channelCount,e.channelCountMode=t.channelCountMode,e.channelInterpretation=t.channelInterpretation})}_getChannelProperties(){const t=this._getInternalNodes();ti(t.length>0,"ToneAudioNode does not have any internal nodes");const e=t[0];return{channelCount:e.channelCount,channelCountMode:e.channelCountMode,channelInterpretation:e.channelInterpretation}}get channelCount(){return this._getChannelProperties().channelCount}set channelCount(t){const e=this._getChannelProperties();this._setChannelProperties(Object.assign(e,{channelCount:t}))}get channelCountMode(){return this._getChannelProperties().channelCountMode}set channelCountMode(t){const e=this._getChannelProperties();this._setChannelProperties(Object.assign(e,{channelCountMode:t}))}get channelInterpretation(){return this._getChannelProperties().channelInterpretation}set channelInterpretation(t){const e=this._getChannelProperties();this._setChannelProperties(Object.assign(e,{channelInterpretation:t}))}connect(t,e=0,s=0){return To(this,t,e,s),this}toDestination(){return this.connect(this.context.destination),this}toMaster(){return ri("toMaster() has been renamed toDestination()"),this.toDestination()}disconnect(t,e=0,s=0){return So(this,t,e,s),this}chain(...t){return bo(this,...t),this}fan(...t){return t.forEach(t=>this.connect(t)),this}dispose(){return super.dispose(),ci(this.input)&&(this.input instanceof wo?this.input.dispose():bi(this.input)&&this.input.disconnect()),ci(this.output)&&(this.output instanceof wo?this.output.dispose():bi(this.output)&&this.output.disconnect()),this._internalChannels=[],this}}function bo(...t){const e=t.shift();t.reduce((t,e)=>(t instanceof wo?t.connect(e):bi(t)&&To(t,e),e),e)}function To(t,e,s=0,n=0){for(ti(ci(t),"Cannot connect from undefined node"),ti(ci(e),"Cannot connect to undefined node"),(e instanceof wo||bi(e))&&ti(e.numberOfInputs>0,"Cannot connect to node with no inputs"),ti(t.numberOfOutputs>0,"Cannot connect from node with no outputs");e instanceof wo||e instanceof xo;)ci(e.input)&&(e=e.input);for(;t instanceof wo;)ci(t.output)&&(t=t.output);wi(e)?t.connect(e,s):t.connect(e,s,n)}function So(t,e,s=0,n=0){if(ci(e))for(;e instanceof wo;)e=e.input;for(;!bi(t);)ci(t.output)&&(t=t.output);wi(e)?t.disconnect(e,s):bi(e)?t.disconnect(e,s,n):t.disconnect()}class ko extends wo{constructor(){super(Di(ko.getDefaults(),arguments,["gain","units"])),this.name="Gain",this._gainNode=this.context.createGain(),this.input=this._gainNode,this.output=this._gainNode;const t=Di(ko.getDefaults(),arguments,["gain","units"]);this.gain=new xo({context:this.context,convert:t.convert,param:this._gainNode.gain,units:t.units,value:t.gain,minValue:t.minValue,maxValue:t.maxValue}),Ui(this,"gain")}static getDefaults(){return Object.assign(wo.getDefaults(),{convert:!0,gain:1,units:"gain"})}dispose(){return super.dispose(),this._gainNode.disconnect(),this.gain.dispose(),this}}class Co extends wo{constructor(t){super(t),this.onended=Zi,this._startTime=-1,this._stopTime=-1,this._timeout=-1,this.output=new ko({context:this.context,gain:0}),this._gainNode=this.output,this.getStateAtTime=function(t){const e=this.toSeconds(t);return-1!==this._startTime&&e>=this._startTime&&(-1===this._stopTime||e<=this._stopTime)?"started":"stopped"},this._fadeIn=t.fadeIn,this._fadeOut=t.fadeOut,this._curve=t.curve,this.onended=t.onended}static getDefaults(){return Object.assign(wo.getDefaults(),{curve:"linear",fadeIn:0,fadeOut:0,onended:Zi})}_startGain(t,e=1){ti(-1===this._startTime,"Source cannot be started more than once");const s=this.toSeconds(this._fadeIn);return this._startTime=t+s,this._startTime=Math.max(this._startTime,this.context.currentTime),s>0?(this._gainNode.gain.setValueAtTime(0,t),"linear"===this._curve?this._gainNode.gain.linearRampToValueAtTime(e,t+s):this._gainNode.gain.exponentialApproachValueAtTime(e,t,s)):this._gainNode.gain.setValueAtTime(e,t),this}stop(t){return this.log("stop",t),this._stopGain(this.toSeconds(t)),this}_stopGain(t){ti(-1!==this._startTime,"'start' must be called before 'stop'"),this.cancelStop();const e=this.toSeconds(this._fadeOut);return this._stopTime=this.toSeconds(t)+e,this._stopTime=Math.max(this._stopTime,this.context.currentTime),e>0?"linear"===this._curve?this._gainNode.gain.linearRampTo(0,e,t):this._gainNode.gain.targetRampTo(0,e,t):(this._gainNode.gain.cancelAndHoldAtTime(t),this._gainNode.gain.setValueAtTime(0,t)),this.context.clearTimeout(this._timeout),this._timeout=this.context.setTimeout(()=>{const t="exponential"===this._curve?2*e:0;this._stopSource(this.now()+t),this._onended()},this._stopTime-this.context.currentTime),this}_onended(){if(this.onended!==Zi&&(this.onended(this),this.onended=Zi,!this.context.isOffline)){const t=()=>this.dispose();void 0!==window.requestIdleCallback?window.requestIdleCallback(t):setTimeout(t,1e3)}}get state(){return this.getStateAtTime(this.now())}cancelStop(){return this.log("cancelStop"),ti(-1!==this._startTime,"Source is not started"),this._gainNode.gain.cancelScheduledValues(this._startTime+this.sampleTime),this.context.clearTimeout(this._timeout),this._stopTime=-1,this}dispose(){return super.dispose(),this._gainNode.disconnect(),this}}class Ao extends Co{constructor(){super(Di(Ao.getDefaults(),arguments,["offset"])),this.name="ToneConstantSource",this._source=this.context.createConstantSource();const t=Di(Ao.getDefaults(),arguments,["offset"]);To(this._source,this._gainNode),this.offset=new xo({context:this.context,convert:t.convert,param:this._source.offset,units:t.units,value:t.offset,minValue:t.minValue,maxValue:t.maxValue})}static getDefaults(){return Object.assign(Co.getDefaults(),{convert:!0,offset:1,units:"number"})}start(t){const e=this.toSeconds(t);return this.log("start",e),this._startGain(e),this._source.start(e),this}_stopSource(t){this._source.stop(t)}dispose(){return super.dispose(),"started"===this.state&&this.stop(),this._source.disconnect(),this.offset.dispose(),this}}class Do extends wo{constructor(){super(Di(Do.getDefaults(),arguments,["value","units"])),this.name="Signal",this.override=!0;const t=Di(Do.getDefaults(),arguments,["value","units"]);this.output=this._constantSource=new Ao({context:this.context,convert:t.convert,offset:t.value,units:t.units,minValue:t.minValue,maxValue:t.maxValue}),this._constantSource.start(0),this.input=this._param=this._constantSource.offset}static getDefaults(){return Object.assign(wo.getDefaults(),{convert:!0,units:"number",value:0})}connect(t,e=0,s=0){return Oo(this,t,e,s),this}dispose(){return super.dispose(),this._param.dispose(),this._constantSource.dispose(),this}setValueAtTime(t,e){return this._param.setValueAtTime(t,e),this}getValueAtTime(t){return this._param.getValueAtTime(t)}setRampPoint(t){return this._param.setRampPoint(t),this}linearRampToValueAtTime(t,e){return this._param.linearRampToValueAtTime(t,e),this}exponentialRampToValueAtTime(t,e){return this._param.exponentialRampToValueAtTime(t,e),this}exponentialRampTo(t,e,s){return this._param.exponentialRampTo(t,e,s),this}linearRampTo(t,e,s){return this._param.linearRampTo(t,e,s),this}targetRampTo(t,e,s){return this._param.targetRampTo(t,e,s),this}exponentialApproachValueAtTime(t,e,s){return this._param.exponentialApproachValueAtTime(t,e,s),this}setTargetAtTime(t,e,s){return this._param.setTargetAtTime(t,e,s),this}setValueCurveAtTime(t,e,s,n){return this._param.setValueCurveAtTime(t,e,s,n),this}cancelScheduledValues(t){return this._param.cancelScheduledValues(t),this}cancelAndHoldAtTime(t){return this._param.cancelAndHoldAtTime(t),this}rampTo(t,e,s){return this._param.rampTo(t,e,s),this}get value(){return this._param.value}set value(t){this._param.value=t}get convert(){return this._param.convert}set convert(t){this._param.convert=t}get units(){return this._param.units}get overridden(){return this._param.overridden}set overridden(t){this._param.overridden=t}get maxValue(){return this._param.maxValue}get minValue(){return this._param.minValue}apply(t){return this._param.apply(t),this}}function Oo(t,e,s,n){(e instanceof xo||wi(e)||e instanceof Do&&e.override)&&(e.cancelScheduledValues(0),e.setValueAtTime(0,0),e instanceof Do&&(e.overridden=!0)),To(t,e,s,n)}class Mo extends xo{constructor(){super(Di(Mo.getDefaults(),arguments,["value"])),this.name="TickParam",this._events=new Ni(1/0),this._multiplier=1;const t=Di(Mo.getDefaults(),arguments,["value"]);this._multiplier=t.multiplier,this._events.cancel(0),this._events.add({ticks:0,time:0,type:"setValueAtTime",value:this._fromType(t.value)}),this.setValueAtTime(t.value,0)}static getDefaults(){return Object.assign(xo.getDefaults(),{multiplier:1,units:"hertz",value:1})}setTargetAtTime(t,e,s){e=this.toSeconds(e),this.setRampPoint(e);const n=this._fromType(t),i=this._events.get(e),o=Math.round(Math.max(1/s,1));for(let t=0;t<=o;t++){const o=s*t+e,r=this._exponentialApproach(i.time,i.value,n,s,o);this.linearRampToValueAtTime(this._toType(r),o)}return this}setValueAtTime(t,e){const s=this.toSeconds(e);super.setValueAtTime(t,e);const n=this._events.get(s),i=this._events.previousEvent(n),o=this._getTicksUntilEvent(i,s);return n.ticks=Math.max(o,0),this}linearRampToValueAtTime(t,e){const s=this.toSeconds(e);super.linearRampToValueAtTime(t,e);const n=this._events.get(s),i=this._events.previousEvent(n),o=this._getTicksUntilEvent(i,s);return n.ticks=Math.max(o,0),this}exponentialRampToValueAtTime(t,e){e=this.toSeconds(e);const s=this._fromType(t),n=this._events.get(e),i=Math.round(Math.max(10*(e-n.time),1)),o=(e-n.time)/i;for(let t=0;t<=i;t++){const i=o*t+n.time,r=this._exponentialInterpolate(n.time,n.value,e,s,i);this.linearRampToValueAtTime(this._toType(r),i)}return this}_getTicksUntilEvent(t,e){if(null===t)t={ticks:0,time:0,type:"setValueAtTime",value:0};else if(ai(t.ticks)){const e=this._events.previousEvent(t);t.ticks=this._getTicksUntilEvent(e,t.time)}const s=this._fromType(this.getValueAtTime(t.time));let n=this._fromType(this.getValueAtTime(e));const i=this._events.get(e);return i&&i.time===e&&"setValueAtTime"===i.type&&(n=this._fromType(this.getValueAtTime(e-this.sampleTime))),.5*(e-t.time)*(s+n)+t.ticks}getTicksAtTime(t){const e=this.toSeconds(t),s=this._events.get(e);return Math.max(this._getTicksUntilEvent(s,e),0)}getDurationOfTicks(t,e){const s=this.toSeconds(e),n=this.getTicksAtTime(e);return this.getTimeOfTick(n+t)-s}getTimeOfTick(t){const e=this._events.get(t,"ticks"),s=this._events.getAfter(t,"ticks");if(e&&e.ticks===t)return e.time;if(e&&s&&"linearRampToValueAtTime"===s.type&&e.value!==s.value){const n=this._fromType(this.getValueAtTime(e.time)),i=(this._fromType(this.getValueAtTime(s.time))-n)/(s.time-e.time),o=Math.sqrt(Math.pow(n,2)-2*i*(e.ticks-t)),r=(-n+o)/i,a=(-n-o)/i;return(r>0?r:a)+e.time}return e?0===e.value?1/0:e.time+(t-e.ticks)/e.value:t/this._initialValue}ticksToTime(t,e){return this.getDurationOfTicks(t,e)}timeToTicks(t,e){const s=this.toSeconds(e),n=this.toSeconds(t),i=this.getTicksAtTime(s);return this.getTicksAtTime(s+n)-i}_fromType(t){return"bpm"===this.units&&this.multiplier?1/(60/t/this.multiplier):super._fromType(t)}_toType(t){return"bpm"===this.units&&this.multiplier?t/this.multiplier*60:super._toType(t)}get multiplier(){return this._multiplier}set multiplier(t){const e=this.value;this._multiplier=t,this.cancelScheduledValues(0),this.setValueAtTime(e,0)}}class Eo extends Do{constructor(){super(Di(Eo.getDefaults(),arguments,["value"])),this.name="TickSignal";const t=Di(Eo.getDefaults(),arguments,["value"]);this.input=this._param=new Mo({context:this.context,convert:t.convert,multiplier:t.multiplier,param:this._constantSource.offset,units:t.units,value:t.value})}static getDefaults(){return Object.assign(Do.getDefaults(),{multiplier:1,units:"hertz",value:1})}ticksToTime(t,e){return this._param.ticksToTime(t,e)}timeToTicks(t,e){return this._param.timeToTicks(t,e)}getTimeOfTick(t){return this._param.getTimeOfTick(t)}getDurationOfTicks(t,e){return this._param.getDurationOfTicks(t,e)}getTicksAtTime(t){return this._param.getTicksAtTime(t)}get multiplier(){return this._param.multiplier}set multiplier(t){this._param.multiplier=t}dispose(){return super.dispose(),this._param.dispose(),this}}class Ro extends vo{constructor(){super(Di(Ro.getDefaults(),arguments,["frequency"])),this.name="TickSource",this._state=new yo,this._tickOffset=new Ni;const t=Di(Ro.getDefaults(),arguments,["frequency"]);this.frequency=new Eo({context:this.context,units:t.units,value:t.frequency}),Ui(this,"frequency"),this._state.setStateAtTime("stopped",0),this.setTicksAtTime(0,0)}static getDefaults(){return Object.assign({frequency:1,units:"hertz"},vo.getDefaults())}get state(){return this.getStateAtTime(this.now())}start(t,e){const s=this.toSeconds(t);return"started"!==this._state.getValueAtTime(s)&&(this._state.setStateAtTime("started",s),ci(e)&&this.setTicksAtTime(e,s)),this}stop(t){const e=this.toSeconds(t);if("stopped"===this._state.getValueAtTime(e)){const t=this._state.get(e);t&&t.time>0&&(this._tickOffset.cancel(t.time),this._state.cancel(t.time))}return this._state.cancel(e),this._state.setStateAtTime("stopped",e),this.setTicksAtTime(0,e),this}pause(t){const e=this.toSeconds(t);return"started"===this._state.getValueAtTime(e)&&this._state.setStateAtTime("paused",e),this}cancel(t){return t=this.toSeconds(t),this._state.cancel(t),this._tickOffset.cancel(t),this}getTicksAtTime(t){const e=this.toSeconds(t),s=this._state.getLastState("stopped",e),n={state:"paused",time:e};this._state.add(n);let i=s,o=0;return this._state.forEachBetween(s.time,e+this.sampleTime,t=>{let e=i.time;const s=this._tickOffset.get(t.time);s&&s.time>=i.time&&(o=s.ticks,e=s.time),"started"===i.state&&"started"!==t.state&&(o+=this.frequency.getTicksAtTime(t.time)-this.frequency.getTicksAtTime(e)),i=t}),this._state.remove(n),o}get ticks(){return this.getTicksAtTime(this.now())}set ticks(t){this.setTicksAtTime(t,this.now())}get seconds(){return this.getSecondsAtTime(this.now())}set seconds(t){const e=this.now(),s=this.frequency.timeToTicks(t,e);this.setTicksAtTime(s,e)}getSecondsAtTime(t){t=this.toSeconds(t);const e=this._state.getLastState("stopped",t),s={state:"paused",time:t};this._state.add(s);let n=e,i=0;return this._state.forEachBetween(e.time,t+this.sampleTime,t=>{let e=n.time;const s=this._tickOffset.get(t.time);s&&s.time>=n.time&&(i=s.seconds,e=s.time),"started"===n.state&&"started"!==t.state&&(i+=t.time-e),n=t}),this._state.remove(s),i}setTicksAtTime(t,e){return e=this.toSeconds(e),this._tickOffset.cancel(e),this._tickOffset.add({seconds:this.frequency.getDurationOfTicks(t,e),ticks:t,time:e}),this}getStateAtTime(t){return t=this.toSeconds(t),this._state.getValueAtTime(t)}getTimeOfTick(t,e=this.now()){const s=this._tickOffset.get(e),n=this._state.get(e),i=Math.max(s.time,n.time),o=this.frequency.getTicksAtTime(i)+t-s.ticks;return this.frequency.getTimeOfTick(o)}forEachTickBetween(t,e,s){let n=this._state.get(t);this._state.forEachBetween(t,e,e=>{n&&"started"===n.state&&"started"!==e.state&&this.forEachTickBetween(Math.max(n.time,t),e.time-this.sampleTime,s),n=e});let i=null;if(n&&"started"===n.state){const o=Math.max(n.time,t),r=this.frequency.getTicksAtTime(o),a=r-this.frequency.getTicksAtTime(n.time);let c=Math.ceil(a)-a;c=Ii(c,1)?0:c;let h=this.frequency.getTimeOfTick(r+c);for(;h<e;){try{s(h,Math.round(this.getTicksAtTime(h)))}catch(t){i=t;break}h+=this.frequency.getDurationOfTicks(1,h)}}if(i)throw i;return this}dispose(){return super.dispose(),this._state.dispose(),this._tickOffset.dispose(),this.frequency.dispose(),this}}class qo extends vo{constructor(){super(Di(qo.getDefaults(),arguments,["callback","frequency"])),this.name="Clock",this.callback=Zi,this._lastUpdate=0,this._state=new yo("stopped"),this._boundLoop=this._loop.bind(this);const t=Di(qo.getDefaults(),arguments,["callback","frequency"]);this.callback=t.callback,this._tickSource=new Ro({context:this.context,frequency:t.frequency,units:t.units}),this._lastUpdate=0,this.frequency=this._tickSource.frequency,Ui(this,"frequency"),this._state.setStateAtTime("stopped",0),this.context.on("tick",this._boundLoop)}static getDefaults(){return Object.assign(vo.getDefaults(),{callback:Zi,frequency:1,units:"hertz"})}get state(){return this._state.getValueAtTime(this.now())}start(t,e){si(this.context);const s=this.toSeconds(t);return this.log("start",s),"started"!==this._state.getValueAtTime(s)&&(this._state.setStateAtTime("started",s),this._tickSource.start(s,e),s<this._lastUpdate&&this.emit("start",s,e)),this}stop(t){const e=this.toSeconds(t);return this.log("stop",e),this._state.cancel(e),this._state.setStateAtTime("stopped",e),this._tickSource.stop(e),e<this._lastUpdate&&this.emit("stop",e),this}pause(t){const e=this.toSeconds(t);return"started"===this._state.getValueAtTime(e)&&(this._state.setStateAtTime("paused",e),this._tickSource.pause(e),e<this._lastUpdate&&this.emit("pause",e)),this}get ticks(){return Math.ceil(this.getTicksAtTime(this.now()))}set ticks(t){this._tickSource.ticks=t}get seconds(){return this._tickSource.seconds}set seconds(t){this._tickSource.seconds=t}getSecondsAtTime(t){return this._tickSource.getSecondsAtTime(t)}setTicksAtTime(t,e){return this._tickSource.setTicksAtTime(t,e),this}getTimeOfTick(t,e=this.now()){return this._tickSource.getTimeOfTick(t,e)}getTicksAtTime(t){return this._tickSource.getTicksAtTime(t)}nextTickTime(t,e){const s=this.toSeconds(e),n=this.getTicksAtTime(s);return this._tickSource.getTimeOfTick(n+t,s)}_loop(){const t=this._lastUpdate,e=this.now();this._lastUpdate=e,this.log("loop",t,e),t!==e&&(this._state.forEachBetween(t,e,t=>{switch(t.state){case"started":const e=this._tickSource.getTicksAtTime(t.time);this.emit("start",t.time,e);break;case"stopped":0!==t.time&&this.emit("stop",t.time);break;case"paused":this.emit("pause",t.time)}}),this._tickSource.forEachTickBetween(t,e,(t,e)=>{this.callback(t,e)}))}getStateAtTime(t){const e=this.toSeconds(t);return this._state.getValueAtTime(e)}dispose(){return super.dispose(),this.context.off("tick",this._boundLoop),this._tickSource.dispose(),this._state.dispose(),this}}Bi.mixin(qo);class Fo extends wo{constructor(){super(Di(Fo.getDefaults(),arguments,["delayTime","maxDelay"])),this.name="Delay";const t=Di(Fo.getDefaults(),arguments,["delayTime","maxDelay"]),e=this.toSeconds(t.maxDelay);this._maxDelay=Math.max(e,this.toSeconds(t.delayTime)),this._delayNode=this.input=this.output=this.context.createDelay(e),this.delayTime=new xo({context:this.context,param:this._delayNode.delayTime,units:"time",value:t.delayTime,minValue:0,maxValue:this.maxDelay}),Ui(this,"delayTime")}static getDefaults(){return Object.assign(wo.getDefaults(),{delayTime:0,maxDelay:1})}get maxDelay(){return this._maxDelay}dispose(){return super.dispose(),this._delayNode.disconnect(),this.delayTime.dispose(),this}}function Io(t,e,s=2,n=Ji().sampleRate){return yi(this,void 0,void 0,(function*(){const i=Ji(),o=new Yi(s,e,n);Ki(o),yield t(o);const r=o.render();Ki(i);const a=yield r;return new Xi(a)}))}class Vo extends Ei{constructor(){super(),this.name="ToneAudioBuffers",this._buffers=new Map,this._loadingCount=0;const t=Di(Vo.getDefaults(),arguments,["urls","onload","baseUrl"],"urls");this.baseUrl=t.baseUrl,Object.keys(t.urls).forEach(e=>{this._loadingCount++;const s=t.urls[e];this.add(e,s,this._bufferLoaded.bind(this,t.onload),t.onerror)})}static getDefaults(){return{baseUrl:"",onerror:Zi,onload:Zi,urls:{}}}has(t){return this._buffers.has(t.toString())}get(t){return ti(this.has(t),"ToneAudioBuffers has no buffer named: "+t),this._buffers.get(t.toString())}_bufferLoaded(t){this._loadingCount--,0===this._loadingCount&&t&&t()}get loaded(){return Array.from(this._buffers).every(([t,e])=>e.loaded)}add(t,e,s=Zi,n=Zi){return fi(e)?this._buffers.set(t.toString(),new Xi(this.baseUrl+e,s,n)):this._buffers.set(t.toString(),new Xi(e,s,n)),this}dispose(){return super.dispose(),this._buffers.forEach(t=>t.dispose()),this._buffers.clear(),this}}class No extends lo{constructor(){super(...arguments),this.name="MidiClass",this.defaultUnits="midi"}_frequencyToUnits(t){return oo(super._frequencyToUnits(t))}_ticksToUnits(t){return oo(super._ticksToUnits(t))}_beatsToUnits(t){return oo(super._beatsToUnits(t))}_secondsToUnits(t){return oo(super._secondsToUnits(t))}toMidi(){return this.valueOf()}toFrequency(){return ao(this.toMidi())}transpose(t){return new No(this.context,this.toMidi()+t)}}function Po(t,e){return new No(Ji(),t,e)}class jo extends mo{constructor(){super(...arguments),this.name="Ticks",this.defaultUnits="i"}_now(){return this.context.transport.ticks}_beatsToUnits(t){return this._getPPQ()*t}_secondsToUnits(t){return Math.floor(t/(60/this._getBpm())*this._getPPQ())}_ticksToUnits(t){return t}toTicks(){return this.valueOf()}toSeconds(){return this.valueOf()/this._getPPQ()*(60/this._getBpm())}}function Lo(t,e){return new jo(Ji(),t,e)}class zo extends vo{constructor(){super(...arguments),this.name="Draw",this.expiration=.25,this.anticipation=.008,this._events=new Ni,this._boundDrawLoop=this._drawLoop.bind(this),this._animationFrame=-1}schedule(t,e){return this._events.add({callback:t,time:this.toSeconds(e)}),1===this._events.length&&(this._animationFrame=requestAnimationFrame(this._boundDrawLoop)),this}cancel(t){return this._events.cancel(this.toSeconds(t)),this}_drawLoop(){const t=this.context.currentTime;for(;this._events.length&&this._events.peek().time-this.anticipation<=t;){const e=this._events.shift();e&&t-e.time<=this.expiration&&e.callback()}this._events.length>0&&(this._animationFrame=requestAnimationFrame(this._boundDrawLoop))}dispose(){return super.dispose(),this._events.dispose(),cancelAnimationFrame(this._animationFrame),this}}ji(t=>{t.draw=new zo({context:t})}),zi(t=>{t.draw.dispose()});class Bo extends Ei{constructor(){super(...arguments),this.name="IntervalTimeline",this._root=null,this._length=0}add(t){ti(ci(t.time),"Events must have a time property"),ti(ci(t.duration),"Events must have a duration parameter"),t.time=t.time.valueOf();let e=new Wo(t.time,t.time+t.duration,t);for(null===this._root?this._root=e:this._root.insert(e),this._length++;null!==e;)e.updateHeight(),e.updateMax(),this._rebalance(e),e=e.parent;return this}remove(t){if(null!==this._root){const e=[];this._root.search(t.time,e);for(const s of e)if(s.event===t){this._removeNode(s),this._length--;break}}return this}get length(){return this._length}cancel(t){return this.forEachFrom(t,t=>this.remove(t)),this}_setRoot(t){this._root=t,null!==this._root&&(this._root.parent=null)}_replaceNodeInParent(t,e){null!==t.parent?(t.isLeftChild()?t.parent.left=e:t.parent.right=e,this._rebalance(t.parent)):this._setRoot(e)}_removeNode(t){if(null===t.left&&null===t.right)this._replaceNodeInParent(t,null);else if(null===t.right)this._replaceNodeInParent(t,t.left);else if(null===t.left)this._replaceNodeInParent(t,t.right);else{let e,s=null;if(t.getBalance()>0)if(null===t.left.right)e=t.left,e.right=t.right,s=e;else{for(e=t.left.right;null!==e.right;)e=e.right;e.parent&&(e.parent.right=e.left,s=e.parent,e.left=t.left,e.right=t.right)}else if(null===t.right.left)e=t.right,e.left=t.left,s=e;else{for(e=t.right.left;null!==e.left;)e=e.left;e.parent&&(e.parent.left=e.right,s=e.parent,e.left=t.left,e.right=t.right)}null!==t.parent?t.isLeftChild()?t.parent.left=e:t.parent.right=e:this._setRoot(e),s&&this._rebalance(s)}t.dispose()}_rotateLeft(t){const e=t.parent,s=t.isLeftChild(),n=t.right;n&&(t.right=n.left,n.left=t),null!==e?s?e.left=n:e.right=n:this._setRoot(n)}_rotateRight(t){const e=t.parent,s=t.isLeftChild(),n=t.left;n&&(t.left=n.right,n.right=t),null!==e?s?e.left=n:e.right=n:this._setRoot(n)}_rebalance(t){const e=t.getBalance();e>1&&t.left?t.left.getBalance()<0?this._rotateLeft(t.left):this._rotateRight(t):e<-1&&t.right&&(t.right.getBalance()>0?this._rotateRight(t.right):this._rotateLeft(t))}get(t){if(null!==this._root){const e=[];if(this._root.search(t,e),e.length>0){let t=e[0];for(let s=1;s<e.length;s++)e[s].low>t.low&&(t=e[s]);return t.event}}return null}forEach(t){if(null!==this._root){const e=[];this._root.traverse(t=>e.push(t)),e.forEach(e=>{e.event&&t(e.event)})}return this}forEachAtTime(t,e){if(null!==this._root){const s=[];this._root.search(t,s),s.forEach(t=>{t.event&&e(t.event)})}return this}forEachFrom(t,e){if(null!==this._root){const s=[];this._root.searchAfter(t,s),s.forEach(t=>{t.event&&e(t.event)})}return this}dispose(){return super.dispose(),null!==this._root&&this._root.traverse(t=>t.dispose()),this._root=null,this}}class Wo{constructor(t,e,s){this._left=null,this._right=null,this.parent=null,this.height=0,this.event=s,this.low=t,this.high=e,this.max=this.high}insert(t){t.low<=this.low?null===this.left?this.left=t:this.left.insert(t):null===this.right?this.right=t:this.right.insert(t)}search(t,e){t>this.max||(null!==this.left&&this.left.search(t,e),this.low<=t&&this.high>t&&e.push(this),this.low>t||null!==this.right&&this.right.search(t,e))}searchAfter(t,e){this.low>=t&&(e.push(this),null!==this.left&&this.left.searchAfter(t,e)),null!==this.right&&this.right.searchAfter(t,e)}traverse(t){t(this),null!==this.left&&this.left.traverse(t),null!==this.right&&this.right.traverse(t)}updateHeight(){null!==this.left&&null!==this.right?this.height=Math.max(this.left.height,this.right.height)+1:null!==this.right?this.height=this.right.height+1:null!==this.left?this.height=this.left.height+1:this.height=0}updateMax(){this.max=this.high,null!==this.left&&(this.max=Math.max(this.max,this.left.max)),null!==this.right&&(this.max=Math.max(this.max,this.right.max))}getBalance(){let t=0;return null!==this.left&&null!==this.right?t=this.left.height-this.right.height:null!==this.left?t=this.left.height+1:null!==this.right&&(t=-(this.right.height+1)),t}isLeftChild(){return null!==this.parent&&this.parent.left===this}get left(){return this._left}set left(t){this._left=t,null!==t&&(t.parent=this),this.updateHeight(),this.updateMax()}get right(){return this._right}set right(t){this._right=t,null!==t&&(t.parent=this),this.updateHeight(),this.updateMax()}dispose(){this.parent=null,this._left=null,this._right=null,this.event=null}}class Go extends wo{constructor(){super(Di(Go.getDefaults(),arguments,["volume"])),this.name="Volume";const t=Di(Go.getDefaults(),arguments,["volume"]);this.input=this.output=new ko({context:this.context,gain:t.volume,units:"decibels"}),this.volume=this.output.gain,Ui(this,"volume"),this._unmutedVolume=t.volume,this.mute=t.mute}static getDefaults(){return Object.assign(wo.getDefaults(),{mute:!1,volume:0})}get mute(){return this.volume.value===-1/0}set mute(t){!this.mute&&t?(this._unmutedVolume=this.volume.value,this.volume.value=-1/0):this.mute&&!t&&(this.volume.value=this._unmutedVolume)}dispose(){return super.dispose(),this.input.dispose(),this.volume.dispose(),this}}class Uo extends wo{constructor(){super(Di(Uo.getDefaults(),arguments)),this.name="Destination",this.input=new Go({context:this.context}),this.output=new ko({context:this.context}),this.volume=this.input.volume;const t=Di(Uo.getDefaults(),arguments);bo(this.input,this.output,this.context.rawContext.destination),this.mute=t.mute,this._internalChannels=[this.input,this.context.rawContext.destination,this.output]}static getDefaults(){return Object.assign(wo.getDefaults(),{mute:!1,volume:0})}get mute(){return this.input.mute}set mute(t){this.input.mute=t}chain(...t){return this.input.disconnect(),t.unshift(this.input),t.push(this.output),bo(...t),this}get maxChannelCount(){return this.context.rawContext.destination.maxChannelCount}dispose(){return super.dispose(),this.volume.dispose(),this}}ji(t=>{t.destination=new Uo({context:t})}),zi(t=>{t.destination.dispose()});class Qo extends Ei{constructor(t){super(),this.name="TimelineValue",this._timeline=new Ni({memory:10}),this._initialValue=t}set(t,e){return this._timeline.add({value:t,time:e}),this}get(t){const e=this._timeline.get(t);return e?e.value:this._initialValue}}class Zo{constructor(t,e){this.id=Zo._eventId++;const s=Object.assign(Zo.getDefaults(),e);this.transport=t,this.callback=s.callback,this._once=s.once,this.time=s.time}static getDefaults(){return{callback:Zi,once:!1,time:0}}invoke(t){this.callback&&(this.callback(t),this._once&&this.transport.clear(this.id))}dispose(){return this.callback=void 0,this}}Zo._eventId=0;class Xo extends Zo{constructor(t,e){super(t,e),this._currentId=-1,this._nextId=-1,this._nextTick=this.time,this._boundRestart=this._restart.bind(this);const s=Object.assign(Xo.getDefaults(),e);this.duration=new jo(t.context,s.duration).valueOf(),this._interval=new jo(t.context,s.interval).valueOf(),this._nextTick=s.time,this.transport.on("start",this._boundRestart),this.transport.on("loopStart",this._boundRestart),this.context=this.transport.context,this._restart()}static getDefaults(){return Object.assign({},Zo.getDefaults(),{duration:1/0,interval:1,once:!1})}invoke(t){this._createEvents(t),super.invoke(t)}_createEvents(t){const e=this.transport.getTicksAtTime(t);e>=this.time&&e>=this._nextTick&&this._nextTick+this._interval<this.time+this.duration&&(this._nextTick+=this._interval,this._currentId=this._nextId,this._nextId=this.transport.scheduleOnce(this.invoke.bind(this),new jo(this.context,this._nextTick).toSeconds()))}_restart(t){this.transport.clear(this._currentId),this.transport.clear(this._nextId),this._nextTick=this.time;const e=this.transport.getTicksAtTime(t);e>this.time&&(this._nextTick=this.time+Math.ceil((e-this.time)/this._interval)*this._interval),this._currentId=this.transport.scheduleOnce(this.invoke.bind(this),new jo(this.context,this._nextTick).toSeconds()),this._nextTick+=this._interval,this._nextId=this.transport.scheduleOnce(this.invoke.bind(this),new jo(this.context,this._nextTick).toSeconds())}dispose(){return super.dispose(),this.transport.clear(this._currentId),this.transport.clear(this._nextId),this.transport.off("start",this._boundRestart),this.transport.off("loopStart",this._boundRestart),this}}class Yo extends vo{constructor(){super(Di(Yo.getDefaults(),arguments)),this.name="Transport",this._loop=new Qo(!1),this._loopStart=0,this._loopEnd=0,this._scheduledEvents={},this._timeline=new Ni,this._repeatedEvents=new Bo,this._syncedSignals=[],this._swingAmount=0;const t=Di(Yo.getDefaults(),arguments);this._ppq=t.ppq,this._clock=new qo({callback:this._processTick.bind(this),context:this.context,frequency:0,units:"bpm"}),this._bindClockEvents(),this.bpm=this._clock.frequency,this._clock.frequency.multiplier=t.ppq,this.bpm.setValueAtTime(t.bpm,0),Ui(this,"bpm"),this._timeSignature=t.timeSignature,this._swingTicks=t.ppq/2}static getDefaults(){return Object.assign(vo.getDefaults(),{bpm:120,loopEnd:"4m",loopStart:0,ppq:192,swing:0,swingSubdivision:"8n",timeSignature:4})}_processTick(t,e){if(this._loop.get(t)&&e>=this._loopEnd&&(this.emit("loopEnd",t),this._clock.setTicksAtTime(this._loopStart,t),e=this._loopStart,this.emit("loopStart",t,this._clock.getSecondsAtTime(t)),this.emit("loop",t)),this._swingAmount>0&&e%this._ppq!=0&&e%(2*this._swingTicks)!=0){const s=e%(2*this._swingTicks)/(2*this._swingTicks),n=Math.sin(s*Math.PI)*this._swingAmount;t+=new jo(this.context,2*this._swingTicks/3).toSeconds()*n}this._timeline.forEachAtTime(e,e=>e.invoke(t))}schedule(t,e){const s=new Zo(this,{callback:t,time:new mo(this.context,e).toTicks()});return this._addEvent(s,this._timeline)}scheduleRepeat(t,e,s,n=1/0){const i=new Xo(this,{callback:t,duration:new ho(this.context,n).toTicks(),interval:new ho(this.context,e).toTicks(),time:new mo(this.context,s).toTicks()});return this._addEvent(i,this._repeatedEvents)}scheduleOnce(t,e){const s=new Zo(this,{callback:t,once:!0,time:new mo(this.context,e).toTicks()});return this._addEvent(s,this._timeline)}clear(t){if(this._scheduledEvents.hasOwnProperty(t)){const e=this._scheduledEvents[t.toString()];e.timeline.remove(e.event),e.event.dispose(),delete this._scheduledEvents[t.toString()]}return this}_addEvent(t,e){return this._scheduledEvents[t.id.toString()]={event:t,timeline:e},e.add(t),t.id}cancel(t=0){const e=this.toTicks(t);return this._timeline.forEachFrom(e,t=>this.clear(t.id)),this._repeatedEvents.forEachFrom(e,t=>this.clear(t.id)),this}_bindClockEvents(){this._clock.on("start",(t,e)=>{e=new jo(this.context,e).toSeconds(),this.emit("start",t,e)}),this._clock.on("stop",t=>{this.emit("stop",t)}),this._clock.on("pause",t=>{this.emit("pause",t)})}get state(){return this._clock.getStateAtTime(this.now())}start(t,e){let s;return ci(e)&&(s=this.toTicks(e)),this._clock.start(t,s),this}stop(t){return this._clock.stop(t),this}pause(t){return this._clock.pause(t),this}toggle(t){return t=this.toSeconds(t),"started"!==this._clock.getStateAtTime(t)?this.start(t):this.stop(t),this}get timeSignature(){return this._timeSignature}set timeSignature(t){di(t)&&(t=t[0]/t[1]*4),this._timeSignature=t}get loopStart(){return new ho(this.context,this._loopStart,"i").toSeconds()}set loopStart(t){this._loopStart=this.toTicks(t)}get loopEnd(){return new ho(this.context,this._loopEnd,"i").toSeconds()}set loopEnd(t){this._loopEnd=this.toTicks(t)}get loop(){return this._loop.get(this.now())}set loop(t){this._loop.set(t,this.now())}setLoopPoints(t,e){return this.loopStart=t,this.loopEnd=e,this}get swing(){return this._swingAmount}set swing(t){this._swingAmount=t}get swingSubdivision(){return new jo(this.context,this._swingTicks).toNotation()}set swingSubdivision(t){this._swingTicks=this.toTicks(t)}get position(){const t=this.now(),e=this._clock.getTicksAtTime(t);return new jo(this.context,e).toBarsBeatsSixteenths()}set position(t){const e=this.toTicks(t);this.ticks=e}get seconds(){return this._clock.seconds}set seconds(t){const e=this.now(),s=this._clock.frequency.timeToTicks(t,e);this.ticks=s}get progress(){if(this.loop){const t=this.now();return(this._clock.getTicksAtTime(t)-this._loopStart)/(this._loopEnd-this._loopStart)}return 0}get ticks(){return this._clock.ticks}set ticks(t){if(this._clock.ticks!==t){const e=this.now();if("started"===this.state){const s=this._clock.getTicksAtTime(e),n=e+this._clock.frequency.getDurationOfTicks(Math.ceil(s)-s,e);this.emit("stop",n),this._clock.setTicksAtTime(t,n),this.emit("start",n,this._clock.getSecondsAtTime(n))}else this._clock.setTicksAtTime(t,e)}}getTicksAtTime(t){return Math.round(this._clock.getTicksAtTime(t))}getSecondsAtTime(t){return this._clock.getSecondsAtTime(t)}get PPQ(){return this._clock.frequency.multiplier}set PPQ(t){this._clock.frequency.multiplier=t}nextSubdivision(t){if(t=this.toTicks(t),"started"!==this.state)return 0;{const e=this.now(),s=t-this.getTicksAtTime(e)%t;return this._clock.nextTickTime(s,e)}}syncSignal(t,e){if(!e){const s=this.now();if(0!==t.getValueAtTime(s)){const n=1/(60/this.bpm.getValueAtTime(s)/this.PPQ);e=t.getValueAtTime(s)/n}else e=0}const s=new ko(e);return this.bpm.connect(s),s.connect(t._param),this._syncedSignals.push({initial:t.value,ratio:s,signal:t}),t.value=0,this}unsyncSignal(t){for(let e=this._syncedSignals.length-1;e>=0;e--){const s=this._syncedSignals[e];s.signal===t&&(s.ratio.dispose(),s.signal.value=s.initial,this._syncedSignals.splice(e,1))}return this}dispose(){return super.dispose(),this._clock.dispose(),Qi(this,"bpm"),this._timeline.dispose(),this._repeatedEvents.dispose(),this}}Bi.mixin(Yo),ji(t=>{t.transport=new Yo({context:t})}),zi(t=>{t.transport.dispose()});class Ho extends wo{constructor(t){super(t),this.input=void 0,this._state=new yo("stopped"),this._synced=!1,this._scheduled=[],this._syncedStart=Zi,this._syncedStop=Zi,this._state.memory=100,this._state.increasing=!0,this._volume=this.output=new Go({context:this.context,mute:t.mute,volume:t.volume}),this.volume=this._volume.volume,Ui(this,"volume"),this.onstop=t.onstop}static getDefaults(){return Object.assign(wo.getDefaults(),{mute:!1,onstop:Zi,volume:0})}get state(){return this._synced?"started"===this.context.transport.state?this._state.getValueAtTime(this.context.transport.seconds):"stopped":this._state.getValueAtTime(this.now())}get mute(){return this._volume.mute}set mute(t){this._volume.mute=t}_clampToCurrentTime(t){return this._synced?t:Math.max(t,this.context.currentTime)}start(t,e,s){let n=ai(t)&&this._synced?this.context.transport.seconds:this.toSeconds(t);if(n=this._clampToCurrentTime(n),this._synced||"started"!==this._state.getValueAtTime(n))if(this.log("start",n),this._state.setStateAtTime("started",n),this._synced){const t=this._state.get(n);t&&(t.offset=this.toSeconds(Oi(e,0)),t.duration=s?this.toSeconds(s):void 0);const i=this.context.transport.schedule(t=>{this._start(t,e,s)},n);this._scheduled.push(i),"started"===this.context.transport.state&&this.context.transport.getSecondsAtTime(this.immediate())>n&&this._syncedStart(this.now(),this.context.transport.seconds)}else si(this.context),this._start(n,e,s);else ti(Ri(n,this._state.get(n).time),"Start time must be strictly greater than previous start time"),this._state.cancel(n),this._state.setStateAtTime("started",n),this.log("restart",n),this.restart(n,e,s);return this}stop(t){let e=ai(t)&&this._synced?this.context.transport.seconds:this.toSeconds(t);if(e=this._clampToCurrentTime(e),"started"===this._state.getValueAtTime(e)||ci(this._state.getNextState("started",e))){if(this.log("stop",e),this._synced){const t=this.context.transport.schedule(this._stop.bind(this),e);this._scheduled.push(t)}else this._stop(e);this._state.cancel(e),this._state.setStateAtTime("stopped",e)}return this}restart(t,e,s){return t=this.toSeconds(t),"started"===this._state.getValueAtTime(t)&&(this._state.cancel(t),this._restart(t,e,s)),this}sync(){return this._synced||(this._synced=!0,this._syncedStart=(t,e)=>{if(e>0){const s=this._state.get(e);if(s&&"started"===s.state&&s.time!==e){const n=e-this.toSeconds(s.time);let i;s.duration&&(i=this.toSeconds(s.duration)-n),this._start(t,this.toSeconds(s.offset)+n,i)}}},this._syncedStop=t=>{const e=this.context.transport.getSecondsAtTime(Math.max(t-this.sampleTime,0));"started"===this._state.getValueAtTime(e)&&this._stop(t)},this.context.transport.on("start",this._syncedStart),this.context.transport.on("loopStart",this._syncedStart),this.context.transport.on("stop",this._syncedStop),this.context.transport.on("pause",this._syncedStop),this.context.transport.on("loopEnd",this._syncedStop)),this}unsync(){return this._synced&&(this.context.transport.off("stop",this._syncedStop),this.context.transport.off("pause",this._syncedStop),this.context.transport.off("loopEnd",this._syncedStop),this.context.transport.off("start",this._syncedStart),this.context.transport.off("loopStart",this._syncedStart)),this._synced=!1,this._scheduled.forEach(t=>this.context.transport.clear(t)),this._scheduled=[],this._state.cancel(0),this._stop(0),this}dispose(){return super.dispose(),this.onstop=Zi,this.unsync(),this._volume.dispose(),this._state.dispose(),this}}class $o extends Co{constructor(){super(Di($o.getDefaults(),arguments,["url","onload"])),this.name="ToneBufferSource",this._source=this.context.createBufferSource(),this._internalChannels=[this._source],this._sourceStarted=!1,this._sourceStopped=!1;const t=Di($o.getDefaults(),arguments,["url","onload"]);To(this._source,this._gainNode),this._source.onended=()=>this._stopSource(),this.playbackRate=new xo({context:this.context,param:this._source.playbackRate,units:"positive",value:t.playbackRate}),this.loop=t.loop,this.loopStart=t.loopStart,this.loopEnd=t.loopEnd,this._buffer=new Xi(t.url,t.onload,t.onerror),this._internalChannels.push(this._source)}static getDefaults(){return Object.assign(Co.getDefaults(),{url:new Xi,loop:!1,loopEnd:0,loopStart:0,onload:Zi,onerror:Zi,playbackRate:1})}get fadeIn(){return this._fadeIn}set fadeIn(t){this._fadeIn=t}get fadeOut(){return this._fadeOut}set fadeOut(t){this._fadeOut=t}get curve(){return this._curve}set curve(t){this._curve=t}start(t,e,s,n=1){ti(this.buffer.loaded,"buffer is either not set or not loaded");const i=this.toSeconds(t);this._startGain(i,n),e=this.loop?Oi(e,this.loopStart):Oi(e,0);let o=Math.max(this.toSeconds(e),0);if(this.loop){const t=this.toSeconds(this.loopEnd)||this.buffer.duration,e=this.toSeconds(this.loopStart),s=t-e;qi(o,t)&&(o=(o-e)%s+e),Ii(o,this.buffer.duration)&&(o=0)}if(this._source.buffer=this.buffer.get(),this._source.loopEnd=this.toSeconds(this.loopEnd)||this.buffer.duration,Fi(o,this.buffer.duration)&&(this._sourceStarted=!0,this._source.start(i,o)),ci(s)){let t=this.toSeconds(s);t=Math.max(t,0),this.stop(i+t)}return this}_stopSource(t){!this._sourceStopped&&this._sourceStarted&&(this._sourceStopped=!0,this._source.stop(this.toSeconds(t)),this._onended())}get loopStart(){return this._source.loopStart}set loopStart(t){this._source.loopStart=this.toSeconds(t)}get loopEnd(){return this._source.loopEnd}set loopEnd(t){this._source.loopEnd=this.toSeconds(t)}get buffer(){return this._buffer}set buffer(t){this._buffer.set(t)}get loop(){return this._source.loop}set loop(t){this._source.loop=t,this._sourceStarted&&this.cancelStop()}dispose(){return super.dispose(),this._source.onended=null,this._source.disconnect(),this._buffer.dispose(),this.playbackRate.dispose(),this}}class Jo extends Ho{constructor(){super(Di(Jo.getDefaults(),arguments,["type"])),this.name="Noise",this._source=null;const t=Di(Jo.getDefaults(),arguments,["type"]);this._playbackRate=t.playbackRate,this.type=t.type,this._fadeIn=t.fadeIn,this._fadeOut=t.fadeOut}static getDefaults(){return Object.assign(Ho.getDefaults(),{fadeIn:0,fadeOut:0,playbackRate:1,type:"white"})}get type(){return this._type}set type(t){if(ti(t in tr,"Noise: invalid type: "+t),this._type!==t&&(this._type=t,"started"===this.state)){const t=this.now();this._stop(t),this._start(t)}}get playbackRate(){return this._playbackRate}set playbackRate(t){this._playbackRate=t,this._source&&(this._source.playbackRate.value=t)}_start(t){const e=tr[this._type];this._source=new $o({url:e,context:this.context,fadeIn:this._fadeIn,fadeOut:this._fadeOut,loop:!0,onended:()=>this.onstop(this),playbackRate:this._playbackRate}).connect(this.output),this._source.start(this.toSeconds(t),Math.random()*(e.duration-.001))}_stop(t){this._source&&(this._source.stop(this.toSeconds(t)),this._source=null)}get fadeIn(){return this._fadeIn}set fadeIn(t){this._fadeIn=t,this._source&&(this._source.fadeIn=this._fadeIn)}get fadeOut(){return this._fadeOut}set fadeOut(t){this._fadeOut=t,this._source&&(this._source.fadeOut=this._fadeOut)}_restart(t){this._stop(t),this._start(t)}dispose(){return super.dispose(),this._source&&this._source.disconnect(),this}}const Ko={brown:null,pink:null,white:null},tr={get brown(){if(!Ko.brown){const t=[];for(let e=0;e<2;e++){const s=new Float32Array(220500);t[e]=s;let n=0;for(let t=0;t<220500;t++){const e=2*Math.random()-1;s[t]=(n+.02*e)/1.02,n=s[t],s[t]*=3.5}}Ko.brown=(new Xi).fromArray(t)}return Ko.brown},get pink(){if(!Ko.pink){const t=[];for(let e=0;e<2;e++){const s=new Float32Array(220500);let n,i,o,r,a,c,h;t[e]=s,n=i=o=r=a=c=h=0;for(let t=0;t<220500;t++){const e=2*Math.random()-1;n=.99886*n+.0555179*e,i=.99332*i+.0750759*e,o=.969*o+.153852*e,r=.8665*r+.3104856*e,a=.55*a+.5329522*e,c=-.7616*c-.016898*e,s[t]=n+i+o+r+a+c+h+.5362*e,s[t]*=.11,h=.115926*e}}Ko.pink=(new Xi).fromArray(t)}return Ko.pink},get white(){if(!Ko.white){const t=[];for(let e=0;e<2;e++){const s=new Float32Array(220500);t[e]=s;for(let t=0;t<220500;t++)s[t]=2*Math.random()-1}Ko.white=(new Xi).fromArray(t)}return Ko.white}};class er extends wo{constructor(){super(Di(er.getDefaults(),arguments,["volume"])),this.name="UserMedia";const t=Di(er.getDefaults(),arguments,["volume"]);this._volume=this.output=new Go({context:this.context,volume:t.volume}),this.volume=this._volume.volume,Ui(this,"volume"),this.mute=t.mute}static getDefaults(){return Object.assign(wo.getDefaults(),{mute:!1,volume:0})}open(t){return yi(this,void 0,void 0,(function*(){ti(er.supported,"UserMedia is not supported"),"started"===this.state&&this.close();const e=yield er.enumerateDevices();ui(t)?this._device=e[t]:(this._device=e.find(e=>e.label===t||e.deviceId===t),!this._device&&e.length>0&&(this._device=e[0]),ti(ci(this._device),"No matching device "+t));const s={audio:{echoCancellation:!1,sampleRate:this.context.sampleRate,noiseSuppression:!1,mozNoiseSuppression:!1}};this._device&&(s.audio.deviceId=this._device.deviceId);const n=yield navigator.mediaDevices.getUserMedia(s);if(!this._stream){this._stream=n;const t=this.context.createMediaStreamSource(n);To(t,this.output),this._mediaStream=t}return this}))}close(){return this._stream&&this._mediaStream&&(this._stream.getAudioTracks().forEach(t=>{t.stop()}),this._stream=void 0,this._mediaStream.disconnect(),this._mediaStream=void 0),this._device=void 0,this}static enumerateDevices(){return yi(this,void 0,void 0,(function*(){return(yield navigator.mediaDevices.enumerateDevices()).filter(t=>"audioinput"===t.kind)}))}get state(){return this._stream&&this._stream.active?"started":"stopped"}get deviceId(){return this._device?this._device.deviceId:void 0}get groupId(){return this._device?this._device.groupId:void 0}get label(){return this._device?this._device.label:void 0}get mute(){return this._volume.mute}set mute(t){this._volume.mute=t}dispose(){return super.dispose(),this.close(),this._volume.dispose(),this.volume.dispose(),this}static get supported(){return ci(navigator.mediaDevices)&&ci(navigator.mediaDevices.getUserMedia)}}function sr(t,e){return yi(this,void 0,void 0,(function*(){const s=e/t.context.sampleRate,n=new Yi(1,s,t.context.sampleRate);new t.constructor(Object.assign(t.get(),{frequency:2/s,detune:0,context:n})).toDestination().start(0);return(yield n.render()).getChannelData(0)}))}class nr extends Co{constructor(){super(Di(nr.getDefaults(),arguments,["frequency","type"])),this.name="ToneOscillatorNode",this._oscillator=this.context.createOscillator(),this._internalChannels=[this._oscillator];const t=Di(nr.getDefaults(),arguments,["frequency","type"]);To(this._oscillator,this._gainNode),this.type=t.type,this.frequency=new xo({context:this.context,param:this._oscillator.frequency,units:"frequency",value:t.frequency}),this.detune=new xo({context:this.context,param:this._oscillator.detune,units:"cents",value:t.detune}),Ui(this,["frequency","detune"])}static getDefaults(){return Object.assign(Co.getDefaults(),{detune:0,frequency:440,type:"sine"})}start(t){const e=this.toSeconds(t);return this.log("start",e),this._startGain(e),this._oscillator.start(e),this}_stopSource(t){this._oscillator.stop(t)}setPeriodicWave(t){return this._oscillator.setPeriodicWave(t),this}get type(){return this._oscillator.type}set type(t){this._oscillator.type=t}dispose(){return super.dispose(),"started"===this.state&&this.stop(),this._oscillator.disconnect(),this.frequency.dispose(),this.detune.dispose(),this}}class ir extends Ho{constructor(){super(Di(ir.getDefaults(),arguments,["frequency","type"])),this.name="Oscillator",this._oscillator=null;const t=Di(ir.getDefaults(),arguments,["frequency","type"]);this.frequency=new Do({context:this.context,units:"frequency",value:t.frequency}),Ui(this,"frequency"),this.detune=new Do({context:this.context,units:"cents",value:t.detune}),Ui(this,"detune"),this._partials=t.partials,this._partialCount=t.partialCount,this._type=t.type,t.partialCount&&"custom"!==t.type&&(this._type=this.baseType+t.partialCount.toString()),this.phase=t.phase}static getDefaults(){return Object.assign(Ho.getDefaults(),{detune:0,frequency:440,partialCount:0,partials:[],phase:0,type:"sine"})}_start(t){const e=this.toSeconds(t),s=new nr({context:this.context,onended:()=>this.onstop(this)});this._oscillator=s,this._wave?this._oscillator.setPeriodicWave(this._wave):this._oscillator.type=this._type,this._oscillator.connect(this.output),this.frequency.connect(this._oscillator.frequency),this.detune.connect(this._oscillator.detune),this._oscillator.start(e)}_stop(t){const e=this.toSeconds(t);this._oscillator&&this._oscillator.stop(e)}_restart(t){const e=this.toSeconds(t);return this.log("restart",e),this._oscillator&&this._oscillator.cancelStop(),this._state.cancel(e),this}syncFrequency(){return this.context.transport.syncSignal(this.frequency),this}unsyncFrequency(){return this.context.transport.unsyncSignal(this.frequency),this}_getCachedPeriodicWave(){if("custom"===this._type){return ir._periodicWaveCache.find(t=>{return t.phase===this._phase&&(e=t.partials,s=this._partials,e.length===s.length&&e.every((t,e)=>s[e]===t));var e,s})}{const t=ir._periodicWaveCache.find(t=>t.type===this._type&&t.phase===this._phase);return this._partialCount=t?t.partialCount:this._partialCount,t}}get type(){return this._type}set type(t){this._type=t;const e=-1!==["sine","square","sawtooth","triangle"].indexOf(t);if(0===this._phase&&e)this._wave=void 0,this._partialCount=0,null!==this._oscillator&&(this._oscillator.type=t);else{const e=this._getCachedPeriodicWave();if(ci(e)){const{partials:t,wave:s}=e;this._wave=s,this._partials=t,null!==this._oscillator&&this._oscillator.setPeriodicWave(this._wave)}else{const[e,s]=this._getRealImaginary(t,this._phase),n=this.context.createPeriodicWave(e,s);this._wave=n,null!==this._oscillator&&this._oscillator.setPeriodicWave(this._wave),ir._periodicWaveCache.push({imag:s,partialCount:this._partialCount,partials:this._partials,phase:this._phase,real:e,type:this._type,wave:this._wave}),ir._periodicWaveCache.length>100&&ir._periodicWaveCache.shift()}}}get baseType(){return this._type.replace(this.partialCount.toString(),"")}set baseType(t){this.partialCount&&"custom"!==this._type&&"custom"!==t?this.type=t+this.partialCount:this.type=t}get partialCount(){return this._partialCount}set partialCount(t){ei(t,0);let e=this._type;const s=/^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);if(s&&(e=s[1]),"custom"!==this._type)this.type=0===t?e:e+t.toString();else{const e=new Float32Array(t);this._partials.forEach((t,s)=>e[s]=t),this._partials=Array.from(e),this.type=this._type}}_getRealImaginary(t,e){let s=2048;const n=new Float32Array(s),i=new Float32Array(s);let o=1;if("custom"===t){if(o=this._partials.length+1,this._partialCount=this._partials.length,s=o,0===this._partials.length)return[n,i]}else{const e=/^(sine|triangle|square|sawtooth)(\d+)$/.exec(t);e?(o=parseInt(e[2],10)+1,this._partialCount=parseInt(e[2],10),t=e[1],o=Math.max(o,2),s=o):this._partialCount=0,this._partials=[]}for(let r=1;r<s;++r){const s=2/(r*Math.PI);let a;switch(t){case"sine":a=r<=o?1:0,this._partials[r-1]=a;break;case"square":a=1&r?2*s:0,this._partials[r-1]=a;break;case"sawtooth":a=s*(1&r?1:-1),this._partials[r-1]=a;break;case"triangle":a=1&r?s*s*2*(r-1>>1&1?-1:1):0,this._partials[r-1]=a;break;case"custom":a=this._partials[r-1];break;default:throw new TypeError("Oscillator: invalid type: "+t)}0!==a?(n[r]=-a*Math.sin(e*r),i[r]=a*Math.cos(e*r)):(n[r]=0,i[r]=0)}return[n,i]}_inverseFFT(t,e,s){let n=0;const i=t.length;for(let o=0;o<i;o++)n+=t[o]*Math.cos(o*s)+e[o]*Math.sin(o*s);return n}getInitialValue(){const[t,e]=this._getRealImaginary(this._type,0);let s=0;const n=2*Math.PI;for(let i=0;i<32;i++)s=Math.max(this._inverseFFT(t,e,i/32*n),s);return Vi(-this._inverseFFT(t,e,this._phase)/s,-1,1)}get partials(){return this._partials.slice(0,this.partialCount)}set partials(t){this._partials=t,this._partialCount=this._partials.length,t.length&&(this.type="custom")}get phase(){return this._phase*(180/Math.PI)}set phase(t){this._phase=t*Math.PI/180,this.type=this._type}asArray(t=1024){return yi(this,void 0,void 0,(function*(){return sr(this,t)}))}dispose(){return super.dispose(),null!==this._oscillator&&this._oscillator.dispose(),this._wave=void 0,this.frequency.dispose(),this.detune.dispose(),this}}ir._periodicWaveCache=[];class or extends wo{constructor(){super(Object.assign(Di(or.getDefaults(),arguments,["context"])))}connect(t,e=0,s=0){return Oo(this,t,e,s),this}}class rr extends or{constructor(){super(Object.assign(Di(rr.getDefaults(),arguments,["mapping","length"]))),this.name="WaveShaper",this._shaper=this.context.createWaveShaper(),this.input=this._shaper,this.output=this._shaper;const t=Di(rr.getDefaults(),arguments,["mapping","length"]);di(t.mapping)||t.mapping instanceof Float32Array?this.curve=Float32Array.from(t.mapping):hi(t.mapping)&&this.setMap(t.mapping,t.length)}static getDefaults(){return Object.assign(Do.getDefaults(),{length:1024})}setMap(t,e=1024){const s=new Float32Array(e);for(let n=0,i=e;n<i;n++){const e=n/(i-1)*2-1;s[n]=t(e,n)}return this.curve=s,this}get curve(){return this._shaper.curve}set curve(t){this._shaper.curve=t}get oversample(){return this._shaper.oversample}set oversample(t){ti(["none","2x","4x"].some(e=>e.includes(t)),"oversampling must be either 'none', '2x', or '4x'"),this._shaper.oversample=t}dispose(){return super.dispose(),this._shaper.disconnect(),this}}class ar extends or{constructor(){super(...arguments),this.name="AudioToGain",this._norm=new rr({context:this.context,mapping:t=>(t+1)/2}),this.input=this._norm,this.output=this._norm}dispose(){return super.dispose(),this._norm.dispose(),this}}class cr extends Do{constructor(){super(Object.assign(Di(cr.getDefaults(),arguments,["value"]))),this.name="Multiply",this.override=!1;const t=Di(cr.getDefaults(),arguments,["value"]);this._mult=this.input=this.output=new ko({context:this.context,minValue:t.minValue,maxValue:t.maxValue}),this.factor=this._param=this._mult.gain,this.factor.setValueAtTime(t.value,0)}static getDefaults(){return Object.assign(Do.getDefaults(),{value:0})}dispose(){return super.dispose(),this._mult.dispose(),this}}class hr extends Ho{constructor(){super(Di(hr.getDefaults(),arguments,["frequency","type","modulationType"])),this.name="AMOscillator",this._modulationScale=new ar({context:this.context}),this._modulationNode=new ko({context:this.context});const t=Di(hr.getDefaults(),arguments,["frequency","type","modulationType"]);this._carrier=new ir({context:this.context,detune:t.detune,frequency:t.frequency,onstop:()=>this.onstop(this),phase:t.phase,type:t.type}),this.frequency=this._carrier.frequency,this.detune=this._carrier.detune,this._modulator=new ir({context:this.context,phase:t.phase,type:t.modulationType}),this.harmonicity=new cr({context:this.context,units:"positive",value:t.harmonicity}),this.frequency.chain(this.harmonicity,this._modulator.frequency),this._modulator.chain(this._modulationScale,this._modulationNode.gain),this._carrier.chain(this._modulationNode,this.output),Ui(this,["frequency","detune","harmonicity"])}static getDefaults(){return Object.assign(ir.getDefaults(),{harmonicity:1,modulationType:"square"})}_start(t){this._modulator.start(t),this._carrier.start(t)}_stop(t){this._modulator.stop(t),this._carrier.stop(t)}_restart(t){this._modulator.restart(t),this._carrier.restart(t)}get type(){return this._carrier.type}set type(t){this._carrier.type=t}get baseType(){return this._carrier.baseType}set baseType(t){this._carrier.baseType=t}get partialCount(){return this._carrier.partialCount}set partialCount(t){this._carrier.partialCount=t}get modulationType(){return this._modulator.type}set modulationType(t){this._modulator.type=t}get phase(){return this._carrier.phase}set phase(t){this._carrier.phase=t,this._modulator.phase=t}get partials(){return this._carrier.partials}set partials(t){this._carrier.partials=t}asArray(t=1024){return yi(this,void 0,void 0,(function*(){return sr(this,t)}))}dispose(){return super.dispose(),this.frequency.dispose(),this.detune.dispose(),this.harmonicity.dispose(),this._carrier.dispose(),this._modulator.dispose(),this._modulationNode.dispose(),this._modulationScale.dispose(),this}}class ur extends Ho{constructor(){super(Di(ur.getDefaults(),arguments,["frequency","type","modulationType"])),this.name="FMOscillator",this._modulationNode=new ko({context:this.context,gain:0});const t=Di(ur.getDefaults(),arguments,["frequency","type","modulationType"]);this._carrier=new ir({context:this.context,detune:t.detune,frequency:0,onstop:()=>this.onstop(this),phase:t.phase,type:t.type}),this.detune=this._carrier.detune,this.frequency=new Do({context:this.context,units:"frequency",value:t.frequency}),this._modulator=new ir({context:this.context,phase:t.phase,type:t.modulationType}),this.harmonicity=new cr({context:this.context,units:"positive",value:t.harmonicity}),this.modulationIndex=new cr({context:this.context,units:"positive",value:t.modulationIndex}),this.frequency.connect(this._carrier.frequency),this.frequency.chain(this.harmonicity,this._modulator.frequency),this.frequency.chain(this.modulationIndex,this._modulationNode),this._modulator.connect(this._modulationNode.gain),this._modulationNode.connect(this._carrier.frequency),this._carrier.connect(this.output),this.detune.connect(this._modulator.detune),Ui(this,["modulationIndex","frequency","detune","harmonicity"])}static getDefaults(){return Object.assign(ir.getDefaults(),{harmonicity:1,modulationIndex:2,modulationType:"square"})}_start(t){this._modulator.start(t),this._carrier.start(t)}_stop(t){this._modulator.stop(t),this._carrier.stop(t)}_restart(t){return this._modulator.restart(t),this._carrier.restart(t),this}get type(){return this._carrier.type}set type(t){this._carrier.type=t}get baseType(){return this._carrier.baseType}set baseType(t){this._carrier.baseType=t}get partialCount(){return this._carrier.partialCount}set partialCount(t){this._carrier.partialCount=t}get modulationType(){return this._modulator.type}set modulationType(t){this._modulator.type=t}get phase(){return this._carrier.phase}set phase(t){this._carrier.phase=t,this._modulator.phase=t}get partials(){return this._carrier.partials}set partials(t){this._carrier.partials=t}asArray(t=1024){return yi(this,void 0,void 0,(function*(){return sr(this,t)}))}dispose(){return super.dispose(),this.frequency.dispose(),this.harmonicity.dispose(),this._carrier.dispose(),this._modulator.dispose(),this._modulationNode.dispose(),this.modulationIndex.dispose(),this}}class lr extends Ho{constructor(){super(Di(lr.getDefaults(),arguments,["frequency","width"])),this.name="PulseOscillator",this._widthGate=new ko({context:this.context,gain:0}),this._thresh=new rr({context:this.context,mapping:t=>t<=0?-1:1});const t=Di(lr.getDefaults(),arguments,["frequency","width"]);this.width=new Do({context:this.context,units:"audioRange",value:t.width}),this._triangle=new ir({context:this.context,detune:t.detune,frequency:t.frequency,onstop:()=>this.onstop(this),phase:t.phase,type:"triangle"}),this.frequency=this._triangle.frequency,this.detune=this._triangle.detune,this._triangle.chain(this._thresh,this.output),this.width.chain(this._widthGate,this._thresh),Ui(this,["width","frequency","detune"])}static getDefaults(){return Object.assign(Ho.getDefaults(),{detune:0,frequency:440,phase:0,type:"pulse",width:.2})}_start(t){t=this.toSeconds(t),this._triangle.start(t),this._widthGate.gain.setValueAtTime(1,t)}_stop(t){t=this.toSeconds(t),this._triangle.stop(t),this._widthGate.gain.cancelScheduledValues(t),this._widthGate.gain.setValueAtTime(0,t)}_restart(t){this._triangle.restart(t),this._widthGate.gain.cancelScheduledValues(t),this._widthGate.gain.setValueAtTime(1,t)}get phase(){return this._triangle.phase}set phase(t){this._triangle.phase=t}get type(){return"pulse"}get baseType(){return"pulse"}get partials(){return[]}get partialCount(){return 0}set carrierType(t){this._triangle.type=t}asArray(t=1024){return yi(this,void 0,void 0,(function*(){return sr(this,t)}))}dispose(){return super.dispose(),this._triangle.dispose(),this.width.dispose(),this._widthGate.dispose(),this._thresh.dispose(),this}}class pr extends Ho{constructor(){super(Di(pr.getDefaults(),arguments,["frequency","type","spread"])),this.name="FatOscillator",this._oscillators=[];const t=Di(pr.getDefaults(),arguments,["frequency","type","spread"]);this.frequency=new Do({context:this.context,units:"frequency",value:t.frequency}),this.detune=new Do({context:this.context,units:"cents",value:t.detune}),this._spread=t.spread,this._type=t.type,this._phase=t.phase,this._partials=t.partials,this._partialCount=t.partialCount,this.count=t.count,Ui(this,["frequency","detune"])}static getDefaults(){return Object.assign(ir.getDefaults(),{count:3,spread:20,type:"sawtooth"})}_start(t){t=this.toSeconds(t),this._forEach(e=>e.start(t))}_stop(t){t=this.toSeconds(t),this._forEach(e=>e.stop(t))}_restart(t){this._forEach(e=>e.restart(t))}_forEach(t){for(let e=0;e<this._oscillators.length;e++)t(this._oscillators[e],e)}get type(){return this._type}set type(t){this._type=t,this._forEach(e=>e.type=t)}get spread(){return this._spread}set spread(t){if(this._spread=t,this._oscillators.length>1){const e=-t/2,s=t/(this._oscillators.length-1);this._forEach((t,n)=>t.detune.value=e+s*n)}}get count(){return this._oscillators.length}set count(t){if(ei(t,1),this._oscillators.length!==t){this._forEach(t=>t.dispose()),this._oscillators=[];for(let e=0;e<t;e++){const s=new ir({context:this.context,volume:-6-1.1*t,type:this._type,phase:this._phase+e/t*360,partialCount:this._partialCount,onstop:0===e?()=>this.onstop(this):Zi});"custom"===this.type&&(s.partials=this._partials),this.frequency.connect(s.frequency),this.detune.connect(s.detune),s.detune.overridden=!1,s.connect(this.output),this._oscillators[e]=s}this.spread=this._spread,"started"===this.state&&this._forEach(t=>t.start())}}get phase(){return this._phase}set phase(t){this._phase=t,this._forEach((t,e)=>t.phase=this._phase+e/this.count*360)}get baseType(){return this._oscillators[0].baseType}set baseType(t){this._forEach(e=>e.baseType=t),this._type=this._oscillators[0].type}get partials(){return this._oscillators[0].partials}set partials(t){this._partials=t,this._partialCount=this._partials.length,t.length&&(this._type="custom",this._forEach(e=>e.partials=t))}get partialCount(){return this._oscillators[0].partialCount}set partialCount(t){this._partialCount=t,this._forEach(e=>e.partialCount=t),this._type=this._oscillators[0].type}asArray(t=1024){return yi(this,void 0,void 0,(function*(){return sr(this,t)}))}dispose(){return super.dispose(),this.frequency.dispose(),this.detune.dispose(),this._forEach(t=>t.dispose()),this}}class dr extends Ho{constructor(){super(Di(dr.getDefaults(),arguments,["frequency","modulationFrequency"])),this.name="PWMOscillator",this.sourceType="pwm",this._scale=new cr({context:this.context,value:2});const t=Di(dr.getDefaults(),arguments,["frequency","modulationFrequency"]);this._pulse=new lr({context:this.context,frequency:t.modulationFrequency}),this._pulse.carrierType="sine",this.modulationFrequency=this._pulse.frequency,this._modulator=new ir({context:this.context,detune:t.detune,frequency:t.frequency,onstop:()=>this.onstop(this),phase:t.phase}),this.frequency=this._modulator.frequency,this.detune=this._modulator.detune,this._modulator.chain(this._scale,this._pulse.width),this._pulse.connect(this.output),Ui(this,["modulationFrequency","frequency","detune"])}static getDefaults(){return Object.assign(Ho.getDefaults(),{detune:0,frequency:440,modulationFrequency:.4,phase:0,type:"pwm"})}_start(t){t=this.toSeconds(t),this._modulator.start(t),this._pulse.start(t)}_stop(t){t=this.toSeconds(t),this._modulator.stop(t),this._pulse.stop(t)}_restart(t){this._modulator.restart(t),this._pulse.restart(t)}get type(){return"pwm"}get baseType(){return"pwm"}get partials(){return[]}get partialCount(){return 0}get phase(){return this._modulator.phase}set phase(t){this._modulator.phase=t}asArray(t=1024){return yi(this,void 0,void 0,(function*(){return sr(this,t)}))}dispose(){return super.dispose(),this._pulse.dispose(),this._scale.dispose(),this._modulator.dispose(),this}}const fr={am:hr,fat:pr,fm:ur,oscillator:ir,pulse:lr,pwm:dr};class _r extends Ho{constructor(){super(Di(_r.getDefaults(),arguments,["frequency","type"])),this.name="OmniOscillator";const t=Di(_r.getDefaults(),arguments,["frequency","type"]);this.frequency=new Do({context:this.context,units:"frequency",value:t.frequency}),this.detune=new Do({context:this.context,units:"cents",value:t.detune}),Ui(this,["frequency","detune"]),this.set(t)}static getDefaults(){return Object.assign(ir.getDefaults(),ur.getDefaults(),hr.getDefaults(),pr.getDefaults(),lr.getDefaults(),dr.getDefaults())}_start(t){this._oscillator.start(t)}_stop(t){this._oscillator.stop(t)}_restart(t){return this._oscillator.restart(t),this}get type(){let t="";return["am","fm","fat"].some(t=>this._sourceType===t)&&(t=this._sourceType),t+this._oscillator.type}set type(t){"fm"===t.substr(0,2)?(this._createNewOscillator("fm"),this._oscillator=this._oscillator,this._oscillator.type=t.substr(2)):"am"===t.substr(0,2)?(this._createNewOscillator("am"),this._oscillator=this._oscillator,this._oscillator.type=t.substr(2)):"fat"===t.substr(0,3)?(this._createNewOscillator("fat"),this._oscillator=this._oscillator,this._oscillator.type=t.substr(3)):"pwm"===t?(this._createNewOscillator("pwm"),this._oscillator=this._oscillator):"pulse"===t?this._createNewOscillator("pulse"):(this._createNewOscillator("oscillator"),this._oscillator=this._oscillator,this._oscillator.type=t)}get partials(){return this._oscillator.partials}set partials(t){this._getOscType(this._oscillator,"pulse")||this._getOscType(this._oscillator,"pwm")||(this._oscillator.partials=t)}get partialCount(){return this._oscillator.partialCount}set partialCount(t){this._getOscType(this._oscillator,"pulse")||this._getOscType(this._oscillator,"pwm")||(this._oscillator.partialCount=t)}set(t){return Reflect.has(t,"type")&&t.type&&(this.type=t.type),super.set(t),this}_createNewOscillator(t){if(t!==this._sourceType){this._sourceType=t;const e=fr[t],s=this.now();if(this._oscillator){const t=this._oscillator;t.stop(s),this.context.setTimeout(()=>t.dispose(),this.blockTime)}this._oscillator=new e({context:this.context}),this.frequency.connect(this._oscillator.frequency),this.detune.connect(this._oscillator.detune),this._oscillator.connect(this.output),this._oscillator.onstop=()=>this.onstop(this),"started"===this.state&&this._oscillator.start(s)}}get phase(){return this._oscillator.phase}set phase(t){this._oscillator.phase=t}get sourceType(){return this._sourceType}set sourceType(t){let e="sine";"pwm"!==this._oscillator.type&&"pulse"!==this._oscillator.type&&(e=this._oscillator.type),"fm"===t?this.type="fm"+e:"am"===t?this.type="am"+e:"fat"===t?this.type="fat"+e:"oscillator"===t?this.type=e:"pulse"===t?this.type="pulse":"pwm"===t&&(this.type="pwm")}_getOscType(t,e){return t instanceof fr[e]}get baseType(){return this._oscillator.baseType}set baseType(t){this._getOscType(this._oscillator,"pulse")||this._getOscType(this._oscillator,"pwm")||"pulse"===t||"pwm"===t||(this._oscillator.baseType=t)}get width(){return this._getOscType(this._oscillator,"pulse")?this._oscillator.width:void 0}get count(){return this._getOscType(this._oscillator,"fat")?this._oscillator.count:void 0}set count(t){this._getOscType(this._oscillator,"fat")&&ui(t)&&(this._oscillator.count=t)}get spread(){return this._getOscType(this._oscillator,"fat")?this._oscillator.spread:void 0}set spread(t){this._getOscType(this._oscillator,"fat")&&ui(t)&&(this._oscillator.spread=t)}get modulationType(){return this._getOscType(this._oscillator,"fm")||this._getOscType(this._oscillator,"am")?this._oscillator.modulationType:void 0}set modulationType(t){(this._getOscType(this._oscillator,"fm")||this._getOscType(this._oscillator,"am"))&&fi(t)&&(this._oscillator.modulationType=t)}get modulationIndex(){return this._getOscType(this._oscillator,"fm")?this._oscillator.modulationIndex:void 0}get harmonicity(){return this._getOscType(this._oscillator,"fm")||this._getOscType(this._oscillator,"am")?this._oscillator.harmonicity:void 0}get modulationFrequency(){return this._getOscType(this._oscillator,"pwm")?this._oscillator.modulationFrequency:void 0}asArray(t=1024){return yi(this,void 0,void 0,(function*(){return sr(this,t)}))}dispose(){return super.dispose(),this.detune.dispose(),this.frequency.dispose(),this._oscillator.dispose(),this}}class mr extends Do{constructor(){super(Object.assign(Di(mr.getDefaults(),arguments,["value"]))),this.override=!1,this.name="Add",this._sum=new ko({context:this.context}),this.input=this._sum,this.output=this._sum,this.addend=this._param,bo(this._constantSource,this._sum)}static getDefaults(){return Object.assign(Do.getDefaults(),{value:0})}dispose(){return super.dispose(),this._sum.dispose(),this}}class gr extends or{constructor(){super(Object.assign(Di(gr.getDefaults(),arguments,["min","max"]))),this.name="Scale";const t=Di(gr.getDefaults(),arguments,["min","max"]);this._mult=this.input=new cr({context:this.context,value:t.max-t.min}),this._add=this.output=new mr({context:this.context,value:t.min}),this._min=t.min,this._max=t.max,this.input.connect(this.output)}static getDefaults(){return Object.assign(or.getDefaults(),{max:1,min:0})}get min(){return this._min}set min(t){this._min=t,this._setRange()}get max(){return this._max}set max(t){this._max=t,this._setRange()}_setRange(){this._add.value=this._min,this._mult.value=this._max-this._min}dispose(){return super.dispose(),this._add.dispose(),this._mult.dispose(),this}}class vr extends or{constructor(){super(Object.assign(Di(vr.getDefaults(),arguments))),this.name="Zero",this._gain=new ko({context:this.context}),this.output=this._gain,this.input=void 0,To(this.context.getConstant(0),this._gain)}dispose(){return super.dispose(),So(this.context.getConstant(0),this._gain),this}}class yr extends wo{constructor(){super(Di(yr.getDefaults(),arguments,["frequency","min","max"])),this.name="LFO",this._stoppedValue=0,this._units="number",this.convert=!0,this._fromType=xo.prototype._fromType,this._toType=xo.prototype._toType,this._is=xo.prototype._is,this._clampValue=xo.prototype._clampValue;const t=Di(yr.getDefaults(),arguments,["frequency","min","max"]);this._oscillator=new ir(t),this.frequency=this._oscillator.frequency,this._amplitudeGain=new ko({context:this.context,gain:t.amplitude,units:"normalRange"}),this.amplitude=this._amplitudeGain.gain,this._stoppedSignal=new Do({context:this.context,units:"audioRange",value:0}),this._zeros=new vr({context:this.context}),this._a2g=new ar({context:this.context}),this._scaler=this.output=new gr({context:this.context,max:t.max,min:t.min}),this.units=t.units,this.min=t.min,this.max=t.max,this._oscillator.chain(this._amplitudeGain,this._a2g,this._scaler),this._zeros.connect(this._a2g),this._stoppedSignal.connect(this._a2g),Ui(this,["amplitude","frequency"]),this.phase=t.phase}static getDefaults(){return Object.assign(ir.getDefaults(),{amplitude:1,frequency:"4n",max:1,min:0,type:"sine",units:"number"})}start(t){return t=this.toSeconds(t),this._stoppedSignal.setValueAtTime(0,t),this._oscillator.start(t),this}stop(t){return t=this.toSeconds(t),this._stoppedSignal.setValueAtTime(this._stoppedValue,t),this._oscillator.stop(t),this}sync(){return this._oscillator.sync(),this._oscillator.syncFrequency(),this}unsync(){return this._oscillator.unsync(),this._oscillator.unsyncFrequency(),this}_setStoppedValue(){this._stoppedValue=this._oscillator.getInitialValue(),this._stoppedSignal.value=this._stoppedValue}get min(){return this._toType(this._scaler.min)}set min(t){t=this._fromType(t),this._scaler.min=t}get max(){return this._toType(this._scaler.max)}set max(t){t=this._fromType(t),this._scaler.max=t}get type(){return this._oscillator.type}set type(t){this._oscillator.type=t,this._setStoppedValue()}get partials(){return this._oscillator.partials}set partials(t){this._oscillator.partials=t,this._setStoppedValue()}get phase(){return this._oscillator.phase}set phase(t){this._oscillator.phase=t,this._setStoppedValue()}get units(){return this._units}set units(t){const e=this.min,s=this.max;this._units=t,this.min=e,this.max=s}get state(){return this._oscillator.state}connect(t,e,s){return(t instanceof xo||t instanceof Do)&&(this.convert=t.convert,this.units=t.units),Oo(this,t,e,s),this}dispose(){return super.dispose(),this._oscillator.dispose(),this._stoppedSignal.dispose(),this._zeros.dispose(),this._scaler.dispose(),this._a2g.dispose(),this._amplitudeGain.dispose(),this.amplitude.dispose(),this}}function xr(t,e=1/0){const s=new WeakMap;return function(n,i){Reflect.defineProperty(n,i,{configurable:!0,enumerable:!0,get:function(){return s.get(this)},set:function(n){ei(n,t,e),s.set(this,n)}})}}function wr(t,e=1/0){const s=new WeakMap;return function(n,i){Reflect.defineProperty(n,i,{configurable:!0,enumerable:!0,get:function(){return s.get(this)},set:function(n){ei(this.toSeconds(n),t,e),s.set(this,n)}})}}class br extends Ho{constructor(){super(Di(br.getDefaults(),arguments,["url","onload"])),this.name="Player",this._activeSources=new Set;const t=Di(br.getDefaults(),arguments,["url","onload"]);this._buffer=new Xi({onload:this._onload.bind(this,t.onload),onerror:t.onerror,reverse:t.reverse,url:t.url}),this.autostart=t.autostart,this._loop=t.loop,this._loopStart=t.loopStart,this._loopEnd=t.loopEnd,this._playbackRate=t.playbackRate,this.fadeIn=t.fadeIn,this.fadeOut=t.fadeOut}static getDefaults(){return Object.assign(Ho.getDefaults(),{autostart:!1,fadeIn:0,fadeOut:0,loop:!1,loopEnd:0,loopStart:0,onload:Zi,onerror:Zi,playbackRate:1,reverse:!1})}load(t){return yi(this,void 0,void 0,(function*(){return yield this._buffer.load(t),this._onload(),this}))}_onload(t=Zi){t(),this.autostart&&this.start()}_onSourceEnd(t){this.onstop(this),this._activeSources.delete(t),0!==this._activeSources.size||this._synced||"started"!==this._state.getValueAtTime(this.now())||(this._state.cancel(this.now()),this._state.setStateAtTime("stopped",this.now()))}start(t,e,s){return super.start(t,e,s),this}_start(t,e,s){e=this._loop?Oi(e,this._loopStart):Oi(e,0);const n=this.toSeconds(e),i=s;s=Oi(s,Math.max(this._buffer.duration-n,0));let o=this.toSeconds(s);o/=this._playbackRate,t=this.toSeconds(t);const r=new $o({url:this._buffer,context:this.context,fadeIn:this.fadeIn,fadeOut:this.fadeOut,loop:this._loop,loopEnd:this._loopEnd,loopStart:this._loopStart,onended:this._onSourceEnd.bind(this),playbackRate:this._playbackRate}).connect(this.output);this._loop||this._synced||(this._state.cancel(t+o),this._state.setStateAtTime("stopped",t+o,{implicitEnd:!0})),this._activeSources.add(r),this._loop&&ai(i)?r.start(t,n):r.start(t,n,o-this.toSeconds(this.fadeOut))}_stop(t){const e=this.toSeconds(t);this._activeSources.forEach(t=>t.stop(e))}restart(t,e,s){return super.restart(t,e,s),this}_restart(t,e,s){this._stop(t),this._start(t,e,s)}seek(t,e){const s=this.toSeconds(e);if("started"===this._state.getValueAtTime(s)){const e=this.toSeconds(t);this._stop(s),this._start(s,e)}return this}setLoopPoints(t,e){return this.loopStart=t,this.loopEnd=e,this}get loopStart(){return this._loopStart}set loopStart(t){this._loopStart=t,this.buffer.loaded&&ei(this.toSeconds(t),0,this.buffer.duration),this._activeSources.forEach(e=>{e.loopStart=t})}get loopEnd(){return this._loopEnd}set loopEnd(t){this._loopEnd=t,this.buffer.loaded&&ei(this.toSeconds(t),0,this.buffer.duration),this._activeSources.forEach(e=>{e.loopEnd=t})}get buffer(){return this._buffer}set buffer(t){this._buffer.set(t)}get loop(){return this._loop}set loop(t){if(this._loop!==t&&(this._loop=t,this._activeSources.forEach(e=>{e.loop=t}),t)){const t=this._state.getNextState("stopped",this.now());t&&this._state.cancel(t.time)}}get playbackRate(){return this._playbackRate}set playbackRate(t){this._playbackRate=t;const e=this.now(),s=this._state.getNextState("stopped",e);s&&s.implicitEnd&&(this._state.cancel(s.time),this._activeSources.forEach(t=>t.cancelStop())),this._activeSources.forEach(s=>{s.playbackRate.setValueAtTime(t,e)})}get reverse(){return this._buffer.reverse}set reverse(t){this._buffer.reverse=t}get loaded(){return this._buffer.loaded}dispose(){return super.dispose(),this._activeSources.forEach(t=>t.dispose()),this._activeSources.clear(),this._buffer.dispose(),this}}vi([wr(0)],br.prototype,"fadeIn",void 0),vi([wr(0)],br.prototype,"fadeOut",void 0);class Tr extends wo{constructor(){super(Di(Tr.getDefaults(),arguments,["urls","onload"],"urls")),this.name="Players",this.input=void 0,this._players=new Map;const t=Di(Tr.getDefaults(),arguments,["urls","onload"],"urls");this._volume=this.output=new Go({context:this.context,volume:t.volume}),this.volume=this._volume.volume,Ui(this,"volume"),this._buffers=new Vo({urls:t.urls,onload:t.onload,baseUrl:t.baseUrl,onerror:t.onerror}),this.mute=t.mute,this._fadeIn=t.fadeIn,this._fadeOut=t.fadeOut}static getDefaults(){return Object.assign(Ho.getDefaults(),{baseUrl:"",fadeIn:0,fadeOut:0,mute:!1,onload:Zi,onerror:Zi,urls:{},volume:0})}get mute(){return this._volume.mute}set mute(t){this._volume.mute=t}get fadeIn(){return this._fadeIn}set fadeIn(t){this._fadeIn=t,this._players.forEach(e=>{e.fadeIn=t})}get fadeOut(){return this._fadeOut}set fadeOut(t){this._fadeOut=t,this._players.forEach(e=>{e.fadeOut=t})}get state(){return Array.from(this._players).some(([t,e])=>"started"===e.state)?"started":"stopped"}has(t){return this._buffers.has(t)}player(t){if(ti(this.has(t),`No Player with the name ${t} exists on this object`),!this._players.has(t)){const e=new br({context:this.context,fadeIn:this._fadeIn,fadeOut:this._fadeOut,url:this._buffers.get(t)}).connect(this.output);this._players.set(t,e)}return this._players.get(t)}get loaded(){return this._buffers.loaded}add(t,e,s){return ti(!this._buffers.has(t),"A buffer with that name already exists on this object"),this._buffers.add(t,e,s),this}stopAll(t){return this._players.forEach(e=>e.stop(t)),this}dispose(){return super.dispose(),this._volume.dispose(),this.volume.dispose(),this._players.forEach(t=>t.dispose()),this._buffers.dispose(),this}}class Sr extends Ho{constructor(){super(Di(Sr.getDefaults(),arguments,["url","onload"])),this.name="GrainPlayer",this._loopStart=0,this._loopEnd=0,this._activeSources=[];const t=Di(Sr.getDefaults(),arguments,["url","onload"]);this.buffer=new Xi({onload:t.onload,onerror:t.onerror,reverse:t.reverse,url:t.url}),this._clock=new qo({context:this.context,callback:this._tick.bind(this),frequency:1/t.grainSize}),this._playbackRate=t.playbackRate,this._grainSize=t.grainSize,this._overlap=t.overlap,this.detune=t.detune,this.overlap=t.overlap,this.loop=t.loop,this.playbackRate=t.playbackRate,this.grainSize=t.grainSize,this.loopStart=t.loopStart,this.loopEnd=t.loopEnd,this.reverse=t.reverse,this._clock.on("stop",this._onstop.bind(this))}static getDefaults(){return Object.assign(Ho.getDefaults(),{onload:Zi,onerror:Zi,overlap:.1,grainSize:.2,playbackRate:1,detune:0,loop:!1,loopStart:0,loopEnd:0,reverse:!1})}_start(t,e,s){e=Oi(e,0),e=this.toSeconds(e),t=this.toSeconds(t);const n=1/this._clock.frequency.getValueAtTime(t);this._clock.start(t,e/n),s&&this.stop(t+this.toSeconds(s))}restart(t,e,s){return super.restart(t,e,s),this}_restart(t,e,s){this._stop(t),this._start(t,e,s)}_stop(t){this._clock.stop(t)}_onstop(t){this._activeSources.forEach(e=>{e.fadeOut=0,e.stop(t)}),this.onstop(this)}_tick(t){const e=this._clock.getTicksAtTime(t),s=e*this._grainSize;if(this.log("offset",s),!this.loop&&s>this.buffer.duration)return void this.stop(t);const n=s<this._overlap?0:this._overlap,i=new $o({context:this.context,url:this.buffer,fadeIn:n,fadeOut:this._overlap,loop:this.loop,loopStart:this._loopStart,loopEnd:this._loopEnd,playbackRate:no(this.detune/100)}).connect(this.output);i.start(t,this._grainSize*e),i.stop(t+this._grainSize/this.playbackRate),this._activeSources.push(i),i.onended=()=>{const t=this._activeSources.indexOf(i);-1!==t&&this._activeSources.splice(t,1)}}get playbackRate(){return this._playbackRate}set playbackRate(t){ei(t,.001),this._playbackRate=t,this.grainSize=this._grainSize}get loopStart(){return this._loopStart}set loopStart(t){this.buffer.loaded&&ei(this.toSeconds(t),0,this.buffer.duration),this._loopStart=this.toSeconds(t)}get loopEnd(){return this._loopEnd}set loopEnd(t){this.buffer.loaded&&ei(this.toSeconds(t),0,this.buffer.duration),this._loopEnd=this.toSeconds(t)}get reverse(){return this.buffer.reverse}set reverse(t){this.buffer.reverse=t}get grainSize(){return this._grainSize}set grainSize(t){this._grainSize=this.toSeconds(t),this._clock.frequency.setValueAtTime(this._playbackRate/this._grainSize,this.now())}get overlap(){return this._overlap}set overlap(t){const e=this.toSeconds(t);ei(e,0),this._overlap=e}get loaded(){return this.buffer.loaded}dispose(){return super.dispose(),this.buffer.dispose(),this._clock.dispose(),this._activeSources.forEach(t=>t.dispose()),this}}class kr extends or{constructor(){super(...arguments),this.name="Abs",this._abs=new rr({context:this.context,mapping:t=>Math.abs(t)<.001?0:Math.abs(t)}),this.input=this._abs,this.output=this._abs}dispose(){return super.dispose(),this._abs.dispose(),this}}class Cr extends or{constructor(){super(...arguments),this.name="GainToAudio",this._norm=new rr({context:this.context,mapping:t=>2*Math.abs(t)-1}),this.input=this._norm,this.output=this._norm}dispose(){return super.dispose(),this._norm.dispose(),this}}class Ar extends or{constructor(){super(...arguments),this.name="Negate",this._multiply=new cr({context:this.context,value:-1}),this.input=this._multiply,this.output=this._multiply}dispose(){return super.dispose(),this._multiply.dispose(),this}}class Dr extends Do{constructor(){super(Object.assign(Di(Dr.getDefaults(),arguments,["value"]))),this.override=!1,this.name="Subtract",this._sum=new ko({context:this.context}),this.input=this._sum,this.output=this._sum,this._neg=new Ar({context:this.context}),this.subtrahend=this._param,bo(this._constantSource,this._neg,this._sum)}static getDefaults(){return Object.assign(Do.getDefaults(),{value:0})}dispose(){return super.dispose(),this._neg.dispose(),this._sum.dispose(),this}}class Or extends or{constructor(){super(Object.assign(Di(Or.getDefaults(),arguments))),this.name="GreaterThanZero",this._thresh=this.output=new rr({context:this.context,length:127,mapping:t=>t<=0?0:1}),this._scale=this.input=new cr({context:this.context,value:1e4}),this._scale.connect(this._thresh)}dispose(){return super.dispose(),this._scale.dispose(),this._thresh.dispose(),this}}class Mr extends Do{constructor(){super(Object.assign(Di(Mr.getDefaults(),arguments,["value"]))),this.name="GreaterThan",this.override=!1;const t=Di(Mr.getDefaults(),arguments,["value"]);this._subtract=this.input=new Dr({context:this.context,value:t.value}),this._gtz=this.output=new Or({context:this.context}),this.comparator=this._param=this._subtract.subtrahend,Ui(this,"comparator"),this._subtract.connect(this._gtz)}static getDefaults(){return Object.assign(Do.getDefaults(),{value:0})}dispose(){return super.dispose(),this._gtz.dispose(),this._subtract.dispose(),this.comparator.dispose(),this}}class Er extends or{constructor(){super(Object.assign(Di(Er.getDefaults(),arguments,["value"]))),this.name="Pow";const t=Di(Er.getDefaults(),arguments,["value"]);this._exponentScaler=this.input=this.output=new rr({context:this.context,mapping:this._expFunc(t.value),length:8192}),this._exponent=t.value}static getDefaults(){return Object.assign(or.getDefaults(),{value:1})}_expFunc(t){return e=>Math.pow(Math.abs(e),t)}get value(){return this._exponent}set value(t){this._exponent=t,this._exponentScaler.setMap(this._expFunc(this._exponent))}dispose(){return super.dispose(),this._exponentScaler.dispose(),this}}class Rr extends gr{constructor(){super(Object.assign(Di(Rr.getDefaults(),arguments,["min","max","exponent"]))),this.name="ScaleExp";const t=Di(Rr.getDefaults(),arguments,["min","max","exponent"]);this.input=this._exp=new Er({context:this.context,value:t.exponent}),this._exp.connect(this._mult)}static getDefaults(){return Object.assign(gr.getDefaults(),{exponent:1})}get exponent(){return this._exp.value}set exponent(t){this._exp.value=t}dispose(){return super.dispose(),this._exp.dispose(),this}}class qr extends Do{constructor(){super(Di(Do.getDefaults(),arguments,["value","units"])),this.name="SyncedSignal",this.override=!1;const t=Di(Do.getDefaults(),arguments,["value","units"]);this._lastVal=t.value,this._synced=this.context.transport.scheduleRepeat(this._onTick.bind(this),"1i"),this._syncedCallback=this._anchorValue.bind(this),this.context.transport.on("start",this._syncedCallback),this.context.transport.on("pause",this._syncedCallback),this.context.transport.on("stop",this._syncedCallback),this._constantSource.disconnect(),this._constantSource.stop(0),this._constantSource=this.output=new Ao({context:this.context,offset:t.value,units:t.units}).start(0),this.setValueAtTime(t.value,0)}_onTick(t){const e=super.getValueAtTime(this.context.transport.seconds);this._lastVal!==e&&(this._lastVal=e,this._constantSource.offset.setValueAtTime(e,t))}_anchorValue(t){const e=super.getValueAtTime(this.context.transport.seconds);this._lastVal=e,this._constantSource.offset.cancelAndHoldAtTime(t),this._constantSource.offset.setValueAtTime(e,t)}getValueAtTime(t){const e=new mo(this.context,t).toSeconds();return super.getValueAtTime(e)}setValueAtTime(t,e){const s=new mo(this.context,e).toSeconds();return super.setValueAtTime(t,s),this}linearRampToValueAtTime(t,e){const s=new mo(this.context,e).toSeconds();return super.linearRampToValueAtTime(t,s),this}exponentialRampToValueAtTime(t,e){const s=new mo(this.context,e).toSeconds();return super.exponentialRampToValueAtTime(t,s),this}setTargetAtTime(t,e,s){const n=new mo(this.context,e).toSeconds();return super.setTargetAtTime(t,n,s),this}cancelScheduledValues(t){const e=new mo(this.context,t).toSeconds();return super.cancelScheduledValues(e),this}setValueCurveAtTime(t,e,s,n){const i=new mo(this.context,e).toSeconds();return s=this.toSeconds(s),super.setValueCurveAtTime(t,i,s,n),this}cancelAndHoldAtTime(t){const e=new mo(this.context,t).toSeconds();return super.cancelAndHoldAtTime(e),this}setRampPoint(t){const e=new mo(this.context,t).toSeconds();return super.setRampPoint(e),this}exponentialRampTo(t,e,s){const n=new mo(this.context,s).toSeconds();return super.exponentialRampTo(t,e,n),this}linearRampTo(t,e,s){const n=new mo(this.context,s).toSeconds();return super.linearRampTo(t,e,n),this}targetRampTo(t,e,s){const n=new mo(this.context,s).toSeconds();return super.targetRampTo(t,e,n),this}dispose(){return super.dispose(),this.context.transport.clear(this._synced),this.context.transport.off("start",this._syncedCallback),this.context.transport.off("pause",this._syncedCallback),this.context.transport.off("stop",this._syncedCallback),this._constantSource.dispose(),this}}class Fr extends wo{constructor(){super(Di(Fr.getDefaults(),arguments,["attack","decay","sustain","release"])),this.name="Envelope",this._sig=new Do({context:this.context,value:0}),this.output=this._sig,this.input=void 0;const t=Di(Fr.getDefaults(),arguments,["attack","decay","sustain","release"]);this.attack=t.attack,this.decay=t.decay,this.sustain=t.sustain,this.release=t.release,this.attackCurve=t.attackCurve,this.releaseCurve=t.releaseCurve,this.decayCurve=t.decayCurve}static getDefaults(){return Object.assign(wo.getDefaults(),{attack:.01,attackCurve:"linear",decay:.1,decayCurve:"exponential",release:1,releaseCurve:"exponential",sustain:.5})}get value(){return this.getValueAtTime(this.now())}_getCurve(t,e){if(fi(t))return t;{let s;for(s in Ir)if(Ir[s][e]===t)return s;return t}}_setCurve(t,e,s){if(fi(s)&&Reflect.has(Ir,s)){const n=Ir[s];li(n)?"_decayCurve"!==t&&(this[t]=n[e]):this[t]=n}else{if(!di(s)||"_decayCurve"===t)throw new Error("Envelope: invalid curve: "+s);this[t]=s}}get attackCurve(){return this._getCurve(this._attackCurve,"In")}set attackCurve(t){this._setCurve("_attackCurve","In",t)}get releaseCurve(){return this._getCurve(this._releaseCurve,"Out")}set releaseCurve(t){this._setCurve("_releaseCurve","Out",t)}get decayCurve(){return this._decayCurve}set decayCurve(t){ti(["linear","exponential"].some(e=>e===t),"Invalid envelope curve: "+t),this._decayCurve=t}triggerAttack(t,e=1){this.log("triggerAttack",t,e),t=this.toSeconds(t);let s=this.toSeconds(this.attack);const n=this.toSeconds(this.decay),i=this.getValueAtTime(t);if(i>0){s=(1-i)/(1/s)}if(s<this.sampleTime)this._sig.cancelScheduledValues(t),this._sig.setValueAtTime(e,t);else if("linear"===this._attackCurve)this._sig.linearRampTo(e,s,t);else if("exponential"===this._attackCurve)this._sig.targetRampTo(e,s,t);else{this._sig.cancelAndHoldAtTime(t);let n=this._attackCurve;for(let t=1;t<n.length;t++)if(n[t-1]<=i&&i<=n[t]){n=this._attackCurve.slice(t),n[0]=i;break}this._sig.setValueCurveAtTime(n,t,s,e)}if(n&&this.sustain<1){const i=e*this.sustain,o=t+s;this.log("decay",o),"linear"===this._decayCurve?this._sig.linearRampToValueAtTime(i,n+o):this._sig.exponentialApproachValueAtTime(i,o,n)}return this}triggerRelease(t){this.log("triggerRelease",t),t=this.toSeconds(t);const e=this.getValueAtTime(t);if(e>0){const s=this.toSeconds(this.release);s<this.sampleTime?this._sig.setValueAtTime(0,t):"linear"===this._releaseCurve?this._sig.linearRampTo(0,s,t):"exponential"===this._releaseCurve?this._sig.targetRampTo(0,s,t):(ti(di(this._releaseCurve),"releaseCurve must be either 'linear', 'exponential' or an array"),this._sig.cancelAndHoldAtTime(t),this._sig.setValueCurveAtTime(this._releaseCurve,t,s,e))}return this}getValueAtTime(t){return this._sig.getValueAtTime(t)}triggerAttackRelease(t,e,s=1){return e=this.toSeconds(e),this.triggerAttack(e,s),this.triggerRelease(e+this.toSeconds(t)),this}cancel(t){return this._sig.cancelScheduledValues(this.toSeconds(t)),this}connect(t,e=0,s=0){return Oo(this,t,e,s),this}asArray(t=1024){return yi(this,void 0,void 0,(function*(){const e=t/this.context.sampleRate,s=new Yi(1,e,this.context.sampleRate),n=this.toSeconds(this.attack)+this.toSeconds(this.decay),i=n+this.toSeconds(this.release),o=.1*i,r=i+o,a=new this.constructor(Object.assign(this.get(),{attack:e*this.toSeconds(this.attack)/r,decay:e*this.toSeconds(this.decay)/r,release:e*this.toSeconds(this.release)/r,context:s}));a._sig.toDestination(),a.triggerAttackRelease(e*(n+o)/r,0);return(yield s.render()).getChannelData(0)}))}dispose(){return super.dispose(),this._sig.dispose(),this}}vi([wr(0)],Fr.prototype,"attack",void 0),vi([wr(0)],Fr.prototype,"decay",void 0),vi([xr(0,1)],Fr.prototype,"sustain",void 0),vi([wr(0)],Fr.prototype,"release",void 0);const Ir=(()=>{let t,e;const s=[];for(t=0;t<128;t++)s[t]=Math.sin(t/127*(Math.PI/2));const n=[];for(t=0;t<127;t++){e=t/127;const s=Math.sin(e*(2*Math.PI)*6.4-Math.PI/2)+1;n[t]=s/10+.83*e}n[127]=1;const i=[];for(t=0;t<128;t++)i[t]=Math.ceil(t/127*5)/5;const o=[];for(t=0;t<128;t++)e=t/127,o[t]=.5*(1-Math.cos(Math.PI*e));const r=[];for(t=0;t<128;t++){e=t/127;const s=4*Math.pow(e,3)+.2,n=Math.cos(s*Math.PI*2*e);r[t]=Math.abs(n*(1-e))}function a(t){const e=new Array(t.length);for(let s=0;s<t.length;s++)e[s]=1-t[s];return e}return{bounce:{In:a(r),Out:r},cosine:{In:s,Out:(c=s,c.slice(0).reverse())},exponential:"exponential",linear:"linear",ripple:{In:n,Out:a(n)},sine:{In:o,Out:a(o)},step:{In:i,Out:a(i)}};var c})();class Vr extends wo{constructor(){super(Di(Vr.getDefaults(),arguments)),this._scheduledEvents=[],this._synced=!1,this._original_triggerAttack=this.triggerAttack,this._original_triggerRelease=this.triggerRelease;const t=Di(Vr.getDefaults(),arguments);this._volume=this.output=new Go({context:this.context,volume:t.volume}),this.volume=this._volume.volume,Ui(this,"volume")}static getDefaults(){return Object.assign(wo.getDefaults(),{volume:0})}sync(){return this._syncState()&&(this._syncMethod("triggerAttack",1),this._syncMethod("triggerRelease",0)),this}_syncState(){let t=!1;return this._synced||(this._synced=!0,t=!0),t}_syncMethod(t,e){const s=this["_original_"+t]=this[t];this[t]=(...t)=>{const n=t[e],i=this.context.transport.schedule(n=>{t[e]=n,s.apply(this,t)},n);this._scheduledEvents.push(i)}}unsync(){return this._scheduledEvents.forEach(t=>this.context.transport.clear(t)),this._scheduledEvents=[],this._synced&&(this._synced=!1,this.triggerAttack=this._original_triggerAttack,this.triggerRelease=this._original_triggerRelease),this}triggerAttackRelease(t,e,s,n){const i=this.toSeconds(s),o=this.toSeconds(e);return this.triggerAttack(t,i,n),this.triggerRelease(i+o),this}dispose(){return super.dispose(),this._volume.dispose(),this.unsync(),this._scheduledEvents=[],this}}class Nr extends Vr{constructor(){super(Di(Nr.getDefaults(),arguments));const t=Di(Nr.getDefaults(),arguments);this.portamento=t.portamento,this.onsilence=t.onsilence}static getDefaults(){return Object.assign(Vr.getDefaults(),{detune:0,onsilence:Zi,portamento:0})}triggerAttack(t,e,s=1){this.log("triggerAttack",t,e,s);const n=this.toSeconds(e);return this._triggerEnvelopeAttack(n,s),this.setNote(t,n),this}triggerRelease(t){this.log("triggerRelease",t);const e=this.toSeconds(t);return this._triggerEnvelopeRelease(e),this}setNote(t,e){const s=this.toSeconds(e),n=t instanceof lo?t.toFrequency():t;if(this.portamento>0&&this.getLevelAtTime(s)>.05){const t=this.toSeconds(this.portamento);this.frequency.exponentialRampTo(n,t,s)}else this.frequency.setValueAtTime(n,s);return this}}vi([wr(0)],Nr.prototype,"portamento",void 0);class Pr extends Fr{constructor(){super(Di(Pr.getDefaults(),arguments,["attack","decay","sustain","release"])),this.name="AmplitudeEnvelope",this._gainNode=new ko({context:this.context,gain:0}),this.output=this._gainNode,this.input=this._gainNode,this._sig.connect(this._gainNode.gain),this.output=this._gainNode,this.input=this._gainNode}dispose(){return super.dispose(),this._gainNode.dispose(),this}}class jr extends Nr{constructor(){super(Di(jr.getDefaults(),arguments)),this.name="Synth";const t=Di(jr.getDefaults(),arguments);this.oscillator=new _r(Object.assign({context:this.context,detune:t.detune,onstop:()=>this.onsilence(this)},t.oscillator)),this.frequency=this.oscillator.frequency,this.detune=this.oscillator.detune,this.envelope=new Pr(Object.assign({context:this.context},t.envelope)),this.oscillator.chain(this.envelope,this.output),Ui(this,["oscillator","frequency","detune","envelope"])}static getDefaults(){return Object.assign(Nr.getDefaults(),{envelope:Object.assign(Mi(Fr.getDefaults(),Object.keys(wo.getDefaults())),{attack:.005,decay:.1,release:1,sustain:.3}),oscillator:Object.assign(Mi(_r.getDefaults(),[...Object.keys(Ho.getDefaults()),"frequency","detune"]),{type:"triangle"})})}_triggerEnvelopeAttack(t,e){if(this.envelope.triggerAttack(t,e),this.oscillator.start(t),0===this.envelope.sustain){const e=this.toSeconds(this.envelope.attack),s=this.toSeconds(this.envelope.decay);this.oscillator.stop(t+e+s)}}_triggerEnvelopeRelease(t){this.envelope.triggerRelease(t),this.oscillator.stop(t+this.toSeconds(this.envelope.release))}getLevelAtTime(t){return t=this.toSeconds(t),this.envelope.getValueAtTime(t)}dispose(){return super.dispose(),this.oscillator.dispose(),this.envelope.dispose(),this}}class Lr extends Nr{constructor(){super(Di(Lr.getDefaults(),arguments)),this.name="ModulationSynth";const t=Di(Lr.getDefaults(),arguments);this._carrier=new jr({context:this.context,oscillator:t.oscillator,envelope:t.envelope,onsilence:()=>this.onsilence(this),volume:-10}),this._modulator=new jr({context:this.context,oscillator:t.modulation,envelope:t.modulationEnvelope,volume:-10}),this.oscillator=this._carrier.oscillator,this.envelope=this._carrier.envelope,this.modulation=this._modulator.oscillator,this.modulationEnvelope=this._modulator.envelope,this.frequency=new Do({context:this.context,units:"frequency"}),this.detune=new Do({context:this.context,value:t.detune,units:"cents"}),this.harmonicity=new cr({context:this.context,value:t.harmonicity,minValue:0}),this._modulationNode=new ko({context:this.context,gain:0}),Ui(this,["frequency","harmonicity","oscillator","envelope","modulation","modulationEnvelope","detune"])}static getDefaults(){return Object.assign(Nr.getDefaults(),{harmonicity:3,oscillator:Object.assign(Mi(_r.getDefaults(),[...Object.keys(Ho.getDefaults()),"frequency","detune"]),{type:"sine"}),envelope:Object.assign(Mi(Fr.getDefaults(),Object.keys(wo.getDefaults())),{attack:.01,decay:.01,sustain:1,release:.5}),modulation:Object.assign(Mi(_r.getDefaults(),[...Object.keys(Ho.getDefaults()),"frequency","detune"]),{type:"square"}),modulationEnvelope:Object.assign(Mi(Fr.getDefaults(),Object.keys(wo.getDefaults())),{attack:.5,decay:0,sustain:1,release:.5})})}_triggerEnvelopeAttack(t,e){this._carrier._triggerEnvelopeAttack(t,e),this._modulator._triggerEnvelopeAttack(t,e)}_triggerEnvelopeRelease(t){return this._carrier._triggerEnvelopeRelease(t),this._modulator._triggerEnvelopeRelease(t),this}getLevelAtTime(t){return t=this.toSeconds(t),this.envelope.getValueAtTime(t)}dispose(){return super.dispose(),this._carrier.dispose(),this._modulator.dispose(),this.frequency.dispose(),this.detune.dispose(),this.harmonicity.dispose(),this._modulationNode.dispose(),this}}class zr extends Lr{constructor(){super(Di(zr.getDefaults(),arguments)),this.name="AMSynth",this._modulationScale=new ar({context:this.context}),this.frequency.connect(this._carrier.frequency),this.frequency.chain(this.harmonicity,this._modulator.frequency),this.detune.fan(this._carrier.detune,this._modulator.detune),this._modulator.chain(this._modulationScale,this._modulationNode.gain),this._carrier.chain(this._modulationNode,this.output)}dispose(){return super.dispose(),this._modulationScale.dispose(),this}}class Br extends wo{constructor(){super(Di(Br.getDefaults(),arguments,["frequency","type"])),this.name="BiquadFilter";const t=Di(Br.getDefaults(),arguments,["frequency","type"]);this._filter=this.context.createBiquadFilter(),this.input=this.output=this._filter,this.Q=new xo({context:this.context,units:"number",value:t.Q,param:this._filter.Q}),this.frequency=new xo({context:this.context,units:"frequency",value:t.frequency,param:this._filter.frequency}),this.detune=new xo({context:this.context,units:"cents",value:t.detune,param:this._filter.detune}),this.gain=new xo({context:this.context,units:"decibels",convert:!1,value:t.gain,param:this._filter.gain}),this.type=t.type}static getDefaults(){return Object.assign(wo.getDefaults(),{Q:1,type:"lowpass",frequency:350,detune:0,gain:0})}get type(){return this._filter.type}set type(t){ti(-1!==["lowpass","highpass","bandpass","lowshelf","highshelf","notch","allpass","peaking"].indexOf(t),"Invalid filter type: "+t),this._filter.type=t}getFrequencyResponse(t=128){const e=new Float32Array(t);for(let s=0;s<t;s++){const n=19980*Math.pow(s/t,2)+20;e[s]=n}const s=new Float32Array(t),n=new Float32Array(t),i=this.context.createBiquadFilter();return i.type=this.type,i.Q.value=this.Q.value,i.frequency.value=this.frequency.value,i.gain.value=this.gain.value,i.getFrequencyResponse(e,s,n),s}dispose(){return super.dispose(),this._filter.disconnect(),this.Q.dispose(),this.frequency.dispose(),this.gain.dispose(),this.detune.dispose(),this}}class Wr extends wo{constructor(){super(Di(Wr.getDefaults(),arguments,["frequency","type","rolloff"])),this.name="Filter",this.input=new ko({context:this.context}),this.output=new ko({context:this.context}),this._filters=[];const t=Di(Wr.getDefaults(),arguments,["frequency","type","rolloff"]);this._filters=[],this.Q=new Do({context:this.context,units:"positive",value:t.Q}),this.frequency=new Do({context:this.context,units:"frequency",value:t.frequency}),this.detune=new Do({context:this.context,units:"cents",value:t.detune}),this.gain=new Do({context:this.context,units:"decibels",convert:!1,value:t.gain}),this._type=t.type,this.rolloff=t.rolloff,Ui(this,["detune","frequency","gain","Q"])}static getDefaults(){return Object.assign(wo.getDefaults(),{Q:1,detune:0,frequency:350,gain:0,rolloff:-12,type:"lowpass"})}get type(){return this._type}set type(t){ti(-1!==["lowpass","highpass","bandpass","lowshelf","highshelf","notch","allpass","peaking"].indexOf(t),"Invalid filter type: "+t),this._type=t,this._filters.forEach(e=>e.type=t)}get rolloff(){return this._rolloff}set rolloff(t){const e=ui(t)?t:parseInt(t,10),s=[-12,-24,-48,-96];let n=s.indexOf(e);ti(-1!==n,"rolloff can only be "+s.join(", ")),n+=1,this._rolloff=e,this.input.disconnect(),this._filters.forEach(t=>t.disconnect()),this._filters=new Array(n);for(let t=0;t<n;t++){const e=new Br({context:this.context});e.type=this._type,this.frequency.connect(e.frequency),this.detune.connect(e.detune),this.Q.connect(e.Q),this.gain.connect(e.gain),this._filters[t]=e}this._internalChannels=this._filters,bo(this.input,...this._internalChannels,this.output)}getFrequencyResponse(t=128){const e=new Br({frequency:this.frequency.value,gain:this.gain.value,Q:this.Q.value,type:this._type,detune:this.detune.value}),s=new Float32Array(t).map(()=>1);return this._filters.forEach(()=>{e.getFrequencyResponse(t).forEach((t,e)=>s[e]*=t)}),e.dispose(),s}dispose(){return super.dispose(),this._filters.forEach(t=>{t.dispose()}),Qi(this,["detune","frequency","gain","Q"]),this.frequency.dispose(),this.Q.dispose(),this.detune.dispose(),this.gain.dispose(),this}}class Gr extends Fr{constructor(){super(Di(Gr.getDefaults(),arguments,["attack","decay","sustain","release"])),this.name="FrequencyEnvelope";const t=Di(Gr.getDefaults(),arguments,["attack","decay","sustain","release"]);this._octaves=t.octaves,this._baseFrequency=this.toFrequency(t.baseFrequency),this._exponent=this.input=new Er({context:this.context,value:t.exponent}),this._scale=this.output=new gr({context:this.context,min:this._baseFrequency,max:this._baseFrequency*Math.pow(2,this._octaves)}),this._sig.chain(this._exponent,this._scale)}static getDefaults(){return Object.assign(Fr.getDefaults(),{baseFrequency:200,exponent:1,octaves:4})}get baseFrequency(){return this._baseFrequency}set baseFrequency(t){const e=this.toFrequency(t);ei(e,0),this._baseFrequency=e,this._scale.min=this._baseFrequency,this.octaves=this._octaves}get octaves(){return this._octaves}set octaves(t){this._octaves=t,this._scale.max=this._baseFrequency*Math.pow(2,t)}get exponent(){return this._exponent.value}set exponent(t){this._exponent.value=t}dispose(){return super.dispose(),this._exponent.dispose(),this._scale.dispose(),this}}class Ur extends Nr{constructor(){super(Di(Ur.getDefaults(),arguments)),this.name="MonoSynth";const t=Di(Ur.getDefaults(),arguments);this.oscillator=new _r(Object.assign(t.oscillator,{context:this.context,detune:t.detune,onstop:()=>this.onsilence(this)})),this.frequency=this.oscillator.frequency,this.detune=this.oscillator.detune,this.filter=new Wr(Object.assign(t.filter,{context:this.context})),this.filterEnvelope=new Gr(Object.assign(t.filterEnvelope,{context:this.context})),this.envelope=new Pr(Object.assign(t.envelope,{context:this.context})),this.oscillator.chain(this.filter,this.envelope,this.output),this.filterEnvelope.connect(this.filter.frequency),Ui(this,["oscillator","frequency","detune","filter","filterEnvelope","envelope"])}static getDefaults(){return Object.assign(Nr.getDefaults(),{envelope:Object.assign(Mi(Fr.getDefaults(),Object.keys(wo.getDefaults())),{attack:.005,decay:.1,release:1,sustain:.9}),filter:Object.assign(Mi(Wr.getDefaults(),Object.keys(wo.getDefaults())),{Q:1,rolloff:-12,type:"lowpass"}),filterEnvelope:Object.assign(Mi(Gr.getDefaults(),Object.keys(wo.getDefaults())),{attack:.6,baseFrequency:200,decay:.2,exponent:2,octaves:3,release:2,sustain:.5}),oscillator:Object.assign(Mi(_r.getDefaults(),Object.keys(Ho.getDefaults())),{type:"sawtooth"})})}_triggerEnvelopeAttack(t,e=1){if(this.envelope.triggerAttack(t,e),this.filterEnvelope.triggerAttack(t),this.oscillator.start(t),0===this.envelope.sustain){const e=this.toSeconds(this.envelope.attack),s=this.toSeconds(this.envelope.decay);this.oscillator.stop(t+e+s)}}_triggerEnvelopeRelease(t){this.envelope.triggerRelease(t),this.filterEnvelope.triggerRelease(t),this.oscillator.stop(t+this.toSeconds(this.envelope.release))}getLevelAtTime(t){return t=this.toSeconds(t),this.envelope.getValueAtTime(t)}dispose(){return super.dispose(),this.oscillator.dispose(),this.envelope.dispose(),this.filterEnvelope.dispose(),this.filter.dispose(),this}}class Qr extends Nr{constructor(){super(Di(Qr.getDefaults(),arguments)),this.name="DuoSynth";const t=Di(Qr.getDefaults(),arguments);this.voice0=new Ur(Object.assign(t.voice0,{context:this.context,onsilence:()=>this.onsilence(this)})),this.voice1=new Ur(Object.assign(t.voice1,{context:this.context})),this.harmonicity=new cr({context:this.context,units:"positive",value:t.harmonicity}),this._vibrato=new yr({frequency:t.vibratoRate,context:this.context,min:-50,max:50}),this._vibrato.start(),this.vibratoRate=this._vibrato.frequency,this._vibratoGain=new ko({context:this.context,units:"normalRange",gain:t.vibratoAmount}),this.vibratoAmount=this._vibratoGain.gain,this.frequency=new Do({context:this.context,units:"frequency",value:440}),this.detune=new Do({context:this.context,units:"cents",value:t.detune}),this.frequency.connect(this.voice0.frequency),this.frequency.chain(this.harmonicity,this.voice1.frequency),this._vibrato.connect(this._vibratoGain),this._vibratoGain.fan(this.voice0.detune,this.voice1.detune),this.detune.fan(this.voice0.detune,this.voice1.detune),this.voice0.connect(this.output),this.voice1.connect(this.output),Ui(this,["voice0","voice1","frequency","vibratoAmount","vibratoRate"])}getLevelAtTime(t){return t=this.toSeconds(t),this.voice0.envelope.getValueAtTime(t)+this.voice1.envelope.getValueAtTime(t)}static getDefaults(){return Ai(Nr.getDefaults(),{vibratoAmount:.5,vibratoRate:5,harmonicity:1.5,voice0:Ai(Mi(Ur.getDefaults(),Object.keys(Nr.getDefaults())),{filterEnvelope:{attack:.01,decay:0,sustain:1,release:.5},envelope:{attack:.01,decay:0,sustain:1,release:.5}}),voice1:Ai(Mi(Ur.getDefaults(),Object.keys(Nr.getDefaults())),{filterEnvelope:{attack:.01,decay:0,sustain:1,release:.5},envelope:{attack:.01,decay:0,sustain:1,release:.5}})})}_triggerEnvelopeAttack(t,e){this.voice0._triggerEnvelopeAttack(t,e),this.voice1._triggerEnvelopeAttack(t,e)}_triggerEnvelopeRelease(t){return this.voice0._triggerEnvelopeRelease(t),this.voice1._triggerEnvelopeRelease(t),this}dispose(){return super.dispose(),this.voice0.dispose(),this.voice1.dispose(),this.frequency.dispose(),this.detune.dispose(),this._vibrato.dispose(),this.vibratoRate.dispose(),this._vibratoGain.dispose(),this.harmonicity.dispose(),this}}class Zr extends Lr{constructor(){super(Di(Zr.getDefaults(),arguments)),this.name="FMSynth";const t=Di(Zr.getDefaults(),arguments);this.modulationIndex=new cr({context:this.context,value:t.modulationIndex}),this.frequency.connect(this._carrier.frequency),this.frequency.chain(this.harmonicity,this._modulator.frequency),this.frequency.chain(this.modulationIndex,this._modulationNode),this.detune.fan(this._carrier.detune,this._modulator.detune),this._modulator.connect(this._modulationNode.gain),this._modulationNode.connect(this._carrier.frequency),this._carrier.connect(this.output)}static getDefaults(){return Object.assign(Lr.getDefaults(),{modulationIndex:10})}dispose(){return super.dispose(),this.modulationIndex.dispose(),this}}const Xr=[1,1.483,1.932,2.546,2.63,3.897];class Yr extends Nr{constructor(){super(Di(Yr.getDefaults(),arguments)),this.name="MetalSynth",this._oscillators=[],this._freqMultipliers=[];const t=Di(Yr.getDefaults(),arguments);this.detune=new Do({context:this.context,units:"cents",value:t.detune}),this.frequency=new Do({context:this.context,units:"frequency"}),this._amplitude=new ko({context:this.context,gain:0}).connect(this.output),this._highpass=new Wr({Q:0,context:this.context,type:"highpass"}).connect(this._amplitude);for(let e=0;e<Xr.length;e++){const s=new ur({context:this.context,harmonicity:t.harmonicity,modulationIndex:t.modulationIndex,modulationType:"square",onstop:0===e?()=>this.onsilence(this):Zi,type:"square"});s.connect(this._highpass),this._oscillators[e]=s;const n=new cr({context:this.context,value:Xr[e]});this._freqMultipliers[e]=n,this.frequency.chain(n,s.frequency),this.detune.connect(s.detune)}this._filterFreqScaler=new gr({context:this.context,max:7e3,min:this.toFrequency(t.resonance)}),this.envelope=new Fr({attack:t.envelope.attack,attackCurve:"linear",context:this.context,decay:t.envelope.decay,release:t.envelope.release,sustain:0}),this.envelope.chain(this._filterFreqScaler,this._highpass.frequency),this.envelope.connect(this._amplitude.gain),this._octaves=t.octaves,this.octaves=t.octaves}static getDefaults(){return Ai(Nr.getDefaults(),{envelope:Object.assign(Mi(Fr.getDefaults(),Object.keys(wo.getDefaults())),{attack:.001,decay:1.4,release:.2}),harmonicity:5.1,modulationIndex:32,octaves:1.5,resonance:4e3})}_triggerEnvelopeAttack(t,e=1){return this.envelope.triggerAttack(t,e),this._oscillators.forEach(e=>e.start(t)),0===this.envelope.sustain&&this._oscillators.forEach(e=>{e.stop(t+this.toSeconds(this.envelope.attack)+this.toSeconds(this.envelope.decay))}),this}_triggerEnvelopeRelease(t){return this.envelope.triggerRelease(t),this._oscillators.forEach(e=>e.stop(t+this.toSeconds(this.envelope.release))),this}getLevelAtTime(t){return t=this.toSeconds(t),this.envelope.getValueAtTime(t)}get modulationIndex(){return this._oscillators[0].modulationIndex.value}set modulationIndex(t){this._oscillators.forEach(e=>e.modulationIndex.value=t)}get harmonicity(){return this._oscillators[0].harmonicity.value}set harmonicity(t){this._oscillators.forEach(e=>e.harmonicity.value=t)}get resonance(){return this._filterFreqScaler.min}set resonance(t){this._filterFreqScaler.min=this.toFrequency(t),this.octaves=this._octaves}get octaves(){return this._octaves}set octaves(t){this._octaves=t,this._filterFreqScaler.max=this._filterFreqScaler.min*Math.pow(2,t)}dispose(){return super.dispose(),this._oscillators.forEach(t=>t.dispose()),this._freqMultipliers.forEach(t=>t.dispose()),this.frequency.dispose(),this.detune.dispose(),this._filterFreqScaler.dispose(),this._amplitude.dispose(),this.envelope.dispose(),this._highpass.dispose(),this}}class Hr extends jr{constructor(){super(Di(Hr.getDefaults(),arguments)),this.name="MembraneSynth",this.portamento=0;const t=Di(Hr.getDefaults(),arguments);this.pitchDecay=t.pitchDecay,this.octaves=t.octaves,Ui(this,["oscillator","envelope"])}static getDefaults(){return Ai(Nr.getDefaults(),jr.getDefaults(),{envelope:{attack:.001,attackCurve:"exponential",decay:.4,release:1.4,sustain:.01},octaves:10,oscillator:{type:"sine"},pitchDecay:.05})}setNote(t,e){const s=this.toSeconds(e),n=this.toFrequency(t instanceof lo?t.toFrequency():t),i=n*this.octaves;return this.oscillator.frequency.setValueAtTime(i,s),this.oscillator.frequency.exponentialRampToValueAtTime(n,s+this.toSeconds(this.pitchDecay)),this}dispose(){return super.dispose(),this}}vi([xr(0)],Hr.prototype,"octaves",void 0),vi([wr(0)],Hr.prototype,"pitchDecay",void 0);class $r extends Vr{constructor(){super(Di($r.getDefaults(),arguments)),this.name="NoiseSynth";const t=Di($r.getDefaults(),arguments);this.noise=new Jo(Object.assign({context:this.context},t.noise)),this.envelope=new Pr(Object.assign({context:this.context},t.envelope)),this.noise.chain(this.envelope,this.output)}static getDefaults(){return Object.assign(Vr.getDefaults(),{envelope:Object.assign(Mi(Fr.getDefaults(),Object.keys(wo.getDefaults())),{decay:.1,sustain:0}),noise:Object.assign(Mi(Jo.getDefaults(),Object.keys(Ho.getDefaults())),{type:"white"})})}triggerAttack(t,e=1){return t=this.toSeconds(t),this.envelope.triggerAttack(t,e),this.noise.start(t),0===this.envelope.sustain&&this.noise.stop(t+this.toSeconds(this.envelope.attack)+this.toSeconds(this.envelope.decay)),this}triggerRelease(t){return t=this.toSeconds(t),this.envelope.triggerRelease(t),this.noise.stop(t+this.toSeconds(this.envelope.release)),this}sync(){return this._syncState()&&(this._syncMethod("triggerAttack",0),this._syncMethod("triggerRelease",0)),this}triggerAttackRelease(t,e,s=1){return e=this.toSeconds(e),t=this.toSeconds(t),this.triggerAttack(e,s),this.triggerRelease(e+t),this}dispose(){return super.dispose(),this.noise.dispose(),this.envelope.dispose(),this}}const Jr=new Set;function Kr(t){Jr.add(t)}function ta(t,e){const s=`registerProcessor("${t}", ${e})`;Jr.add(s)}class ea extends wo{constructor(t){super(t),this.name="ToneAudioWorklet",this.workletOptions={},this.onprocessorerror=Zi;const e=URL.createObjectURL(new Blob([Array.from(Jr).join("\n")],{type:"text/javascript"})),s=this._audioWorkletName();this._dummyGain=this.context.createGain(),this._dummyParam=this._dummyGain.gain,this.context.addAudioWorkletModule(e,s).then(()=>{this.disposed||(this._worklet=this.context.createAudioWorkletNode(s,this.workletOptions),this._worklet.onprocessorerror=this.onprocessorerror.bind(this),this.onReady(this._worklet))})}dispose(){return super.dispose(),this._dummyGain.disconnect(),this._worklet&&(this._worklet.port.postMessage("dispose"),this._worklet.disconnect()),this}}Kr('\n\t/**\n\t * The base AudioWorkletProcessor for use in Tone.js. Works with the [[ToneAudioWorklet]]. \n\t */\n\tclass ToneAudioWorkletProcessor extends AudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\t\n\t\t\tsuper(options);\n\t\t\t/**\n\t\t\t * If the processor was disposed or not. Keep alive until it\'s disposed.\n\t\t\t */\n\t\t\tthis.disposed = false;\n\t\t   \t/** \n\t\t\t * The number of samples in the processing block\n\t\t\t */\n\t\t\tthis.blockSize = 128;\n\t\t\t/**\n\t\t\t * the sample rate\n\t\t\t */\n\t\t\tthis.sampleRate = sampleRate;\n\n\t\t\tthis.port.onmessage = (event) => {\n\t\t\t\t// when it receives a dispose \n\t\t\t\tif (event.data === "dispose") {\n\t\t\t\t\tthis.disposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n');Kr("\n\t/**\n\t * Abstract class for a single input/output processor. \n\t * has a 'generate' function which processes one sample at a time\n\t */\n\tclass SingleIOProcessor extends ToneAudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(Object.assign(options, {\n\t\t\t\tnumberOfInputs: 1,\n\t\t\t\tnumberOfOutputs: 1\n\t\t\t}));\n\t\t\t/**\n\t\t\t * Holds the name of the parameter and a single value of that\n\t\t\t * parameter at the current sample\n\t\t\t * @type { [name: string]: number }\n\t\t\t */\n\t\t\tthis.params = {}\n\t\t}\n\n\t\t/**\n\t\t * Generate an output sample from the input sample and parameters\n\t\t * @abstract\n\t\t * @param input number\n\t\t * @param channel number\n\t\t * @param parameters { [name: string]: number }\n\t\t * @returns number\n\t\t */\n\t\tgenerate(){}\n\n\t\t/**\n\t\t * Update the private params object with the \n\t\t * values of the parameters at the given index\n\t\t * @param parameters { [name: string]: Float32Array },\n\t\t * @param index number\n\t\t */\n\t\tupdateParams(parameters, index) {\n\t\t\tfor (const paramName in parameters) {\n\t\t\t\tconst param = parameters[paramName];\n\t\t\t\tif (param.length > 1) {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][index];\n\t\t\t\t} else {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Process a single frame of the audio\n\t\t * @param inputs Float32Array[][]\n\t\t * @param outputs Float32Array[][]\n\t\t */\n\t\tprocess(inputs, outputs, parameters) {\n\t\t\tconst input = inputs[0];\n\t\t\tconst output = outputs[0];\n\t\t\t// get the parameter values\n\t\t\tconst channelCount = Math.max(input && input.length || 0, output.length);\n\t\t\tfor (let sample = 0; sample < this.blockSize; sample++) {\n\t\t\t\tthis.updateParams(parameters, sample);\n\t\t\t\tfor (let channel = 0; channel < channelCount; channel++) {\n\t\t\t\t\tconst inputSample = input && input.length ? input[channel][sample] : 0;\n\t\t\t\t\toutput[channel][sample] = this.generate(inputSample, channel, this.params);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn !this.disposed;\n\t\t}\n\t};\n");Kr("\n\t/**\n\t * A multichannel buffer for use within an AudioWorkletProcessor as a delay line\n\t */\n\tclass DelayLine {\n\t\t\n\t\tconstructor(size, channels) {\n\t\t\tthis.buffer = [];\n\t\t\tthis.writeHead = []\n\t\t\tthis.size = size;\n\n\t\t\t// create the empty channels\n\t\t\tfor (let i = 0; i < channels; i++) {\n\t\t\t\tthis.buffer[i] = new Float32Array(this.size);\n\t\t\t\tthis.writeHead[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Push a value onto the end\n\t\t * @param channel number\n\t\t * @param value number\n\t\t */\n\t\tpush(channel, value) {\n\t\t\tthis.writeHead[channel] += 1;\n\t\t\tif (this.writeHead[channel] > this.size) {\n\t\t\t\tthis.writeHead[channel] = 0;\n\t\t\t}\n\t\t\tthis.buffer[channel][this.writeHead[channel]] = value;\n\t\t}\n\n\t\t/**\n\t\t * Get the recorded value of the channel given the delay\n\t\t * @param channel number\n\t\t * @param delay number delay samples\n\t\t */\n\t\tget(channel, delay) {\n\t\t\tlet readHead = this.writeHead[channel] - Math.floor(delay);\n\t\t\tif (readHead < 0) {\n\t\t\t\treadHead += this.size;\n\t\t\t}\n\t\t\treturn this.buffer[channel][readHead];\n\t\t}\n\t}\n");ta("feedback-comb-filter",'\n\tclass FeedbackCombFilterWorklet extends SingleIOProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(options);\n\t\t\tthis.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);\n\t\t}\n\n\t\tstatic get parameterDescriptors() {\n\t\t\treturn [{\n\t\t\t\tname: "delayTime",\n\t\t\t\tdefaultValue: 0.1,\n\t\t\t\tminValue: 0,\n\t\t\t\tmaxValue: 1,\n\t\t\t\tautomationRate: "k-rate"\n\t\t\t}, {\n\t\t\t\tname: "feedback",\n\t\t\t\tdefaultValue: 0.5,\n\t\t\t\tminValue: 0,\n\t\t\t\tmaxValue: 0.9999,\n\t\t\t\tautomationRate: "k-rate"\n\t\t\t}];\n\t\t}\n\n\t\tgenerate(input, channel, parameters) {\n\t\t\tconst delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);\n\t\t\tthis.delayLine.push(channel, input + delayedSample * parameters.feedback);\n\t\t\treturn delayedSample;\n\t\t}\n\t}\n');class sa extends ea{constructor(){super(Di(sa.getDefaults(),arguments,["delayTime","resonance"])),this.name="FeedbackCombFilter";const t=Di(sa.getDefaults(),arguments,["delayTime","resonance"]);this.input=new ko({context:this.context}),this.output=new ko({context:this.context}),this.delayTime=new xo({context:this.context,value:t.delayTime,units:"time",minValue:0,maxValue:1,param:this._dummyParam,swappable:!0}),this.resonance=new xo({context:this.context,value:t.resonance,units:"normalRange",param:this._dummyParam,swappable:!0}),Ui(this,["resonance","delayTime"])}_audioWorkletName(){return"feedback-comb-filter"}static getDefaults(){return Object.assign(wo.getDefaults(),{delayTime:.1,resonance:.5})}onReady(t){bo(this.input,t,this.output);const e=t.parameters.get("delayTime");this.delayTime.setParam(e);const s=t.parameters.get("feedback");this.resonance.setParam(s)}dispose(){return super.dispose(),this.input.dispose(),this.output.dispose(),this.delayTime.dispose(),this.resonance.dispose(),this}}class na extends wo{constructor(){super(Di(na.getDefaults(),arguments,["frequency","type"])),this.name="OnePoleFilter";const t=Di(na.getDefaults(),arguments,["frequency","type"]);this._frequency=t.frequency,this._type=t.type,this.input=new ko({context:this.context}),this.output=new ko({context:this.context}),this._createFilter()}static getDefaults(){return Object.assign(wo.getDefaults(),{frequency:880,type:"lowpass"})}_createFilter(){const t=this._filter,e=this.toFrequency(this._frequency),s=1/(2*Math.PI*e);if("lowpass"===this._type){const t=1/(s*this.context.sampleRate),e=t-1;this._filter=this.context.createIIRFilter([t,0],[1,e])}else{const t=1/(s*this.context.sampleRate)-1;this._filter=this.context.createIIRFilter([1,-1],[1,t])}this.input.chain(this._filter,this.output),t&&this.context.setTimeout(()=>{this.disposed||(this.input.disconnect(t),t.disconnect())},this.blockTime)}get frequency(){return this._frequency}set frequency(t){this._frequency=t,this._createFilter()}get type(){return this._type}set type(t){this._type=t,this._createFilter()}getFrequencyResponse(t=128){const e=new Float32Array(t);for(let s=0;s<t;s++){const n=19980*Math.pow(s/t,2)+20;e[s]=n}const s=new Float32Array(t),n=new Float32Array(t);return this._filter.getFrequencyResponse(e,s,n),s}dispose(){return super.dispose(),this.input.dispose(),this.output.dispose(),this._filter.disconnect(),this}}class ia extends wo{constructor(){super(Di(ia.getDefaults(),arguments,["delayTime","resonance","dampening"])),this.name="LowpassCombFilter";const t=Di(ia.getDefaults(),arguments,["delayTime","resonance","dampening"]);this._combFilter=this.output=new sa({context:this.context,delayTime:t.delayTime,resonance:t.resonance}),this.delayTime=this._combFilter.delayTime,this.resonance=this._combFilter.resonance,this._lowpass=this.input=new na({context:this.context,frequency:t.dampening,type:"lowpass"}),this._lowpass.connect(this._combFilter)}static getDefaults(){return Object.assign(wo.getDefaults(),{dampening:3e3,delayTime:.1,resonance:.5})}get dampening(){return this._lowpass.frequency}set dampening(t){this._lowpass.frequency=t}dispose(){return super.dispose(),this._combFilter.dispose(),this._lowpass.dispose(),this}}class oa extends Vr{constructor(){super(Di(oa.getDefaults(),arguments)),this.name="PluckSynth";const t=Di(oa.getDefaults(),arguments);this._noise=new Jo({context:this.context,type:"pink"}),this.attackNoise=t.attackNoise,this._lfcf=new ia({context:this.context,dampening:t.dampening,resonance:t.resonance}),this.resonance=t.resonance,this.release=t.release,this._noise.connect(this._lfcf),this._lfcf.connect(this.output)}static getDefaults(){return Ai(Vr.getDefaults(),{attackNoise:1,dampening:4e3,resonance:.7,release:1})}get dampening(){return this._lfcf.dampening}set dampening(t){this._lfcf.dampening=t}triggerAttack(t,e){const s=this.toFrequency(t);e=this.toSeconds(e);const n=1/s;return this._lfcf.delayTime.setValueAtTime(n,e),this._noise.start(e),this._noise.stop(e+n*this.attackNoise),this._lfcf.resonance.cancelScheduledValues(e),this._lfcf.resonance.setValueAtTime(this.resonance,e),this}triggerRelease(t){return this._lfcf.resonance.linearRampTo(0,this.release,t),this}dispose(){return super.dispose(),this._noise.dispose(),this._lfcf.dispose(),this}}class ra extends Vr{constructor(){super(Di(ra.getDefaults(),arguments,["voice","options"])),this.name="PolySynth",this._availableVoices=[],this._activeVoices=[],this._voices=[],this._gcTimeout=-1,this._averageActiveVoices=0;const t=Di(ra.getDefaults(),arguments,["voice","options"]);ti(!ui(t.voice),"DEPRECATED: The polyphony count is no longer the first argument.");const e=t.voice.getDefaults();this.options=Object.assign(e,t.options),this.voice=t.voice,this.maxPolyphony=t.maxPolyphony,this._dummyVoice=this._getNextAvailableVoice();const s=this._voices.indexOf(this._dummyVoice);this._voices.splice(s,1),this._gcTimeout=this.context.setInterval(this._collectGarbage.bind(this),1)}static getDefaults(){return Object.assign(Vr.getDefaults(),{maxPolyphony:32,options:{},voice:jr})}get activeVoices(){return this._activeVoices.length}_makeVoiceAvailable(t){this._availableVoices.push(t);const e=this._activeVoices.findIndex(e=>e.voice===t);this._activeVoices.splice(e,1)}_getNextAvailableVoice(){if(this._availableVoices.length)return this._availableVoices.shift();if(this._voices.length<this.maxPolyphony){const t=new this.voice(Object.assign(this.options,{context:this.context,onsilence:this._makeVoiceAvailable.bind(this)}));return t.connect(this.output),this._voices.push(t),t}ri("Max polyphony exceeded. Note dropped.")}_collectGarbage(){if(this._averageActiveVoices=Math.max(.95*this._averageActiveVoices,this.activeVoices),this._availableVoices.length&&this._voices.length>Math.ceil(this._averageActiveVoices+1)){const t=this._availableVoices.shift(),e=this._voices.indexOf(t);this._voices.splice(e,1),this.context.isOffline||t.dispose()}}_triggerAttack(t,e,s){t.forEach(t=>{const n=new No(this.context,t).toMidi(),i=this._getNextAvailableVoice();i&&(i.triggerAttack(t,e,s),this._activeVoices.push({midi:n,voice:i,released:!1}),this.log("triggerAttack",t,e))})}_triggerRelease(t,e){t.forEach(t=>{const s=new No(this.context,t).toMidi(),n=this._activeVoices.find(({midi:t,released:e})=>t===s&&!e);n&&(n.voice.triggerRelease(e),n.released=!0,this.log("triggerRelease",t,e))})}_scheduleEvent(t,e,s,n){ti(!this.disposed,"Synth was already disposed"),s<=this.now()?"attack"===t?this._triggerAttack(e,s,n):this._triggerRelease(e,s):this.context.setTimeout(()=>{this._scheduleEvent(t,e,s,n)},s-this.now())}triggerAttack(t,e,s){Array.isArray(t)||(t=[t]);const n=this.toSeconds(e);return this._scheduleEvent("attack",t,n,s),this}triggerRelease(t,e){Array.isArray(t)||(t=[t]);const s=this.toSeconds(e);return this._scheduleEvent("release",t,s),this}triggerAttackRelease(t,e,s,n){const i=this.toSeconds(s);if(this.triggerAttack(t,i,n),di(e)){ti(di(t),"If the duration is an array, the notes must also be an array"),t=t;for(let s=0;s<t.length;s++){const n=e[Math.min(s,e.length-1)],o=this.toSeconds(n);ti(o>0,"The duration must be greater than 0"),this.triggerRelease(t[s],i+o)}}else{const s=this.toSeconds(e);ti(s>0,"The duration must be greater than 0"),this.triggerRelease(t,i+s)}return this}sync(){return this._syncState()&&(this._syncMethod("triggerAttack",1),this._syncMethod("triggerRelease",1)),this}set(t){const e=Mi(t,["onsilence","context"]);return this.options=Ai(this.options,e),this._voices.forEach(t=>t.set(e)),this._dummyVoice.set(e),this}get(){return this._dummyVoice.get()}releaseAll(t){const e=this.toSeconds(t);return this._activeVoices.forEach(({voice:t})=>{t.triggerRelease(e)}),this}dispose(){return super.dispose(),this._dummyVoice.dispose(),this._voices.forEach(t=>t.dispose()),this._activeVoices=[],this._availableVoices=[],this.context.clearInterval(this._gcTimeout),this}}class aa extends Vr{constructor(){super(Di(aa.getDefaults(),arguments,["urls","onload","baseUrl"],"urls")),this.name="Sampler",this._activeSources=new Map;const t=Di(aa.getDefaults(),arguments,["urls","onload","baseUrl"],"urls"),e={};Object.keys(t.urls).forEach(s=>{const n=parseInt(s,10);if(ti(_i(s)||ui(n)&&isFinite(n),"url key is neither a note or midi pitch: "+s),_i(s)){const n=new lo(this.context,s).toMidi();e[n]=t.urls[s]}else ui(n)&&isFinite(n)&&(e[n]=t.urls[n])}),this._buffers=new Vo({urls:e,onload:t.onload,baseUrl:t.baseUrl,onerror:t.onerror}),this.attack=t.attack,this.release=t.release,this.curve=t.curve,this._buffers.loaded&&Promise.resolve().then(t.onload)}static getDefaults(){return Object.assign(Vr.getDefaults(),{attack:0,baseUrl:"",curve:"exponential",onload:Zi,onerror:Zi,release:.1,urls:{}})}_findClosest(t){let e=0;for(;e<96;){if(this._buffers.has(t+e))return-e;if(this._buffers.has(t-e))return e;e++}throw new Error("No available buffers for note: "+t)}triggerAttack(t,e,s=1){return this.log("triggerAttack",t,e,s),Array.isArray(t)||(t=[t]),t.forEach(t=>{const n=ro(new lo(this.context,t).toFrequency()),i=Math.round(n),o=n-i,r=this._findClosest(i),a=i-r,c=this._buffers.get(a),h=no(r+o),u=new $o({url:c,context:this.context,curve:this.curve,fadeIn:this.attack,fadeOut:this.release,playbackRate:h}).connect(this.output);u.start(e,0,c.duration/h,s),di(this._activeSources.get(i))||this._activeSources.set(i,[]),this._activeSources.get(i).push(u),u.onended=()=>{if(this._activeSources&&this._activeSources.has(i)){const t=this._activeSources.get(i),e=t.indexOf(u);-1!==e&&t.splice(e,1)}}}),this}triggerRelease(t,e){return this.log("triggerRelease",t,e),Array.isArray(t)||(t=[t]),t.forEach(t=>{const s=new lo(this.context,t).toMidi();if(this._activeSources.has(s)&&this._activeSources.get(s).length){const t=this._activeSources.get(s);e=this.toSeconds(e),t.forEach(t=>{t.stop(e)}),this._activeSources.set(s,[])}}),this}releaseAll(t){const e=this.toSeconds(t);return this._activeSources.forEach(t=>{for(;t.length;){t.shift().stop(e)}}),this}sync(){return this._syncState()&&(this._syncMethod("triggerAttack",1),this._syncMethod("triggerRelease",1)),this}triggerAttackRelease(t,e,s,n=1){const i=this.toSeconds(s);return this.triggerAttack(t,i,n),di(e)?(ti(di(t),"notes must be an array when duration is array"),t.forEach((t,s)=>{const n=e[Math.min(s,e.length-1)];this.triggerRelease(t,i+this.toSeconds(n))})):this.triggerRelease(t,i+this.toSeconds(e)),this}add(t,e,s){if(ti(_i(t)||isFinite(t),"note must be a pitch or midi: "+t),_i(t)){const n=new lo(this.context,t).toMidi();this._buffers.add(n,e,s)}else this._buffers.add(t,e,s);return this}get loaded(){return this._buffers.loaded}dispose(){return super.dispose(),this._buffers.dispose(),this._activeSources.forEach(t=>{t.forEach(t=>t.dispose())}),this._activeSources.clear(),this}}vi([wr(0)],aa.prototype,"attack",void 0),vi([wr(0)],aa.prototype,"release",void 0);class ca extends vo{constructor(){super(Di(ca.getDefaults(),arguments,["callback","value"])),this.name="ToneEvent",this._state=new yo("stopped"),this._startOffset=0;const t=Di(ca.getDefaults(),arguments,["callback","value"]);this._loop=t.loop,this.callback=t.callback,this.value=t.value,this._loopStart=this.toTicks(t.loopStart),this._loopEnd=this.toTicks(t.loopEnd),this._playbackRate=t.playbackRate,this._probability=t.probability,this._humanize=t.humanize,this.mute=t.mute,this._playbackRate=t.playbackRate,this._state.increasing=!0,this._rescheduleEvents()}static getDefaults(){return Object.assign(vo.getDefaults(),{callback:Zi,humanize:!1,loop:!1,loopEnd:"1m",loopStart:0,mute:!1,playbackRate:1,probability:1,value:null})}_rescheduleEvents(t=-1){this._state.forEachFrom(t,t=>{let e;if("started"===t.state){-1!==t.id&&this.context.transport.clear(t.id);const s=t.time+Math.round(this.startOffset/this._playbackRate);if(!0===this._loop||ui(this._loop)&&this._loop>1){e=1/0,ui(this._loop)&&(e=this._loop*this._getLoopDuration());const n=this._state.getAfter(s);null!==n&&(e=Math.min(e,n.time-s)),e!==1/0&&(this._state.setStateAtTime("stopped",s+e+1,{id:-1}),e=new jo(this.context,e));const i=new jo(this.context,this._getLoopDuration());t.id=this.context.transport.scheduleRepeat(this._tick.bind(this),i,new jo(this.context,s),e)}else t.id=this.context.transport.schedule(this._tick.bind(this),new jo(this.context,s))}})}get state(){return this._state.getValueAtTime(this.context.transport.ticks)}get startOffset(){return this._startOffset}set startOffset(t){this._startOffset=t}get probability(){return this._probability}set probability(t){this._probability=t}get humanize(){return this._humanize}set humanize(t){this._humanize=t}start(t){const e=this.toTicks(t);return"stopped"===this._state.getValueAtTime(e)&&(this._state.add({id:-1,state:"started",time:e}),this._rescheduleEvents(e)),this}stop(t){this.cancel(t);const e=this.toTicks(t);if("started"===this._state.getValueAtTime(e)){this._state.setStateAtTime("stopped",e,{id:-1});const t=this._state.getBefore(e);let s=e;null!==t&&(s=t.time),this._rescheduleEvents(s)}return this}cancel(t){t=Oi(t,-1/0);const e=this.toTicks(t);return this._state.forEachFrom(e,t=>{this.context.transport.clear(t.id)}),this._state.cancel(e),this}_tick(t){const e=this.context.transport.getTicksAtTime(t);if(!this.mute&&"started"===this._state.getValueAtTime(e)){if(this.probability<1&&Math.random()>this.probability)return;if(this.humanize){let e=.02;pi(this.humanize)||(e=this.toSeconds(this.humanize)),t+=(2*Math.random()-1)*e}this.callback(t,this.value)}}_getLoopDuration(){return Math.round((this._loopEnd-this._loopStart)/this._playbackRate)}get loop(){return this._loop}set loop(t){this._loop=t,this._rescheduleEvents()}get playbackRate(){return this._playbackRate}set playbackRate(t){this._playbackRate=t,this._rescheduleEvents()}get loopEnd(){return new jo(this.context,this._loopEnd).toSeconds()}set loopEnd(t){this._loopEnd=this.toTicks(t),this._loop&&this._rescheduleEvents()}get loopStart(){return new jo(this.context,this._loopStart).toSeconds()}set loopStart(t){this._loopStart=this.toTicks(t),this._loop&&this._rescheduleEvents()}get progress(){if(this._loop){const t=this.context.transport.ticks,e=this._state.get(t);if(null!==e&&"started"===e.state){const s=this._getLoopDuration();return(t-e.time)%s/s}return 0}return 0}dispose(){return super.dispose(),this.cancel(),this._state.dispose(),this}}class ha extends vo{constructor(){super(Di(ha.getDefaults(),arguments,["callback","interval"])),this.name="Loop";const t=Di(ha.getDefaults(),arguments,["callback","interval"]);this._event=new ca({context:this.context,callback:this._tick.bind(this),loop:!0,loopEnd:t.interval,playbackRate:t.playbackRate,probability:t.probability}),this.callback=t.callback,this.iterations=t.iterations}static getDefaults(){return Object.assign(vo.getDefaults(),{interval:"4n",callback:Zi,playbackRate:1,iterations:1/0,probability:1,mute:!1,humanize:!1})}start(t){return this._event.start(t),this}stop(t){return this._event.stop(t),this}cancel(t){return this._event.cancel(t),this}_tick(t){this.callback(t)}get state(){return this._event.state}get progress(){return this._event.progress}get interval(){return this._event.loopEnd}set interval(t){this._event.loopEnd=t}get playbackRate(){return this._event.playbackRate}set playbackRate(t){this._event.playbackRate=t}get humanize(){return this._event.humanize}set humanize(t){this._event.humanize=t}get probability(){return this._event.probability}set probability(t){this._event.probability=t}get mute(){return this._event.mute}set mute(t){this._event.mute=t}get iterations(){return!0===this._event.loop?1/0:this._event.loop}set iterations(t){this._event.loop=t===1/0||t}dispose(){return super.dispose(),this._event.dispose(),this}}class ua extends ca{constructor(){super(Di(ua.getDefaults(),arguments,["callback","events"])),this.name="Part",this._state=new yo("stopped"),this._events=new Set;const t=Di(ua.getDefaults(),arguments,["callback","events"]);this._state.increasing=!0,t.events.forEach(t=>{di(t)?this.add(t[0],t[1]):this.add(t)})}static getDefaults(){return Object.assign(ca.getDefaults(),{events:[]})}start(t,e){const s=this.toTicks(t);if("started"!==this._state.getValueAtTime(s)){e=Oi(e,this._loop?this._loopStart:0),e=this._loop?Oi(e,this._loopStart):Oi(e,0);const t=this.toTicks(e);this._state.add({id:-1,offset:t,state:"started",time:s}),this._forEach(e=>{this._startNote(e,s,t)})}return this}_startNote(t,e,s){e-=s,this._loop?t.startOffset>=this._loopStart&&t.startOffset<this._loopEnd?(t.startOffset<s&&(e+=this._getLoopDuration()),t.start(new jo(this.context,e))):t.startOffset<this._loopStart&&t.startOffset>=s&&(t.loop=!1,t.start(new jo(this.context,e))):t.startOffset>=s&&t.start(new jo(this.context,e))}get startOffset(){return this._startOffset}set startOffset(t){this._startOffset=t,this._forEach(t=>{t.startOffset+=this._startOffset})}stop(t){const e=this.toTicks(t);return this._state.cancel(e),this._state.setStateAtTime("stopped",e),this._forEach(e=>{e.stop(t)}),this}at(t,e){const s=new mo(this.context,t).toTicks(),n=new jo(this.context,1).toSeconds(),i=this._events.values();let o=i.next();for(;!o.done;){const t=o.value;if(Math.abs(s-t.startOffset)<n)return ci(e)&&(t.value=e),t;o=i.next()}return ci(e)?(this.add(t,e),this.at(t)):null}add(t,e){t instanceof Object&&Reflect.has(t,"time")&&(t=(e=t).time);const s=this.toTicks(t);let n;return e instanceof ca?(n=e,n.callback=this._tick.bind(this)):n=new ca({callback:this._tick.bind(this),context:this.context,value:e}),n.startOffset=s,n.set({humanize:this.humanize,loop:this.loop,loopEnd:this.loopEnd,loopStart:this.loopStart,playbackRate:this.playbackRate,probability:this.probability}),this._events.add(n),this._restartEvent(n),this}_restartEvent(t){this._state.forEach(e=>{"started"===e.state?this._startNote(t,e.time,e.offset):t.stop(new jo(this.context,e.time))})}remove(t,e){return li(t)&&t.hasOwnProperty("time")&&(t=(e=t).time),t=this.toTicks(t),this._events.forEach(s=>{s.startOffset===t&&(ai(e)||ci(e)&&s.value===e)&&(this._events.delete(s),s.dispose())}),this}clear(){return this._forEach(t=>t.dispose()),this._events.clear(),this}cancel(t){return this._forEach(e=>e.cancel(t)),this._state.cancel(this.toTicks(t)),this}_forEach(t){return this._events&&this._events.forEach(e=>{e instanceof ua?e._forEach(t):t(e)}),this}_setAll(t,e){this._forEach(s=>{s[t]=e})}_tick(t,e){this.mute||this.callback(t,e)}_testLoopBoundries(t){this._loop&&(t.startOffset<this._loopStart||t.startOffset>=this._loopEnd)?t.cancel(0):"stopped"===t.state&&this._restartEvent(t)}get probability(){return this._probability}set probability(t){this._probability=t,this._setAll("probability",t)}get humanize(){return this._humanize}set humanize(t){this._humanize=t,this._setAll("humanize",t)}get loop(){return this._loop}set loop(t){this._loop=t,this._forEach(e=>{e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.loop=t,this._testLoopBoundries(e)})}get loopEnd(){return new jo(this.context,this._loopEnd).toSeconds()}set loopEnd(t){this._loopEnd=this.toTicks(t),this._loop&&this._forEach(e=>{e.loopEnd=t,this._testLoopBoundries(e)})}get loopStart(){return new jo(this.context,this._loopStart).toSeconds()}set loopStart(t){this._loopStart=this.toTicks(t),this._loop&&this._forEach(t=>{t.loopStart=this.loopStart,this._testLoopBoundries(t)})}get playbackRate(){return this._playbackRate}set playbackRate(t){this._playbackRate=t,this._setAll("playbackRate",t)}get length(){return this._events.size}dispose(){return super.dispose(),this.clear(),this}}function*la(t){let e=0;for(;e<t.length;)e=fa(e,t),yield t[e],e++}function*pa(t){let e=t.length-1;for(;e>=0;)e=fa(e,t),yield t[e],e--}function*da(t,e){for(;;)yield*e(t)}function fa(t,e){return Vi(t,0,e.length-1)}function*_a(t,e){let s=e?0:t.length-1;for(;;)s=fa(s,t),yield t[s],e?(s++,s>=t.length-1&&(e=!1)):(s--,s<=0&&(e=!0))}function*ma(t){let e=0,s=0;for(;e<t.length;)e=fa(e,t),yield t[e],s++,e+=s%2?2:-1}function*ga(t){let e=t.length-1,s=0;for(;e>=0;)e=fa(e,t),yield t[e],s++,e+=s%2?-2:1}function*va(t){const e=[];for(let s=0;s<t.length;s++)e.push(s);for(;e.length>0;){const s=fa(e.splice(Math.floor(e.length*Math.random()),1)[0],t);yield t[s]}}function*ya(t,e="up",s=0){switch(ti(t.length>0,"The array must have more than one value in it"),e){case"up":yield*da(t,la);case"down":yield*da(t,pa);case"upDown":yield*_a(t,!0);case"downUp":yield*_a(t,!1);case"alternateUp":yield*da(t,ma);case"alternateDown":yield*da(t,ga);case"random":yield*function*(t){for(;;){const e=Math.floor(Math.random()*t.length);yield t[e]}}(t);case"randomOnce":yield*da(t,va);case"randomWalk":yield*function*(t){let e=Math.floor(Math.random()*t.length);for(;;)0===e?e++:e===t.length-1||Math.random()<.5?e--:e++,yield t[e]}(t)}}class xa extends ha{constructor(){super(Di(xa.getDefaults(),arguments,["callback","values","pattern"])),this.name="Pattern";const t=Di(xa.getDefaults(),arguments,["callback","values","pattern"]);this.callback=t.callback,this._values=t.values,this._pattern=ya(t.values,t.pattern),this._type=t.pattern}static getDefaults(){return Object.assign(ha.getDefaults(),{pattern:"up",values:[],callback:Zi})}_tick(t){const e=this._pattern.next();this._value=e.value,this.callback(t,this._value)}get values(){return this._values}set values(t){this._values=t,this.pattern=this._type}get value(){return this._value}get pattern(){return this._type}set pattern(t){this._type=t,this._pattern=ya(this._values,this._type)}}class wa extends ca{constructor(){super(Di(wa.getDefaults(),arguments,["callback","events","subdivision"])),this.name="Sequence",this._part=new ua({callback:this._seqCallback.bind(this),context:this.context}),this._events=[],this._eventsArray=[];const t=Di(wa.getDefaults(),arguments,["callback","events","subdivision"]);this._subdivision=this.toTicks(t.subdivision),this.events=t.events,this.loop=t.loop,this.loopStart=t.loopStart,this.loopEnd=t.loopEnd,this.playbackRate=t.playbackRate,this.probability=t.probability,this.humanize=t.humanize,this.mute=t.mute,this.playbackRate=t.playbackRate}static getDefaults(){return Object.assign(Mi(ca.getDefaults(),["value"]),{events:[],loop:!0,loopEnd:0,loopStart:0,subdivision:"8n"})}_seqCallback(t,e){null!==e&&this.callback(t,e)}get events(){return this._events}set events(t){this.clear(),this._eventsArray=t,this._events=this._createSequence(this._eventsArray),this._eventsUpdated()}start(t,e){return this._part.start(t,e?this._indexTime(e):e),this}stop(t){return this._part.stop(t),this}get subdivision(){return new jo(this.context,this._subdivision).toSeconds()}_createSequence(t){return new Proxy(t,{get:(t,e)=>t[e],set:(t,e,s)=>(fi(e)&&isFinite(parseInt(e,10))&&di(s)?t[e]=this._createSequence(s):t[e]=s,this._eventsUpdated(),!0)})}_eventsUpdated(){this._part.clear(),this._rescheduleSequence(this._eventsArray,this._subdivision,this.startOffset),this.loopEnd=this.loopEnd}_rescheduleSequence(t,e,s){t.forEach((t,n)=>{const i=n*e+s;if(di(t))this._rescheduleSequence(t,e/t.length,i);else{const e=new jo(this.context,i,"i").toSeconds();this._part.add(e,t)}})}_indexTime(t){return new jo(this.context,t*this._subdivision+this.startOffset).toSeconds()}clear(){return this._part.clear(),this}dispose(){return super.dispose(),this._part.dispose(),this}get loop(){return this._part.loop}set loop(t){this._part.loop=t}get loopStart(){return this._loopStart}set loopStart(t){this._loopStart=t,this._part.loopStart=this._indexTime(t)}get loopEnd(){return this._loopEnd}set loopEnd(t){this._loopEnd=t,this._part.loopEnd=0===t?this._indexTime(this._eventsArray.length):this._indexTime(t)}get startOffset(){return this._part.startOffset}set startOffset(t){this._part.startOffset=t}get playbackRate(){return this._part.playbackRate}set playbackRate(t){this._part.playbackRate=t}get probability(){return this._part.probability}set probability(t){this._part.probability=t}get progress(){return this._part.progress}get humanize(){return this._part.humanize}set humanize(t){this._part.humanize=t}get length(){return this._part.length}}class ba extends wo{constructor(){super(Object.assign(Di(ba.getDefaults(),arguments,["fade"]))),this.name="CrossFade",this._panner=this.context.createStereoPanner(),this._split=this.context.createChannelSplitter(2),this._g2a=new Cr({context:this.context}),this.a=new ko({context:this.context,gain:0}),this.b=new ko({context:this.context,gain:0}),this.output=new ko({context:this.context}),this._internalChannels=[this.a,this.b];const t=Di(ba.getDefaults(),arguments,["fade"]);this.fade=new Do({context:this.context,units:"normalRange",value:t.fade}),Ui(this,"fade"),this.context.getConstant(1).connect(this._panner),this._panner.connect(this._split),this._panner.channelCount=1,this._panner.channelCountMode="explicit",To(this._split,this.a.gain,0),To(this._split,this.b.gain,1),this.fade.chain(this._g2a,this._panner.pan),this.a.connect(this.output),this.b.connect(this.output)}static getDefaults(){return Object.assign(wo.getDefaults(),{fade:.5})}dispose(){return super.dispose(),this.a.dispose(),this.b.dispose(),this.output.dispose(),this.fade.dispose(),this._g2a.dispose(),this._panner.disconnect(),this._split.disconnect(),this}}class Ta extends wo{constructor(t){super(t),this.name="Effect",this._dryWet=new ba({context:this.context}),this.wet=this._dryWet.fade,this.effectSend=new ko({context:this.context}),this.effectReturn=new ko({context:this.context}),this.input=new ko({context:this.context}),this.output=this._dryWet,this.input.fan(this._dryWet.a,this.effectSend),this.effectReturn.connect(this._dryWet.b),this.wet.setValueAtTime(t.wet,0),this._internalChannels=[this.effectReturn,this.effectSend],Ui(this,"wet")}static getDefaults(){return Object.assign(wo.getDefaults(),{wet:1})}connectEffect(t){return this._internalChannels.push(t),this.effectSend.chain(t,this.effectReturn),this}dispose(){return super.dispose(),this._dryWet.dispose(),this.effectSend.dispose(),this.effectReturn.dispose(),this.wet.dispose(),this}}class Sa extends Ta{constructor(t){super(t),this.name="LFOEffect",this._lfo=new yr({context:this.context,frequency:t.frequency,amplitude:t.depth}),this.depth=this._lfo.amplitude,this.frequency=this._lfo.frequency,this.type=t.type,Ui(this,["frequency","depth"])}static getDefaults(){return Object.assign(Ta.getDefaults(),{frequency:1,type:"sine",depth:1})}start(t){return this._lfo.start(t),this}stop(t){return this._lfo.stop(t),this}sync(){return this._lfo.sync(),this}unsync(){return this._lfo.unsync(),this}get type(){return this._lfo.type}set type(t){this._lfo.type=t}dispose(){return super.dispose(),this._lfo.dispose(),this.frequency.dispose(),this.depth.dispose(),this}}class ka extends Sa{constructor(){super(Di(ka.getDefaults(),arguments,["frequency","baseFrequency","octaves"])),this.name="AutoFilter";const t=Di(ka.getDefaults(),arguments,["frequency","baseFrequency","octaves"]);this.filter=new Wr(Object.assign(t.filter,{context:this.context})),this.connectEffect(this.filter),this._lfo.connect(this.filter.frequency),this.octaves=t.octaves,this.baseFrequency=t.baseFrequency}static getDefaults(){return Object.assign(Sa.getDefaults(),{baseFrequency:200,octaves:2.6,filter:{type:"lowpass",rolloff:-12,Q:1}})}get baseFrequency(){return this._lfo.min}set baseFrequency(t){this._lfo.min=this.toFrequency(t),this.octaves=this._octaves}get octaves(){return this._octaves}set octaves(t){this._octaves=t,this._lfo.max=this._lfo.min*Math.pow(2,t)}dispose(){return super.dispose(),this.filter.dispose(),this}}class Ca extends wo{constructor(){super(Object.assign(Di(Ca.getDefaults(),arguments,["pan"]))),this.name="Panner",this._panner=this.context.createStereoPanner(),this.input=this._panner,this.output=this._panner;const t=Di(Ca.getDefaults(),arguments,["pan"]);this.pan=new xo({context:this.context,param:this._panner.pan,value:t.pan,minValue:-1,maxValue:1}),this._panner.channelCount=t.channelCount,this._panner.channelCountMode="explicit",Ui(this,"pan")}static getDefaults(){return Object.assign(wo.getDefaults(),{pan:0,channelCount:1})}dispose(){return super.dispose(),this._panner.disconnect(),this.pan.dispose(),this}}class Aa extends Sa{constructor(){super(Di(Aa.getDefaults(),arguments,["frequency"])),this.name="AutoPanner";const t=Di(Aa.getDefaults(),arguments,["frequency"]);this._panner=new Ca({context:this.context,channelCount:t.channelCount}),this.connectEffect(this._panner),this._lfo.connect(this._panner.pan),this._lfo.min=-1,this._lfo.max=1}static getDefaults(){return Object.assign(Sa.getDefaults(),{channelCount:1})}dispose(){return super.dispose(),this._panner.dispose(),this}}class Da extends wo{constructor(){super(Di(Da.getDefaults(),arguments,["smoothing"])),this.name="Follower";const t=Di(Da.getDefaults(),arguments,["smoothing"]);this._abs=this.input=new kr({context:this.context}),this._lowpass=this.output=new na({context:this.context,frequency:1/this.toSeconds(t.smoothing),type:"lowpass"}),this._abs.connect(this._lowpass),this._smoothing=t.smoothing}static getDefaults(){return Object.assign(wo.getDefaults(),{smoothing:.05})}get smoothing(){return this._smoothing}set smoothing(t){this._smoothing=t,this._lowpass.frequency=1/this.toSeconds(this.smoothing)}dispose(){return super.dispose(),this._abs.dispose(),this._lowpass.dispose(),this}}class Oa extends Ta{constructor(){super(Di(Oa.getDefaults(),arguments,["baseFrequency","octaves","sensitivity"])),this.name="AutoWah";const t=Di(Oa.getDefaults(),arguments,["baseFrequency","octaves","sensitivity"]);this._follower=new Da({context:this.context,smoothing:t.follower}),this._sweepRange=new Rr({context:this.context,min:0,max:1,exponent:.5}),this._baseFrequency=this.toFrequency(t.baseFrequency),this._octaves=t.octaves,this._inputBoost=new ko({context:this.context}),this._bandpass=new Wr({context:this.context,rolloff:-48,frequency:0,Q:t.Q}),this._peaking=new Wr({context:this.context,type:"peaking"}),this._peaking.gain.value=t.gain,this.gain=this._peaking.gain,this.Q=this._bandpass.Q,this.effectSend.chain(this._inputBoost,this._follower,this._sweepRange),this._sweepRange.connect(this._bandpass.frequency),this._sweepRange.connect(this._peaking.frequency),this.effectSend.chain(this._bandpass,this._peaking,this.effectReturn),this._setSweepRange(),this.sensitivity=t.sensitivity,Ui(this,["gain","Q"])}static getDefaults(){return Object.assign(Ta.getDefaults(),{baseFrequency:100,octaves:6,sensitivity:0,Q:2,gain:2,follower:.2})}get octaves(){return this._octaves}set octaves(t){this._octaves=t,this._setSweepRange()}get follower(){return this._follower.smoothing}set follower(t){this._follower.smoothing=t}get baseFrequency(){return this._baseFrequency}set baseFrequency(t){this._baseFrequency=this.toFrequency(t),this._setSweepRange()}get sensitivity(){return so(1/this._inputBoost.gain.value)}set sensitivity(t){this._inputBoost.gain.value=1/eo(t)}_setSweepRange(){this._sweepRange.min=this._baseFrequency,this._sweepRange.max=Math.min(this._baseFrequency*Math.pow(2,this._octaves),this.context.sampleRate/2)}dispose(){return super.dispose(),this._follower.dispose(),this._sweepRange.dispose(),this._bandpass.dispose(),this._peaking.dispose(),this._inputBoost.dispose(),this}}ta("bit-crusher","\n\tclass BitCrusherWorklet extends SingleIOProcessor {\n\n\t\tstatic get parameterDescriptors() {\n\t\t\treturn [{\n\t\t\t\tname: \"bits\",\n\t\t\t\tdefaultValue: 12,\n\t\t\t\tminValue: 1,\n\t\t\t\tmaxValue: 16,\n\t\t\t\tautomationRate: 'k-rate'\n\t\t\t}];\n\t\t}\n\n\t\tgenerate(input, _channel, parameters) {\n\t\t\tconst step = Math.pow(0.5, parameters.bits - 1);\n\t\t\tconst val = step * Math.floor(input / step + 0.5);\n\t\t\treturn val;\n\t\t}\n\t}\n");class Ma extends Ta{constructor(){super(Di(Ma.getDefaults(),arguments,["bits"])),this.name="BitCrusher";const t=Di(Ma.getDefaults(),arguments,["bits"]);this._bitCrusherWorklet=new Ea({context:this.context,bits:t.bits}),this.connectEffect(this._bitCrusherWorklet),this.bits=this._bitCrusherWorklet.bits}static getDefaults(){return Object.assign(Ta.getDefaults(),{bits:4})}dispose(){return super.dispose(),this._bitCrusherWorklet.dispose(),this}}class Ea extends ea{constructor(){super(Di(Ea.getDefaults(),arguments)),this.name="BitCrusherWorklet";const t=Di(Ea.getDefaults(),arguments);this.input=new ko({context:this.context}),this.output=new ko({context:this.context}),this.bits=new xo({context:this.context,value:t.bits,units:"positive",minValue:1,maxValue:16,param:this._dummyParam,swappable:!0})}static getDefaults(){return Object.assign(ea.getDefaults(),{bits:12})}_audioWorkletName(){return"bit-crusher"}onReady(t){bo(this.input,t,this.output);const e=t.parameters.get("bits");this.bits.setParam(e)}dispose(){return super.dispose(),this.input.dispose(),this.output.dispose(),this.bits.dispose(),this}}class Ra extends Ta{constructor(){super(Di(Ra.getDefaults(),arguments,["order"])),this.name="Chebyshev";const t=Di(Ra.getDefaults(),arguments,["order"]);this._shaper=new rr({context:this.context,length:4096}),this._order=t.order,this.connectEffect(this._shaper),this.order=t.order,this.oversample=t.oversample}static getDefaults(){return Object.assign(Ta.getDefaults(),{order:1,oversample:"none"})}_getCoefficient(t,e,s){return s.has(e)||(0===e?s.set(e,0):1===e?s.set(e,t):s.set(e,2*t*this._getCoefficient(t,e-1,s)-this._getCoefficient(t,e-2,s))),s.get(e)}get order(){return this._order}set order(t){this._order=t,this._shaper.setMap(e=>this._getCoefficient(e,t,new Map))}get oversample(){return this._shaper.oversample}set oversample(t){this._shaper.oversample=t}dispose(){return super.dispose(),this._shaper.dispose(),this}}class qa extends wo{constructor(){super(Di(qa.getDefaults(),arguments,["channels"])),this.name="Split";const t=Di(qa.getDefaults(),arguments,["channels"]);this._splitter=this.input=this.output=this.context.createChannelSplitter(t.channels),this._internalChannels=[this._splitter]}static getDefaults(){return Object.assign(wo.getDefaults(),{channels:2})}dispose(){return super.dispose(),this._splitter.disconnect(),this}}class Fa extends wo{constructor(){super(Di(Fa.getDefaults(),arguments,["channels"])),this.name="Merge";const t=Di(Fa.getDefaults(),arguments,["channels"]);this._merger=this.output=this.input=this.context.createChannelMerger(t.channels)}static getDefaults(){return Object.assign(wo.getDefaults(),{channels:2})}dispose(){return super.dispose(),this._merger.disconnect(),this}}class Ia extends wo{constructor(t){super(t),this.name="StereoEffect",this.input=new ko({context:this.context}),this.input.channelCount=2,this.input.channelCountMode="explicit",this._dryWet=this.output=new ba({context:this.context,fade:t.wet}),this.wet=this._dryWet.fade,this._split=new qa({context:this.context,channels:2}),this._merge=new Fa({context:this.context,channels:2}),this.input.connect(this._split),this.input.connect(this._dryWet.a),this._merge.connect(this._dryWet.b),Ui(this,["wet"])}connectEffectLeft(...t){this._split.connect(t[0],0,0),bo(...t),To(t[t.length-1],this._merge,0,0)}connectEffectRight(...t){this._split.connect(t[0],1,0),bo(...t),To(t[t.length-1],this._merge,0,1)}static getDefaults(){return Object.assign(wo.getDefaults(),{wet:1})}dispose(){return super.dispose(),this._dryWet.dispose(),this._split.dispose(),this._merge.dispose(),this}}class Va extends Ia{constructor(t){super(t),this.feedback=new Do({context:this.context,value:t.feedback,units:"normalRange"}),this._feedbackL=new ko({context:this.context}),this._feedbackR=new ko({context:this.context}),this._feedbackSplit=new qa({context:this.context,channels:2}),this._feedbackMerge=new Fa({context:this.context,channels:2}),this._merge.connect(this._feedbackSplit),this._feedbackMerge.connect(this._split),this._feedbackSplit.connect(this._feedbackL,0,0),this._feedbackL.connect(this._feedbackMerge,0,0),this._feedbackSplit.connect(this._feedbackR,1,0),this._feedbackR.connect(this._feedbackMerge,0,1),this.feedback.fan(this._feedbackL.gain,this._feedbackR.gain),Ui(this,["feedback"])}static getDefaults(){return Object.assign(Ia.getDefaults(),{feedback:.5})}dispose(){return super.dispose(),this.feedback.dispose(),this._feedbackL.dispose(),this._feedbackR.dispose(),this._feedbackSplit.dispose(),this._feedbackMerge.dispose(),this}}class Na extends Va{constructor(){super(Di(Na.getDefaults(),arguments,["frequency","delayTime","depth"])),this.name="Chorus";const t=Di(Na.getDefaults(),arguments,["frequency","delayTime","depth"]);this._depth=t.depth,this._delayTime=t.delayTime/1e3,this._lfoL=new yr({context:this.context,frequency:t.frequency,min:0,max:1}),this._lfoR=new yr({context:this.context,frequency:t.frequency,min:0,max:1,phase:180}),this._delayNodeL=new Fo({context:this.context}),this._delayNodeR=new Fo({context:this.context}),this.frequency=this._lfoL.frequency,Ui(this,["frequency"]),this._lfoL.frequency.connect(this._lfoR.frequency),this.connectEffectLeft(this._delayNodeL),this.connectEffectRight(this._delayNodeR),this._lfoL.connect(this._delayNodeL.delayTime),this._lfoR.connect(this._delayNodeR.delayTime),this.depth=this._depth,this.type=t.type,this.spread=t.spread}static getDefaults(){return Object.assign(Va.getDefaults(),{frequency:1.5,delayTime:3.5,depth:.7,type:"sine",spread:180,feedback:0,wet:.5})}get depth(){return this._depth}set depth(t){this._depth=t;const e=this._delayTime*t;this._lfoL.min=Math.max(this._delayTime-e,0),this._lfoL.max=this._delayTime+e,this._lfoR.min=Math.max(this._delayTime-e,0),this._lfoR.max=this._delayTime+e}get delayTime(){return 1e3*this._delayTime}set delayTime(t){this._delayTime=t/1e3,this.depth=this._depth}get type(){return this._lfoL.type}set type(t){this._lfoL.type=t,this._lfoR.type=t}get spread(){return this._lfoR.phase-this._lfoL.phase}set spread(t){this._lfoL.phase=90-t/2,this._lfoR.phase=t/2+90}start(t){return this._lfoL.start(t),this._lfoR.start(t),this}stop(t){return this._lfoL.stop(t),this._lfoR.stop(t),this}sync(){return this._lfoL.sync(),this._lfoR.sync(),this}unsync(){return this._lfoL.unsync(),this._lfoR.unsync(),this}dispose(){return super.dispose(),this._lfoL.dispose(),this._lfoR.dispose(),this._delayNodeL.dispose(),this._delayNodeR.dispose(),this.frequency.dispose(),this}}class Pa extends Ta{constructor(){super(Di(Pa.getDefaults(),arguments,["distortion"])),this.name="Distortion";const t=Di(Pa.getDefaults(),arguments,["distortion"]);this._shaper=new rr({context:this.context,length:4096}),this._distortion=t.distortion,this.connectEffect(this._shaper),this.distortion=t.distortion,this.oversample=t.oversample}static getDefaults(){return Object.assign(Ta.getDefaults(),{distortion:.4,oversample:"none"})}get distortion(){return this._distortion}set distortion(t){this._distortion=t;const e=100*t,s=Math.PI/180;this._shaper.setMap(t=>Math.abs(t)<.001?0:(3+e)*t*20*s/(Math.PI+e*Math.abs(t)))}get oversample(){return this._shaper.oversample}set oversample(t){this._shaper.oversample=t}dispose(){return super.dispose(),this._shaper.dispose(),this}}class ja extends Ta{constructor(t){super(t),this.name="FeedbackEffect",this._feedbackGain=new ko({context:this.context,gain:t.feedback,units:"normalRange"}),this.feedback=this._feedbackGain.gain,Ui(this,"feedback"),this.effectReturn.chain(this._feedbackGain,this.effectSend)}static getDefaults(){return Object.assign(Ta.getDefaults(),{feedback:.125})}dispose(){return super.dispose(),this._feedbackGain.dispose(),this.feedback.dispose(),this}}class La extends ja{constructor(){super(Di(La.getDefaults(),arguments,["delayTime","feedback"])),this.name="FeedbackDelay";const t=Di(La.getDefaults(),arguments,["delayTime","feedback"]);this._delayNode=new Fo({context:this.context,delayTime:t.delayTime,maxDelay:t.maxDelay}),this.delayTime=this._delayNode.delayTime,this.connectEffect(this._delayNode),Ui(this,"delayTime")}static getDefaults(){return Object.assign(ja.getDefaults(),{delayTime:.25,maxDelay:1})}dispose(){return super.dispose(),this._delayNode.dispose(),this.delayTime.dispose(),this}}class za extends wo{constructor(t){super(t),this.name="PhaseShiftAllpass",this.input=new ko({context:this.context}),this.output=new ko({context:this.context}),this.offset90=new ko({context:this.context});this._bank0=this._createAllPassFilterBank([.6923878,.9360654322959,.988229522686,.9987488452737]),this._bank1=this._createAllPassFilterBank([.4021921162426,.856171088242,.9722909545651,.9952884791278]),this._oneSampleDelay=this.context.createIIRFilter([0,1],[1,0]),bo(this.input,...this._bank0,this._oneSampleDelay,this.output),bo(this.input,...this._bank1,this.offset90)}_createAllPassFilterBank(t){return t.map(t=>{const e=[[t*t,0,-1],[1,0,-t*t]];return this.context.createIIRFilter(e[0],e[1])})}dispose(){return super.dispose(),this.input.dispose(),this.output.dispose(),this.offset90.dispose(),this._bank0.forEach(t=>t.disconnect()),this._bank1.forEach(t=>t.disconnect()),this._oneSampleDelay.disconnect(),this}}class Ba extends Ta{constructor(){super(Di(Ba.getDefaults(),arguments,["frequency"])),this.name="FrequencyShifter";const t=Di(Ba.getDefaults(),arguments,["frequency"]);this.frequency=new Do({context:this.context,units:"frequency",value:t.frequency,minValue:-this.context.sampleRate/2,maxValue:this.context.sampleRate/2}),this._sine=new nr({context:this.context,type:"sine"}),this._cosine=new ir({context:this.context,phase:-90,type:"sine"}),this._sineMultiply=new cr({context:this.context}),this._cosineMultiply=new cr({context:this.context}),this._negate=new Ar({context:this.context}),this._add=new mr({context:this.context}),this._phaseShifter=new za({context:this.context}),this.effectSend.connect(this._phaseShifter),this.frequency.fan(this._sine.frequency,this._cosine.frequency),this._phaseShifter.offset90.connect(this._cosineMultiply),this._cosine.connect(this._cosineMultiply.factor),this._phaseShifter.connect(this._sineMultiply),this._sine.connect(this._sineMultiply.factor),this._sineMultiply.connect(this._negate),this._cosineMultiply.connect(this._add),this._negate.connect(this._add.addend),this._add.connect(this.effectReturn);const e=this.immediate();this._sine.start(e),this._cosine.start(e)}static getDefaults(){return Object.assign(Ta.getDefaults(),{frequency:0})}dispose(){return super.dispose(),this.frequency.dispose(),this._add.dispose(),this._cosine.dispose(),this._cosineMultiply.dispose(),this._negate.dispose(),this._phaseShifter.dispose(),this._sine.dispose(),this._sineMultiply.dispose(),this}}const Wa=[1557/44100,1617/44100,1491/44100,1422/44100,1277/44100,1356/44100,1188/44100,1116/44100],Ga=[225,556,441,341];class Ua extends Ia{constructor(){super(Di(Ua.getDefaults(),arguments,["roomSize","dampening"])),this.name="Freeverb",this._combFilters=[],this._allpassFiltersL=[],this._allpassFiltersR=[];const t=Di(Ua.getDefaults(),arguments,["roomSize","dampening"]);this.roomSize=new Do({context:this.context,value:t.roomSize,units:"normalRange"}),this._allpassFiltersL=Ga.map(t=>{const e=this.context.createBiquadFilter();return e.type="allpass",e.frequency.value=t,e}),this._allpassFiltersR=Ga.map(t=>{const e=this.context.createBiquadFilter();return e.type="allpass",e.frequency.value=t,e}),this._combFilters=Wa.map((e,s)=>{const n=new ia({context:this.context,dampening:t.dampening,delayTime:e});return s<Wa.length/2?this.connectEffectLeft(n,...this._allpassFiltersL):this.connectEffectRight(n,...this._allpassFiltersR),this.roomSize.connect(n.resonance),n}),Ui(this,["roomSize"])}static getDefaults(){return Object.assign(Ia.getDefaults(),{roomSize:.7,dampening:3e3})}get dampening(){return this._combFilters[0].dampening}set dampening(t){this._combFilters.forEach(e=>e.dampening=t)}dispose(){return super.dispose(),this._allpassFiltersL.forEach(t=>t.disconnect()),this._allpassFiltersR.forEach(t=>t.disconnect()),this._combFilters.forEach(t=>t.dispose()),this.roomSize.dispose(),this}}const Qa=[.06748,.06404,.08212,.09004],Za=[.773,.802,.753,.733],Xa=[347,113,37];class Ya extends Ia{constructor(){super(Di(Ya.getDefaults(),arguments,["roomSize"])),this.name="JCReverb",this._allpassFilters=[],this._feedbackCombFilters=[];const t=Di(Ya.getDefaults(),arguments,["roomSize"]);this.roomSize=new Do({context:this.context,value:t.roomSize,units:"normalRange"}),this._scaleRoomSize=new gr({context:this.context,min:-.733,max:.197}),this._allpassFilters=Xa.map(t=>{const e=this.context.createBiquadFilter();return e.type="allpass",e.frequency.value=t,e}),this._feedbackCombFilters=Qa.map((t,e)=>{const s=new sa({context:this.context,delayTime:t});return this._scaleRoomSize.connect(s.resonance),s.resonance.value=Za[e],e<Qa.length/2?this.connectEffectLeft(...this._allpassFilters,s):this.connectEffectRight(...this._allpassFilters,s),s}),this.roomSize.connect(this._scaleRoomSize),Ui(this,["roomSize"])}static getDefaults(){return Object.assign(Ia.getDefaults(),{roomSize:.5})}dispose(){return super.dispose(),this._allpassFilters.forEach(t=>t.disconnect()),this._feedbackCombFilters.forEach(t=>t.dispose()),this.roomSize.dispose(),this._scaleRoomSize.dispose(),this}}class Ha extends Va{constructor(t){super(t),this._feedbackL.disconnect(),this._feedbackL.connect(this._feedbackMerge,0,1),this._feedbackR.disconnect(),this._feedbackR.connect(this._feedbackMerge,0,0),Ui(this,["feedback"])}}class $a extends Ha{constructor(){super(Di($a.getDefaults(),arguments,["delayTime","feedback"])),this.name="PingPongDelay";const t=Di($a.getDefaults(),arguments,["delayTime","feedback"]);this._leftDelay=new Fo({context:this.context,maxDelay:t.maxDelay}),this._rightDelay=new Fo({context:this.context,maxDelay:t.maxDelay}),this._rightPreDelay=new Fo({context:this.context,maxDelay:t.maxDelay}),this.delayTime=new Do({context:this.context,units:"time",value:t.delayTime}),this.connectEffectLeft(this._leftDelay),this.connectEffectRight(this._rightPreDelay,this._rightDelay),this.delayTime.fan(this._leftDelay.delayTime,this._rightDelay.delayTime,this._rightPreDelay.delayTime),this._feedbackL.disconnect(),this._feedbackL.connect(this._rightDelay),Ui(this,["delayTime"])}static getDefaults(){return Object.assign(Ha.getDefaults(),{delayTime:.25,maxDelay:1})}dispose(){return super.dispose(),this._leftDelay.dispose(),this._rightDelay.dispose(),this._rightPreDelay.dispose(),this.delayTime.dispose(),this}}class Ja extends ja{constructor(){super(Di(Ja.getDefaults(),arguments,["pitch"])),this.name="PitchShift";const t=Di(Ja.getDefaults(),arguments,["pitch"]);this._frequency=new Do({context:this.context}),this._delayA=new Fo({maxDelay:1,context:this.context}),this._lfoA=new yr({context:this.context,min:0,max:.1,type:"sawtooth"}).connect(this._delayA.delayTime),this._delayB=new Fo({maxDelay:1,context:this.context}),this._lfoB=new yr({context:this.context,min:0,max:.1,type:"sawtooth",phase:180}).connect(this._delayB.delayTime),this._crossFade=new ba({context:this.context}),this._crossFadeLFO=new yr({context:this.context,min:0,max:1,type:"triangle",phase:90}).connect(this._crossFade.fade),this._feedbackDelay=new Fo({delayTime:t.delayTime,context:this.context}),this.delayTime=this._feedbackDelay.delayTime,Ui(this,"delayTime"),this._pitch=t.pitch,this._windowSize=t.windowSize,this._delayA.connect(this._crossFade.a),this._delayB.connect(this._crossFade.b),this._frequency.fan(this._lfoA.frequency,this._lfoB.frequency,this._crossFadeLFO.frequency),this.effectSend.fan(this._delayA,this._delayB),this._crossFade.chain(this._feedbackDelay,this.effectReturn);const e=this.now();this._lfoA.start(e),this._lfoB.start(e),this._crossFadeLFO.start(e),this.windowSize=this._windowSize}static getDefaults(){return Object.assign(ja.getDefaults(),{pitch:0,windowSize:.1,delayTime:0,feedback:0})}get pitch(){return this._pitch}set pitch(t){this._pitch=t;let e=0;t<0?(this._lfoA.min=0,this._lfoA.max=this._windowSize,this._lfoB.min=0,this._lfoB.max=this._windowSize,e=no(t-1)+1):(this._lfoA.min=this._windowSize,this._lfoA.max=0,this._lfoB.min=this._windowSize,this._lfoB.max=0,e=no(t)-1),this._frequency.value=e*(1.2/this._windowSize)}get windowSize(){return this._windowSize}set windowSize(t){this._windowSize=this.toSeconds(t),this.pitch=this._pitch}dispose(){return super.dispose(),this._frequency.dispose(),this._delayA.dispose(),this._delayB.dispose(),this._lfoA.dispose(),this._lfoB.dispose(),this._crossFade.dispose(),this._crossFadeLFO.dispose(),this._feedbackDelay.dispose(),this}}class Ka extends Ia{constructor(){super(Di(Ka.getDefaults(),arguments,["frequency","octaves","baseFrequency"])),this.name="Phaser";const t=Di(Ka.getDefaults(),arguments,["frequency","octaves","baseFrequency"]);this._lfoL=new yr({context:this.context,frequency:t.frequency,min:0,max:1}),this._lfoR=new yr({context:this.context,frequency:t.frequency,min:0,max:1,phase:180}),this._baseFrequency=this.toFrequency(t.baseFrequency),this._octaves=t.octaves,this.Q=new Do({context:this.context,value:t.Q,units:"positive"}),this._filtersL=this._makeFilters(t.stages,this._lfoL),this._filtersR=this._makeFilters(t.stages,this._lfoR),this.frequency=this._lfoL.frequency,this.frequency.value=t.frequency,this.connectEffectLeft(...this._filtersL),this.connectEffectRight(...this._filtersR),this._lfoL.frequency.connect(this._lfoR.frequency),this.baseFrequency=t.baseFrequency,this.octaves=t.octaves,this._lfoL.start(),this._lfoR.start(),Ui(this,["frequency","Q"])}static getDefaults(){return Object.assign(Ia.getDefaults(),{frequency:.5,octaves:3,stages:10,Q:10,baseFrequency:350})}_makeFilters(t,e){const s=[];for(let n=0;n<t;n++){const t=this.context.createBiquadFilter();t.type="allpass",this.Q.connect(t.Q),e.connect(t.frequency),s.push(t)}return s}get octaves(){return this._octaves}set octaves(t){this._octaves=t;const e=this._baseFrequency*Math.pow(2,t);this._lfoL.max=e,this._lfoR.max=e}get baseFrequency(){return this._baseFrequency}set baseFrequency(t){this._baseFrequency=this.toFrequency(t),this._lfoL.min=this._baseFrequency,this._lfoR.min=this._baseFrequency,this.octaves=this._octaves}dispose(){return super.dispose(),this.Q.dispose(),this._lfoL.dispose(),this._lfoR.dispose(),this._filtersL.forEach(t=>t.disconnect()),this._filtersR.forEach(t=>t.disconnect()),this.frequency.dispose(),this}}class tc extends Ta{constructor(){super(Di(tc.getDefaults(),arguments,["decay"])),this.name="Reverb",this._convolver=this.context.createConvolver(),this.ready=Promise.resolve();const t=Di(tc.getDefaults(),arguments,["decay"]);this._decay=t.decay,this._preDelay=t.preDelay,this.generate(),this.connectEffect(this._convolver)}static getDefaults(){return Object.assign(Ta.getDefaults(),{decay:1.5,preDelay:.01})}get decay(){return this._decay}set decay(t){ei(t=this.toSeconds(t),.001),this._decay=t,this.generate()}get preDelay(){return this._preDelay}set preDelay(t){ei(t=this.toSeconds(t),0),this._preDelay=t,this.generate()}generate(){return yi(this,void 0,void 0,(function*(){const t=this.ready,e=new Yi(2,this._decay+this._preDelay,this.context.sampleRate),s=new Jo({context:e}),n=new Jo({context:e}),i=new Fa({context:e});s.connect(i,0,0),n.connect(i,0,1);const o=new ko({context:e}).toDestination();i.connect(o),s.start(0),n.start(0),o.gain.setValueAtTime(0,0),o.gain.setValueAtTime(1,this._preDelay),o.gain.exponentialApproachValueAtTime(0,this._preDelay,this.decay);const r=e.render();return this.ready=r.then(Zi),yield t,this._convolver.buffer=(yield r).get(),this}))}dispose(){return super.dispose(),this._convolver.disconnect(),this}}class ec extends wo{constructor(){super(Di(ec.getDefaults(),arguments)),this.name="MidSideSplit",this._split=this.input=new qa({channels:2,context:this.context}),this._midAdd=new mr({context:this.context}),this.mid=new cr({context:this.context,value:Math.SQRT1_2}),this._sideSubtract=new Dr({context:this.context}),this.side=new cr({context:this.context,value:Math.SQRT1_2}),this._split.connect(this._midAdd,0),this._split.connect(this._midAdd.addend,1),this._split.connect(this._sideSubtract,0),this._split.connect(this._sideSubtract.subtrahend,1),this._midAdd.connect(this.mid),this._sideSubtract.connect(this.side)}dispose(){return super.dispose(),this.mid.dispose(),this.side.dispose(),this._midAdd.dispose(),this._sideSubtract.dispose(),this._split.dispose(),this}}class sc extends wo{constructor(){super(Di(sc.getDefaults(),arguments)),this.name="MidSideMerge",this.mid=new ko({context:this.context}),this.side=new ko({context:this.context}),this._left=new mr({context:this.context}),this._leftMult=new cr({context:this.context,value:Math.SQRT1_2}),this._right=new Dr({context:this.context}),this._rightMult=new cr({context:this.context,value:Math.SQRT1_2}),this._merge=this.output=new Fa({context:this.context}),this.mid.fan(this._left),this.side.connect(this._left.addend),this.mid.connect(this._right),this.side.connect(this._right.subtrahend),this._left.connect(this._leftMult),this._right.connect(this._rightMult),this._leftMult.connect(this._merge,0,0),this._rightMult.connect(this._merge,0,1)}dispose(){return super.dispose(),this.mid.dispose(),this.side.dispose(),this._leftMult.dispose(),this._rightMult.dispose(),this._left.dispose(),this._right.dispose(),this}}class nc extends Ta{constructor(t){super(t),this.name="MidSideEffect",this._midSideMerge=new sc({context:this.context}),this._midSideSplit=new ec({context:this.context}),this._midSend=this._midSideSplit.mid,this._sideSend=this._midSideSplit.side,this._midReturn=this._midSideMerge.mid,this._sideReturn=this._midSideMerge.side,this.effectSend.connect(this._midSideSplit),this._midSideMerge.connect(this.effectReturn)}connectEffectMid(...t){this._midSend.chain(...t,this._midReturn)}connectEffectSide(...t){this._sideSend.chain(...t,this._sideReturn)}dispose(){return super.dispose(),this._midSideSplit.dispose(),this._midSideMerge.dispose(),this._midSend.dispose(),this._sideSend.dispose(),this._midReturn.dispose(),this._sideReturn.dispose(),this}}class ic extends nc{constructor(){super(Di(ic.getDefaults(),arguments,["width"])),this.name="StereoWidener";const t=Di(ic.getDefaults(),arguments,["width"]);this.width=new Do({context:this.context,value:t.width,units:"normalRange"}),Ui(this,["width"]),this._twoTimesWidthMid=new cr({context:this.context,value:2}),this._twoTimesWidthSide=new cr({context:this.context,value:2}),this._midMult=new cr({context:this.context}),this._twoTimesWidthMid.connect(this._midMult.factor),this.connectEffectMid(this._midMult),this._oneMinusWidth=new Dr({context:this.context}),this._oneMinusWidth.connect(this._twoTimesWidthMid),To(this.context.getConstant(1),this._oneMinusWidth),this.width.connect(this._oneMinusWidth.subtrahend),this._sideMult=new cr({context:this.context}),this.width.connect(this._twoTimesWidthSide),this._twoTimesWidthSide.connect(this._sideMult.factor),this.connectEffectSide(this._sideMult)}static getDefaults(){return Object.assign(nc.getDefaults(),{width:.5})}dispose(){return super.dispose(),this.width.dispose(),this._midMult.dispose(),this._sideMult.dispose(),this._twoTimesWidthMid.dispose(),this._twoTimesWidthSide.dispose(),this._oneMinusWidth.dispose(),this}}class oc extends Ia{constructor(){super(Di(oc.getDefaults(),arguments,["frequency","depth"])),this.name="Tremolo";const t=Di(oc.getDefaults(),arguments,["frequency","depth"]);this._lfoL=new yr({context:this.context,type:t.type,min:1,max:0}),this._lfoR=new yr({context:this.context,type:t.type,min:1,max:0}),this._amplitudeL=new ko({context:this.context}),this._amplitudeR=new ko({context:this.context}),this.frequency=new Do({context:this.context,value:t.frequency,units:"frequency"}),this.depth=new Do({context:this.context,value:t.depth,units:"normalRange"}),Ui(this,["frequency","depth"]),this.connectEffectLeft(this._amplitudeL),this.connectEffectRight(this._amplitudeR),this._lfoL.connect(this._amplitudeL.gain),this._lfoR.connect(this._amplitudeR.gain),this.frequency.fan(this._lfoL.frequency,this._lfoR.frequency),this.depth.fan(this._lfoR.amplitude,this._lfoL.amplitude),this.spread=t.spread}static getDefaults(){return Object.assign(Ia.getDefaults(),{frequency:10,type:"sine",depth:.5,spread:180})}start(t){return this._lfoL.start(t),this._lfoR.start(t),this}stop(t){return this._lfoL.stop(t),this._lfoR.stop(t),this}sync(){return this._lfoL.sync(),this._lfoR.sync(),this.context.transport.syncSignal(this.frequency),this}unsync(){return this._lfoL.unsync(),this._lfoR.unsync(),this.context.transport.unsyncSignal(this.frequency),this}get type(){return this._lfoL.type}set type(t){this._lfoL.type=t,this._lfoR.type=t}get spread(){return this._lfoR.phase-this._lfoL.phase}set spread(t){this._lfoL.phase=90-t/2,this._lfoR.phase=t/2+90}dispose(){return super.dispose(),this._lfoL.dispose(),this._lfoR.dispose(),this._amplitudeL.dispose(),this._amplitudeR.dispose(),this.frequency.dispose(),this.depth.dispose(),this}}class rc extends Ta{constructor(){super(Di(rc.getDefaults(),arguments,["frequency","depth"])),this.name="Vibrato";const t=Di(rc.getDefaults(),arguments,["frequency","depth"]);this._delayNode=new Fo({context:this.context,delayTime:0,maxDelay:t.maxDelay}),this._lfo=new yr({context:this.context,type:t.type,min:0,max:t.maxDelay,frequency:t.frequency,phase:-90}).start().connect(this._delayNode.delayTime),this.frequency=this._lfo.frequency,this.depth=this._lfo.amplitude,this.depth.value=t.depth,Ui(this,["frequency","depth"]),this.effectSend.chain(this._delayNode,this.effectReturn)}static getDefaults(){return Object.assign(Ta.getDefaults(),{maxDelay:.005,frequency:5,depth:.1,type:"sine"})}get type(){return this._lfo.type}set type(t){this._lfo.type=t}dispose(){return super.dispose(),this._delayNode.dispose(),this._lfo.dispose(),this.frequency.dispose(),this.depth.dispose(),this}}class ac extends wo{constructor(){super(Di(ac.getDefaults(),arguments,["type","size"])),this.name="Analyser",this._analysers=[],this._buffers=[];const t=Di(ac.getDefaults(),arguments,["type","size"]);this.input=this.output=this._gain=new ko({context:this.context}),this._split=new qa({context:this.context,channels:t.channels}),this.input.connect(this._split),ei(t.channels,1);for(let e=0;e<t.channels;e++)this._analysers[e]=this.context.createAnalyser(),this._split.connect(this._analysers[e],e,0);this.size=t.size,this.type=t.type}static getDefaults(){return Object.assign(wo.getDefaults(),{size:1024,smoothing:.8,type:"fft",channels:1})}getValue(){return this._analysers.forEach((t,e)=>{const s=this._buffers[e];"fft"===this._type?t.getFloatFrequencyData(s):"waveform"===this._type&&t.getFloatTimeDomainData(s)}),1===this.channels?this._buffers[0]:this._buffers}get size(){return this._analysers[0].frequencyBinCount}set size(t){this._analysers.forEach((e,s)=>{e.fftSize=2*t,this._buffers[s]=new Float32Array(t)})}get channels(){return this._analysers.length}get type(){return this._type}set type(t){ti("waveform"===t||"fft"===t,"Analyser: invalid type: "+t),this._type=t}get smoothing(){return this._analysers[0].smoothingTimeConstant}set smoothing(t){this._analysers.forEach(e=>e.smoothingTimeConstant=t)}dispose(){return super.dispose(),this._analysers.forEach(t=>t.disconnect()),this._split.dispose(),this._gain.dispose(),this}}class cc extends wo{constructor(){super(Di(cc.getDefaults(),arguments)),this.name="MeterBase",this.input=this.output=this._analyser=new ac({context:this.context,size:256,type:"waveform"})}dispose(){return super.dispose(),this._analyser.dispose(),this}}class hc extends cc{constructor(){super(Di(hc.getDefaults(),arguments,["smoothing"])),this.name="Meter",this._rms=0;const t=Di(hc.getDefaults(),arguments,["smoothing"]);this.input=this.output=this._analyser=new ac({context:this.context,size:256,type:"waveform",channels:t.channels}),this.smoothing=t.smoothing,this.normalRange=t.normalRange}static getDefaults(){return Object.assign(cc.getDefaults(),{smoothing:.8,normalRange:!1,channels:1})}getLevel(){return ri("'getLevel' has been changed to 'getValue'"),this.getValue()}getValue(){const t=this._analyser.getValue(),e=(1===this.channels?[t]:t).map(t=>{const e=t.reduce((t,e)=>t+e*e,0),s=Math.sqrt(e/t.length);return this._rms=Math.max(s,this._rms*this.smoothing),this.normalRange?this._rms:so(this._rms)});return 1===this.channels?e[0]:e}get channels(){return this._analyser.channels}dispose(){return super.dispose(),this._analyser.dispose(),this}}class uc extends cc{constructor(){super(Di(uc.getDefaults(),arguments,["size"])),this.name="FFT";const t=Di(uc.getDefaults(),arguments,["size"]);this.normalRange=t.normalRange,this._analyser.type="fft",this.size=t.size}static getDefaults(){return Object.assign(wo.getDefaults(),{normalRange:!1,size:1024,smoothing:.8})}getValue(){return this._analyser.getValue().map(t=>this.normalRange?eo(t):t)}get size(){return this._analyser.size}set size(t){this._analyser.size=t}get smoothing(){return this._analyser.smoothing}set smoothing(t){this._analyser.smoothing=t}getFrequencyOfIndex(t){return ti(0<=t&&t<this.size,"index must be greater than or equal to 0 and less than "+this.size),t*this.context.sampleRate/(2*this.size)}}class lc extends cc{constructor(){super(Di(lc.getDefaults(),arguments)),this.name="DCMeter",this._analyser.type="waveform",this._analyser.size=256}getValue(){return this._analyser.getValue()[0]}}class pc extends cc{constructor(){super(Di(pc.getDefaults(),arguments,["size"])),this.name="Waveform";const t=Di(pc.getDefaults(),arguments,["size"]);this._analyser.type="waveform",this.size=t.size}static getDefaults(){return Object.assign(cc.getDefaults(),{size:1024})}getValue(){return this._analyser.getValue()}get size(){return this._analyser.size}set size(t){this._analyser.size=t}}class dc extends wo{constructor(){super(Di(dc.getDefaults(),arguments,["solo"])),this.name="Solo";const t=Di(dc.getDefaults(),arguments,["solo"]);this.input=this.output=new ko({context:this.context}),dc._allSolos.has(this.context)||dc._allSolos.set(this.context,new Set),dc._allSolos.get(this.context).add(this),this.solo=t.solo}static getDefaults(){return Object.assign(wo.getDefaults(),{solo:!1})}get solo(){return this._isSoloed()}set solo(t){t?this._addSolo():this._removeSolo(),dc._allSolos.get(this.context).forEach(t=>t._updateSolo())}get muted(){return 0===this.input.gain.value}_addSolo(){dc._soloed.has(this.context)||dc._soloed.set(this.context,new Set),dc._soloed.get(this.context).add(this)}_removeSolo(){dc._soloed.has(this.context)&&dc._soloed.get(this.context).delete(this)}_isSoloed(){return dc._soloed.has(this.context)&&dc._soloed.get(this.context).has(this)}_noSolos(){return!dc._soloed.has(this.context)||dc._soloed.has(this.context)&&0===dc._soloed.get(this.context).size}_updateSolo(){this._isSoloed()||this._noSolos()?this.input.gain.value=1:this.input.gain.value=0}dispose(){return super.dispose(),dc._allSolos.get(this.context).delete(this),this._removeSolo(),this}}dc._allSolos=new Map,dc._soloed=new Map;class fc extends wo{constructor(){super(Di(fc.getDefaults(),arguments,["pan","volume"])),this.name="PanVol";const t=Di(fc.getDefaults(),arguments,["pan","volume"]);this._panner=this.input=new Ca({context:this.context,pan:t.pan,channelCount:t.channelCount}),this.pan=this._panner.pan,this._volume=this.output=new Go({context:this.context,volume:t.volume}),this.volume=this._volume.volume,this._panner.connect(this._volume),this.mute=t.mute,Ui(this,["pan","volume"])}static getDefaults(){return Object.assign(wo.getDefaults(),{mute:!1,pan:0,volume:0,channelCount:1})}get mute(){return this._volume.mute}set mute(t){this._volume.mute=t}dispose(){return super.dispose(),this._panner.dispose(),this.pan.dispose(),this._volume.dispose(),this.volume.dispose(),this}}class _c extends wo{constructor(){super(Di(_c.getDefaults(),arguments,["volume","pan"])),this.name="Channel";const t=Di(_c.getDefaults(),arguments,["volume","pan"]);this._solo=this.input=new dc({solo:t.solo,context:this.context}),this._panVol=this.output=new fc({context:this.context,pan:t.pan,volume:t.volume,mute:t.mute,channelCount:t.channelCount}),this.pan=this._panVol.pan,this.volume=this._panVol.volume,this._solo.connect(this._panVol),Ui(this,["pan","volume"])}static getDefaults(){return Object.assign(wo.getDefaults(),{pan:0,volume:0,mute:!1,solo:!1,channelCount:1})}get solo(){return this._solo.solo}set solo(t){this._solo.solo=t}get muted(){return this._solo.muted||this.mute}get mute(){return this._panVol.mute}set mute(t){this._panVol.mute=t}_getBus(t){return _c.buses.has(t)||_c.buses.set(t,new ko({context:this.context})),_c.buses.get(t)}send(t,e=0){const s=this._getBus(t),n=new ko({context:this.context,units:"decibels",gain:e});return this.connect(n),n.connect(s),n}receive(t){return this._getBus(t).connect(this),this}dispose(){return super.dispose(),this._panVol.dispose(),this.pan.dispose(),this.volume.dispose(),this._solo.dispose(),this}}_c.buses=new Map;class mc extends wo{constructor(){super(Di(mc.getDefaults(),arguments)),this.name="Mono",this.input=new ko({context:this.context}),this._merge=this.output=new Fa({channels:2,context:this.context}),this.input.connect(this._merge,0,0),this.input.connect(this._merge,0,1)}dispose(){return super.dispose(),this._merge.dispose(),this.input.dispose(),this}}class gc extends wo{constructor(){super(Di(gc.getDefaults(),arguments,["lowFrequency","highFrequency"])),this.name="MultibandSplit",this.input=new ko({context:this.context}),this.output=void 0,this.low=new Wr({context:this.context,frequency:0,type:"lowpass"}),this._lowMidFilter=new Wr({context:this.context,frequency:0,type:"highpass"}),this.mid=new Wr({context:this.context,frequency:0,type:"lowpass"}),this.high=new Wr({context:this.context,frequency:0,type:"highpass"}),this._internalChannels=[this.low,this.mid,this.high];const t=Di(gc.getDefaults(),arguments,["lowFrequency","highFrequency"]);this.lowFrequency=new Do({context:this.context,units:"frequency",value:t.lowFrequency}),this.highFrequency=new Do({context:this.context,units:"frequency",value:t.highFrequency}),this.Q=new Do({context:this.context,units:"positive",value:t.Q}),this.input.fan(this.low,this.high),this.input.chain(this._lowMidFilter,this.mid),this.lowFrequency.fan(this.low.frequency,this._lowMidFilter.frequency),this.highFrequency.fan(this.mid.frequency,this.high.frequency),this.Q.connect(this.low.Q),this.Q.connect(this._lowMidFilter.Q),this.Q.connect(this.mid.Q),this.Q.connect(this.high.Q),Ui(this,["high","mid","low","highFrequency","lowFrequency"])}static getDefaults(){return Object.assign(wo.getDefaults(),{Q:1,highFrequency:2500,lowFrequency:400})}dispose(){return super.dispose(),Qi(this,["high","mid","low","highFrequency","lowFrequency"]),this.low.dispose(),this._lowMidFilter.dispose(),this.mid.dispose(),this.high.dispose(),this.lowFrequency.dispose(),this.highFrequency.dispose(),this.Q.dispose(),this}}class vc extends wo{constructor(){super(...arguments),this.name="Listener",this.positionX=new xo({context:this.context,param:this.context.rawContext.listener.positionX}),this.positionY=new xo({context:this.context,param:this.context.rawContext.listener.positionY}),this.positionZ=new xo({context:this.context,param:this.context.rawContext.listener.positionZ}),this.forwardX=new xo({context:this.context,param:this.context.rawContext.listener.forwardX}),this.forwardY=new xo({context:this.context,param:this.context.rawContext.listener.forwardY}),this.forwardZ=new xo({context:this.context,param:this.context.rawContext.listener.forwardZ}),this.upX=new xo({context:this.context,param:this.context.rawContext.listener.upX}),this.upY=new xo({context:this.context,param:this.context.rawContext.listener.upY}),this.upZ=new xo({context:this.context,param:this.context.rawContext.listener.upZ})}static getDefaults(){return Object.assign(wo.getDefaults(),{positionX:0,positionY:0,positionZ:0,forwardX:0,forwardY:0,forwardZ:-1,upX:0,upY:1,upZ:0})}dispose(){return super.dispose(),this.positionX.dispose(),this.positionY.dispose(),this.positionZ.dispose(),this.forwardX.dispose(),this.forwardY.dispose(),this.forwardZ.dispose(),this.upX.dispose(),this.upY.dispose(),this.upZ.dispose(),this}}ji(t=>{t.listener=new vc({context:t})}),zi(t=>{t.listener.dispose()});class yc extends wo{constructor(){super(Di(yc.getDefaults(),arguments,["positionX","positionY","positionZ"])),this.name="Panner3D";const t=Di(yc.getDefaults(),arguments,["positionX","positionY","positionZ"]);this._panner=this.input=this.output=this.context.createPanner(),this.panningModel=t.panningModel,this.maxDistance=t.maxDistance,this.distanceModel=t.distanceModel,this.coneOuterGain=t.coneOuterGain,this.coneOuterAngle=t.coneOuterAngle,this.coneInnerAngle=t.coneInnerAngle,this.refDistance=t.refDistance,this.rolloffFactor=t.rolloffFactor,this.positionX=new xo({context:this.context,param:this._panner.positionX,value:t.positionX}),this.positionY=new xo({context:this.context,param:this._panner.positionY,value:t.positionY}),this.positionZ=new xo({context:this.context,param:this._panner.positionZ,value:t.positionZ}),this.orientationX=new xo({context:this.context,param:this._panner.orientationX,value:t.orientationX}),this.orientationY=new xo({context:this.context,param:this._panner.orientationY,value:t.orientationY}),this.orientationZ=new xo({context:this.context,param:this._panner.orientationZ,value:t.orientationZ})}static getDefaults(){return Object.assign(wo.getDefaults(),{coneInnerAngle:360,coneOuterAngle:360,coneOuterGain:0,distanceModel:"inverse",maxDistance:1e4,orientationX:0,orientationY:0,orientationZ:0,panningModel:"equalpower",positionX:0,positionY:0,positionZ:0,refDistance:1,rolloffFactor:1})}setPosition(t,e,s){return this.positionX.value=t,this.positionY.value=e,this.positionZ.value=s,this}setOrientation(t,e,s){return this.orientationX.value=t,this.orientationY.value=e,this.orientationZ.value=s,this}get panningModel(){return this._panner.panningModel}set panningModel(t){this._panner.panningModel=t}get refDistance(){return this._panner.refDistance}set refDistance(t){this._panner.refDistance=t}get rolloffFactor(){return this._panner.rolloffFactor}set rolloffFactor(t){this._panner.rolloffFactor=t}get distanceModel(){return this._panner.distanceModel}set distanceModel(t){this._panner.distanceModel=t}get coneInnerAngle(){return this._panner.coneInnerAngle}set coneInnerAngle(t){this._panner.coneInnerAngle=t}get coneOuterAngle(){return this._panner.coneOuterAngle}set coneOuterAngle(t){this._panner.coneOuterAngle=t}get coneOuterGain(){return this._panner.coneOuterGain}set coneOuterGain(t){this._panner.coneOuterGain=t}get maxDistance(){return this._panner.maxDistance}set maxDistance(t){this._panner.maxDistance=t}dispose(){return super.dispose(),this._panner.disconnect(),this.orientationX.dispose(),this.orientationY.dispose(),this.orientationZ.dispose(),this.positionX.dispose(),this.positionY.dispose(),this.positionZ.dispose(),this}}class xc extends wo{constructor(){super(Di(xc.getDefaults(),arguments)),this.name="Recorder";const t=Di(xc.getDefaults(),arguments);this.input=new ko({context:this.context}),ti(xc.supported,"Media Recorder API is not available"),this._stream=this.context.createMediaStreamDestination(),this.input.connect(this._stream),this._recorder=new MediaRecorder(this._stream.stream,{mimeType:t.mimeType})}static getDefaults(){return wo.getDefaults()}get mimeType(){return this._recorder.mimeType}static get supported(){return null!==mi&&Reflect.has(mi,"MediaRecorder")}get state(){return"inactive"===this._recorder.state?"stopped":"paused"===this._recorder.state?"paused":"started"}start(){return yi(this,void 0,void 0,(function*(){ti("started"!==this.state,"Recorder is already started");const t=new Promise(t=>{const e=()=>{this._recorder.removeEventListener("start",e,!1),t()};this._recorder.addEventListener("start",e,!1)});return this._recorder.start(),yield t}))}stop(){return yi(this,void 0,void 0,(function*(){ti("stopped"!==this.state,"Recorder is not started");const t=new Promise(t=>{const e=s=>{this._recorder.removeEventListener("dataavailable",e,!1),t(s.data)};this._recorder.addEventListener("dataavailable",e,!1)});return this._recorder.stop(),yield t}))}pause(){return ti("started"===this.state,"Recorder must be started"),this._recorder.pause(),this}dispose(){return super.dispose(),this.input.dispose(),this._stream.disconnect(),this}}class wc extends wo{constructor(){super(Di(wc.getDefaults(),arguments,["threshold","ratio"])),this.name="Compressor",this._compressor=this.context.createDynamicsCompressor(),this.input=this._compressor,this.output=this._compressor;const t=Di(wc.getDefaults(),arguments,["threshold","ratio"]);this.threshold=new xo({minValue:this._compressor.threshold.minValue,maxValue:this._compressor.threshold.maxValue,context:this.context,convert:!1,param:this._compressor.threshold,units:"decibels",value:t.threshold}),this.attack=new xo({minValue:this._compressor.attack.minValue,maxValue:this._compressor.attack.maxValue,context:this.context,param:this._compressor.attack,units:"time",value:t.attack}),this.release=new xo({minValue:this._compressor.release.minValue,maxValue:this._compressor.release.maxValue,context:this.context,param:this._compressor.release,units:"time",value:t.release}),this.knee=new xo({minValue:this._compressor.knee.minValue,maxValue:this._compressor.knee.maxValue,context:this.context,convert:!1,param:this._compressor.knee,units:"decibels",value:t.knee}),this.ratio=new xo({minValue:this._compressor.ratio.minValue,maxValue:this._compressor.ratio.maxValue,context:this.context,convert:!1,param:this._compressor.ratio,units:"positive",value:t.ratio}),Ui(this,["knee","release","attack","ratio","threshold"])}static getDefaults(){return Object.assign(wo.getDefaults(),{attack:.003,knee:30,ratio:12,release:.25,threshold:-24})}get reduction(){return this._compressor.reduction}dispose(){return super.dispose(),this._compressor.disconnect(),this.attack.dispose(),this.release.dispose(),this.threshold.dispose(),this.ratio.dispose(),this.knee.dispose(),this}}class bc extends wo{constructor(){super(Object.assign(Di(bc.getDefaults(),arguments,["threshold","smoothing"]))),this.name="Gate";const t=Di(bc.getDefaults(),arguments,["threshold","smoothing"]);this._follower=new Da({context:this.context,smoothing:t.smoothing}),this._gt=new Mr({context:this.context,value:eo(t.threshold)}),this.input=new ko({context:this.context}),this._gate=this.output=new ko({context:this.context}),this.input.connect(this._gate),this.input.chain(this._follower,this._gt,this._gate.gain)}static getDefaults(){return Object.assign(wo.getDefaults(),{smoothing:.1,threshold:-40})}get threshold(){return so(this._gt.value)}set threshold(t){this._gt.value=eo(t)}get smoothing(){return this._follower.smoothing}set smoothing(t){this._follower.smoothing=t}dispose(){return super.dispose(),this.input.dispose(),this._follower.dispose(),this._gt.dispose(),this._gate.dispose(),this}}class Tc extends wo{constructor(){super(Object.assign(Di(Tc.getDefaults(),arguments,["threshold"]))),this.name="Limiter";const t=Di(Tc.getDefaults(),arguments,["threshold"]);this._compressor=this.input=this.output=new wc({context:this.context,ratio:20,attack:.003,release:.01,threshold:t.threshold}),this.threshold=this._compressor.threshold,Ui(this,"threshold")}static getDefaults(){return Object.assign(wo.getDefaults(),{threshold:-12})}get reduction(){return this._compressor.reduction}dispose(){return super.dispose(),this._compressor.dispose(),this.threshold.dispose(),this}}class Sc extends wo{constructor(){super(Object.assign(Di(Sc.getDefaults(),arguments))),this.name="MidSideCompressor";const t=Di(Sc.getDefaults(),arguments);this._midSideSplit=this.input=new ec({context:this.context}),this._midSideMerge=this.output=new sc({context:this.context}),this.mid=new wc(Object.assign(t.mid,{context:this.context})),this.side=new wc(Object.assign(t.side,{context:this.context})),this._midSideSplit.mid.chain(this.mid,this._midSideMerge.mid),this._midSideSplit.side.chain(this.side,this._midSideMerge.side),Ui(this,["mid","side"])}static getDefaults(){return Object.assign(wo.getDefaults(),{mid:{ratio:3,threshold:-24,release:.03,attack:.02,knee:16},side:{ratio:6,threshold:-30,release:.25,attack:.03,knee:10}})}dispose(){return super.dispose(),this.mid.dispose(),this.side.dispose(),this._midSideSplit.dispose(),this._midSideMerge.dispose(),this}}class kc extends wo{constructor(){super(Object.assign(Di(kc.getDefaults(),arguments))),this.name="MultibandCompressor";const t=Di(kc.getDefaults(),arguments);this._splitter=this.input=new gc({context:this.context,lowFrequency:t.lowFrequency,highFrequency:t.highFrequency}),this.lowFrequency=this._splitter.lowFrequency,this.highFrequency=this._splitter.highFrequency,this.output=new ko({context:this.context}),this.low=new wc(Object.assign(t.low,{context:this.context})),this.mid=new wc(Object.assign(t.mid,{context:this.context})),this.high=new wc(Object.assign(t.high,{context:this.context})),this._splitter.low.chain(this.low,this.output),this._splitter.mid.chain(this.mid,this.output),this._splitter.high.chain(this.high,this.output),Ui(this,["high","mid","low","highFrequency","lowFrequency"])}static getDefaults(){return Object.assign(wo.getDefaults(),{lowFrequency:250,highFrequency:2e3,low:{ratio:6,threshold:-30,release:.25,attack:.03,knee:10},mid:{ratio:3,threshold:-24,release:.03,attack:.02,knee:16},high:{ratio:3,threshold:-24,release:.03,attack:.02,knee:16}})}dispose(){return super.dispose(),this._splitter.dispose(),this.low.dispose(),this.mid.dispose(),this.high.dispose(),this.output.dispose(),this}}class Cc extends wo{constructor(){super(Di(Cc.getDefaults(),arguments,["low","mid","high"])),this.name="EQ3",this.output=new ko({context:this.context}),this._internalChannels=[];const t=Di(Cc.getDefaults(),arguments,["low","mid","high"]);this.input=this._multibandSplit=new gc({context:this.context,highFrequency:t.highFrequency,lowFrequency:t.lowFrequency}),this._lowGain=new ko({context:this.context,gain:t.low,units:"decibels"}),this._midGain=new ko({context:this.context,gain:t.mid,units:"decibels"}),this._highGain=new ko({context:this.context,gain:t.high,units:"decibels"}),this.low=this._lowGain.gain,this.mid=this._midGain.gain,this.high=this._highGain.gain,this.Q=this._multibandSplit.Q,this.lowFrequency=this._multibandSplit.lowFrequency,this.highFrequency=this._multibandSplit.highFrequency,this._multibandSplit.low.chain(this._lowGain,this.output),this._multibandSplit.mid.chain(this._midGain,this.output),this._multibandSplit.high.chain(this._highGain,this.output),Ui(this,["low","mid","high","lowFrequency","highFrequency"]),this._internalChannels=[this._multibandSplit]}static getDefaults(){return Object.assign(wo.getDefaults(),{high:0,highFrequency:2500,low:0,lowFrequency:400,mid:0})}dispose(){return super.dispose(),Qi(this,["low","mid","high","lowFrequency","highFrequency"]),this._multibandSplit.dispose(),this.lowFrequency.dispose(),this.highFrequency.dispose(),this._lowGain.dispose(),this._midGain.dispose(),this._highGain.dispose(),this.low.dispose(),this.mid.dispose(),this.high.dispose(),this.Q.dispose(),this}}class Ac extends wo{constructor(){super(Di(Ac.getDefaults(),arguments,["url","onload"])),this.name="Convolver",this._convolver=this.context.createConvolver();const t=Di(Ac.getDefaults(),arguments,["url","onload"]);this._buffer=new Xi(t.url,e=>{this.buffer=e,t.onload()}),this.input=new ko({context:this.context}),this.output=new ko({context:this.context}),this._buffer.loaded&&(this.buffer=this._buffer),this.normalize=t.normalize,this.input.chain(this._convolver,this.output)}static getDefaults(){return Object.assign(wo.getDefaults(),{normalize:!0,onload:Zi})}load(t){return yi(this,void 0,void 0,(function*(){this.buffer=yield this._buffer.load(t)}))}get buffer(){return this._buffer.length?this._buffer:null}set buffer(t){t&&this._buffer.set(t),this._convolver.buffer&&(this.input.disconnect(),this._convolver.disconnect(),this._convolver=this.context.createConvolver(),this.input.chain(this._convolver,this.output));const e=this._buffer.get();this._convolver.buffer=e||null}get normalize(){return this._convolver.normalize}set normalize(t){this._convolver.normalize=t}dispose(){return super.dispose(),this._buffer.dispose(),this._convolver.disconnect(),this}}function Dc(){return Ji().now()}function Oc(){return Ji().immediate()}const Mc=Ji().transport;function Ec(){return Ji().transport}const Rc=Ji().destination,qc=Ji().destination;function Fc(){return Ji().destination}const Ic=Ji().listener;function Vc(){return Ji().listener}const Nc=Ji().draw;function Pc(){return Ji().draw}const jc=Ji();function Lc(){return Xi.loaded()}const zc=Xi,Bc=Vo,Wc=$o}])}));

},{}],53:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],54:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],55:[function(require,module,exports){
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

'use strict';

var isArgumentsObject = require('is-arguments');
var isGeneratorFunction = require('is-generator-function');
var whichTypedArray = require('which-typed-array');
var isTypedArray = require('is-typed-array');

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});

},{"is-arguments":29,"is-generator-function":31,"is-typed-array":32,"which-typed-array":146}],56:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').slice(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.slice(1, -1);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = require('./support/types');

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

}).call(this)}).call(this,require('_process'))
},{"./support/isBuffer":54,"./support/types":55,"_process":33,"inherits":28}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.abs = function (x) { return _1.NDArray.array(x).abs(); };
_1.NDArray.prototype.abs = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.abs(d1[i]);
    }
    return this;
};

},{"./":93}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.acos = function (x) { return _1.NDArray.array(x).acos(); };
_1.NDArray.prototype.acos = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.acos(d1[i]);
    }
    return this;
};

},{"./":93}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.acosh = function (x) { return _1.NDArray.array(x).acosh(); };
_1.NDArray.prototype.acosh = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.acosh(d1[i]);
    }
    return this;
};

},{"./":93}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
var nblas;
try {
    nblas = require('nblas');
}
catch (err) { }
_1.NDArray.add = function (x, y, alpha) {
    if (alpha === void 0) { alpha = 1; }
    return _1.NDArray.array(x).add(_1.NDArray.array(y), alpha);
};
_1.NDArray.prototype.add = function (x, alpha) {
    if (alpha === void 0) { alpha = 1; }
    this.equilateral(x);
    this.equidimensional(x);
    var l1 = this.length;
    try {
        if (!['float32', 'float64'].includes(this.dtype)) {
            this.dtype = 'float32';
            this.data = util_1.get_type(this.dtype).from(this.data);
        }
        var d1 = this.data;
        var d2 = x.data;
        if (this.dtype === 'float64') {
            nblas.daxpy(l1, alpha, d2, 1, d1, 1);
        }
        else if (this.dtype === 'float32') {
            nblas.saxpy(l1, alpha, d2, 1, d1, 1);
        }
    }
    catch (err) {
        var d1 = this.data;
        var d2 = x.data;
        var i = void 0;
        for (i = 0; i < l1; i += 1) {
            d1[i] += alpha * d2[i];
        }
    }
    return this;
};

},{"../util":145,"./":93,"nblas":3}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.angle = function (x, y) {
    return _1.NDArray.array(x).angle(_1.NDArray.array(y));
};
_1.NDArray.prototype.angle = function (x) {
    return Math.acos(this.dot(x) / this.norm() / x.norm());
};

},{"./":93}],62:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.array = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return new (this.bind.apply(this, __spread([void 0], args)))();
};

},{"./":93}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.asin = function (x) { return _1.NDArray.array(x).asin(); };
_1.NDArray.prototype.asin = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.asin(d1[i]);
    }
    return this;
};

},{"./":93}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.asinh = function (x) { return _1.NDArray.array(x).asinh(); };
_1.NDArray.prototype.asinh = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.asinh(d1[i]);
    }
    return this;
};

},{"./":93}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.atan = function (x) { return _1.NDArray.array(x).atan(); };
_1.NDArray.prototype.atan = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.atan(d1[i]);
    }
    return this;
};

},{"./":93}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.atanh = function (x) { return _1.NDArray.array(x).atanh(); };
_1.NDArray.prototype.atanh = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.atanh(d1[i]);
    }
    return this;
};

},{"./":93}],67:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.augment = function (x, y) {
    return _1.NDArray.array(x).augment(_1.NDArray.array(y));
};
_1.NDArray.prototype.augment = function (x) {
    var _a = __read(this.shape, 2), r1 = _a[0], c1 = _a[1];
    var _b = __read(x.shape, 2), r2 = _b[0], c2 = _b[1];
    var d1 = this.data;
    var d2 = x.data;
    if (r2 === 0 || c2 === 0) {
        return this;
    }
    if (r1 !== r2) {
        throw new Error('rows do not match');
    }
    var y = _1.NDArray.zeros(r1, c1 + c2);
    var d3 = y.data;
    var i;
    var j;
    for (i = 0; i < r1; i += 1) {
        for (j = 0; j < c1; j += 1) {
            d3[i * (c1 + c2) + j] = d1[i * c1 + j];
        }
    }
    for (i = 0; i < r2; i += 1) {
        for (j = 0; j < c2; j += 1) {
            d3[i * (c1 + c2) + (j + c1)] = d2[i * c2 + j];
        }
    }
    return y;
};

},{"./":93}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.binOp = function (x, y, f) { return _1.NDArray.array(x).binOp(_1.NDArray.array(y), f); };
_1.NDArray.prototype.binOp = function (x, f) {
    this.equilateral(x);
    this.equidimensional(x);
    var _a = this, d1 = _a.data, l1 = _a.length;
    var d2 = x.data;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = f(d1[i], d2[i], i);
    }
    return this;
};

},{"./":93}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.cbrt = function (x) { return _1.NDArray.array(x).cbrt(); };
_1.NDArray.prototype.cbrt = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.cbrt(d1[i]);
    }
    return this;
};

},{"./":93}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.ceil = function (x) { return _1.NDArray.array(x).ceil(); };
_1.NDArray.prototype.ceil = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.ceil(d1[i]);
    }
    return this;
};

},{"./":93}],71:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.check = function (x) {
    var _a;
    var indices = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        indices[_i - 1] = arguments[_i];
    }
    (_a = _1.NDArray.array(x)).check.apply(_a, __spread(indices));
};
_1.NDArray.prototype.check = function () {
    var indices = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        indices[_i] = arguments[_i];
    }
    var _a = this, s1 = _a.shape, l1 = _a.length;
    if (indices.length === 1) {
        var _b = __read(indices, 1), i = _b[0];
        if (i < 0 || i > l1 - 1 || !Number.isFinite(i)) {
            throw new Error('index out of bounds');
        }
    }
    else if (!s1.every(function (dim, i) {
        return dim > indices[i]
            && Number.isFinite(indices[i])
            && indices[i] >= 0;
    })) {
        throw new Error('index out of bounds');
    }
};

},{"./":93}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
_1.NDArray.combine = function (x, y) {
    return _1.NDArray.array(x).combine(_1.NDArray.array(y));
};
_1.NDArray.prototype.combine = function (x) {
    if (this.shape.length !== 1 && x.shape.length !== 1) {
        throw new Error('combine operation not permitted for multidimensional arrays');
    }
    var _a = this, l1 = _a.length, d1 = _a.data;
    var l2 = x.length, d2 = x.data;
    if (l2 === 0) {
        return this;
    }
    if (l1 === 0) {
        this.data = new (util_1.get_type(x.dtype))(d2);
        this.length = l2;
        this.dtype = x.dtype;
        return this;
    }
    var l3 = l1 + l2;
    var d3 = new (util_1.get_type(this.dtype))(l3);
    d3.set(d1);
    d3.set(d2, l1);
    this.data = d3;
    this.length = l3;
    this.shape = [l3];
    return this;
};

},{"../util":145,"./":93}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
_1.NDArray.copy = function (x) { return _1.NDArray.array(x).copy(); };
_1.NDArray.prototype.copy = function () {
    var copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
    copy.data = new (util_1.get_type(this.dtype))(this.data);
    copy.shape = this.shape;
    copy.length = this.length;
    copy.dtype = this.dtype;
    return copy;
};

},{"../util":145,"./":93}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.cos = function (x) { return _1.NDArray.array(x).cos(); };
_1.NDArray.prototype.cos = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.cos(d1[i]);
    }
    return this;
};

},{"./":93}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.cosh = function (x) { return _1.NDArray.array(x).cosh(); };
_1.NDArray.prototype.cosh = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.cosh(d1[i]);
    }
    return this;
};

},{"./":93}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.cross = function (x, y) {
    return _1.NDArray.array(x).cross(_1.NDArray.array(y));
};
_1.NDArray.prototype.cross = function (x) {
    var l1 = this.length;
    var l2 = x.length;
    if (l1 !== 3 || l2 !== 3) {
        throw new Error('vectors must have three components');
    }
    var c1 = this.y * x.z - this.z * x.y;
    var c2 = this.z * x.x - this.x * x.z;
    var c3 = this.x * x.y - this.y * x.x;
    this.x = c1;
    this.y = c2;
    this.z = c3;
    return this;
};

},{"./":93}],77:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.det = function (x) { return _1.NDArray.array(x).det(); };
_1.NDArray.prototype.det = function () {
    this.square();
    var _a = __read(this.shape, 1), n = _a[0];
    var _b = __read(this.copy().lu_factor(), 2), LU = _b[0], ipiv = _b[1];
    var d1 = LU.data;
    var product = 1;
    var sign = 1;
    var i;
    for (i = 0; i < n; i += 1) {
        product *= d1[i * n + i];
        if (i !== ipiv[i] - 1) {
            sign *= -1;
        }
    }
    return sign * product;
};

},{"./":93}],78:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.diagonal = function (x) {
    return _1.NDArray.array(x).diagonal();
};
_1.NDArray.prototype.diagonal = function () {
    this.square();
    var l1 = this.length;
    var _a = __read(this.shape, 2), r = _a[0], c = _a[1];
    var l2 = Math.min(r, c);
    return this.reshape(l1).slice(0, l1, l2 + 1);
};

},{"./":93}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
var nblas;
try {
    nblas = require('nblas');
}
catch (err) { }
_1.NDArray.dot = function (x, y) {
    return _1.NDArray.array(x).dot(_1.NDArray.array(y));
};
_1.NDArray.prototype.dot = function (x) {
    this.equilateral(x);
    this.equidimensional(x);
    var l1 = this.length;
    var result = 0;
    try {
        if (!['float32', 'float64'].includes(this.dtype)) {
            this.dtype = 'float32';
            this.data = util_1.get_type(this.dtype).from(this.data);
        }
        var d1 = this.data;
        var d2 = x.data;
        if (this.dtype === 'float64') {
            result = nblas.ddot(l1, d2, 1, d1, 1);
        }
        if (this.dtype === 'float32') {
            result = nblas.sdot(l1, d2, 1, d1, 1);
        }
    }
    catch (err) {
        var d1 = this.data;
        var d2 = x.data;
        var i = void 0;
        for (i = 0; i < l1; i += 1) {
            result += d1[i] * d2[i];
        }
    }
    return result;
};

},{"../util":145,"./":93,"nblas":3}],80:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
var nlapack;
try {
    nlapack = require('nlapack');
}
catch (err) { }
var rotate = function (x, c, s, k, l, i, j) {
    var _a = __read(x.shape, 1), n = _a[0];
    var d1 = x.data;
    var temp = d1[k * n + l];
    var tau = 1 / (c + s);
    d1[k * n + l] = temp - s * (d1[i * n + j] + tau * temp);
    d1[i * n + j] += s * (temp - tau * d1[i * n + j]);
};
_1.NDArray.eig = function (x) { return _1.NDArray.array(x).eig(); };
_1.NDArray.prototype.eig = function () {
    this.square();
    var _a = __read(this.shape, 1), n = _a[0];
    try {
        if (!['float32', 'float64'].includes(this.dtype)) {
            this.dtype = 'float32';
            this.data = util_1.get_type(this.dtype).from(this.data);
        }
        var jobvl = nlapack.NoEigenvector;
        var jobvr = nlapack.Eigenvector;
        var wr = _1.NDArray.zeros(n);
        var wi = _1.NDArray.zeros(n);
        var vl = _1.NDArray.zeros(n, n);
        var vr = _1.NDArray.zeros(n, n);
        var d1 = this.data;
        var d2 = wr.data;
        var d3 = wi.data;
        var d4 = vl.data;
        var d5 = vr.data;
        if (this.dtype === 'float64') {
            nlapack.dgeev(jobvl, jobvr, n, d1, n, d2, d3, d4, n, d5, n);
        }
        if (this.dtype === 'float32') {
            nlapack.sgeev(jobvl, jobvr, n, d1, n, d2, d3, d4, n, d5, n);
        }
        return [wr, vr];
    }
    catch (err) {
        var d1 = this.data;
        var p = _1.NDArray.eye(n);
        var max = 0;
        var i = 0;
        var j = 0;
        var k = 0;
        var l = 0;
        do {
            for (i = 0; i < n; i += 1) {
                for (j = i + 1; j < n; j += 1) {
                    if (Math.abs(d1[i * n + j]) >= max) {
                        max = Math.abs(d1[i * n + j]);
                        k = i;
                        l = j;
                    }
                }
            }
            var t = void 0;
            if (Math.abs(d1[k * n + l]) < Math.abs(d1[l * n + l]) * 1e-36) {
                t = d1[k * n + l] / d1[l * n + l];
            }
            else {
                var phi = d1[l * n + l] / 2 * d1[k * n + l];
                t = 1 / (Math.abs(phi) + Math.sqrt(phi * phi + 1));
            }
            var c = 1 / Math.sqrt(t * t + 1);
            var s = t * c;
            var e = d1[k * n + l];
            d1[k * n + l] = 0;
            d1[k * n + k] -= t * e;
            d1[l * n + l] += t * e;
            for (i = 0; i < k; i += 1) {
                rotate(this, c, s, i, k, i, l);
            }
            for (i = k + 1; i < l; i += 1) {
                rotate(this, c, s, k, i, i, l);
            }
            for (i = l + 1; i < n; i += 1) {
                rotate(this, c, s, k, i, l, i);
            }
            for (i = 0; i < n; i += 1) {
                rotate(p, c, s, i, k, i, l);
            }
        } while (max >= 1e-9);
        return [this.diagonal(), p];
    }
};

},{"../util":145,"./":93,"nlapack":3}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.equals = function (x, y) {
    return _1.NDArray.array(x).equals(_1.NDArray.array(y));
};
_1.NDArray.prototype.equals = function (x) {
    this.equilateral(x);
    this.equidimensional(x);
    var _a = this, d1 = _a.data, l1 = _a.length;
    var d2 = x.data;
    var i;
    for (i = 0; i < l1; i += 1) {
        if (d1[i] !== d2[i]) {
            return false;
        }
    }
    return true;
};

},{"./":93}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.equidimensional = function (x, y) {
    _1.NDArray.array(x).equidimensional(_1.NDArray.array(y));
};
_1.NDArray.prototype.equidimensional = function (x) {
    var s1 = this.shape;
    var s2 = x.shape;
    if (!s1.every(function (dim, i) { return dim === s2[i]; })) {
        throw new Error("shapes " + s1 + " and " + s2 + " do not match");
    }
};

},{"./":93}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.equilateral = function (x, y) {
    _1.NDArray.array(x).equilateral(_1.NDArray.array(y));
};
_1.NDArray.prototype.equilateral = function (x) {
    var l1 = this.length;
    var l2 = x.length;
    if (l1 !== l2) {
        throw new Error("lengths " + l1 + " and " + l2 + " do not match");
    }
};

},{"./":93}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.exp = function (x) { return _1.NDArray.array(x).exp(); };
_1.NDArray.prototype.exp = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.exp(d1[i]);
    }
    return this;
};

},{"./":93}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.expm1 = function (x) { return _1.NDArray.array(x).expm1(); };
_1.NDArray.prototype.expm1 = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.expm1(d1[i]);
    }
    return this;
};

},{"./":93}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.eye = function (n) {
    var x = new this(new Float32Array(n * n), { shape: [n, n] });
    var d1 = x.data;
    var i;
    var j;
    for (i = 0; i < n; i += 1) {
        for (j = 0; j < n; j += 1) {
            d1[i * n + j] = i === j ? 1 : 0;
        }
    }
    return x;
};

},{"./":93}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.fill = function (x, value) {
    if (value === void 0) { value = 0; }
    return _1.NDArray.array(x).fill(value);
};
_1.NDArray.prototype.fill = function (value) {
    if (value === void 0) { value = 0; }
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = value instanceof Function ? value(i) : value;
    }
    return this;
};

},{"./":93}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.floor = function (x) { return _1.NDArray.array(x).floor(); };
_1.NDArray.prototype.floor = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.floor(d1[i]);
    }
    return this;
};

},{"./":93}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.forEach = function (x, f) {
    x.forEach(f);
};
_1.NDArray.prototype.forEach = function (f) {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        f.call(this, d1[i], i, d1);
    }
};

},{"./":93}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.fround = function (x) { return _1.NDArray.array(x).fround(); };
_1.NDArray.prototype.fround = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.fround(d1[i]);
    }
    return this;
};

},{"./":93}],91:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.gauss = function (x) { return _1.NDArray.array(x).gauss(); };
_1.NDArray.prototype.gauss = function () {
    var _a = __read(this.shape, 2), r = _a[0], c = _a[1];
    var d1 = this.data;
    var lead = 0;
    var leadValue;
    var pivot;
    var i;
    var j;
    var k;
    for (i = 0; i < r; i += 1) {
        if (c <= lead) {
            return this;
        }
        j = i;
        while (d1[j * c + lead] === 0) {
            j += 1;
            if (r === j) {
                j = i;
                lead += 1;
                if (c === lead) {
                    return this;
                }
            }
        }
        if (i !== j) {
            this.swap(i, j);
        }
        pivot = d1[i * c + lead];
        if (pivot !== 0) {
            for (k = 0; k < c; k += 1) {
                d1[i * c + k] /= pivot;
            }
        }
        for (j = 0; j < r; j += 1) {
            leadValue = d1[j * c + lead];
            if (j !== i) {
                for (k = 0; k < c; k += 1) {
                    d1[j * c + k] -= d1[i * c + k] * leadValue;
                }
            }
        }
        lead += 1;
    }
    for (i = 0; i < r; i += 1) {
        pivot = 0;
        for (j = 0; j < c; j += 1) {
            if (pivot === 0) {
                pivot = d1[i * c + j];
            }
        }
        if (pivot === 0) {
            for (k = 0; k < c; k += 1) {
                d1[i * c + k] /= pivot;
            }
        }
    }
    return this;
};

},{"./":93}],92:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.get = function (x) {
    var _a;
    var indices = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        indices[_i - 1] = arguments[_i];
    }
    return (_a = _1.NDArray.array(x)).get.apply(_a, __spread(indices));
};
_1.NDArray.prototype.get = function () {
    var indices = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        indices[_i] = arguments[_i];
    }
    this.check.apply(this, __spread(indices));
    var _a = this, d1 = _a.data, s1 = _a.shape;
    var ndim = s1.length;
    var index = indices[ndim - 1];
    var i;
    var j;
    for (i = 0; i < ndim - 1; i += 1) {
        var p = 1;
        for (j = i + 1; j < ndim; j += 1) {
            p *= s1[j];
        }
        index += indices[i] * p;
    }
    return d1[index];
};

},{"./":93}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
exports.inspectSymbol = Symbol.for('nodejs.util.inspect.custom');
var NDArray = (function () {
    function NDArray(data, options) {
        this.data = new Float32Array(0);
        this.dtype = 'float32';
        this.length = 0;
        this.shape = [0];
        if (util_1.is_typed_array(data)) {
            this.data = data;
            this.shape = typeof options === 'object' && options.hasOwnProperty('shape') ? options.shape : [this.data.length];
            this.length = this.data.length;
            this.dtype = typeof options === 'object' && options.hasOwnProperty('dtype') ? options.dtype : util_1.get_dtype(data);
        }
        else if (data instanceof Array) {
            this.data = new (util_1.get_type(this.dtype))(util_1.flatten(data));
            this.shape = util_1.get_shape(data);
            this.length = this.data.length;
        }
        else if (data instanceof NDArray) {
            return data.copy();
        }
    }
    Object.defineProperty(NDArray.prototype, "x", {
        get: function () {
            return this.get(0);
        },
        set: function (value) {
            this.set(0, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NDArray.prototype, "y", {
        get: function () {
            return this.get(1);
        },
        set: function (value) {
            this.set(1, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NDArray.prototype, "z", {
        get: function () {
            return this.get(2);
        },
        set: function (value) {
            this.set(2, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NDArray.prototype, "w", {
        get: function () {
            return this.get(3);
        },
        set: function (value) {
            this.set(3, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NDArray.prototype, "T", {
        get: function () {
            return this.transpose();
        },
        enumerable: true,
        configurable: true
    });
    return NDArray;
}());
exports.NDArray = NDArray;
require("./abs");
require("./acos");
require("./acosh");
require("./add");
require("./angle");
require("./array");
require("./asin");
require("./asinh");
require("./atan");
require("./atanh");
require("./augment");
require("./binOp");
require("./cbrt");
require("./ceil");
require("./check");
require("./combine");
require("./copy");
require("./cos");
require("./cosh");
require("./cross");
require("./det");
require("./diagonal");
require("./dot");
require("./eig");
require("./equals");
require("./equidimensional");
require("./equilateral");
require("./exp");
require("./expm1");
require("./eye");
require("./fill");
require("./floor");
require("./forEach");
require("./fround");
require("./gauss");
require("./get");
require("./inv");
require("./log");
require("./log10");
require("./log1p");
require("./log2");
require("./lu");
require("./lu_factor");
require("./magic");
require("./map");
require("./matrix");
require("./max");
require("./mean");
require("./min");
require("./multiply");
require("./norm");
require("./normalize");
require("./ones");
require("./pow");
require("./prod");
require("./product");
require("./project");
require("./push");
require("./random");
require("./range");
require("./rank");
require("./reciprocal");
require("./reduce");
require("./reshape");
require("./round");
require("./row_add");
require("./scale");
require("./set");
require("./sign");
require("./sin");
require("./sinh");
require("./slice");
require("./solve");
require("./sqrt");
require("./square");
require("./subtract");
require("./sum");
require("./swap");
require("./tan");
require("./tanh");
require("./toArray");
require("./toString");
require("./trace");
require("./transpose");
require("./trunc");
require("./zeros");
try {
    window.v = NDArray;
}
catch (error) { }

},{"../util":145,"./abs":57,"./acos":58,"./acosh":59,"./add":60,"./angle":61,"./array":62,"./asin":63,"./asinh":64,"./atan":65,"./atanh":66,"./augment":67,"./binOp":68,"./cbrt":69,"./ceil":70,"./check":71,"./combine":72,"./copy":73,"./cos":74,"./cosh":75,"./cross":76,"./det":77,"./diagonal":78,"./dot":79,"./eig":80,"./equals":81,"./equidimensional":82,"./equilateral":83,"./exp":84,"./expm1":85,"./eye":86,"./fill":87,"./floor":88,"./forEach":89,"./fround":90,"./gauss":91,"./get":92,"./inv":94,"./log":95,"./log10":96,"./log1p":97,"./log2":98,"./lu":99,"./lu_factor":100,"./magic":101,"./map":102,"./matrix":103,"./max":104,"./mean":105,"./min":106,"./multiply":107,"./norm":108,"./normalize":109,"./ones":110,"./pow":111,"./prod":112,"./product":113,"./project":114,"./push":115,"./random":116,"./range":117,"./rank":118,"./reciprocal":119,"./reduce":120,"./reshape":121,"./round":122,"./row_add":123,"./scale":124,"./set":125,"./sign":126,"./sin":127,"./sinh":128,"./slice":129,"./solve":130,"./sqrt":131,"./square":132,"./subtract":133,"./sum":134,"./swap":135,"./tan":136,"./tanh":137,"./toArray":138,"./toString":139,"./trace":140,"./transpose":141,"./trunc":142,"./zeros":143}],94:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
var nlapack;
try {
    nlapack = require('nlapack');
}
catch (err) { }
_1.NDArray.inv = function (x) { return _1.NDArray.array(x).inv(); };
_1.NDArray.prototype.inv = function () {
    this.square();
    var _a = __read(this.shape, 1), n = _a[0];
    try {
        if (!['float32', 'float64'].includes(this.dtype)) {
            this.dtype = 'float32';
            this.data = util_1.get_type(this.dtype).from(this.data);
        }
        var d1 = this.data;
        var ipiv = new Int32Array(n);
        if (this.dtype === 'float64') {
            nlapack.dgetrf(n, n, d1, n, ipiv);
            nlapack.dgetri(n, d1, n, ipiv);
        }
        else if (this.dtype === 'float32') {
            nlapack.sgetrf(n, n, d1, n, ipiv);
            nlapack.sgetri(n, d1, n, ipiv);
        }
        return this;
    }
    catch (err) {
        var eye = _1.NDArray.eye(n);
        var rref = _1.NDArray.augment(this, eye).gauss();
        var left = _1.NDArray.zeros(n, n);
        var right = _1.NDArray.zeros(n, n);
        var d1 = rref.data;
        var d2 = left.data;
        var d3 = right.data;
        var i = void 0;
        var j = void 0;
        for (i = 0; i < n; i += 1) {
            for (j = 0; j < n + n; j += 1) {
                if (j < n) {
                    d2[i * n + j] = d1[i * (n + n) + j];
                }
                else {
                    d3[i * n + (j - n)] = d1[i * (n + n) + j];
                }
            }
        }
        if (!left.equals(eye)) {
            throw new Error('matrix is not invertible');
        }
        return right;
    }
};

},{"../util":145,"./":93,"nlapack":3}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.log = function (x) { return _1.NDArray.array(x).log(); };
_1.NDArray.prototype.log = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.log(d1[i]);
    }
    return this;
};

},{"./":93}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.log10 = function (x) { return _1.NDArray.array(x).log10(); };
_1.NDArray.prototype.log10 = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.log10(d1[i]);
    }
    return this;
};

},{"./":93}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.log1p = function (x) { return _1.NDArray.array(x).log1p(); };
_1.NDArray.prototype.log1p = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.log1p(d1[i]);
    }
    return this;
};

},{"./":93}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.log2 = function (x) { return _1.NDArray.array(x).log2(); };
_1.NDArray.prototype.log2 = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.log2(d1[i]);
    }
    return this;
};

},{"./":93}],99:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.lu = function (x) {
    return _1.NDArray.array(x).lu();
};
_1.NDArray.prototype.lu = function () {
    var _a = __read(this.shape, 2), r = _a[0], c = _a[1];
    var _b = __read(this.copy().lu_factor(), 2), LU = _b[0], ipiv = _b[1];
    var L = LU.copy();
    var T = LU.copy();
    var d1 = L.data;
    var d2 = T.data;
    var i;
    var j;
    for (i = 0; i < r; i += 1) {
        for (j = i; j < c; j += 1) {
            d1[i * c + j] = i === j ? 1 : 0;
        }
    }
    for (i = 0; i < r; i += 1) {
        for (j = 0; j < i && j < c; j += 1) {
            d2[i * c + j] = 0;
        }
    }
    return [L, T, ipiv];
};

},{"./":93}],100:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
var nlapack;
try {
    nlapack = require('nlapack');
}
catch (err) { }
_1.NDArray.lu_factor = function (x) {
    return _1.NDArray.array(x).lu_factor();
};
_1.NDArray.prototype.lu_factor = function () {
    var _a = __read(this.shape, 1), n = _a[0];
    var ipiv = new Int32Array(n);
    try {
        if (!['float32', 'float64'].includes(this.dtype)) {
            this.dtype = 'float32';
            this.data = util_1.get_type(this.dtype).from(this.data);
        }
        var d1 = this.data;
        if (this.dtype === 'float64') {
            nlapack.dgetrf(n, n, d1, n, ipiv);
        }
        else if (this.dtype === 'float32') {
            nlapack.sgetrf(n, n, d1, n, ipiv);
        }
    }
    catch (err) {
        var d1 = this.data;
        var max = void 0;
        var abs = void 0;
        var diag = void 0;
        var p = void 0;
        var i = void 0;
        var j = void 0;
        var k = void 0;
        for (k = 0; k < n; k += 1) {
            p = k;
            max = Math.abs(d1[k * n + k]);
            for (j = k + 1; j < n; j += 1) {
                abs = Math.abs(d1[j * n + k]);
                if (max < abs) {
                    max = abs;
                    p = j;
                }
            }
            ipiv[k] = p + 1;
            if (p !== k) {
                this.swap(k, p);
            }
            diag = d1[k * n + k];
            for (i = k + 1; i < n; i += 1) {
                d1[i * n + k] /= diag;
            }
            for (i = k + 1; i < n; i += 1) {
                for (j = k + 1; j < n - 1; j += 2) {
                    d1[i * n + j] -= d1[i * n + k] * d1[k * n + j];
                    d1[i * n + j + 1] -= d1[i * n + k] * d1[k * n + j + 1];
                }
                if (j === n - 1) {
                    d1[i * n + j] -= d1[i * n + k] * d1[k * n + j];
                }
            }
        }
    }
    return [this, ipiv];
};

},{"../util":145,"./":93,"nlapack":3}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
var magicHelper = function (n, x, y) {
    return (x + y * 2 + 1) % n;
};
_1.NDArray.magic = function (size) {
    if (size < 0) {
        throw new Error('invalid size');
    }
    var d1 = new Float32Array(size * size);
    var i;
    var j;
    for (i = 0; i < size; i += 1) {
        for (j = 0; j < size; j += 1) {
            d1[(size - i - 1) * size + (size - j - 1)] =
                magicHelper(size, size - j - 1, i) * size + magicHelper(size, j, i) + 1;
        }
    }
    return new this(d1, { shape: [size, size] });
};

},{"./":93}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.map = function (x, f) { return _1.NDArray.array(x).map(f); };
_1.NDArray.prototype.map = function (f) {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var mapped = this.copy();
    var d2 = mapped.data;
    var i;
    for (i = 0; i < l1; i += 1) {
        d2[i] = f.call(mapped, d1[i], i, d1);
    }
    return mapped;
};

},{"./":93}],103:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.matrix = function (r, c) {
    return new this(new Float32Array(r * c), { shape: [r, c] });
};

},{"./":93}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
var nblas;
try {
    nblas = require('nblas');
}
catch (err) { }
_1.NDArray.max = function (x) { return _1.NDArray.array(x).max(); };
_1.NDArray.prototype.max = function () {
    var l1 = this.length;
    var result = Number.NEGATIVE_INFINITY;
    try {
        if (!['float32', 'float64'].includes(this.dtype)) {
            this.dtype = 'float32';
            this.data = util_1.get_type(this.dtype).from(this.data);
        }
        var d1 = this.data;
        if (this.dtype === 'float64') {
            result = d1[nblas.idamax(l1, d1, 1)];
        }
        if (this.dtype === 'float32') {
            result = d1[nblas.isamax(l1, d1, 1)];
        }
    }
    catch (err) {
        var d1 = this.data;
        var i = void 0;
        for (i = 0; i < l1; i += 1) {
            var value = d1[i];
            result = result < value ? value : result;
        }
    }
    return result;
};

},{"../util":145,"./":93,"nblas":3}],105:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.mean = function (x) { return _1.NDArray.array(x).mean(); };
_1.NDArray.prototype.mean = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    var mean = 0;
    for (i = 0; i < l1; i += 1) {
        mean += d1[i];
    }
    return mean / l1;
};

},{"./":93}],106:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.min = function (x) { return _1.NDArray.array(x).min(); };
_1.NDArray.prototype.min = function () {
    var _a = this, data = _a.data, length = _a.length;
    var result = Number.POSITIVE_INFINITY;
    var i;
    for (i = 0; i < length; i += 1) {
        result = result < data[i] ? result : data[i];
    }
    return result;
};

},{"./":93}],107:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
var nblas;
try {
    nblas = require('nblas');
}
catch (err) { }
_1.NDArray.multiply = function (x, y) {
    return _1.NDArray.array(x).multiply(_1.NDArray.array(y));
};
_1.NDArray.prototype.multiply = function (x) {
    var _a = __read(this.shape, 2), r1 = _a[0], c1 = _a[1];
    var _b = __read(x.shape, 2), r2 = _b[0], c2 = _b[1];
    if (c1 !== r2) {
        throw new Error('sizes do not match');
    }
    var y = _1.NDArray.matrix(r1, c2);
    try {
        if (!['float32', 'float64'].includes(this.dtype)) {
            this.dtype = 'float32';
            this.data = util_1.get_type(this.dtype).from(this.data);
        }
        var d1 = this.data;
        var d2 = x.data;
        var d3 = y.data;
        if (this.dtype === 'float64') {
            nblas.dgemm(nblas.NoTrans, nblas.NoTrans, r1, c2, c1, 1, d1, c1, d2, c2, 0, d3, c2);
        }
        else if (this.dtype === 'float32') {
            nblas.sgemm(nblas.NoTrans, nblas.NoTrans, r1, c2, c1, 1, d1, c1, d2, c2, 0, d3, c2);
        }
    }
    catch (err) {
        var d1 = this.data;
        var d2 = x.data;
        var d3 = y.data;
        var i = void 0;
        var j = void 0;
        var k = void 0;
        var sum = void 0;
        for (i = 0; i < r1; i += 1) {
            for (j = 0; j < c2; j += 1) {
                sum = 0;
                for (k = 0; k < c1; k += 1) {
                    sum += d1[i * c1 + k] * d2[k * c2 + j];
                }
                d3[i * c2 + j] = sum;
            }
        }
    }
    return y;
};

},{"../util":145,"./":93,"nblas":3}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
var nblas;
try {
    nblas = require('nblas');
}
catch (err) { }
_1.NDArray.norm = function (x) { return _1.NDArray.array(x).norm(); };
_1.NDArray.prototype.norm = function () {
    var l1 = this.length;
    var result = 0;
    try {
        if (!['float32', 'float64'].includes(this.dtype)) {
            this.dtype = 'float32';
            this.data = util_1.get_type(this.dtype).from(this.data);
        }
        var d1 = this.data;
        if (this.dtype === 'float64') {
            result = nblas.dnrm2(l1, d1, 1);
        }
        if (this.dtype === 'float32') {
            result = nblas.snrm2(l1, d1, 1);
        }
    }
    catch (err) {
        result = Math.sqrt(this.dot(this));
    }
    return result;
};

},{"../util":145,"./":93,"nblas":3}],109:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.normalize = function (x) {
    return _1.NDArray.array(x).normalize();
};
_1.NDArray.prototype.normalize = function () {
    return this.scale(1 / this.norm());
};

},{"./":93}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.ones = function () {
    var shape = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        shape[_i] = arguments[_i];
    }
    return new this(new Float32Array(shape.reduce(function (sum, dim) { return sum * dim; }, 1)), { shape: shape }).fill(1);
};

},{"./":93}],111:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.pow = function (x, exponent) {
    return _1.NDArray.array(x).pow(exponent);
};
_1.NDArray.prototype.pow = function (exponent) {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.pow(d1[i], exponent);
    }
    return this;
};

},{"./":93}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.prod = function (x) { return _1.NDArray.array(x).prod(); };
_1.NDArray.prototype.prod = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    var prod = 1;
    for (i = 0; i < l1; i += 1) {
        prod *= d1[i];
    }
    return prod;
};

},{"./":93}],113:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.product = function (x, y) {
    return _1.NDArray.array(x).product(_1.NDArray.array(y));
};
_1.NDArray.prototype.product = function (x) {
    this.equilateral(x);
    this.equidimensional(x);
    var _a = this, d1 = _a.data, l1 = _a.length;
    var d2 = x.data;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] *= d2[i];
    }
    return this;
};

},{"./":93}],114:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.project = function (x, y) {
    return _1.NDArray.array(x).project(_1.NDArray.array(y));
};
_1.NDArray.prototype.project = function (x) {
    return x.scale(this.dot(x) / x.dot(x));
};

},{"./":93}],115:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
_1.NDArray.push = function (x, value) {
    return _1.NDArray.array(x).push(value);
};
_1.NDArray.prototype.push = function (value) {
    if (this.shape.length !== 1) {
        throw new Error('push operation not permitted for multidimensional arrays');
    }
    var _a = this, d1 = _a.data, l1 = _a.length;
    var l2 = l1 + 1;
    var d2 = new (util_1.get_type(this.dtype))(l2);
    d2.set(d1);
    d2[l1] = value;
    this.data = d2;
    this.length = l2;
    this.shape = [l2];
    return this;
};

},{"../util":145,"./":93}],116:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.random = function () {
    var shape = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        shape[_i] = arguments[_i];
    }
    return new this(new Float32Array(shape.reduce(function (sum, dim) { return sum * dim; }, 1)), { shape: shape }).map(function () { return Math.random(); });
};

},{"./":93}],117:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.range = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var type = Float32Array;
    var backwards = false;
    var start;
    var step;
    var end;
    switch (args.length) {
        case 2:
            end = args.pop();
            step = 1;
            start = args.pop();
            break;
        case 3:
            end = args.pop();
            step = args.pop();
            start = args.pop();
            break;
        default:
            throw new Error('invalid range');
    }
    if (end - start < 0) {
        var copy = end;
        end = start;
        start = copy;
        backwards = true;
    }
    if (step > end - start) {
        throw new Error('invalid range');
    }
    var data = new type(Math.ceil((end - start) / step));
    var i = start;
    var j = 0;
    if (backwards) {
        for (; i < end; i += step, j += 1) {
            data[j] = end - i + start;
        }
    }
    else {
        for (; i < end; i += step, j += 1) {
            data[j] = i;
        }
    }
    return new this(data);
};

},{"./":93}],118:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.rank = function (x) { return _1.NDArray.array(x).rank(); };
_1.NDArray.prototype.rank = function () {
    this.gauss();
    var _a = __read(this.shape, 2), r = _a[0], c = _a[1];
    var d1 = this.data;
    var rk = 0;
    var i;
    var j;
    for (i = 0; i < r; i += 1) {
        for (j = i; j < c; j += 1) {
            if (rk <= i && d1[i * c + j] !== 0) {
                rk += 1;
                continue;
            }
        }
    }
    return rk;
};

},{"./":93}],119:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.reciprocal = function (x) {
    return _1.NDArray.array(x).reciprocal();
};
_1.NDArray.prototype.reciprocal = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = 1 / d1[i];
    }
    return this;
};

},{"./":93}],120:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.reduce = function (x, f, initialValue) { return _1.NDArray.array(x).reduce(f, initialValue); };
_1.NDArray.prototype.reduce = function (f, initialValue) {
    var _a = this, d1 = _a.data, l1 = _a.length;
    if (l1 === 0 && typeof initialValue === 'undefined') {
        throw new Error('Reduce of empty matrix with no initial value.');
    }
    var i;
    var value;
    if (typeof initialValue === 'undefined') {
        value = d1[0];
        i = 1;
    }
    else {
        value = initialValue;
        i = 0;
    }
    for (; i < l1; i += 1) {
        value = f.call(this, value, d1[i], i, d1);
    }
    return value;
};

},{"./":93}],121:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.reshape = function (x) {
    var _a;
    var shape = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        shape[_i - 1] = arguments[_i];
    }
    return (_a = _1.NDArray.array(x)).reshape.apply(_a, __spread(shape));
};
_1.NDArray.prototype.reshape = function () {
    var shape = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        shape[_i] = arguments[_i];
    }
    var length = this.length;
    if (shape.reduce(function (sum, dim) { return sum * dim; }, 1) !== length) {
        throw new Error("shape " + shape + " does not match length " + length);
    }
    this.shape = shape;
    return this;
};

},{"./":93}],122:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.round = function (x) { return _1.NDArray.array(x).round(); };
_1.NDArray.prototype.round = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.round(d1[i]);
    }
    return this;
};

},{"./":93}],123:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.row_add = function (x, dest, source, scalar) {
    if (scalar === void 0) { scalar = 1; }
    return _1.NDArray.array(x).row_add(dest, source, scalar);
};
_1.NDArray.prototype.row_add = function (dest, source, scalar) {
    if (scalar === void 0) { scalar = 1; }
    this.check(dest, 0);
    this.check(source, 0);
    var _a = __read(this.shape, 2), c = _a[1];
    var d1 = this.data;
    var j;
    for (j = 0; j < c; j += 1) {
        d1[dest * c + j] += d1[source * c + j] * scalar;
    }
    return this;
};

},{"./":93}],124:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
var nblas;
try {
    nblas = require('nblas');
}
catch (err) { }
_1.NDArray.scale = function (x, scalar) {
    return _1.NDArray.array(x).scale(scalar);
};
_1.NDArray.prototype.scale = function (scalar) {
    var l1 = this.length;
    try {
        if (!['float32', 'float64'].includes(this.dtype)) {
            this.dtype = 'float32';
            this.data = util_1.get_type(this.dtype).from(this.data);
        }
        var d1 = this.data;
        if (this.dtype === 'float64') {
            nblas.dscal(l1, scalar, d1, 1);
        }
        else if (this.dtype === 'float32') {
            nblas.sscal(l1, scalar, d1, 1);
        }
    }
    catch (err) {
        var d1 = this.data;
        var i = void 0;
        for (i = 0; i < l1; i += 1) {
            d1[i] *= scalar;
        }
    }
    return this;
};

},{"../util":145,"./":93,"nblas":3}],125:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.set = function (x) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    x.set.apply(x, __spread(args));
};
_1.NDArray.prototype.set = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var indices = args.slice(0, -1);
    var value = args[args.length - 1];
    this.check.apply(this, __spread(indices));
    var s1 = this.shape;
    var index = indices[indices.length - 1];
    var i;
    for (i = 0; i < indices.length - 1; i += 1) {
        index += indices[i] * s1[i + 1];
    }
    this.data[index] = value;
};

},{"./":93}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.sign = function (x) { return _1.NDArray.array(x).sign(); };
_1.NDArray.prototype.sign = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.sign(d1[i]);
    }
    return this;
};

},{"./":93}],127:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.sin = function (x) { return _1.NDArray.array(x).sin(); };
_1.NDArray.prototype.sin = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.sin(d1[i]);
    }
    return this;
};

},{"./":93}],128:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.sinh = function (x) { return _1.NDArray.array(x).sinh(); };
_1.NDArray.prototype.sinh = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.sinh(d1[i]);
    }
    return this;
};

},{"./":93}],129:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
_1.NDArray.slice = function (x, start, step, end) {
    return _1.NDArray.array(x).slice(start, step, end);
};
_1.NDArray.prototype.slice = function (begin, end, step) {
    if (begin === void 0) { begin = 0; }
    if (end === void 0) { end = this.shape[0]; }
    if (step === void 0) { step = 1; }
    var _a = this, d1 = _a.data, s1 = _a.shape;
    var ndim = s1.length;
    if (begin < 0 || end < 0) {
        return this.slice(begin < 0 ? ndim + begin : begin, end < 0 ? ndim + end : end);
    }
    if (step === 0) {
        throw new Error('step argument cannot be 0');
    }
    var s2 = __spread([Math.ceil((end - begin) / step)], s1.slice(1));
    var l2 = s2.reduce(function (sum, dim) { return sum * dim; }, 1);
    var d2 = new (util_1.get_type(this.dtype))(l2);
    var i;
    for (i = 0; i < l2; i += 1) {
        d2[i] = d1[begin + i * step];
    }
    this.length = l2;
    this.data = d2;
    this.reshape.apply(this, __spread(s2));
    return this;
};

},{"../util":145,"./":93}],130:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var _1 = require("./");
var nlapack;
try {
    nlapack = require('nlapack');
}
catch (err) { }
_1.NDArray.solve = function (x, y) {
    return _1.NDArray.array(x).solve(_1.NDArray.array(y));
};
_1.NDArray.prototype.solve = function (x) {
    var _a = __read(x.shape, 2), n = _a[0], nrhs = _a[1];
    try {
        if (!['float32', 'float64'].includes(this.dtype)) {
            this.dtype = 'float32';
            this.data = util_1.get_type(this.dtype).from(this.data);
        }
        var d1 = this.data;
        var d2 = x.data;
        var ipiv = new Int32Array(n);
        if (this.dtype === 'float64') {
            nlapack.dgesv(n, nrhs, d1, n, ipiv, d2, nrhs);
        }
        else if (this.dtype === 'float32') {
            nlapack.sgesv(n, nrhs, d1, n, ipiv, d2, nrhs);
        }
    }
    catch (err) {
        var _b = __read(this.lu_factor(), 2), LU = _b[0], ipiv = _b[1];
        var d1 = LU.data;
        var d2 = x.data;
        var i = void 0;
        var j = void 0;
        var k = void 0;
        for (i = 0; i < ipiv.length; i += 1) {
            if (i !== ipiv[i] - 1) {
                x.swap(i, ipiv[i] - 1);
            }
        }
        for (k = 0; k < nrhs; k += 1) {
            for (i = 0; i < n; i += 1) {
                for (j = 0; j < i; j += 1) {
                    d2[i * nrhs + k] -= d1[i * n + j] * d2[j * nrhs + k];
                }
            }
            for (i = n - 1; i >= 0; i -= 1) {
                for (j = i + 1; j < n; j += 1) {
                    d2[i * nrhs + k] -= d1[i * n + j] * d2[j * nrhs + k];
                }
                d2[i * nrhs + k] /= d1[i * n + i];
            }
        }
    }
    return x;
};

},{"../util":145,"./":93,"nlapack":3}],131:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.sqrt = function (x) { return _1.NDArray.array(x).sqrt(); };
_1.NDArray.prototype.sqrt = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.sqrt(d1[i]);
    }
    return this;
};

},{"./":93}],132:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.square = function (x) {
    _1.NDArray.array(x).square();
};
_1.NDArray.prototype.square = function () {
    var length = this.shape.length;
    var _a = __read(this.shape, 2), r = _a[0], c = _a[1];
    if (length !== 2 || r !== c) {
        throw new Error('matrix is not square');
    }
};

},{"./":93}],133:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.subtract = function (x, y) {
    return _1.NDArray.array(x).subtract(_1.NDArray.array(y));
};
_1.NDArray.prototype.subtract = function (x) {
    return this.add(x, -1);
};

},{"./":93}],134:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.sum = function (x) { return _1.NDArray.array(x).sum(); };
_1.NDArray.prototype.sum = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    var sum = 0;
    for (i = 0; i < l1; i += 1) {
        sum += d1[i];
    }
    return sum;
};

},{"./":93}],135:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.swap = function (x, i, j) {
    return _1.NDArray.array(x).swap(i, j);
};
_1.NDArray.prototype.swap = function (i, j) {
    this.check(i, 0);
    this.check(j, 0);
    var d1 = this.data;
    var _a = __read(this.shape, 2), c = _a[1];
    var d2 = d1.slice(i * c, (i + 1) * c);
    d1.copyWithin(i * c, j * c, (j + 1) * c);
    d1.set(d2, j * c);
    return this;
};

},{"./":93}],136:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.tan = function (x) { return _1.NDArray.array(x).tan(); };
_1.NDArray.prototype.tan = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.tan(d1[i]);
    }
    return this;
};

},{"./":93}],137:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.tanh = function (x) { return _1.NDArray.array(x).tanh(); };
_1.NDArray.prototype.tanh = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.tanh(d1[i]);
    }
    return this;
};

},{"./":93}],138:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.toArray = function (x) { return _1.NDArray.array(x).toArray(); };
_1.NDArray.prototype.toArray = function () {
    var _a = this, l1 = _a.length, s1 = _a.shape;
    var ndim = s1.length;
    var i;
    var j;
    var k;
    var res = [];
    for (i = 0; i < l1; i += 1) {
        var indices = [];
        for (j = 0; j < ndim; j += 1) {
            var p = 1;
            for (k = j + 1; k < ndim; k += 1) {
                p *= s1[k];
            }
            var index = Math.floor(i / p);
            if (j > 0) {
                index %= s1[j];
            }
            indices.push(index);
        }
        var node = res;
        for (j = 0; j < ndim; j += 1) {
            var index = indices[j];
            if (j < ndim - 1) {
                if (!node[index]) {
                    node[index] = [];
                }
                node = node[index];
            }
            else {
                node[index] = this.get.apply(this, __spread(indices));
            }
        }
    }
    return res;
};

},{"./":93}],139:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("util");
var _1 = require("./");
_1.NDArray.toString = function (x) { return x.toString(); };
_1.NDArray.prototype.toString = function () {
    return "array(" + util_1.inspect(this.toArray(), { depth: 10, breakLength: 40 }) + ", dtype=" + this.dtype + ")";
};
_1.NDArray.prototype[_1.inspectSymbol] = _1.NDArray.prototype.toString;

},{"./":93,"util":56}],140:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.trace = function (x) { return _1.NDArray.array(x).trace(); };
_1.NDArray.prototype.trace = function () {
    var _a = __read(this.shape, 2), r = _a[0], c = _a[1];
    var d1 = this.data;
    var n = Math.min(r, c);
    var result = 0;
    var j;
    for (j = 0; j < n; j += 1) {
        result += d1[j * c + j];
    }
    return result;
};

},{"./":93}],141:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.transpose = function (x) {
    return _1.NDArray.array(x).transpose();
};
_1.NDArray.prototype.transpose = function () {
    var _a = __read(this.shape, 2), r = _a[0], c = _a[1];
    var d1 = this.data;
    var x = this.copy().reshape(c, r);
    var d2 = x.data;
    var i;
    var j;
    for (i = 0; i < r; i += 1) {
        for (j = 0; j < c; j += 1) {
            d2[j * r + i] = d1[i * c + j];
        }
    }
    return x;
};

},{"./":93}],142:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.trunc = function (x) { return _1.NDArray.array(x).trunc(); };
_1.NDArray.prototype.trunc = function () {
    var _a = this, d1 = _a.data, l1 = _a.length;
    var i;
    for (i = 0; i < l1; i += 1) {
        d1[i] = Math.trunc(d1[i]);
    }
    return this;
};

},{"./":93}],143:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
_1.NDArray.zeros = function () {
    var shape = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        shape[_i] = arguments[_i];
    }
    return new this(new Float32Array(shape.reduce(function (sum, dim) { return sum * dim; }, 1)), { shape: shape }).fill(0);
};

},{"./":93}],144:[function(require,module,exports){
"use strict";
var core_1 = require("./core");
module.exports = core_1.NDArray;

},{"./core":93}],145:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.flatten = function (input) {
    return input.reduce(function (acc, next) { return acc.concat(Array.isArray(next) ? exports.flatten(next) : next); }, []);
};
exports.get_shape = function (input) { return Array.isArray(input)
    ? [input.length].concat(exports.get_shape(input[0]))
    : []; };
exports.get_dtype = function (input) {
    switch (input.constructor.name) {
        case 'Int8Array': return 'int8';
        case 'Uint8Array': return 'uint8';
        case 'Int16Array': return 'int16';
        case 'Uint16Array': return 'uint16';
        case 'Int32Array': return 'int32';
        case 'Uint32Array': return 'uint32';
        case 'Uint8ClampedArray': return 'uint8c';
        case 'Float64Array': return 'float64';
        default: return 'float32';
    }
};
exports.get_type = function (input) {
    switch (input) {
        case 'int8': return Int8Array;
        case 'uint8': return Uint8Array;
        case 'int16': return Int16Array;
        case 'uint16': return Uint16Array;
        case 'int32': return Int32Array;
        case 'uint32': return Uint32Array;
        case 'uint8c': return Uint8ClampedArray;
        case 'float64': return Float64Array;
        default: return Float32Array;
    }
};
exports.is_typed_array = function (input) {
    return !!(input && input.buffer instanceof ArrayBuffer && input.BYTES_PER_ELEMENT);
};

},{}],146:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('for-each');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');
var gOPD = require('gopd');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		if (typeof g[typedArray] === 'function') {
			var arr = new g[typedArray]();
			if (Symbol.toStringTag in arr) {
				var proto = getPrototypeOf(arr);
				var descriptor = gOPD(proto, Symbol.toStringTag);
				if (!descriptor) {
					var superProto = getPrototypeOf(proto);
					descriptor = gOPD(superProto, Symbol.toStringTag);
				}
				toStrTags[typedArray] = descriptor.get;
			}
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var foundName = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!foundName) {
			try {
				var name = getter.call(value);
				if (name === typedArray) {
					foundName = name;
				}
			} catch (e) {}
		}
	});
	return foundName;
};

var isTypedArray = require('is-typed-array');

module.exports = function whichTypedArray(value) {
	if (!isTypedArray(value)) { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"available-typed-arrays":1,"call-bind/callBound":5,"for-each":13,"gopd":17,"has-tostringtag/shams":20,"is-typed-array":32}],"agentmodel":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AgentModel;

  module.exports = AgentModel = (function() {
    var mergeObjectInto;

    class AgentModel {
      // () => AgentModel
      constructor() {
        this.turtles = {};
        this.patches = {};
        this.links = {};
        this.observer = {};
        this.world = {};
        this.drawingEvents = [];
      }

      // (Array[Updater.Update]) => Unit
      updates(modelUpdates) {
        var i, len, u;
        for (i = 0, len = modelUpdates.length; i < len; i++) {
          u = modelUpdates[i];
          this.update(u);
        }
      }

      // (Updater.Update) => Unit
      update({links, observer, patches, turtles, world, drawingEvents}) {
        var coll, i, id, len, linkBundle, patchBundle, ref, turtleBundle, typeCanDie, updates, varUpdates;
        turtleBundle = {
          updates: turtles,
          coll: this.turtles,
          typeCanDie: true
        };
        patchBundle = {
          updates: patches,
          coll: this.patches,
          typeCanDie: false
        };
        linkBundle = {
          updates: links,
          coll: this.links,
          typeCanDie: true
        };
        ref = [turtleBundle, patchBundle, linkBundle];
        for (i = 0, len = ref.length; i < len; i++) {
          ({coll, typeCanDie, updates} = ref[i]);
          for (id in updates) {
            varUpdates = updates[id];
            if (typeCanDie && (varUpdates.WHO === -1 || varUpdates.who === -1)) {
              delete coll[id];
            } else {
              mergeObjectInto(varUpdates, this._itemById(coll, id));
            }
          }
        }
        if ((observer != null ? observer[0] : void 0) != null) {
          mergeObjectInto(observer[0], this.observer);
        }
        if ((world != null ? world[0] : void 0) != null) {
          mergeObjectInto(world[0], this.world);
        }
        if (drawingEvents != null) {
          this.drawingEvents = this.drawingEvents.concat(drawingEvents);
        }
      }

      // (Object, String) => Object
      _itemById(coll, id) {
        if (coll[id] == null) {
          coll[id] = {};
        }
        return coll[id];
      }

    };

    // (Object, Object) => Unit
    mergeObjectInto = function(updatedObject, targetObject) {
      var value, variable;
      for (variable in updatedObject) {
        value = updatedObject[variable];
        targetObject[variable.toLowerCase()] = value;
      }
    };

    return AgentModel;

  }).call(this);

}).call(this);

},{}],"bootstrap":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  /*
    `Workspace` is needed to do anything.  If you want the core of Tortoise, do `require('engine/workspace')`.
    If you want the peripheral stuff (i.e. because you're a compiler or test infrastructure),
    the other things you might want ought to get initialized by RequireJS here. --JAB (5/7/14)
  */
  require('./agentmodel');

  require('./engine/workspace');

  require('./engine/prim/prims');

  require('./engine/prim/tasks');

  require('./extensions/all');

  require('./util/notimplemented');

  module.exports = function() {};

}).call(this);

},{"./agentmodel":"agentmodel","./engine/prim/prims":"engine/prim/prims","./engine/prim/tasks":"engine/prim/tasks","./engine/workspace":"engine/workspace","./extensions/all":"extensions/all","./util/notimplemented":"util/notimplemented"}],"brazier/array":[function(require,module,exports){
(function() {
  var None, Something, arrayOps, eq, isArray, maybe, ref;

  eq = require('./equals').eq;

  ref = require('./maybe'), maybe = ref.maybe, None = ref.None, Something = ref.Something;

  isArray = require('./type').isArray;

  arrayOps = {
    all: function(f) {
      return function(arr) {
        var j, len, x;
        for (j = 0, len = arr.length; j < len; j++) {
          x = arr[j];
          if (!f(x)) {
            return false;
          }
        }
        return true;
      };
    },
    concat: function(xs) {
      return function(ys) {
        return xs.concat(ys);
      };
    },
    contains: function(x) {
      return function(arr) {
        var item, j, len;
        for (j = 0, len = arr.length; j < len; j++) {
          item = arr[j];
          if (eq(x)(item)) {
            return true;
          }
        }
        return false;
      };
    },
    countBy: function(f) {
      return function(arr) {
        var acc, j, key, len, ref1, value, x;
        acc = {};
        for (j = 0, len = arr.length; j < len; j++) {
          x = arr[j];
          key = f(x);
          value = (ref1 = acc[key]) != null ? ref1 : 0;
          acc[key] = value + 1;
        }
        return acc;
      };
    },
    difference: function(xs) {
      return function(arr) {
        var acc, badBoys, j, len, x;
        acc = [];
        badBoys = arrayOps.unique(arr);
        for (j = 0, len = xs.length; j < len; j++) {
          x = xs[j];
          if (!arrayOps.contains(x)(badBoys)) {
            acc.push(x);
          }
        }
        return acc;
      };
    },
    exists: function(f) {
      return function(arr) {
        var j, len, x;
        for (j = 0, len = arr.length; j < len; j++) {
          x = arr[j];
          if (f(x)) {
            return true;
          }
        }
        return false;
      };
    },
    filter: function(f) {
      return function(arr) {
        var j, len, results, x;
        results = [];
        for (j = 0, len = arr.length; j < len; j++) {
          x = arr[j];
          if (f(x)) {
            results.push(x);
          }
        }
        return results;
      };
    },
    find: function(f) {
      return function(arr) {
        var j, len, x;
        for (j = 0, len = arr.length; j < len; j++) {
          x = arr[j];
          if (f(x)) {
            return Something(x);
          }
        }
        return None;
      };
    },
    findIndex: function(f) {
      return function(arr) {
        var i, j, len, x;
        for (i = j = 0, len = arr.length; j < len; i = ++j) {
          x = arr[i];
          if (f(x)) {
            return Something(i);
          }
        }
        return None;
      };
    },
    flatMap: function(f) {
      return function(arr) {
        var arrs, ref1, x;
        arrs = (function() {
          var j, len, results;
          results = [];
          for (j = 0, len = arr.length; j < len; j++) {
            x = arr[j];
            results.push(f(x));
          }
          return results;
        })();
        return (ref1 = []).concat.apply(ref1, arrs);
      };
    },
    flattenDeep: function(arr) {
      var acc, j, len, x;
      acc = [];
      for (j = 0, len = arr.length; j < len; j++) {
        x = arr[j];
        if (isArray(x)) {
          acc = acc.concat(arrayOps.flattenDeep(x));
        } else {
          acc.push(x);
        }
      }
      return acc;
    },
    foldl: function(f) {
      return function(acc) {
        return function(arr) {
          var j, len, out, x;
          out = acc;
          for (j = 0, len = arr.length; j < len; j++) {
            x = arr[j];
            out = f(out, x);
          }
          return out;
        };
      };
    },
    forEach: function(f) {
      return function(arr) {
        var j, len, x;
        for (j = 0, len = arr.length; j < len; j++) {
          x = arr[j];
          f(x);
        }
      };
    },
    head: function(arr) {
      return arrayOps.item(0)(arr);
    },
    isEmpty: function(arr) {
      return arr.length === 0;
    },
    item: function(index) {
      return function(xs) {
        if ((0 <= index && index < xs.length)) {
          return Something(xs[index]);
        } else {
          return None;
        }
      };
    },
    last: function(arr) {
      return arr[arr.length - 1];
    },
    length: function(arr) {
      return arr.length;
    },
    map: function(f) {
      return function(arr) {
        var j, len, results, x;
        results = [];
        for (j = 0, len = arr.length; j < len; j++) {
          x = arr[j];
          results.push(f(x));
        }
        return results;
      };
    },
    maxBy: function(f) {
      return function(arr) {
        var j, len, maxX, maxY, x, y;
        maxX = void 0;
        maxY = -Infinity;
        for (j = 0, len = arr.length; j < len; j++) {
          x = arr[j];
          y = f(x);
          if (y > maxY) {
            maxX = x;
            maxY = y;
          }
        }
        return maybe(maxX);
      };
    },
    reverse: function(xs) {
      return xs.slice(0).reverse();
    },
    singleton: function(x) {
      return [x];
    },
    sortBy: function(f) {
      return function(arr) {
        var g;
        g = function(x, y) {
          var fx, fy;
          fx = f(x);
          fy = f(y);
          if (fx < fy) {
            return -1;
          } else if (fx > fy) {
            return 1;
          } else {
            return 0;
          }
        };
        return arr.slice(0).sort(g);
      };
    },
    sortedIndexBy: function(f) {
      return function(arr) {
        return function(x) {
          var i, item, j, len, y;
          y = f(x);
          for (i = j = 0, len = arr.length; j < len; i = ++j) {
            item = arr[i];
            if (y <= f(item)) {
              return i;
            }
          }
          return arr.length;
        };
      };
    },
    tail: function(arr) {
      return arr.slice(1);
    },
    toObject: function(arr) {
      var a, b, j, len, out, ref1;
      out = {};
      for (j = 0, len = arr.length; j < len; j++) {
        ref1 = arr[j], a = ref1[0], b = ref1[1];
        out[a] = b;
      }
      return out;
    },
    unique: function(arr) {
      var acc, j, len, x;
      acc = [];
      for (j = 0, len = arr.length; j < len; j++) {
        x = arr[j];
        if (!arrayOps.contains(x)(acc)) {
          acc.push(x);
        }
      }
      return acc;
    },
    uniqueBy: function(f) {
      return function(arr) {
        var acc, j, len, seen, x, y;
        acc = [];
        seen = [];
        for (j = 0, len = arr.length; j < len; j++) {
          x = arr[j];
          y = f(x);
          if (!arrayOps.contains(y)(seen)) {
            seen.push(y);
            acc.push(x);
          }
        }
        return acc;
      };
    },
    zip: function(xs) {
      return function(arr) {
        var i, j, length, out, ref1;
        out = [];
        length = Math.min(xs.length, arr.length);
        for (i = j = 0, ref1 = length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
          out.push([xs[i], arr[i]]);
        }
        return out;
      };
    }
  };

  module.exports = arrayOps;

}).call(this);

},{"./equals":"brazier/equals","./maybe":"brazier/maybe","./type":"brazier/type"}],"brazier/equals":[function(require,module,exports){
(function() {
  var arrayEquals, booleanEquals, eq, isArray, isBoolean, isNumber, isObject, isString, numberEquals, objectEquals, ref, stringEquals;

  ref = require('./type'), isArray = ref.isArray, isBoolean = ref.isBoolean, isNumber = ref.isNumber, isObject = ref.isObject, isString = ref.isString;

  arrayEquals = function(x) {
    return function(y) {
      var helper;
      helper = function(a, b) {
        var index, item, j, len;
        for (index = j = 0, len = a.length; j < len; index = ++j) {
          item = a[index];
          if (!eq(item)(b[index])) {
            return false;
          }
        }
        return true;
      };
      return (x === y) || (x.length === y.length && helper(x, y));
    };
  };

  booleanEquals = function(x) {
    return function(y) {
      return x === y;
    };
  };

  eq = function(x) {
    return function(y) {
      return (x === y) || (x === void 0 && y === void 0) || (x === null && y === null) || (isNumber(x) && isNumber(y) && ((isNaN(x) && isNaN(y)) || numberEquals(x)(y))) || (isBoolean(x) && isBoolean(y) && booleanEquals(x)(y)) || (isString(x) && isString(y) && stringEquals(x)(y)) || (isObject(x) && isObject(y) && objectEquals(x)(y)) || (isArray(x) && isArray(y) && arrayEquals(x)(y));
    };
  };

  numberEquals = function(x) {
    return function(y) {
      return x === y;
    };
  };

  objectEquals = function(x) {
    return function(y) {
      var helper, xKeys;
      xKeys = Object.keys(x);
      helper = function(a, b) {
        var i, j, key, ref1;
        for (i = j = 0, ref1 = xKeys.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
          key = xKeys[i];
          if (!eq(x[key])(y[key])) {
            return false;
          }
        }
        return true;
      };
      return (x === y) || (xKeys.length === Object.keys(y).length && helper(x, y));
    };
  };

  stringEquals = function(x) {
    return function(y) {
      return x === y;
    };
  };

  module.exports = {
    arrayEquals: arrayEquals,
    booleanEquals: booleanEquals,
    eq: eq,
    numberEquals: numberEquals,
    objectEquals: objectEquals,
    stringEquals: stringEquals
  };

}).call(this);

},{"./type":"brazier/type"}],"brazier/function":[function(require,module,exports){
(function() {
  var slice = [].slice;

  module.exports = {
    apply: function(f) {
      return function(x) {
        return f(x);
      };
    },
    constantly: function(x) {
      return function() {
        return x;
      };
    },
    curry: function(f) {
      var argsToArray, curryMaster;
      argsToArray = function(args) {
        return Array.prototype.slice.call(args, 0);
      };
      curryMaster = function() {
        var argsThusFar;
        argsThusFar = argsToArray(arguments);
        if (argsThusFar.length >= f.length) {
          return f.apply(null, argsThusFar);
        } else {
          return function() {
            var nextTierArgs;
            nextTierArgs = argsToArray(arguments);
            return curryMaster.apply(null, argsThusFar.concat(nextTierArgs));
          };
        }
      };
      return curryMaster;
    },
    flip: function(f) {
      return function(x) {
        return function(y) {
          return f(y)(x);
        };
      };
    },
    id: function(x) {
      return x;
    },
    pipeline: function() {
      var functions;
      functions = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return function() {
        var args, f, fs, h, i, len, out;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        h = functions[0], fs = 2 <= functions.length ? slice.call(functions, 1) : [];
        out = h.apply(null, args);
        for (i = 0, len = fs.length; i < len; i++) {
          f = fs[i];
          out = f(out);
        }
        return out;
      };
    },
    tee: function(f) {
      return function(g) {
        return function(x) {
          return [f(x), g(x)];
        };
      };
    },
    uncurry: function(f) {
      return function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return args.reduce((function(acc, arg) {
          return acc(arg);
        }), f);
      };
    }
  };

}).call(this);

},{}],"brazier/maybe":[function(require,module,exports){
(function() {
  var maybeOps;

  maybeOps = {
    None: {},
    Something: function(x) {
      return {
        _type: "something",
        _value: x
      };
    },
    filter: function(f) {
      return function(maybe) {
        return maybeOps.flatMap(function(x) {
          if (f(x)) {
            return maybeOps.Something(x);
          } else {
            return maybeOps.None;
          }
        })(maybe);
      };
    },
    flatMap: function(f) {
      return function(maybe) {
        return maybeOps.fold(function() {
          return maybeOps.None;
        })(f)(maybe);
      };
    },
    fold: function(ifNone) {
      return function(ifSomething) {
        return function(maybe) {
          if (maybeOps.isSomething(maybe)) {
            return ifSomething(maybe._value);
          } else {
            return ifNone();
          }
        };
      };
    },
    isSomething: function(arg) {
      var _type;
      _type = arg._type;
      return _type === "something";
    },
    map: function(f) {
      return function(maybe) {
        return maybeOps.fold(function() {
          return maybeOps.None;
        })(function(x) {
          return maybeOps.Something(f(x));
        })(maybe);
      };
    },
    maybe: function(x) {
      if (x != null) {
        return maybeOps.Something(x);
      } else {
        return maybeOps.None;
      }
    },
    toArray: function(maybe) {
      return maybeOps.fold(function() {
        return [];
      })(function(x) {
        return [x];
      })(maybe);
    }
  };

  module.exports = maybeOps;

}).call(this);

},{}],"brazier/number":[function(require,module,exports){
(function() {
  module.exports = {
    multiply: function(x) {
      return function(y) {
        return x * y;
      };
    },
    plus: function(x) {
      return function(y) {
        return x + y;
      };
    },
    rangeTo: function(start) {
      return function(end) {
        var i, results;
        if (start <= end) {
          return (function() {
            results = [];
            for (var i = start; start <= end ? i <= end : i >= end; start <= end ? i++ : i--){ results.push(i); }
            return results;
          }).apply(this);
        } else {
          return [];
        }
      };
    },
    rangeUntil: function(start) {
      return function(end) {
        var i, results;
        if (start < end) {
          return (function() {
            results = [];
            for (var i = start; start <= end ? i < end : i > end; start <= end ? i++ : i--){ results.push(i); }
            return results;
          }).apply(this);
        } else {
          return [];
        }
      };
    }
  };

}).call(this);

},{}],"brazier/object":[function(require,module,exports){
(function() {
  var None, Something, ref;

  ref = require('./maybe'), None = ref.None, Something = ref.Something;

  module.exports = {
    clone: function(obj) {
      var acc, i, j, key, keys, ref1;
      acc = {};
      keys = Object.keys(obj);
      for (i = j = 0, ref1 = keys.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
        key = keys[i];
        acc[key] = obj[key];
      }
      return acc;
    },
    keys: function(obj) {
      return Object.keys(obj);
    },
    lookup: function(key) {
      return function(obj) {
        if (obj.hasOwnProperty(key)) {
          return Something(obj[key]);
        } else {
          return None;
        }
      };
    },
    pairs: function(obj) {
      var i, j, key, keys, ref1, results;
      keys = Object.keys(obj);
      results = [];
      for (i = j = 0, ref1 = keys.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
        key = keys[i];
        results.push([key, obj[key]]);
      }
      return results;
    },
    values: function(obj) {
      var i, j, keys, ref1, results;
      keys = Object.keys(obj);
      results = [];
      for (i = j = 0, ref1 = keys.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
        results.push(obj[keys[i]]);
      }
      return results;
    }
  };

}).call(this);

},{"./maybe":"brazier/maybe"}],"brazier/type":[function(require,module,exports){
(function() {
  module.exports = {
    isArray: function(x) {
      return Array.isArray(x);
    },
    isBoolean: function(x) {
      return typeof x === "boolean";
    },
    isFunction: function(x) {
      return typeof x === "function";
    },
    isNumber: function(x) {
      return typeof x === "number" && !isNaN(x);
    },
    isObject: function(x) {
      return typeof x === "object" && x !== null && !Array.isArray(x);
    },
    isString: function(x) {
      return typeof x === "string";
    }
  };

}).call(this);

},{}],"engine/core/abstractagentset":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AbstractAgentSet, DeathInterrupt, Iterator, Shufflerator, checks, foldl, keys, map, pipeline, stableSort;

  ({checks} = require('./typechecker'));

  Iterator = require('util/iterator');

  Shufflerator = require('util/shufflerator');

  stableSort = require('util/stablesort');

  ({foldl, map} = require('brazierjs/array'));

  ({pipeline} = require('brazierjs/function'));

  ({keys} = require('brazierjs/object'));

  ({DeathInterrupt} = require('util/interrupts'));

  // Never instantiate this class directly --JAB (5/7/14)
  module.exports = AbstractAgentSet = class AbstractAgentSet {
    // (Array[T], World, String, String) => AbstractAgentSet
    constructor(_agentArr, _world, _agentTypeName, _specialName) {
      this._agentArr = _agentArr;
      this._world = _world;
      this._agentTypeName = _agentTypeName;
      this._specialName = _specialName;
    }

    // (() => Boolean) => AbstractAgentSet[T]
    agentFilter(f) {
      return this.filter(this._world.selfManager.askAgent(f));
    }

    // (() => Boolean) => Boolean
    agentAll(f) {
      return this._unsafeIterator().all(this._world.selfManager.askAgent(f));
    }

    // (() => Any, Boolean) => Unit
    ask(f, shouldShuffle) {
      var base, iter;
      iter = shouldShuffle ? this.shufflerator() : this.iterator();
      iter.forEach(this._world.selfManager.askAgent(f));
      if (typeof (base = this._world.selfManager.self()).isDead === "function" ? base.isDead() : void 0) {
        return DeathInterrupt;
      }
    }

    // (Array[(Number, Number)]) => AbstractAgentSet[T]
    atPoints(points) {
      var getPatchAt, getSelf;
      getSelf = () => {
        return this._world.selfManager.self();
      };
      getPatchAt = (x, y) => {
        return this._world.getPatchAt(x, y);
      };
      return require('./agentset/atpoints')(getSelf, getPatchAt).call(this, points);
    }

    // (T) => Boolean
    contains(item) {
      return this._unsafeIterator().contains(item);
    }

    // (Array[T]) => AbstractAgentSet[T]
    copyWithNewAgents(agents) {
      return this._generateFrom(agents);
    }

    // ((T) => Boolean) => Boolean
    exists(pred) {
      return this._unsafeIterator().exists(pred);
    }

    // ((T) => Boolean) => Seq[T]
    filter(pred) {
      return this._generateFrom(this._unsafeIterator().filter(pred));
    }

    // ((T) => Unit) => Unit
    forEach(f) {
      this.iterator().forEach(f);
    }

    // () => String
    getSpecialName() {
      return this._specialName;
    }

    // () => Boolean
    isEmpty() {
      return this.size() === 0;
    }

    // () => Iterator[T]
    iterator() {
      return new Iterator(this._agentArr.slice(0));
    }

    // (Agent) => AbstractAgentSet[T]
    remove(agent) {
      var results;
      results = this._unsafeIterator().filter(function(a) {
        return agent !== a;
      });
      return this._generateFrom(results);
    }

    // (Agent) => AbstractAgentSet[T]
    removeAll(removeSet) {
      var removeIter, results;
      removeIter = removeSet._unsafeIterator();
      results = this._unsafeIterator().filter(function(a) {
        return !removeIter.contains(a);
      });
      return this._generateFrom(results);
    }

    // This is marked "private" and named "unsafe" for a reason.  Since it does not copy the underlying agent array
    // it should only be used internally by the agent set when the resulting Iterator will immediately calculate or
    // tranform to a new value for the consumer.  --JMB, August 2018

      // () => Iterator[T]
    _unsafeIterator() {
      return new Iterator(this._agentArr);
    }

    // (() => Number) => AbstractAgentSet[T]
    maxesBy(f) {
      return this.copyWithNewAgents(this._findMaxesBy(f));
    }

    // (Number, () => Number) => AbstractAgentSet[T]
    maxNOf(n, f) {
      return this._findBestNOf(n, f, function(x, y) {
        if (x === y) {
          return 0;
        } else if (x > y) {
          return -1;
        } else {
          return 1;
        }
      });
    }

    // (() => Number) => T
    maxOneOf(f) {
      return this._randomOneOf(this._findMaxesBy(f));
    }

    // (Number, () => Number) => AbstractAgentSet[T]
    minNOf(n, f) {
      return this._findBestNOf(n, f, function(x, y) {
        if (x === y) {
          return 0;
        } else if (x < y) {
          return -1;
        } else {
          return 1;
        }
      });
    }

    // (() => Number) => T
    minOneOf(f) {
      return this._randomOneOf(this._findMinsBy(f));
    }

    // (() => Number) => AbstractAgentSet[T]
    minsBy(f) {
      return this.copyWithNewAgents(this._findMinsBy(f));
    }

    // [Result] @ (() => Result) => Array[Result]
    projectionBy(f) {
      return this.shufflerator().map(this._world.selfManager.askAgent(f));
    }

    // () => T
    randomAgent() {
      var choice, count, iter;
      iter = this._unsafeIterator();
      count = iter.size();
      if (count === 0) {
        return Nobody;
      } else {
        choice = this._world.rng.nextInt(count);
        return iter.nthItem(choice);
      }
    }

    // () => AbstractAgentSet[T]
    shuffled() {
      return this.copyWithNewAgents(this.shufflerator().toArray());
    }

    // () => Shufflerator[T]
    shufflerator() {
      return new Shufflerator(this.toArray(), (function(agent) {
        return (agent != null ? agent.id : void 0) >= 0;
      }), this._world.rng.nextInt);
    }

    // () => Number
    size() {
      return this._unsafeIterator().size();
    }

    // () => Array[T]
    sort() {
      if (this.isEmpty()) {
        return this.toArray();
      } else {
        return stableSort(this._unsafeIterator().toArray())(function(x, y) {
          return x.compare(y).toInt;
        });
      }
    }

    // [U] @ ((T) => U, (U, U) => Int) => Array[T]
    sortOn(f, sortingFunc) {
      var agentValuePairs;
      if (this.isEmpty()) {
        return [];
      } else {
        agentValuePairs = this.shufflerator().toArray().map(function(agent) {
          return [agent, agent.projectionBy(f)];
        });
        return stableSort(agentValuePairs)(sortingFunc).map(function([a, _]) {
          return a;
        });
      }
    }

    // () => Array[T]
    toArray() {
      this._agentArr = this._unsafeIterator().toArray(); // Prune out dead agents --JAB (7/21/14)
      return this._agentArr.slice(0);
    }

    // () => String
    toString() {
      var ref, ref1;
      return (ref = (ref1 = this._specialName) != null ? ref1.toLowerCase() : void 0) != null ? ref : `(agentset, ${this.size()} ${this._agentTypeName})`;
    }

    // (Number, () => Number, (Number, Number) => Number) => AbstractAgentSet[T]
    _findBestNOf(n, f, cStyleComparator) {
      var appendAgent, ask, best, collectWinners, groupByValue, ref, valueToAgentsMap;
      ask = this._world.selfManager.askAgent(f);
      groupByValue = function(acc, agent) {
        var entry, result;
        result = ask(agent);
        if (checks.isNumber(result)) {
          entry = acc[result];
          if (entry != null) {
            entry.push(agent);
          } else {
            acc[result] = [agent];
          }
        }
        return acc;
      };
      appendAgent = function([winners, numAdded], agent) {
        if (numAdded < n) {
          winners.push(agent);
          return [winners, numAdded + 1];
        } else {
          return [winners, numAdded];
        }
      };
      collectWinners = function([winners, numAdded], agents) {
        if (numAdded < n) {
          return foldl(appendAgent)([winners, numAdded])(agents);
        } else {
          return [winners, numAdded];
        }
      };
      valueToAgentsMap = foldl(groupByValue)({})(this.shufflerator().toArray());
      ref = pipeline(keys, map(parseFloat), (function(x) {
        return x.sort(cStyleComparator);
      }), map(function(value) {
        return valueToAgentsMap[value];
      }), foldl(collectWinners)([[], 0]))(valueToAgentsMap), best = ref[0], ref[1];
      return this._generateFrom(best);
    }

    // (Array[T]) => T
    _randomOneOf(agents) {
      if (agents.length === 0) {
        return Nobody;
      } else {
        return agents[this._world.rng.nextInt(agents.length)];
      }
    }

    // (Number, (Number, Number) => Boolean, () => Number) => Array[T]
    _findBestOf(worstPossible, findIsBetter, f) {
      var foldFunc, ref, winners;
      foldFunc = ([currentBest, currentWinners], agent) => {
        var result;
        result = this._world.selfManager.askAgent(f)(agent);
        if (result === currentBest) {
          currentWinners.push(agent);
          return [currentBest, currentWinners];
        } else if (checks.isNumber(result) && findIsBetter(result, currentBest)) {
          return [result, [agent]];
        } else {
          return [currentBest, currentWinners];
        }
      };
      ref = foldl(foldFunc)([worstPossible, []])(this._unsafeIterator().toArray()), ref[0], winners = ref[1];
      return winners;
    }

    // [U] @ (() => U) => Array[T]
    _findMaxesBy(f) {
      return this._findBestOf(-2e308, (function(result, currentBest) {
        return result > currentBest;
      }), f);
    }

    // [U] @ (() => U) => Array[T]
    _findMinsBy(f) {
      return this._findBestOf(2e308, (function(result, currentBest) {
        return result < currentBest;
      }), f);
    }

    // (Array[T]) => This[T]
    _generateFrom(newAgentArr) {
      return new this.constructor(newAgentArr, this._world);
    }

    // (() => Boolean) => AgentSet
    _optimalOtherWith(f) {
      var filterer, self;
      self = this._world.selfManager.self();
      filterer = function(x) {
        return x !== self && x.projectionBy(f);
      };
      return this.copyWithNewAgents(this._unsafeIterator().filter(filterer));
    }

    // (() => Boolean) => Agent
    _optimalOneOfWith(f) {
      var finder;
      finder = function(x) {
        return x.projectionBy(f);
      };
      return this.shufflerator().find(finder, Nobody);
    }

    // (() => Boolean) => Boolean
    _optimalAnyWith(f) {
      return this.exists(this._world.selfManager.askAgent(f));
    }

    // (() => Boolean) => Boolean
    _optimalAnyOtherWith(f) {
      var checker, self;
      self = this._world.selfManager.self();
      checker = function(x) {
        return x !== self && x.projectionBy(f);
      };
      return this.exists(checker);
    }

    // (() => Boolean) => Number
    _optimalCountOtherWith(f) {
      var filterer, self;
      self = this._world.selfManager.self();
      filterer = function(x) {
        return x !== self && x.projectionBy(f);
      };
      return this._unsafeIterator().filter(filterer).length;
    }

    // (() => Boolean) => Number
    _optimalCountWith(f) {
      var filterer;
      filterer = function(x) {
        return x.projectionBy(f);
      };
      return this._unsafeIterator().filter(filterer).length;
    }

    // (Number, (Number, Number) => Boolean) => Boolean
    _optimalCheckCount(n, operator) {
      return this._unsafeIterator().checkCount(n, operator);
    }

  };

}).call(this);

},{"./agentset/atpoints":"engine/core/agentset/atpoints","./typechecker":"engine/core/typechecker","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/object":"brazier/object","util/interrupts":"util/interrupts","util/iterator":"util/iterator","util/shufflerator":"util/shufflerator","util/stablesort":"util/stablesort"}],"engine/core/agentset/atpoints":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var checks, filter, flatMap, genPatchGrabber, getPatchesAtPoints, map, pipeline, unique;

  ({checks} = require('../typechecker'));

  ({filter, flatMap, map, unique} = require('brazierjs/array'));

  ({pipeline} = require('brazierjs/function'));

  // In this file: `this.type` is `AbstractAgentSet[T]`

  // (SelfType, (Number, Number) => Patch) => (Number, Number) => Patch
  genPatchGrabber = function(self, worldPatchAt) {
    if (self === 0) {
      return worldPatchAt;
    } else if (checks.isTurtle(self) || checks.isPatch(self)) {
      return self.patchAt;
    } else {
      return function() {
        return Nobody;
      };
    }
  };

  // ((Any) => String, (Number, Number) => Patch, Array[(Number, Number)]) => Array[Patch]
  getPatchesAtPoints = function(patchAt, points) {
    var f;
    f = function(point) {
      return patchAt(...point);
    };
    return pipeline(map(f), filter(function(x) {
      return x !== Nobody;
    }))(points);
  };

  // ((Any) => String, () => Agent, (Number, Number) => Patch) => (Array[Any]) => AbstractAgentSet[T]
  module.exports = function(getSelf, getPatchAt) {
    return function(points) {
      var breedName, copyThatFloppy, filterContaining, newAgents, patchAt, patches, turtlesOnPatches, upperBreedName;
      filterContaining = filter((x) => {
        return this.contains(x);
      });
      breedName = this.getSpecialName();
      patchAt = genPatchGrabber(getSelf(), getPatchAt);
      patches = getPatchesAtPoints(patchAt, points);
      newAgents = checks.isPatchSet(this) ? breedName === "patches" ? patches : filterContaining(patches) : checks.isTurtleSet(this) ? (turtlesOnPatches = pipeline(flatMap(function(p) {
        return p.turtlesHere().toArray();
      }), unique)(patches), breedName === "turtles" ? turtlesOnPatches : breedName != null ? (upperBreedName = breedName.toUpperCase(), filter(function(x) {
        return upperBreedName === x.getBreedName();
      })(turtlesOnPatches)) : filterContaining(turtlesOnPatches)) : []; // Breed set
      copyThatFloppy = (x) => {
        return this.copyWithNewAgents.call(this, x);
      };
      return pipeline(unique, copyThatFloppy)(newAgents);
    };
  };

}).call(this);

},{"../typechecker":"engine/core/typechecker","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function"}],"engine/core/agenttoint":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var checks;

  ({checks} = require('./typechecker'));

  module.exports = function(agent) {
    if (checks.isTurtle(agent)) {
      return 1;
    } else if (checks.isPatch(agent)) {
      return 2;
    } else if (checks.isLink(agent)) {
      return 3;
    } else {
      return 0;
    }
  };

}).call(this);

},{"./typechecker":"engine/core/typechecker"}],"engine/core/breedmanager":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Breed, BreedManager, count, foldl, getNextOrdinal, isEmpty, last, map, pipeline, sortedIndexBy, toObject, values;

  ({foldl, isEmpty, last, map, sortedIndexBy, toObject} = require('brazierjs/array'));

  ({pipeline} = require('brazierjs/function'));

  ({values} = require('brazierjs/object'));

  count = 0;

  getNextOrdinal = function() {
    return count++;
  };

  Breed = (function() {
    class Breed {
      
        // (String, String, BreedManager, Array[String], Boolean, String, Array[Agent]) => Breed
      constructor(originalName, originalSingular, _manager, varNames = [], _isDirectedLinkBreed, _shape = void 0, members = []) {
        this.originalName = originalName;
        this.originalSingular = originalSingular;
        this._manager = _manager;
        this.varNames = varNames;
        this._isDirectedLinkBreed = _isDirectedLinkBreed;
        this._shape = _shape;
        this.members = members;
        this.name = this.originalName.toUpperCase();
        this.singular = this.originalSingular.toLowerCase();
        this.ordinal = getNextOrdinal();
      }

      // We can't just set this in the constructor, because people can swoop into the manager and change the turtles'
      // default shape --JAB (5/27/14)
      // () => String
      getShape() {
        var ref;
        return (ref = this._shape) != null ? ref : (this.isLinky() ? this._manager.links()._shape : this._manager.turtles()._shape);
      }

      // (String) => Unit
      setShape(newShape) {
        this._shape = newShape;
      }

      // (Agent) => Unit
      add(newAgent) {
        var howManyToThrowOut, whatToInsert;
        if (isEmpty(this.members) || last(this.members).id < newAgent.id) {
          this.members.push(newAgent);
        } else {
          this.members.splice(this._getAgentIndex(newAgent), howManyToThrowOut = 0, whatToInsert = newAgent);
        }
      }

      // Agent -> Boolean
      contains(agent) {
        return this.members.includes(agent);
      }

      // (Agent) => Unit
      remove(agent) {
        var howManyToThrowOut;
        this.members.splice(this._getAgentIndex(agent), howManyToThrowOut = 1);
        if (this.isLinky() && this.name !== "LINKS") {
          this._manager.links().remove(agent);
        }
        if (!this.isLinky() && this.name !== "TURTLES") {
          this._manager.turtles().remove(agent);
        }
      }

      // () => Boolean
      isLinky() {
        return this._isDirectedLinkBreed != null;
      }

      // () => Boolean
      isUndirected() {
        return this._isDirectedLinkBreed === false;
      }

      // () => Boolean
      isDirected() {
        return this._isDirectedLinkBreed === true;
      }

      // (Agent) => Number
      _getAgentIndex(agent) {
        return sortedIndexBy(function(a) {
          return a.id;
        })(this.members)(agent);
      }

    };

    Breed.prototype.ordinal = void 0; // Number

    return Breed;

  }).call(this);

  module.exports = BreedManager = (function() {
    class BreedManager {
      
        // (Array[BreedObj], Array[String], Array[String]) => BreedManager
      constructor(breedObjs, turtlesOwns = [], linksOwns = []) {
        var defaultBreeds;
        defaultBreeds = {
          TURTLES: new Breed("turtles", "turtle", this, turtlesOwns, void 0, "default"),
          LINKS: new Breed("links", "link", this, linksOwns, false, "default")
        };
        this._breeds = foldl((acc, breedObj) => {
          var breed, ref, trueVarNames;
          trueVarNames = (ref = breedObj.varNames) != null ? ref : [];
          breed = new Breed(breedObj.name, breedObj.singular, this, trueVarNames, breedObj.isDirected);
          acc[breed.name] = breed;
          return acc;
        })(defaultBreeds)(breedObjs);
        this._singularBreeds = pipeline(values, map(function(b) {
          return [b.singular, b];
        }), toObject)(this._breeds);
      }

      // () => Object[Breed]
      breeds() {
        return this._breeds;
      }

      // () => Array[String]
      orderedBreeds() {
        if (this._orderedBreeds == null) {
          this._orderedBreeds = Object.getOwnPropertyNames(this._breeds).sort((a, b) => {
            return this._breeds[a].ordinal - this._breeds[b].ordinal;
          });
        }
        return this._orderedBreeds;
      }

      // () => Array[String]
      orderedLinkBreeds() {
        if (this._orderedLinkBreeds == null) {
          this._orderedLinkBreeds = this.orderedBreeds().filter((b) => {
            return this._breeds[b].isLinky();
          });
        }
        return this._orderedLinkBreeds;
      }

      // () => Array[String]
      orderedTurtleBreeds() {
        if (this._orderedTurtleBreeds == null) {
          this._orderedTurtleBreeds = this.orderedBreeds().filter((b) => {
            return !this._breeds[b].isLinky();
          });
        }
        return this._orderedTurtleBreeds;
      }

      // (String) => Breed
      get(name) {
        return this._breeds[name.toUpperCase()];
      }

      // (String) => Breed
      getSingular(name) {
        return this._singularBreeds[name.toLowerCase()];
      }

      // (String, String) => Unit
      setDefaultShape(breedName, shape) {
        this.get(breedName).setShape(shape.toLowerCase());
      }

      // () => Unit
      setUnbreededLinksUndirected() {
        this.links()._isDirectedLinkBreed = false;
      }

      // () => Unit
      setUnbreededLinksDirected() {
        this.links()._isDirectedLinkBreed = true;
      }

      // () => Breed
      turtles() {
        return this.get("TURTLES");
      }

      // () => Breed
      links() {
        return this.get("LINKS");
      }

    };

    // type BreedObj = { name: String, singular: String, varNames: Array[String], isDirected: Boolean }
    BreedManager.prototype._breeds = void 0; // Object[Breed]

    BreedManager.prototype._singularBreeds = void 0; // Object[Breed]

    return BreedManager;

  }).call(this);

}).call(this);

},{"brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/object":"brazier/object"}],"engine/core/colormodel":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var BaseColors, BaseRGBs, ColorMax, JSType, NLMath, NamesToIndicesMap, RGBCache, RGBMap, StrictMath, attenuate, attenuateRGB, componentsToKey, exceptions, foldl, keyToComponents, map, pairs, pipeline, rangeUntil;

  NLMath = require('util/nlmath');

  JSType = require('util/jstype');

  StrictMath = require('shim/strictmath');

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({foldl, map} = require('brazierjs/array'));

  ({pipeline} = require('brazierjs/function'));

  ({rangeUntil} = require('brazierjs/number'));

  ({pairs} = require('brazierjs/object'));

  // type ColorNumber = Number
  // type ColorName   = String
  // type HSB         = (Number, Number, Number)
  // type RGB         = (Number, Number, Number)
  // type RGBA        = (Number, Number, Number, Number)

  // (Number, Number) => (Number) => Number
  attenuate = function(lowerBound, upperBound) {
    return function(x) {
      if (x < lowerBound) {
        return lowerBound;
      } else if (x > upperBound) {
        return upperBound;
      } else {
        return x;
      }
    };
  };

  // (Number) => Number
  attenuateRGB = attenuate(0, 255);

  // (RGB...) => String
  componentsToKey = function(r, g, b) {
    return `${r}_${g}_${b}`;
  };

  // (String) => RGB
  keyToComponents = function(key) {
    return key.split('_').map(parseFloat);
  };

  ColorMax = 140;

  // Array[ColorNumber]
  BaseColors = map(function(n) {
    return (n * 10) + 5;
  })(rangeUntil(0)(ColorMax / 10));

  // Object[ColorName, Number]
  NamesToIndicesMap = (function() {
    var color, i, j, len, ref, temp;
    temp = {};
    ref = ['gray', 'red', 'orange', 'brown', 'yellow', 'green', 'lime', 'turqoise', 'cyan', 'sky', 'blue', 'violet', 'magenta', 'pink', 'black', 'white'];
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      color = ref[i];
      temp[color] = i;
    }
    return temp;
  })();

  // copied from api/Color.scala. note these aren't the same numbers as
  // `map extract-rgb base-colors` gives you; see comments in Scala source --BH
  // Array[RGB]
  BaseRGBs = [
    [
      140,
      140,
      140 // gray       (5)
    ],
    [
      215,
      48,
      39 // red       (15)
    ],
    [
      241,
      105,
      19 // orange    (25)
    ],
    [
      156,
      109,
      70 // brown     (35)
    ],
    [
      237,
      237,
      47 // yellow    (45)
    ],
    [
      87,
      176,
      58 // green     (55)
    ],
    [
      42,
      209,
      57 // lime      (65)
    ],
    [
      27,
      158,
      119 // turquoise (75)
    ],
    [
      82,
      196,
      196 // cyan      (85)
    ],
    [
      43,
      140,
      190 // sky       (95)
    ],
    [
      50,
      92,
      168 // blue     (105)
    ],
    [
      123,
      78,
      163 // violet   (115)
    ],
    [
      166,
      25,
      105 // magenta  (125)
    ],
    [
      224,
      126,
      149 // pink     (135)
    ],
    [
      0,
      0,
      0 // black
    ],
    [
      255,
      255,
      255 // white
    ]
  ];

  // (Array[RGB], Object[String, RGB])
  [RGBCache, RGBMap] = (function() {
    var baseIndex, clamp, colorTimesTen, finalRGB, rgb, rgbCache, rgbMap, step;
    rgbMap = {};
    rgbCache = (function() {
      var j, ref, results;
      results = [];
      for (colorTimesTen = j = 0, ref = ColorMax * 10; (0 <= ref ? j < ref : j > ref); colorTimesTen = 0 <= ref ? ++j : --j) {
        // We do this branching to make sure that the right color
        // is used for white and black, which appear multiple times
        // in NetLogo's nonsensical color space --JAB (9/24/15)
        finalRGB = colorTimesTen === 0 ? [0, 0, 0] : colorTimesTen === 99 ? [255, 255, 255] : (baseIndex = StrictMath.floor(colorTimesTen / 100), rgb = BaseRGBs[baseIndex], step = (colorTimesTen % 100 - 50) / 50.48 + 0.012, clamp = step <= 0 ? function(x) {
          return x;
        } : function(x) {
          return 0xFF - x;
        }, rgb.map(function(x) {
          return x + StrictMath.trunc(clamp(x) * step);
        }));
        rgbMap[componentsToKey(...finalRGB)] = colorTimesTen / 10;
        results.push(finalRGB);
      }
      return results;
    })();
    return [rgbCache, rgbMap];
  })();

  module.exports = {
    COLOR_MAX: ColorMax, // ColorNumber
    BASE_COLORS: BaseColors, // Array[ColorNumber]
    
    // (ColorNumber, ColorNumber) => Boolean
    areRelatedByShade: function(color1, color2) {
      return this._colorIntegral(color1) === this._colorIntegral(color2);
    },
    // [T <: ColorNumber|RGB|RGBA|ColorName] @ (T) => RGB|RGBA
    colorToList: function(color) {
      var b, g, r;
      [r, g, b] = this.colorToRGB(color);
      if (color.length === 4) {
        return [r, g, b, color[3]];
      } else {
        return [r, g, b];
      }
    },
    // [T <: ColorNumber|RGB|ColorName] @ (T) => RGB
    colorToRGB: function(color) {
      var type;
      type = JSType(color);
      if (type.isNumber()) {
        return RGBCache[StrictMath.floor(this.wrapColor(color) * 10)];
      } else if (type.isArray()) {
        return color.slice(0, 3).map(function(c) {
          return StrictMath.round(c);
        });
      } else if (type.isString()) {
        return this._nameToRGB(color);
      } else {
        throw exceptions.internal(`Unrecognized color format: ${color}`);
      }
    },
    // [T <: ColorNumber|RGB] @ (T) => HSB
    colorToHSB: function(color) {
      var b, g, r, type;
      type = JSType(color);
      [r, g, b] = (function() {
        if (type.isNumber()) {
          return this.colorToRGB(color);
        } else if (type.isArray()) {
          return color;
        } else {
          throw exceptions.internal(`Unrecognized color format: ${color}`);
        }
      }).call(this);
      return this.rgbToHSB(r, g, b);
    },
    // (RGB...) => RGB
    genRGBFromComponents: function(r, g, b) {
      return [r, g, b].map(attenuateRGB);
    },
    // Courtesy of Paul S. at http://stackoverflow.com/a/17243070/1116979 --JAB (9/23/15)
    // (HSB...) => RGB
    hsbToRGB: function(rawH, rawS, rawB) {
      var b, f, h, i, p, q, rgb, s, t;
      h = attenuate(0, 360)(rawH) / 360;
      s = attenuate(0, 100)(rawS) / 100;
      b = attenuate(0, 100)(rawB) / 100;
      i = StrictMath.floor(h * 6);
      f = h * 6 - i;
      p = b * (1 - s);
      q = b * (1 - f * s);
      t = b * (1 - (1 - f) * s);
      rgb = (function() {
        switch (i % 6) {
          case 0:
            return [b, t, p];
          case 1:
            return [q, b, p];
          case 2:
            return [p, b, t];
          case 3:
            return [p, q, b];
          case 4:
            return [t, p, b];
          case 5:
            return [b, p, q];
        }
      })();
      return rgb.map(function(x) {
        return StrictMath.round(x * 255);
      });
    },
    // (HSB...) => ColorNumber
    nearestColorNumberOfHSB: function(h, s, b) {
      return this.nearestColorNumberOfRGB(...this.hsbToRGB(h, s, b));
    },
    // (RGB...) => ColorNumber
    nearestColorNumberOfRGB: function(r, g, b) {
      var blue, colorNumber, green, red, ref;
      red = attenuateRGB(r);
      green = attenuateRGB(g);
      blue = attenuateRGB(b);
      colorNumber = (ref = RGBMap[componentsToKey(red, green, blue)]) != null ? ref : this._estimateColorNumber(red, green, blue);
      return colorNumber;
    },
    // (Number) => ColorNumber
    nthColor: function(n) {
      var index;
      index = n % BaseColors.length;
      return BaseColors[index];
    },
    // ((Number) => Number) => ColorNumber
    randomColor: function(nextInt) {
      var index;
      index = nextInt(BaseColors.length);
      return BaseColors[index];
    },
    // (Array[Number]) => RGB
    rgbList: function(components) {
      return components.map(function(c) {
        return attenuateRGB(StrictMath.ceil(c));
      }).slice(0, 3);
    },
    // Courtesy of Paul S. at http://stackoverflow.com/a/17243070/1116979 --JAB (9/23/15)
    // (RGB...) => HSB
    rgbToHSB: function(rawR, rawG, rawB) {
      var b, brightness, difference, g, hue, max, min, r, saturation;
      r = attenuateRGB(rawR);
      g = attenuateRGB(rawG);
      b = attenuateRGB(rawB);
      max = NLMath.max(r, g, b);
      min = NLMath.min(r, g, b);
      difference = max - min;
      hue = (function() {
        switch (max) {
          case min:
            return 0;
          case r:
            return ((g - b) + difference * (g < b ? 6 : 0)) / (6 * difference);
          case g:
            return ((b - r) + difference * 2) / (6 * difference);
          case b:
            return ((r - g) + difference * 4) / (6 * difference);
        }
      })();
      saturation = max === 0 ? 0 : difference / max;
      brightness = max / 255;
      return [hue * 360, saturation * 100, brightness * 100].map(function(x) {
        return NLMath.precision(x, 3);
      });
    },
    // [T <: ColorNumber|RGB] @ (T) => T
    wrapColor: function(color) {
      var modColor;
      if (JSType(color).isArray()) {
        return color; // Bah!  This branch ought to be equivalent to `color %% ColorMax`, but that causes floating-point discrepancies. --JAB (7/30/14)
      } else {
        modColor = color % ColorMax;
        if (modColor >= 0) {
          return modColor;
        } else {
          return ColorMax + modColor;
        }
      }
    },
    // (ColorNumber, Number, Number, Number) => Number
    scaleColor: function(color, number, min, max) {
      var finalPercent, percent, percent10, tempmax, tempval;
      percent = min > max ? number < max ? 1.0 : number > min ? 0.0 : (tempval = min - number, tempmax = min - max, tempval / tempmax) : number > max ? 1.0 : number <= min ? 0.0 : (tempval = number - min, tempmax = max - min, tempval / tempmax);
      percent10 = percent * 10;
      finalPercent = percent10 >= 9.9999 ? 9.9999 : percent10 < 0 ? 0 : percent10;
      return this._colorIntegral(color) * 10 + finalPercent;
    },
    // (ColorNumber) => Number
    _colorIntegral: function(color) {
      return StrictMath.floor(this.wrapColor(color) / 10);
    },
    // (ColorName) => RGB
    _nameToRGB: function(name) {
      return BaseRGBs[NamesToIndicesMap[name]];
    },
    // (RGB...) => ColorNumber
    _estimateColorNumber: function(r, g, b) {
      var f;
      f = (acc, [k, v]) => {
        var cb, cg, cr, dist;
        [cr, cg, cb] = keyToComponents(k);
        dist = this._colorDistance(r, g, b, cr, cg, cb);
        if (dist < acc[1]) {
          return [v, dist];
        } else {
          return acc;
        }
      };
      return pipeline(pairs, foldl(f)([0, Number.MAX_VALUE]))(RGBMap)[0];
    },
    // CoffeeScript code from the Scala code in Headless' './parser-core/src/main/core/Color.scala',
    // which was translated from Java code that came from a C snippet at www.compuphase.com/cmetric.htm
    // Dealwithit --JAB (9/24/15)
    // (Number, Number, Number, Number, Number, Number) => Number
    _colorDistance: function(r1, g1, b1, r2, g2, b2) {
      var bDiff, gDiff, rDiff, rMean;
      rMean = r1 + StrictMath.floor(r2 / 2);
      rDiff = r1 - r2;
      gDiff = g1 - g2;
      bDiff = b1 - b2;
      return (((512 + rMean) * rDiff * rDiff) >> 8) + 4 * gDiff * gDiff + (((767 - rMean) * bDiff * bDiff) >> 8);
    }
  };

  // I don't know what this code means.
// Leave a comment on this webzone if you know what this code means --JAB (9/24/15)

}).call(this);

},{"brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/number":"brazier/number","brazierjs/object":"brazier/object","shim/strictmath":"shim/strictmath","util/exception":"util/exception","util/jstype":"util/jstype","util/nlmath":"util/nlmath"}],"engine/core/link/linkvariables":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ColorModel, ImmutableVariableSpec, MutableVariableSpec, None, Setters, VariableSpecs, checks, exceptions, isSomething, maybe, setBreed, setColor, setEnd1, setEnd2, setIsHidden, setLabel, setLabelColor, setShape, setThickness, setTieMode, validateColor;

  ({maybe, None, isSomething} = require('brazierjs/maybe'));

  ColorModel = require('engine/core/colormodel');

  ({checks} = require('engine/core/typechecker'));

  ({ImmutableVariableSpec, MutableVariableSpec} = require('../structure/variablespec'));

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  // (Number|RGB|RGBA) => Maybe[String]
  validateColor = function(color) {
    var hasBadLength, isBadCompNumber, isBadCompType;
    hasBadLength = function(xs) {
      return xs.length !== 3 && xs.length !== 4;
    };
    isBadCompNumber = function(x) {
      return !((0 <= x && x <= 255));
    };
    isBadCompType = function(x) {
      return !checks.isNumber(x);
    };
    if (checks.isList(color) && (hasBadLength(color) || color.some(isBadCompType))) {
      return maybe("Invalid RGB format");
    } else if (checks.isList(color) && (color.some(isBadCompNumber))) {
      return maybe("Invalid RGB number");
    } else {
      return None;
    }
  };

  // (String) => Unit
  setShape = function(shape) {
    this._shape = shape.toLowerCase();
    this._genVarUpdate("shape");
  };

  // (AbstractAgentSet|Breed|String) => Unit
  setBreed = function(breed) {
    var newNames, oldNames, ref, ref1, ref2, specialName, trueBreed;
    trueBreed = (function() {
      if (checks.isString(breed)) {
        return this.world.breedManager.get(breed);
      } else if (checks.isAgentSet(breed)) {
        specialName = breed.getSpecialName();
        if ((specialName != null) && this.world.breedManager.get(specialName).isLinky()) {
          return this.world.breedManager.get(specialName);
        } else {
          throw exceptions.runtime("You can't set BREED to a non-link-breed agentset.", "set");
        }
      } else {
        return breed;
      }
    }).call(this);
    this.world.linkManager.trackBreedChange(this, trueBreed, (ref = (ref1 = this._breed) != null ? ref1.name : void 0) != null ? ref : "");
    if (this._breed !== trueBreed) {
      trueBreed.add(this);
      if ((ref2 = this._breed) != null) {
        ref2.remove(this);
      }
      newNames = this._varNamesForBreed(trueBreed);
      oldNames = this._varNamesForBreed(this._breed);
      this._varManager.refineBy(oldNames, newNames);
    }
    this._breed = trueBreed;
    this._genVarUpdate("breed");
    setShape.call(this, trueBreed.getShape());
    this._refreshName();
    if (!this.world.breedManager.links().contains(this)) {
      this.world.breedManager.links().add(this);
    }
  };

  // (Number|RGB|RGBA) => Maybe[String]
  setColor = function(color) {
    var errorMaybe;
    errorMaybe = validateColor(color);
    if (!isSomething(errorMaybe)) {
      this._color = ColorModel.wrapColor(color);
      this._genVarUpdate("color");
    }
    return errorMaybe;
  };

  // (Turtle) => Unit
  setEnd1 = function(turtle) {
    this.end1 = turtle;
    this._genVarUpdate("end1");
  };

  // (Turtle) => Unit
  setEnd2 = function(turtle) {
    this.end2 = turtle;
    this._genVarUpdate("end2");
  };

  // (Boolean) => Unit
  setIsHidden = function(isHidden) {
    this._isHidden = isHidden;
    this._genVarUpdate("hidden?");
  };

  // (String) => Unit
  setLabel = function(label) {
    this._label = label;
    this._genVarUpdate("label");
  };

  // (Number|RGB|RGBA) => Maybe[String]
  setLabelColor = function(color) {
    var errorMaybe;
    errorMaybe = validateColor(color);
    if (!isSomething(errorMaybe)) {
      this._labelcolor = ColorModel.wrapColor(color);
      this._genVarUpdate("label-color");
    }
    return errorMaybe;
  };

  // (Number) => Unit
  setThickness = function(thickness) {
    this._thickness = thickness;
    this._genVarUpdate("thickness");
  };

  // (String) => Unit
  setTieMode = function(mode) {
    this.tiemode = mode;
    this._genVarUpdate("tie-mode");
  };

  Setters = {setBreed, setColor, setEnd1, setEnd2, setIsHidden, setLabel, setLabelColor, setShape, setThickness, setTieMode};

  VariableSpecs = [
    new MutableVariableSpec('breed',
    (function() {
      return this._getLinksByBreedName(this._breed.name);
    }),
    setBreed),
    new MutableVariableSpec('color',
    (function() {
      return this._color;
    }),
    setColor),
    new MutableVariableSpec('end1',
    (function() {
      return this.end1;
    }),
    setEnd1),
    new MutableVariableSpec('end2',
    (function() {
      return this.end2;
    }),
    setEnd2),
    new MutableVariableSpec('hidden?',
    (function() {
      return this._isHidden;
    }),
    setIsHidden),
    new MutableVariableSpec('label',
    (function() {
      return this._label;
    }),
    setLabel),
    new MutableVariableSpec('label-color',
    (function() {
      return this._labelcolor;
    }),
    setLabelColor),
    new MutableVariableSpec('shape',
    (function() {
      return this._shape;
    }),
    setShape),
    new MutableVariableSpec('thickness',
    (function() {
      return this._thickness;
    }),
    setThickness),
    new MutableVariableSpec('tie-mode',
    (function() {
      return this.tiemode;
    }),
    setTieMode)
  ];

  module.exports = {Setters, VariableSpecs};

}).call(this);

},{"../structure/variablespec":"engine/core/structure/variablespec","brazierjs/maybe":"brazier/maybe","engine/core/colormodel":"engine/core/colormodel","engine/core/typechecker":"engine/core/typechecker","util/exception":"util/exception"}],"engine/core/linkset":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AbstractAgentSet, DeadSkippingIterator, JSType, LinkSet;

  AbstractAgentSet = require('./abstractagentset');

  DeadSkippingIterator = require('./structure/deadskippingiterator');

  JSType = require('util/jstype');

  module.exports = LinkSet = class LinkSet extends AbstractAgentSet {
    // [T <: Turtle] @ ((() => Array[T])|Array[T], World, String) => LinkSet
    constructor(agents, world, specialName) {
      super(LinkSet._unwrap(agents, false), world, "links", specialName);
      this._agents = agents;
    }

    // () => Iterator[T]
    iterator() {
      return new DeadSkippingIterator(LinkSet._unwrap(this._agents, true));
    }

    // () => Iterator[T]
    _unsafeIterator() {
      return new DeadSkippingIterator(LinkSet._unwrap(this._agents, false));
    }

    // I know, I know, this is insane, right?  "Why would you do this?!", you demand.  I don't blame you.  I don't like
    // it, either.  But, look... we have a problem on our hands.  Special agentsets are a thing.  They can be stored
    // into variables and then change from some code changing the special agentset.  With turtles, this works out fine,
    // because turtles are ordered by `who` number, and `who` numbers are a function of time, so we can just give a
    // `TurtleSet` a reference to the turtle array and grow it as we see fit.  Unfortunately, links are not quantally
    // ordered; they're ordered based on their properties, so we either need to provide a thunk for getting the latest
    // array, or we need to use a good sorting structure that represents the data as an array under the hood, and then
    // we can pass around that array.  Passing thunks seems to be the better option to me.  --JAB (9/7/14)
    // [T] @ ((() => Array[T])|Array[T]) => Array[T]
    static _unwrap(agents, copy) {
      if (JSType(agents).isFunction()) {
        return agents();
      } else if (copy) {
        return agents.slice(0);
      } else {
        return agents;
      }
    }

  };

}).call(this);

},{"./abstractagentset":"engine/core/abstractagentset","./structure/deadskippingiterator":"engine/core/structure/deadskippingiterator","util/jstype":"util/jstype"}],"engine/core/link":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AbstractAgentSet, ColorModel, Comparator, DeathInterrupt, ExtraVariableSpec, Link, Setters, Stamp, StampErase, StampMode, TurtleSet, VariableManager, VariableSpecs, checks, exceptions, ifInterrupt, linkCompare;

  AbstractAgentSet = require('./abstractagentset');

  ColorModel = require('./colormodel');

  linkCompare = require('./structure/linkcompare');

  VariableManager = require('./structure/variablemanager');

  TurtleSet = require('./turtleset');

  ({checks} = require('./typechecker'));

  Comparator = require('util/comparator');

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({ifInterrupt, DeathInterrupt} = require('util/interrupts'));

  ({Setters, VariableSpecs} = require('./link/linkvariables'));

  ({ExtraVariableSpec} = require('./structure/variablespec'));

  StampMode = class StampMode {
    constructor(name1) { // (String) => StampMode
      this.name = name1;
    }

  };

  Stamp = new StampMode("normal");

  StampErase = new StampMode("erase");

  module.exports = Link = (function() {
    class Link {
      
        // The type signatures here can be found to the right of the parameters. --JAB (4/21/15)
      constructor(id, isDirected, end1, end2, world, genUpdate, _registerDeath, _registerRemoval, _registerLinkStamp, _getLinksByBreedName, breed = this.world.breedManager.links(), _color = 5, _isHidden = false, _label = "", _labelcolor = 9.9, _shape = "default", _thickness = 0, tiemode = "none") { // RegLinkStampFunc, (String) => LinkSet, Breed, Number // Boolean, String, Number, String, Number // String
        var varNames;
        this.id = id;
        this.isDirected = isDirected;
        this.end1 = end1;
        this.end2 = end2;
        this.world = world;
        this._registerDeath = _registerDeath;
        this._registerRemoval = _registerRemoval; // Number, Boolean, Turtle, Turtle, World, (Updatable) => (String*) => Unit, (Number) => Unit, (Link) => Unit
        this._registerLinkStamp = _registerLinkStamp;
        this._getLinksByBreedName = _getLinksByBreedName;
        this._color = _color;
        this._isHidden = _isHidden;
        this._label = _label;
        this._labelcolor = _labelcolor;
        this._shape = _shape;
        this._thickness = _thickness;
        this.tiemode = tiemode;
        this._updateVarsByName = genUpdate(this);
        varNames = this._varNamesForBreed(breed);
        this._varManager = this._genVarManager(varNames);
        Setters.setBreed.call(this, breed);
        this.end1.linkManager.add(this);
        this.end2.linkManager.add(this);
        this.updateEndRelatedVars();
        this._updateVarsByName("directed?");
      }

      // () => String
      getBreedName() {
        return this._breed.name;
      }

      // () => String
      getBreedNameSingular() {
        return this._breed.singular;
      }

      // Tragically needed by `LinkCompare` for compliance with NetLogo's insane means of sorting links --JAB (9/6/14)
      // () => Number
      getBreedOrdinal() {
        return this._breed.ordinal;
      }

      // Unit -> String
      getName() {
        return this._name;
      }

      // (String) => Any
      getVariable(varName) {
        return this._varManager[varName];
      }

      // (String, Any) => Unit
      setVariable(varName, value) {
        this._varManager[varName] = value;
      }

      // (String, Any) => Maybe[Any]
      setIfValid(varName, value) {
        return this._varManager.setIfValid(varName, value);
      }

      // () => DeathInterrupt
      die() {
        this._breed.remove(this);
        if (!this.isDead()) {
          this.end1.linkManager.remove(this);
          this.end2.linkManager.remove(this);
          this._registerRemoval(this);
          this._seppuku();
          this.id = -1;
        }
        return DeathInterrupt;
      }

      // () => Unit
      stamp() {
        this._drawStamp(Stamp);
      }

      // () => Unit
      stampErase() {
        this._drawStamp(StampErase);
      }

      // () => TurtleSet
      bothEnds() {
        return new TurtleSet([this.end1, this.end2], this.world);
      }

      // () => Turtle
      otherEnd() {
        if (this.end1 === this.world.selfManager.myself()) {
          return this.end2;
        } else {
          return this.end1;
        }
      }

      // () => Unit
      tie() {
        Setters.setTieMode.call(this, "fixed");
      }

      // () => Unit
      untie() {
        Setters.setTieMode.call(this, "none");
      }

      // () => Unit
      updateEndRelatedVars() {
        this._updateVarsByName("heading", "size", "midpointx", "midpointy");
      }

      // () => String
      toString() {
        if (!this.isDead()) {
          return `(${this.getName()})`;
        } else {
          return "nobody";
        }
      }

      // () => (Number, Number)
      getCoords() {
        return [this.getMidpointX(), this.getMidpointY()];
      }

      // () => Number | TowardsInterrupt
      getHeading() {
        return this.world.topology.towards(this.end1.xcor, this.end1.ycor, this.end2.xcor, this.end2.ycor);
      }

      // () => Number
      getMidpointX() {
        return this.world.topology.midpointx(this.end1.xcor, this.end2.xcor);
      }

      // () => Number
      getMidpointY() {
        return this.world.topology.midpointy(this.end1.ycor, this.end2.ycor);
      }

      // () => Number
      getSize() {
        return this.world.topology.distanceXY(this.end1.xcor, this.end1.ycor, this.end2.xcor, this.end2.ycor);
      }

      // (String) => Boolean
      isBreed(breedName) {
        return this._breed.name.toUpperCase() === breedName.toUpperCase();
      }

      // () => Boolean
      isDead() {
        return this.id === -1;
      }

      // (() => Any) => Unit
      ask(f) {
        var base;
        if (!this.isDead()) {
          this.world.selfManager.askAgent(f)(this);
          if (typeof (base = this.world.selfManager.self()).isDead === "function" ? base.isDead() : void 0) {
            return DeathInterrupt;
          }
        } else {
          throw exceptions.runtime(`That ${this.getBreedNameSingular()} is dead.`, "ask");
        }
      }

      // [Result] @ (() => Result) => Result
      projectionBy(f) {
        if (!this.isDead()) {
          return this.world.selfManager.askAgent(f)(this);
        } else {
          throw exceptions.runtime(`That ${this._breed.singular} is dead.`, "of");
        }
      }

      // (Any) => { toInt: Number }
      compare(x) {
        if (checks.isLink(x)) {
          switch (linkCompare(this, x)) {
            case -1:
              return Comparator.LESS_THAN;
            case 0:
              return Comparator.EQUALS;
            case 1:
              return Comparator.GREATER_THAN;
            default:
              return exceptions.internal("Comparison should only yield an integer within the interval [-1,1]");
          }
        } else {
          return Comparator.NOT_EQUALS;
        }
      }

      // () => Boolean
      hasVariable(varName) {
        return this._varManager.has(varName);
      }

      // () => Array[String]
      varNames() {
        return this._varManager.names();
      }

      // (StampMode) => Unit
      _drawStamp(mode) {
        var color, e1x, e1y, e2x, e2y, midX, midY, stampHeading;
        ({
          xcor: e1x,
          ycor: e1y
        } = this.end1);
        ({
          xcor: e2x,
          ycor: e2y
        } = this.end2);
        stampHeading = ifInterrupt(this.world.topology.towards(e1x, e1y, e2x, e2y), 0);
        color = ColorModel.colorToList(this._color);
        midX = this.getMidpointX();
        midY = this.getMidpointY();
        this._registerLinkStamp(e1x, e1y, e2x, e2y, midX, midY, stampHeading, color, this._shape, this._thickness, this.isDirected, this.getSize(), this._isHidden, mode.name);
      }

      // Unit -> Unit
      _refreshName() {
        this._name = `${this._breed.singular} ${this.end1.id} ${this.end2.id}`;
      }

      // (Breed) => Array[String]
      _varNamesForBreed(breed) {
        var linksBreed;
        linksBreed = this.world.breedManager.links();
        if (breed === linksBreed || (breed == null)) {
          return linksBreed.varNames;
        } else {
          return linksBreed.varNames.concat(breed.varNames);
        }
      }

      // () => Unit
      _seppuku() {
        this._registerDeath(this.id);
      }

      // (Array[String]) => VariableManager
      _genVarManager(extraVarNames) {
        var allSpecs, extraSpecs;
        extraSpecs = extraVarNames.map(function(name) {
          return new ExtraVariableSpec(name);
        });
        allSpecs = VariableSpecs.concat(extraSpecs);
        return new VariableManager(this, allSpecs);
      }

      // (String) => Unit
      _genVarUpdate(varName) {
        this._updateVarsByName(varName);
      }

    };

    // type RegLinkStampFunc = (Number, Number, Number, Number, Number, Number, Number, RGB, String, Number, String) => Unit
    Link.prototype._breed = void 0; // Breed

    Link.prototype._name = void 0; // String

    Link.prototype._updateVarsByName = void 0; // (String*) => Unit

    Link.prototype._varManager = void 0; // VariableManager

    return Link;

  }).call(this);

}).call(this);

},{"./abstractagentset":"engine/core/abstractagentset","./colormodel":"engine/core/colormodel","./link/linkvariables":"engine/core/link/linkvariables","./structure/linkcompare":"engine/core/structure/linkcompare","./structure/variablemanager":"engine/core/structure/variablemanager","./structure/variablespec":"engine/core/structure/variablespec","./turtleset":"engine/core/turtleset","./typechecker":"engine/core/typechecker","util/comparator":"util/comparator","util/exception":"util/exception","util/interrupts":"util/interrupts"}],"engine/core/observer":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise

  // data Perspective =
  var ExtraVariableSpec, Follow, Observe, Observer, Ride, VariableManager, Watch, agentToInt, checks, difference, exceptions, forEach, perspectiveFromNum, perspectiveFromString, perspectiveToNum, perspectiveToString;

  Observe = {};

  Ride = {};

  Follow = {};

  Watch = {};

  agentToInt = require('./agenttoint');

  ({checks} = require('./typechecker'));

  VariableManager = require('./structure/variablemanager');

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({difference, forEach} = require('brazierjs/array'));

  ({ExtraVariableSpec} = require('./structure/variablespec'));

  perspectiveFromNum = function(num) {
    switch (num) {
      case 0:
        return Observe;
      case 1:
        return Ride;
      case 2:
        return Follow;
      case 3:
        return Watch;
      default:
        throw exceptions.internal(`Invalid perspective number: ${num}`);
    }
  };

  perspectiveToNum = function(p) {
    switch (p) {
      case Observe:
        return 0;
      case Ride:
        return 1;
      case Follow:
        return 2;
      case Watch:
        return 3;
      default:
        throw exceptions.internal(`Invalid perspective: ${p}`);
    }
  };

  perspectiveFromString = function(str) {
    switch (str) {
      case 'observe':
        return Observe;
      case 'ride':
        return Ride;
      case 'follow':
        return Follow;
      case 'watch':
        return Watch;
      default:
        throw exceptions.internal(`Invalid perspective string: ${str}`);
    }
  };

  perspectiveToString = function(p) {
    switch (p) {
      case Observe:
        return 'observe';
      case Ride:
        return 'ride';
      case Follow:
        return 'follow';
      case Watch:
        return 'watch';
      default:
        throw exceptions.internal(`Invalid perspective: ${p}`);
    }
  };

  module.exports.Perspective = {Observe, Ride, Follow, Watch, perspectiveFromNum, perspectiveToNum, perspectiveFromString, perspectiveToString};

  module.exports.Observer = Observer = (function() {
    class Observer {
      
        // ((Updatable) => (String*) => Unit, Array[String], Array[String]) => Observer
      constructor(genUpdate, _globalNames, _interfaceGlobalNames) {
        var globalSpecs;
        this._globalNames = _globalNames;
        this._interfaceGlobalNames = _interfaceGlobalNames;
        this._updateVarsByName = genUpdate(this);
        this.resetPerspective();
        globalSpecs = this._globalNames.map(function(name) {
          return new ExtraVariableSpec(name);
        });
        this._varManager = new VariableManager(this, globalSpecs);
        this._codeGlobalNames = difference(this._globalNames)(this._interfaceGlobalNames);
      }

      // () => Unit
      clearCodeGlobals() {
        forEach((name) => {
          this._varManager[name] = 0;
        })(this._codeGlobalNames);
      }

      // (Turtle) => Unit
      follow(turtle) {
        this._perspective = Follow;
        this._targetAgent = turtle;
        this._updatePerspective();
      }

      // (String) => Any
      getGlobal(varName) {
        return this._varManager[varName];
      }

      // (String) => Any
      getVariable(varName) {
        return this.getGlobal(varName);
      }

      // () => Perspective
      getPerspective() {
        return this._perspective;
      }

      // (Perspective, Agent) => Unit
      setPerspective(perspective, subject) {
        this._perspective = perspective;
        this._targetAgent = subject;
        this._updatePerspective();
      }

      // () => Unit
      resetPerspective() {
        this._perspective = Observe;
        this._targetAgent = null;
        this._updatePerspective();
      }

      // (Turtle) => Unit
      ride(turtle) {
        this._perspective = Ride;
        this._targetAgent = turtle;
        this._updatePerspective();
      }

      // (String, Any) => Unit
      setGlobal(varName, value) {
        this._varManager[varName] = value;
      }

      // (String, Any) => Unit
      setVariable(varName, value) {
        this.setGlobal(varName, value);
      }

      // () => Agent
      subject() {
        var ref;
        return (ref = this._targetAgent) != null ? ref : Nobody;
      }

      // (Turtle) => Unit
      unfocus(turtle) {
        if (this._targetAgent === turtle) {
          this.resetPerspective();
        }
      }

      // () => Array[String]
      varNames() {
        return this._varManager.names();
      }

      // (Agent) => Unit
      watch(agent) {
        this._perspective = Watch;
        this._targetAgent = checks.isTurtle(agent) || checks.isPatch(agent) ? agent : Nobody;
        this._updatePerspective();
      }

      // () => Unit
      _updatePerspective() {
        this._updateVarsByName("perspective", "targetAgent");
      }

      // Used by `Updater` --JAB (9/4/14)
      // () => (Number, Number)
      _getTargetAgentUpdate() {
        if (this._targetAgent != null) {
          return [agentToInt(this._targetAgent), this._targetAgent.id];
        } else {
          return null;
        }
      }

    };

    Observer.prototype.id = 0; // Number

    Observer.prototype._varManager = void 0; // VariableManager

    Observer.prototype._perspective = void 0; // Perspective

    Observer.prototype._targetAgent = void 0; // Agent

    Observer.prototype._codeGlobalNames = void 0; // Array[String]

    Observer.prototype._updateVarsByName = void 0; // (String*) => Unit

    return Observer;

  }).call(this);

}).call(this);

},{"./agenttoint":"engine/core/agenttoint","./structure/variablemanager":"engine/core/structure/variablemanager","./structure/variablespec":"engine/core/structure/variablespec","./typechecker":"engine/core/typechecker","brazierjs/array":"brazier/array","util/exception":"util/exception"}],"engine/core/patch/patchvariables":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ColorModel, ImmutableVariableSpec, MutableVariableSpec, None, Setters, VariableSpecs, all, checks, isArray, isNumber, isSomething, maybe, setPcolor, setPlabel, setPlabelColor, validateColor;

  ColorModel = require('engine/core/colormodel');

  ({checks} = require('engine/core/typechecker'));

  ({ImmutableVariableSpec, MutableVariableSpec} = require('../structure/variablespec'));

  ({all} = require('brazierjs/array'));

  ({maybe, None, isSomething} = require('brazierjs/maybe'));

  ({isArray, isNumber} = require('brazierjs/type'));

  // (Number|RGB|RGBA) => Maybe[String]
  validateColor = function(color) {
    var hasBadLength, isBadCompNumber, isBadCompType;
    hasBadLength = function(xs) {
      return ![3, 4].includes(xs.length);
    };
    isBadCompNumber = function(x) {
      return !((0 <= x && x <= 255));
    };
    isBadCompType = function(x) {
      return !checks.isNumber(x);
    };
    if (checks.isList(color) && (hasBadLength(color) || color.some(isBadCompType))) {
      return maybe("Invalid RGB format");
    } else if (checks.isList(color) && (color.some(isBadCompNumber))) {
      return maybe("Invalid RGB number");
    } else if (!checks.isList(color) && !checks.isNumber(color)) {
      return maybe("Invalid color type");
    } else {
      return None;
    }
  };

  // (Number|RGB|RGBA) => Maybe[String]
  setPcolor = function(color) {
    var errorMaybe, wrappedColor;
    errorMaybe = validateColor(color);
    if (!isSomething(errorMaybe)) {
      wrappedColor = ColorModel.wrapColor(color);
      if (this._pcolor !== wrappedColor) {
        this._pcolor = wrappedColor;
        this._genVarUpdate("pcolor");
        if ((isNumber(wrappedColor) && wrappedColor !== 0) || (isArray(wrappedColor) && !all(function(n) {
          return n % 10 === 0;
        })(wrappedColor))) {
          this._declareNonBlackPatch();
        }
      }
    }
    return errorMaybe;
  };

  // (String) => Unit
  setPlabel = function(label) {
    var isEmpty, wasEmpty;
    wasEmpty = this._plabel === "";
    isEmpty = label === "";
    this._plabel = label;
    this._genVarUpdate("plabel");
    if (isEmpty && !wasEmpty) {
      this._decrementPatchLabelCount();
    } else if (!isEmpty && wasEmpty) {
      this._incrementPatchLabelCount();
    }
  };

  // (Number|RGB|RGBA) => Maybe[String]
  setPlabelColor = function(color) {
    var errorMaybe;
    errorMaybe = validateColor(color);
    if (!isSomething(errorMaybe)) {
      this._plabelcolor = ColorModel.wrapColor(color);
      this._genVarUpdate("plabel-color");
    }
    return errorMaybe;
  };

  Setters = {setPcolor, setPlabel, setPlabelColor};

  VariableSpecs = [
    new ImmutableVariableSpec('pxcor',
    function() {
      return this.pxcor;
    }),
    new ImmutableVariableSpec('pycor',
    function() {
      return this.pycor;
    }),
    new MutableVariableSpec('pcolor',
    (function() {
      return this._pcolor;
    }),
    setPcolor),
    new MutableVariableSpec('plabel',
    (function() {
      return this._plabel;
    }),
    setPlabel),
    new MutableVariableSpec('plabel-color',
    (function() {
      return this._plabelcolor;
    }),
    setPlabelColor)
  ];

  module.exports = {Setters, VariableSpecs};

}).call(this);

},{"../structure/variablespec":"engine/core/structure/variablespec","brazierjs/array":"brazier/array","brazierjs/maybe":"brazier/maybe","brazierjs/type":"brazier/type","engine/core/colormodel":"engine/core/colormodel","engine/core/typechecker":"engine/core/typechecker"}],"engine/core/patchset":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AbstractAgentSet, Iterator, PatchSet;

  AbstractAgentSet = require('./abstractagentset');

  Iterator = require('util/iterator');

  module.exports = PatchSet = class PatchSet extends AbstractAgentSet {
    // [T <: Patch] @ (Array[T], World, String) => PatchSet
    constructor(agents, world, specialName) {
      super(agents, world, "patches", specialName);
    }

  };

}).call(this);

},{"./abstractagentset":"engine/core/abstractagentset","util/iterator":"util/iterator"}],"engine/core/patch":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Comparator, DeathInterrupt, ExtraVariableSpec, Patch, Setters, TurtleSet, VariableManager, VariableSpecs, checks, exceptions, filter, foldl;

  TurtleSet = require('./turtleset');

  ({checks} = require('./typechecker'));

  VariableManager = require('./structure/variablemanager');

  Comparator = require('util/comparator');

  ({filter, foldl} = require('brazierjs/array'));

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({DeathInterrupt} = require('util/interrupts'));

  ({Setters, VariableSpecs} = require('./patch/patchvariables'));

  ({ExtraVariableSpec} = require('./structure/variablespec'));

  module.exports = Patch = (function() {
    class Patch {
      
        // (Number, Number, Number, World, (Updatable) => (String*) => Unit, () => Unit, () => Unit, () => Unit, (String) => LinkSet, Number, String, Number) => Patch
      constructor(id, pxcor, pycor, world, _genUpdate, _declareNonBlackPatch, _decrementPatchLabelCount, _incrementPatchLabelCount, _pcolor = 0.0, _plabel = "", _plabelcolor = 9.9) {
        // (Number, Number) => Agent
        this.patchAt = this.patchAt.bind(this);
        this.id = id;
        this.pxcor = pxcor;
        this.pycor = pycor;
        this.world = world;
        this._genUpdate = _genUpdate;
        this._declareNonBlackPatch = _declareNonBlackPatch;
        this._decrementPatchLabelCount = _decrementPatchLabelCount;
        this._incrementPatchLabelCount = _incrementPatchLabelCount;
        this._pcolor = _pcolor;
        this._plabel = _plabel;
        this._plabelcolor = _plabelcolor;
        this._turtles = [];
        this._varManager = this._genVarManager(this.world.patchesOwnNames);
      }

      getName() {
        return `patch ${this.pxcor} ${this.pycor}`;
      }

      // (String) => Any
      getVariable(varName) {
        return this._varManager[varName];
      }

      // (String, Any) => Unit
      setVariable(varName, value) {
        this._varManager[varName] = value;
      }

      // (String) => Any
      getPatchVariable(varName) {
        return this._varManager[varName];
      }

      // (String, Any) => Unit
      setPatchVariable(varName, value) {
        this._varManager[varName] = value;
      }

      // (String, Any) => Maybe[Any]
      setPatchVariableIfValid(varName, value) {
        return this._varManager.setIfValid(varName, value);
      }

      // (Turtle) => Unit
      untrackTurtle(turtle) {
        this._turtles.splice(this._turtles.indexOf(turtle, 0), 1);
      }

      // (Turtle) => Unit
      trackTurtle(turtle) {
        this._turtles.push(turtle);
      }

      // () => (Number, Number)
      getCoords() {
        return [this.pxcor, this.pycor];
      }

      // (Agent) => Number
      distance(agent) {
        return this.world.topology.distance(this.pxcor, this.pycor, agent);
      }

      // (Number, Number) => Number
      distanceXY(x, y) {
        return this.world.topology.distanceXY(this.pxcor, this.pycor, x, y);
      }

      // (Turtle|Patch) => Number | TowardsInterrupt
      towards(agent) {
        var x, y;
        [x, y] = agent.getCoords();
        return this.towardsXY(x, y);
      }

      // (Number, Number) => Number | TowardsInterrupt
      towardsXY(x, y) {
        return this.world.topology.towards(this.pxcor, this.pycor, x, y);
      }

      // () => TurtleSet
      turtlesHere() {
        return new TurtleSet(this._turtles.slice(0), this.world);
      }

      // (() => Any) => Unit
      ask(f) {
        var base;
        if (!this.isDead()) {
          this.world.selfManager.askAgent(f)(this);
          if (typeof (base = this.world.selfManager.self()).isDead === "function" ? base.isDead() : void 0) {
            return DeathInterrupt;
          }
        } else {
          throw exceptions.runtime("That patch is dead.", "ask");
        }
      }

      // [Result] @ (() => Result) => Result
      projectionBy(f) {
        if (!this.isDead()) {
          return this.world.selfManager.askAgent(f)(this);
        } else {
          throw exceptions.runtime("That patch is dead.", "of");
        }
      }

      // () => PatchSet
      getNeighbors() {
        return this.world.getNeighbors(this.pxcor, this.pycor);
      }

      // () => PatchSet
      getNeighbors4() {
        return this.world.getNeighbors4(this.pxcor, this.pycor);
      }

      // (Number, String) => TurtleSet
      sprout(n, breedName) {
        return this.world.turtleManager.createTurtles(n, breedName, this.pxcor, this.pycor);
      }

      // (String) => TurtleSet
      breedHere(breedName) {
        return new TurtleSet(this.breedHereArray(breedName), this.world);
      }

      // (String) => Array[Turtle]
      breedHereArray(breedName) {
        return filter(function(turtle) {
          return turtle.getBreedName() === breedName;
        })(this._turtles);
      }

      // (String) => Boolean
      anyBreedHere(breedName) {
        var i, len, ref, turtle;
        ref = this._turtles;
        for (i = 0, len = ref.length; i < len; i++) {
          turtle = ref[i];
          if (turtle.getBreedName() === breedName) {
            return true;
          }
        }
        return false;
      }

      // (Number, Number) => TurtleSet
      turtlesAt(dx, dy) {
        return this.patchAt(dx, dy).turtlesHere();
      }

      // (String, Number, Number) => TurtleSet
      breedAt(breedName, dx, dy) {
        return this.patchAt(dx, dy).breedHere(breedName);
      }

      patchAt(dx, dy) {
        return this.patchAtCoords(this.pxcor + dx, this.pycor + dy);
      }

      // (Number, Number) => Agent
      patchAtCoords(x, y) {
        return this.world.getPatchAt(x, y);
      }

      // (Number, Number) => Agent
      patchAtHeadingAndDistance(angle, distance) {
        return this.world.patchAtHeadingAndDistanceFrom(angle, distance, this.pxcor, this.pycor);
      }

      // () => Unit
      watchMe() {
        this.world.observer.watch(this);
      }

      // [T] @ (AbstractAgentSet[T], Number) => AbstractAgentSet[T]
      inRadius(agents, radius) {
        return this.world.topology.inRadius(this.pxcor, this.pycor, agents, radius);
      }

      // (Patch) => { toInt: Number }
      compare(x) {
        return Comparator.numericCompare(this.id, x.id);
      }

      // () => Boolean
      isDead() {
        return this.id === -1;
      }

      // A patch cannot really die, but on a world resize old patches can stick around in variables, so they need to have a
      // way to get gone.  -Jeremy B November 2025
      // () => Unit
      _die() {
        this.id = -1;
      }

      // () => String
      toString() {
        if (!this.isDead()) {
          return `(${this.getName()})`;
        } else {
          return "nobody";
        }
      }

      // () => Unit
      reset() {
        this._varManager.reset(this.world.patchesOwnNames);
        Setters.setPcolor.call(this, 0);
        Setters.setPlabel.call(this, '');
        Setters.setPlabelColor.call(this, 9.9);
      }

      // () => Boolean
      hasVariable(varName) {
        return this._varManager.has(varName);
      }

      // () => Array[String]
      varNames() {
        return this._varManager.names();
      }

      // Array[String] => VariableManager
      _genVarManager(extraVarNames) {
        var allSpecs, extraSpecs;
        extraSpecs = extraVarNames.map(function(name) {
          return new ExtraVariableSpec(name);
        });
        allSpecs = VariableSpecs.concat(extraSpecs);
        return new VariableManager(this, allSpecs);
      }

      // (String) => Unit
      _genVarUpdate(varName) {
        this._genUpdate(this)(varName);
      }

      // (PatchSet, String) => Number
      _neighborSum(nbs, varName) {
        var f;
        f = function(acc, neighbor) {
          var x;
          x = neighbor.getVariable(varName);
          if (checks.isNumber(x)) {
            return acc + x;
          } else {
            throw exceptions.runtime(`noSumOfListWithNonNumbers, ${x}`, "sum");
          }
        };
        return foldl(f)(0)(nbs.iterator().toArray());
      }

      // (String) => Number
      _optimalNSum(varName) {
        return this._neighborSum(this.getNeighbors(), varName);
      }

      // (String) => Number
      _optimalNSum4(varName) {
        return this._neighborSum(this.getNeighbors4(), varName);
      }

      _ifFalse(value, replacement) {
        if (value === false) {
          return replacement;
        } else {
          return value;
        }
      }

      // () => Patch
      _optimalPatchHereInternal() {
        return this;
      }

      _optimalPatchNorth() {
        return this.world.topology._getPatchNorth(this.pxcor, this.pycor) || Nobody;
      }

      _optimalPatchEast() {
        return this.world.topology._getPatchEast(this.pxcor, this.pycor) || Nobody;
      }

      _optimalPatchSouth() {
        return this.world.topology._getPatchSouth(this.pxcor, this.pycor) || Nobody;
      }

      _optimalPatchWest() {
        return this.world.topology._getPatchWest(this.pxcor, this.pycor) || Nobody;
      }

      _optimalPatchNorthEast() {
        return this.world.topology._getPatchNorthEast(this.pxcor, this.pycor) || Nobody;
      }

      _optimalPatchSouthEast() {
        return this.world.topology._getPatchSouthEast(this.pxcor, this.pycor) || Nobody;
      }

      _optimalPatchSouthWest() {
        return this.world.topology._getPatchSouthWest(this.pxcor, this.pycor) || Nobody;
      }

      _optimalPatchNorthWest() {
        return this.world.topology._getPatchNorthWest(this.pxcor, this.pycor) || Nobody;
      }

    };

    Patch.prototype._turtles = void 0; // Array[Turtle]

    Patch.prototype._varManager = void 0; // VariableManager

    return Patch;

  }).call(this);

}).call(this);

},{"./patch/patchvariables":"engine/core/patch/patchvariables","./structure/variablemanager":"engine/core/structure/variablemanager","./structure/variablespec":"engine/core/structure/variablespec","./turtleset":"engine/core/turtleset","./typechecker":"engine/core/typechecker","brazierjs/array":"brazier/array","util/comparator":"util/comparator","util/exception":"util/exception","util/interrupts":"util/interrupts"}],"engine/core/structure/builtins":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  module.exports = {
    turtleBuiltins: ["who", "color", "heading", "xcor", "ycor", "shape", "label", "label-color", "breed", "hidden?", "size", "pen-size", "pen-mode"],
    patchBuiltins: ["pxcor", "pycor", "pcolor", "plabel", "plabel-color"],
    linkBuiltins: ["end1", "end2", "color", "label", "label-color", "hidden?", "breed", "thickness", "shape", "tie-mode"],
    linkExtras: ["heading", "size", "lcolor", "llabel", "llabelcolor", "lhidden", "lbreed", "lshape", "midpointx", "midpointy"]
  };

}).call(this);

},{}],"engine/core/structure/deadskippingiterator":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var DeadSkippingIterator, Iterator;

  Iterator = require('util/iterator');

  module.exports = DeadSkippingIterator = (function() {
    class DeadSkippingIterator extends Iterator {
      
        // [T] @ (Array[T]) => DeadSkippingIterator
      constructor(items) {
        super(items);
        this._i = 0;
      }

      all(f) {
        var j, len, ref, x;
        ref = this._items;
        for (j = 0, len = ref.length; j < len; j++) {
          x = ref[j];
          if (!x.isDead()) {
            if (!f(x)) {
              return false;
            }
          }
        }
        return true;
      }

      contains(x) {
        var j, len, ref, y;
        ref = this._items;
        for (j = 0, len = ref.length; j < len; j++) {
          y = ref[j];
          if (!x.isDead()) {
            if (x === y) {
              return true;
            }
          }
        }
        return false;
      }

      exists(f) {
        var j, len, ref, x;
        ref = this._items;
        for (j = 0, len = ref.length; j < len; j++) {
          x = ref[j];
          if (!x.isDead()) {
            if (f(x)) {
              return true;
            }
          }
        }
        return false;
      }

      filter(f) {
        var j, len, ref, results, x;
        ref = this._items;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          x = ref[j];
          if ((!x.isDead()) && f(x)) {
            results.push(x);
          }
        }
        return results;
      }

      // [U] @ ((T) => U) => Array[U]
      map(f) {
        var acc;
        acc = [];
        while (this._hasNext()) {
          acc.push(f(this._next()));
        }
        return acc;
      }

      // ((T) => Unit) => Unit
      forEach(f) {
        while (this._hasNext()) {
          f(this._next());
        }
      }

      // They're asking for the `n`th not-dead item, so every time we see a dead item, increment the index and the `n`.

        // start           iteration 1     iteration 2     iteration 3     iteration 4
      // [0][X][X][1][2] [0][X][X][1][2] [0][X][X][1][2] [0][X][X][1][2] [0][X][X][1][2]
      // i=0                i=1                i=2                i=3                i=4
      //       n=2             n=2                n=3                n=4             n=4

        // (Int) => T
      nthItem(n) {
        var i;
        i = 0;
        while (i <= n) {
          if (this._items[i].isDead()) {
            n++;
          }
          i++;
        }
        return this._items[n];
      }

      // () => Int
      size() {
        return this._items.reduce(function(acc, item) {
          return acc + (item.isDead() ? 0 : 1);
        }, 0);
      }

      // () => Array[T]
      toArray() {
        var acc;
        acc = [];
        while (this._hasNext()) {
          acc.push(this._next());
        }
        return acc;
      }

      // () => Boolean
      _hasNext() {
        this._skipToNext();
        return this._isntEmpty();
      }

      // () => T
      _next() {
        this._skipToNext();
        return this._items[this._i++];
      }

      // () => Unit
      _skipToNext() {
        while (this._isntEmpty() && this._items[this._i].isDead()) {
          this._i++;
        }
      }

      // () => Boolean
      _isntEmpty() {
        return this._i < this._items.length;
      }

      // (Number, (Number, Number) => Boolean) => Boolean
      checkCount(n, check) {
        var j, len, ref, totalCount, x;
        totalCount = 0;
        ref = this._items;
        for (j = 0, len = ref.length; j < len; j++) {
          x = ref[j];
          if (!(!x.isDead())) {
            continue;
          }
          totalCount += 1;
          if (totalCount > n) {
            return check(totalCount, n);
          }
        }
        return check(totalCount, n);
      }

    };

    DeadSkippingIterator.prototype._i = void 0; // Number

    return DeadSkippingIterator;

  }).call(this);

}).call(this);

},{"util/iterator":"util/iterator"}],"engine/core/structure/linkcompare":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise

  // (Link, Link) => Number
  module.exports = function(a, b) {
    if (a === b) {
      return 0;
    } else if (a.isDead() && b.isDead()) {
      return 0;
    } else if (a.end1.id < b.end1.id) {
      return -1;
    } else if (a.end1.id > b.end1.id) {
      return 1;
    } else if (a.end2.id < b.end2.id) {
      return -1;
    } else if (a.end2.id > b.end2.id) {
      return 1;
    } else if (a.getBreedName() === b.getBreedName()) {
      return 0;
    } else if (a.getBreedName() === "LINKS") {
      return -1;
    } else if (b.getBreedName() === "LINKS") {
      return 1;
    } else if (a.getBreedOrdinal() < b.getBreedOrdinal()) {
      return -1;
    } else if (a.getBreedOrdinal() > b.getBreedOrdinal()) {
      return 1;
    } else {
      return 0;
    }
  };

}).call(this);

},{}],"engine/core/structure/penmanager":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Down, Erase, PenManager, PenStatus, Up;

  PenStatus = class PenStatus {
    constructor(_name) { // (String) => PenStatus
      this._name = _name;
    }

    toString() {
      return this._name; // () => String
    }

  };

  Up = new PenStatus("up");

  Down = new PenStatus("down");

  Erase = new PenStatus("erase");

  PenManager = class PenManager {
    // ((String*) => Unit, Number, PenStatus) => PenManager
    constructor(_updateFunc, _size = 1.0, _status = Up) {
      this._updateFunc = _updateFunc;
      this._size = _size;
      this._status = _status;
    }

    // () => Number
    getSize() {
      return this._size;
    }

    // () => PenStatus
    getMode() {
      return this._status;
    }

    // This is (tragically) JVM NetLogo's idea of sanity... --JAB (5/26/14)
    // (String) => Unit
    setPenMode(position) {
      if (position === Up.toString()) {
        this.raisePen();
      } else if (position === Erase.toString()) {
        this.useEraser();
      } else {
        this.lowerPen();
      }
    }

    // () => Unit
    raisePen() {
      this._updateStatus(Up);
    }

    // () => Unit
    lowerPen() {
      this._updateStatus(Down);
    }

    // () => Unit
    useEraser() {
      this._updateStatus(Erase);
    }

    // (Number) => Unit
    setSize(size) {
      this._updateSize(size);
    }

    // ((String*) => Unit) => PenManager
    clone(updateFunc) {
      return new PenManager(updateFunc, this._size, this._status);
    }

    // (Number) => Unit
    _updateSize(newSize) {
      this._size = newSize;
      this._updateFunc("pen-size");
    }

    // (PenStatus) => Unit
    _updateStatus(newStatus) {
      this._status = newStatus;
      this._updateFunc("pen-mode");
    }

  };

  module.exports = {
    PenManager,
    PenStatus: {Up, Down, Erase}
  };

}).call(this);

},{}],"engine/core/structure/selfmanager":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var SelfManager, exceptions;

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  module.exports = SelfManager = (function() {
    class SelfManager {
      
        // () => SelfManager
      constructor() {
        // () => SelfType
        this.self = this.self.bind(this);
        // Switch from letting CoffeeScript bind "this" to handling it manually to avoid creating extra anonymous functions
        // They add GC pressure, causing runtime slowdown - JMB 07/2017
        // [T] @ (() => T) => (Agent) => T
        this.askAgent = this.askAgent.bind(this);
        this._self = 0;
        this._myself = 0;
      }

      self() {
        return this._self;
      }

      // () => SelfType
      myself() {
        if (this._myself !== 0) {
          return this._myself;
        } else {
          throw exceptions.runtime("There is no agent for MYSELF to refer to.", "myself");
        }
      }

      askAgent(f) {
        var at;
        at = this;
        return function(agent) {
          var oldAgent, oldMyself;
          oldMyself = at._myself;
          oldAgent = at._self;
          at._myself = at._self;
          at._self = agent;
          try {
            return f();
          } finally {
            at._self = oldAgent;
            at._myself = oldMyself;
          }
        };
      }

    };

    // type SelfType = Number|Agent // The type that `self` or `myself` could be at any time
    SelfManager.prototype._self = void 0; // SelfType

    SelfManager.prototype._myself = void 0; // SelfType

    return SelfManager;

  }).call(this);

}).call(this);

},{"util/exception":"util/exception"}],"engine/core/structure/variablemanager":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ExtraVariableSpec, ImmutableVariableSpec, MutableVariableSpec, VariableManager, difference, exceptions;

  ({difference} = require('brazierjs/array'));

  ({ExtraVariableSpec, ImmutableVariableSpec, MutableVariableSpec} = require('./variablespec'));

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  module.exports = VariableManager = (function() {
    class VariableManager {
      
        // (Agent, Array[VariableSpec[_]]) => VariableManager
      constructor(agent, varSpecs) {
        var name;
        this.agent = agent;
        this._validitySetters = new Map();
        this._addVarsBySpec(varSpecs);
        this._names = new Set((function() {
          var i, len, results;
          results = [];
          for (i = 0, len = varSpecs.length; i < len; i++) {
            ({name} = varSpecs[i]);
            results.push(name);
          }
          return results;
        })());
      }

      // (String, Any) => Maybe[Any]
      setIfValid(name, value) {
        return this._validitySetters.get(name).call(this.agent, value);
      }

      // () => Boolean
      has(varName) {
        return this._names.has(varName);
      }

      // () => Array[String]
      names() {
        return Array.from(this._names);
      }

      // (Array[String], Array[String]) => Unit
      refineBy(oldNames, newNames) {
        var freshNames, i, invalidatedSetter, len, name, obsoletedNames, specs;
        invalidatedSetter = function(name) {
          return function(value) {
            throw exceptions.internal(`${name} is no longer a valid variable.`);
          };
        };
        obsoletedNames = difference(oldNames)(newNames);
        freshNames = difference(newNames)(oldNames);
        specs = freshNames.map(function(name) {
          return new ExtraVariableSpec(name);
        });
        for (i = 0, len = obsoletedNames.length; i < len; i++) {
          name = obsoletedNames[i];
          this._defineProperty(name, {
            get: void 0,
            set: invalidatedSetter(name),
            configurable: true
          });
        }
        this._addVarsBySpec(specs);
        this._names = new Set(difference(this.names())(obsoletedNames).concat(freshNames));
      }

      // (Array[VariableSpec]) => Unit
      reset(varNames) {
        varNames.forEach((name) => {
          return this[name] = 0;
        });
      }

      // (Array[VariableSpec]) => Unit
      _addVarsBySpec(varSpecs) {
        var get, i, len, obj, set, spec;
        for (i = 0, len = varSpecs.length; i < len; i++) {
          spec = varSpecs[i];
          obj = (function() {
            if (spec instanceof ExtraVariableSpec) {
              return {
                configurable: true,
                value: 0,
                writable: true
              };
            } else if (spec instanceof MutableVariableSpec) {
              get = (function(spec) {
                return function() {
                  return spec.get.call(this.agent);
                };
              })(spec);
              set = (function(spec) {
                return function(v) {
                  return spec.set.call(this.agent, v);
                };
              })(spec);
              this._validitySetters.set(spec.name, spec.set);
              return {
                configurable: true,
                get,
                set
              };
            } else if (spec instanceof ImmutableVariableSpec) {
              return {
                value: spec.get.call(this.agent),
                writable: false
              };
            } else {
              throw exceptions.internal(`Non-exhaustive spec type match: ${typeof spec}!`);
            }
          }).call(this);
          this._defineProperty(spec.name, obj);
        }
      }

      // (String, Object) => Unit
      _defineProperty(propName, config) {
        Object.defineProperty(this, propName, config);
      }

    };

    VariableManager.prototype._names = void 0; // Set[String]

    VariableManager.prototype._validitySetters = null; // Map[String, (Any) => Boolean]

    return VariableManager;

  }).call(this);

}).call(this);

},{"./variablespec":"engine/core/structure/variablespec","brazierjs/array":"brazier/array","util/exception":"util/exception"}],"engine/core/structure/variablespec":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ExtraVariableSpec, ImmutableVariableSpec, MutableVariableSpec, VariableSpec;

  VariableSpec = class VariableSpec {
    // (String) => VariableSpec[T]
    constructor(name1) {
      this.name = name1;
    }

  };

  ExtraVariableSpec = class ExtraVariableSpec extends VariableSpec {};

  ImmutableVariableSpec = class ImmutableVariableSpec extends VariableSpec {
    // (String, () => T) => ImmutableVariableSpec[T]
    constructor(name, get) {
      super(name);
      this.get = get;
    }

  };

  MutableVariableSpec = class MutableVariableSpec extends VariableSpec {
    //(String, () => T, (T) => Maybe[Any]) => MutableVariableSpec[T]
    constructor(name, get, set) {
      super(name);
      this.get = get;
      this.set = set;
    }

  };

  module.exports = {ExtraVariableSpec, ImmutableVariableSpec, MutableVariableSpec, VariableSpec};

}).call(this);

},{}],"engine/core/topology/box":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Box, Topology,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  Topology = require('./topology');

  module.exports = Box = (function() {
    class Box extends Topology {
      constructor() {
        super(...arguments);
        // (Number, Number) => Number
        this._shortestX = this._shortestX.bind(this);
        // (Number, Number) => Number
        this._shortestY = this._shortestY.bind(this);
      }

      
        // (Number) => Number | TopologyInterrupt
      wrapX(pos) {
        return this._wrapXCautiously(pos);
      }

      // (Number) => Number | TopologyInterrupt
      wrapY(pos) {
        return this._wrapYCautiously(pos);
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorth(pxcor, pycor) {
        return (pycor !== this.maxPycor) && this._getPatchAt(pxcor, pycor + 1);
      }

      _getPatchSouth(pxcor, pycor) {
        return (pycor !== this.minPycor) && this._getPatchAt(pxcor, pycor - 1);
      }

      _getPatchEast(pxcor, pycor) {
        return (pxcor !== this.maxPxcor) && this._getPatchAt(pxcor + 1, pycor);
      }

      _getPatchWest(pxcor, pycor) {
        return (pxcor !== this.minPxcor) && this._getPatchAt(pxcor - 1, pycor);
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorthWest(pxcor, pycor) {
        return (pycor !== this.maxPycor) && (pxcor !== this.minPxcor) && this._getPatchAt(pxcor - 1, pycor + 1);
      }

      _getPatchSouthWest(pxcor, pycor) {
        return (pycor !== this.minPycor) && (pxcor !== this.minPxcor) && this._getPatchAt(pxcor - 1, pycor - 1);
      }

      _getPatchSouthEast(pxcor, pycor) {
        return (pycor !== this.minPycor) && (pxcor !== this.maxPxcor) && this._getPatchAt(pxcor + 1, pycor - 1);
      }

      _getPatchNorthEast(pxcor, pycor) {
        return (pycor !== this.maxPycor) && (pxcor !== this.maxPxcor) && this._getPatchAt(pxcor + 1, pycor + 1);
      }

      _shortestX(x1, x2) {
        boundMethodCheck(this, Box);
        return this._shortestNotWrapped(x1, x2);
      }

      _shortestY(y1, y2) {
        boundMethodCheck(this, Box);
        return this._shortestNotWrapped(y1, y2);
      }

    };

    Box.prototype._wrapInX = false; // Boolean

    Box.prototype._wrapInY = false; // Boolean

    return Box;

  }).call(this);

}).call(this);

},{"./topology":"engine/core/topology/topology"}],"engine/core/topology/diffuser":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise

  // There are some key things to keep in mind to keep this code in sync with how headless/desktop operates:

  // 1. The calculations must be done from patch perspective - diffusing "into" the patch, not "out to" surrounding patches
  // 2. Changes from an earlier patch diffuse are not considered by later patches during a diffuse operation (hence the scratch array).
  // 3. The patch sums must be done in "cross 4" then "diagonal 4" order to keep floating point math happy.
  // 4. The `sum4` method must match what's used by headless/desktop - the high/low sorting is critical for floating point.

  // -JMB March 2018
  var Diffuser;

  module.exports = Diffuser = (function() {
    class Diffuser {
      constructor(_setPatchVariable, _width, _height, wrapInX, wrapInY) {
        this._setPatchVariable = _setPatchVariable;
        this._width = _width;
        this._height = _height;
        this._wrapWest = wrapInX ? this._width - 1 : Diffuser.CENTER;
        this._wrapEast = wrapInX ? 1 - this._width : Diffuser.CENTER;
        this._wrapNorth = wrapInY ? this._height - 1 : Diffuser.CENTER;
        this._wrapSouth = wrapInY ? 1 - this._height : Diffuser.CENTER;
      }

      // (String, Number, Array[Number]) => Unit (side effect: diffuse to patches)
      diffuse4(varName, coefficient, scratch) {
        this._center4(varName, coefficient, scratch);
        this._xBorders4(varName, coefficient, scratch);
        this._yBorders4(varName, coefficient, scratch);
        return this._corners4(varName, coefficient, scratch);
      }

      // (String, Number, Array[Number]) => Unit (side effect: diffuse to patches)
      diffuse8(varName, coefficient, scratch) {
        this._center8(varName, coefficient, scratch);
        this._xBorders8(varName, coefficient, scratch);
        this._yBorders8(varName, coefficient, scratch);
        return this._corners8(varName, coefficient, scratch);
      }

      // (String, Number, Array[Number]) => Unit (side effect: diffuse all non-edge patches)
      _center4(varName, coefficient, scratch) {
        var lastX, lastY, x, y;
        lastX = this._width - 1;
        lastY = this._height - 1;
        x = 1;
        while (x < lastX) {
          y = 1;
          while (y < lastY) {
            this._patch4(x, y, varName, coefficient, scratch, Diffuser.WEST, Diffuser.EAST, Diffuser.NORTH, Diffuser.SOUTH);
            y += 1;
          }
          x += 1;
        }
      }

      // (String, Number, Array[Number]) => Unit (side effect: diffuse all non-edge patches)
      _center8(varName, coefficient, scratch) {
        var lastX, lastY, x, y;
        lastX = this._width - 1;
        lastY = this._height - 1;
        x = 1;
        while (x < lastX) {
          y = 1;
          while (y < lastY) {
            this._patch8(x, y, varName, coefficient, scratch, Diffuser.WEST, Diffuser.EAST, Diffuser.NORTH, Diffuser.SOUTH, Diffuser.EAST_NORTH, Diffuser.WEST_NORTH, Diffuser.EAST_SOUTH, Diffuser.WEST_SOUTH);
            y += 1;
          }
          x += 1;
        }
      }

      // (String, Number, Array[Number]) => Unit (side effect: diffuse non-corner y-edge patches)
      _yBorders4(varName, coefficient, scratch) {
        var lastX, x, y;
        lastX = this._width - 1;
        x = 1;
        while (x < lastX) {
          y = 0; // wrap to the north
          this._patch4(x, y, varName, coefficient, scratch, Diffuser.WEST, Diffuser.EAST, this._wrapNorth, Diffuser.SOUTH);
          y = this._height - 1; // wrap to the south
          this._patch4(x, y, varName, coefficient, scratch, Diffuser.WEST, Diffuser.EAST, Diffuser.NORTH, this._wrapSouth);
          x += 1;
        }
      }

      // (String, Number, Array[Number]) => Unit (side effect: diffuse non-corner y-edge patches)
      _yBorders8(varName, coefficient, scratch) {
        var eastNorth, eastSouth, lastX, westNorth, westSouth, x, y;
        lastX = this._width - 1;
        eastNorth = (this._wrapNorth === 0 ? Diffuser.CURRENT : {
          x: 1,
          y: this._wrapNorth
        });
        westNorth = (this._wrapNorth === 0 ? Diffuser.CURRENT : {
          x: -1,
          y: this._wrapNorth
        });
        eastSouth = (this._wrapSouth === 0 ? Diffuser.CURRENT : {
          x: 1,
          y: this._wrapSouth
        });
        westSouth = (this._wrapSouth === 0 ? Diffuser.CURRENT : {
          x: -1,
          y: this._wrapSouth
        });
        x = 1;
        while (x < lastX) {
          y = 0; // wrap to the north
          this._patch8(x, y, varName, coefficient, scratch, Diffuser.WEST, Diffuser.EAST, this._wrapNorth, Diffuser.SOUTH, eastNorth, westNorth, Diffuser.EAST_SOUTH, Diffuser.WEST_SOUTH);
          y = this._height - 1; // wrap to the south
          this._patch8(x, y, varName, coefficient, scratch, Diffuser.WEST, Diffuser.EAST, Diffuser.NORTH, this._wrapSouth, Diffuser.EAST_NORTH, Diffuser.WEST_NORTH, eastSouth, westSouth);
          x += 1;
        }
      }

      // (String, Number, Array[Number]) => Unit (side effect: diffuse non-corner x-edge patches)
      _xBorders4(varName, coefficient, scratch) {
        var lastY, x, y;
        lastY = this._height - 1;
        y = 1;
        while (y < lastY) {
          x = 0; // wrap to the west
          this._patch4(x, y, varName, coefficient, scratch, this._wrapWest, Diffuser.EAST, Diffuser.NORTH, Diffuser.SOUTH);
          x = this._width - 1; // wrap to the east
          this._patch4(x, y, varName, coefficient, scratch, Diffuser.WEST, this._wrapEast, Diffuser.NORTH, Diffuser.SOUTH);
          y += 1;
        }
      }

      // (String, Number, Array[Number]) => Unit (side effect: diffuse non-corner x-edge patches)
      _xBorders8(varName, coefficient, scratch) {
        var eastNorth, eastSouth, lastY, westNorth, westSouth, x, y;
        lastY = this._height - 1;
        eastNorth = (this._wrapEast === 0 ? Diffuser.CURRENT : {
          x: this._wrapEast,
          y: -1
        });
        westNorth = (this._wrapWest === 0 ? Diffuser.CURRENT : {
          x: this._wrapWest,
          y: -1
        });
        eastSouth = (this._wrapEast === 0 ? Diffuser.CURRENT : {
          x: this._wrapEast,
          y: 1
        });
        westSouth = (this._wrapWest === 0 ? Diffuser.CURRENT : {
          x: this._wrapWest,
          y: 1
        });
        y = 1;
        while (y < lastY) {
          x = 0; // wrap to the west
          this._patch8(x, y, varName, coefficient, scratch, this._wrapWest, Diffuser.EAST, Diffuser.NORTH, Diffuser.SOUTH, Diffuser.EAST_NORTH, westNorth, Diffuser.EAST_SOUTH, westSouth);
          x = this._width - 1; // wrap to the east
          this._patch8(x, y, varName, coefficient, scratch, Diffuser.WEST, this._wrapEast, Diffuser.NORTH, Diffuser.SOUTH, eastNorth, Diffuser.WEST_NORTH, eastSouth, Diffuser.WEST_SOUTH);
          y += 1;
        }
      }

      // (String, Number, Array[Number]) => Unit (side effect: diffuse all corner patches)
      _corners4(varName, coefficient, scratch) {
        var x, y;
        x = 0; // Wrap west
        y = 0; // Wrap to the north
        this._patch4(x, y, varName, coefficient, scratch, this._wrapWest, Diffuser.EAST, this._wrapNorth, Diffuser.SOUTH);
        x = 0; // Wrap to the west
        y = this._height - 1; // Wrap to the south
        this._patch4(x, y, varName, coefficient, scratch, this._wrapWest, Diffuser.EAST, Diffuser.NORTH, this._wrapSouth);
        x = this._width - 1; // Wrap to the east
        y = 0; // Wrap to the north
        this._patch4(x, y, varName, coefficient, scratch, Diffuser.WEST, this._wrapEast, this._wrapNorth, Diffuser.SOUTH);
        x = this._width - 1; // Wrap east
        y = this._height - 1; // Wrap south
        this._patch4(x, y, varName, coefficient, scratch, Diffuser.WEST, this._wrapEast, Diffuser.NORTH, this._wrapSouth);
      }

      // (String, Number, Array[Number]) => Unit (side effect: diffuse all corner patches)
      _corners8(varName, coefficient, scratch) {
        var eastNorth, eastSouth, westNorth, westSouth, x, y;
        x = 0; // Wrap west
        y = 0; // Wrap to the north
        eastNorth = (this._wrapNorth === 0 ? Diffuser.CURRENT : {
          x: 1,
          y: this._wrapNorth
        });
        westNorth = (this._wrapWest === 0 || this._wrapNorth === 0 ? Diffuser.CURRENT : {
          x: this._wrapWest,
          y: this._wrapNorth
        });
        westSouth = (this._wrapWest === 0 ? Diffuser.CURRENT : {
          x: this._wrapWest,
          y: 1
        });
        this._patch8(x, y, varName, coefficient, scratch, this._wrapWest, Diffuser.EAST, this._wrapNorth, Diffuser.SOUTH, eastNorth, westNorth, Diffuser.EAST_SOUTH, westSouth);
        x = 0; // Wrap to the west
        y = this._height - 1; // Wrap to the south
        westNorth = (this._wrapWest === 0 ? Diffuser.CURRENT : {
          x: this._wrapWest,
          y: -1
        });
        eastSouth = (this._wrapSouth === 0 ? Diffuser.CURRENT : {
          x: 1,
          y: this._wrapSouth
        });
        westSouth = (this._wrapWest === 0 || this._wrapSouth === 0 ? Diffuser.CURRENT : {
          x: this._wrapWest,
          y: this._wrapSouth
        });
        this._patch8(x, y, varName, coefficient, scratch, this._wrapWest, Diffuser.EAST, Diffuser.NORTH, this._wrapSouth, Diffuser.EAST_NORTH, westNorth, eastSouth, westSouth);
        x = this._width - 1; // Wrap to the east
        y = 0; // Wrap to the north
        eastNorth = (this._wrapEast === 0 || this._wrapNorth === 0 ? Diffuser.CURRENT : {
          x: this._wrapEast,
          y: this._wrapNorth
        });
        westNorth = (this._wrapNorth === 0 ? Diffuser.CURRENT : {
          x: -1,
          y: this._wrapNorth
        });
        eastSouth = (this._wrapEast === 0 ? Diffuser.CURRENT : {
          x: this._wrapEast,
          y: 1
        });
        this._patch8(x, y, varName, coefficient, scratch, Diffuser.WEST, this._wrapEast, this._wrapNorth, Diffuser.SOUTH, eastNorth, westNorth, eastSouth, Diffuser.WEST_SOUTH);
        x = this._width - 1; // Wrap east
        y = this._height - 1; // Wrap south
        eastNorth = (this._wrapEast === 0 ? Diffuser.CURRENT : {
          x: this._wrapEast,
          y: -1
        });
        eastSouth = (this._wrapEast === 0 || this._wrapSouth === 0 ? Diffuser.CURRENT : {
          x: this._wrapEast,
          y: this._wrapSouth
        });
        westSouth = (this._wrapSouth === 0 ? Diffuser.CURRENT : {
          x: -1,
          y: this._wrapSouth
        });
        this._patch8(x, y, varName, coefficient, scratch, Diffuser.WEST, this._wrapEast, Diffuser.NORTH, this._wrapSouth, eastNorth, Diffuser.WEST_NORTH, eastSouth, westSouth);
      }

      // (Number, Number, String, Number, Array[Number], Number, Number, Number, Number) => Unit
      // (side effect: diffuse a single patch)
      _patch4(x, y, varName, coefficient, scratch, west, east, north, south) {
        var cn, cs, ec, newVal, oldVal, wc;
        oldVal = scratch[x][y];
        ec = scratch[x + east][y];
        cn = scratch[x][y + north];
        cs = scratch[x][y + south];
        wc = scratch[x + west][y];
        newVal = this._patchVal4(coefficient, oldVal, ec, cn, cs, wc);
        this._setPatchVariable(x, y, varName, newVal, oldVal);
      }

      // (Number, Number, String, Number, Array[Number],
      //   Number, Number, Number, Number
      //   (Number, Number), (Number, Number), (Number, Number), (Number, Number)) => Unit
      // (side effect: diffuse a single patch)
      _patch8(x, y, varName, coefficient, scratch, west, east, north, south, eastNorth, westNorth, eastSouth, westSouth) {
        var cn, cs, ec, en, es, newVal, oldVal, wc, wn, ws;
        oldVal = scratch[x][y];
        ec = scratch[x + east][y];
        cn = scratch[x][y + north];
        cs = scratch[x][y + south];
        wc = scratch[x + west][y];
        en = scratch[x + eastNorth.x][y + eastNorth.y];
        wn = scratch[x + westNorth.x][y + westNorth.y];
        es = scratch[x + eastSouth.x][y + eastSouth.y];
        ws = scratch[x + westSouth.x][y + westSouth.y];
        newVal = this._patchVal8(coefficient, oldVal, ec, cn, cs, wc, en, wn, es, ws);
        this._setPatchVariable(x, y, varName, newVal, oldVal);
      }

      // (Number, Number, Number, Number) => Number
      _patchVal(coefficient, oldVal, sum, dirCount) {
        return oldVal + coefficient * (sum / dirCount - oldVal);
      }

      // (Number, Number, Number, Number, Number, Number) => Number
      _patchVal4(coefficient, oldVal, a, b, c, d) {
        var sum;
        sum = this._sum4(a, b, c, d);
        return this._patchVal(coefficient, oldVal, sum, 4);
      }

      // (Number, Number, Number, Number, Number, Number, Number, Number, Number, Number) => Number
      _patchVal8(coefficient, oldVal, a, b, c, d, e, f, g, h) {
        var sum;
        sum = this._sum8(a, b, c, d, e, f, g, h);
        return this._patchVal(coefficient, oldVal, sum, 8);
      }

      // (Number, Number, Number, Number, Number, Number, Number, Number) => Number
      _sum8(a, b, c, d, e, f, g, h) {
        var sum;
        sum = this._sum4(a, b, c, d);
        return sum + this._sum4(e, f, g, h);
      }

      // (Number, Number, Number, Number) => Number
      _sum4(a, b, c, d) {
        var high1, high2, low1, low2;
        if (a < b) {
          low1 = a;
          high1 = b;
        } else {
          low1 = b;
          high1 = a;
        }
        if (c < d) {
          low2 = c;
          high2 = d;
        } else {
          low2 = d;
          high2 = c;
        }
        if (low2 < high1 && low1 < high2) {
          return (low1 + low2) + (high1 + high2);
        } else {
          return (low1 + high1) + (low2 + high2);
        }
      }

    };

    Diffuser.CENTER = 0;

    Diffuser.WEST = -1;

    Diffuser.EAST = 1;

    Diffuser.NORTH = -1;

    Diffuser.SOUTH = 1;

    Diffuser.CURRENT = Object.freeze({
      x: 0,
      y: 0
    });

    Diffuser.EAST_NORTH = Object.freeze({
      x: 1,
      y: -1
    });

    Diffuser.WEST_SOUTH = Object.freeze({
      x: -1,
      y: 1
    });

    Diffuser.EAST_SOUTH = Object.freeze({
      x: 1,
      y: 1
    });

    Diffuser.WEST_NORTH = Object.freeze({
      x: -1,
      y: -1
    });

    return Diffuser;

  }).call(this);

}).call(this);

},{}],"engine/core/topology/factory":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Box, HorizCylinder, Torus, VertCylinder;

  Box = require('./box');

  HorizCylinder = require('./horizcylinder');

  Torus = require('./torus');

  VertCylinder = require('./vertcylinder');

  // (Boolean, Boolean, Number, Number, Number, Number, () => PatchSet, (Number, Number) => Patch) => Topology
  module.exports = function(wrapsInX, wrapsInY, minX, maxX, minY, maxY, getPatchesFunc, getPatchAtFunc) {
    var TopoClass;
    TopoClass = wrapsInX && wrapsInY ? Torus : wrapsInX ? VertCylinder : wrapsInY ? HorizCylinder : Box;
    return new TopoClass(minX, maxX, minY, maxY, getPatchesFunc, getPatchAtFunc);
  };

}).call(this);

},{"./box":"engine/core/topology/box","./horizcylinder":"engine/core/topology/horizcylinder","./torus":"engine/core/topology/torus","./vertcylinder":"engine/core/topology/vertcylinder"}],"engine/core/topology/horizcylinder":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var HorizCylinder, Topology,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  Topology = require('./topology');

  module.exports = HorizCylinder = (function() {
    class HorizCylinder extends Topology {
      constructor() {
        super(...arguments);
        // (Number, Number) => Number
        this._shortestX = this._shortestX.bind(this);
        // (Number, Number) => Number
        this._shortestY = this._shortestY.bind(this);
      }

      
        // (Number) => Number | TopologyInterrupt
      wrapX(pos) {
        return this._wrapXCautiously(pos);
      }

      // (Number) => Number
      wrapY(pos) {
        return this._wrapYLeniently(pos);
      }

      // (Number, Number) => Patch|Boolean
      _getPatchEast(pxcor, pycor) {
        return (pxcor !== this.maxPxcor) && this._getPatchAt(pxcor + 1, pycor);
      }

      // (Number, Number) => Patch|Boolean
      _getPatchWest(pxcor, pycor) {
        return (pxcor !== this.minPxcor) && this._getPatchAt(pxcor - 1, pycor);
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorth(pxcor, pycor) {
        if (pycor === this.maxPycor) {
          return this._getPatchAt(pxcor, this.minPycor);
        } else {
          return this._getPatchAt(pxcor, pycor + 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchSouth(pxcor, pycor) {
        if (pycor === this.minPycor) {
          return this._getPatchAt(pxcor, this.maxPycor);
        } else {
          return this._getPatchAt(pxcor, pycor - 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorthWest(pxcor, pycor) {
        if (pxcor === this.minPxcor) {
          return false;
        } else if (pycor === this.maxPycor) {
          return this._getPatchAt(pxcor - 1, this.minPycor);
        } else {
          return this._getPatchAt(pxcor - 1, pycor + 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchSouthWest(pxcor, pycor) {
        if (pxcor === this.minPxcor) {
          return false;
        } else if (pycor === this.minPycor) {
          return this._getPatchAt(pxcor - 1, this.maxPycor);
        } else {
          return this._getPatchAt(pxcor - 1, pycor - 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchSouthEast(pxcor, pycor) {
        if (pxcor === this.maxPxcor) {
          return false;
        } else if (pycor === this.minPycor) {
          return this._getPatchAt(pxcor + 1, this.maxPycor);
        } else {
          return this._getPatchAt(pxcor + 1, pycor - 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorthEast(pxcor, pycor) {
        if (pxcor === this.maxPxcor) {
          return false;
        } else if (pycor === this.maxPycor) {
          return this._getPatchAt(pxcor + 1, this.minPycor);
        } else {
          return this._getPatchAt(pxcor + 1, pycor + 1);
        }
      }

      _shortestX(x1, x2) {
        boundMethodCheck(this, HorizCylinder);
        return this._shortestNotWrapped(x1, x2);
      }

      _shortestY(y1, y2) {
        boundMethodCheck(this, HorizCylinder);
        return this._shortestYWrapped(y1, y2);
      }

    };

    HorizCylinder.prototype._wrapInX = false; // Boolean

    HorizCylinder.prototype._wrapInY = true; // Boolean

    return HorizCylinder;

  }).call(this);

}).call(this);

},{"./topology":"engine/core/topology/topology"}],"engine/core/topology/inradiusorcone":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var NLMath, bottomSplitLimits, checks, distance, distanceRaw, distanceWrap, exceptions, filterPatchesInRadius, filterTurtlesInRadius, getRadius1Patches, getRadius2APatches, getRadius2BPatches, getRegionsBox, getRegionsHorizontal, getRegionsTorus, getRegionsVertical, getSmallRadiusPatches, inCone, inRadius, initialize, leftSplitLimits, makeDistanceSq, makeInExactRadiusSq, makeInRadiusSq, makePatchGetter, makeRegion, makeRegionGetter, makeTargetChecker, maybeAddPatch, rightSplitLimits, searchPatches, searchRegion, splitHorizontal, splitVertical, theTruth, topSplitLimits, topologyHelpers;

  NLMath = require('util/nlmath');

  ({checks} = require('../typechecker'));

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  // This `in-radius` code looks pretty weird, huh?  That is for a few reasons:

  // 1. We need to match how NetLogo desktop handles in-radius, especially for
  //    returning agents in the same order for reproducibility.

  // 2. We do want this to be optimized, so we want to *avoid* the following things:
  //    a. Binding our functions. We want to call them without binding a `this`.
  //    b. Using a class.  It would help organize the code, but we don't want member
  //       accessor calls.
  //    c. Worrying about safety checks where possible, when we can make assumptions.
  //    d. Making intermediate objects during the search loop, like arrays or
  //       `new Class()` that would be immediately discarded and add GC pressure

  // More comments about specific oddities are below.

  // -Jeremy B August 2020
  topologyHelpers = {};

  // (Topology) => Unit
  initialize = function(topology) {
    topologyHelpers.getRegions = makeRegionGetter(topology);
    topologyHelpers.getPatchAt = makePatchGetter(topology);
    topologyHelpers.distanceSq = makeDistanceSq(topology);
    topologyHelpers.inRadiusSq = makeInRadiusSq(topology);
  };

  // (Number, Number) => Number
  distanceRaw = function(p1, p2) {
    return NLMath.abs(p1 - p2);
  };

  // Intentionally take in the full and the half values instead of repeatedly
  // calculating the half.  -Jeremy B August 2020
  // (Int, Number, Number, Number) => Number
  distanceWrap = function(full, half, p1, p2) {
    var d;
    d = distanceRaw(p1, p2);
    if (d > half) {
      return full - d;
    } else {
      return d;
    }
  };

  // (Boolean, Int) => (Number, Number) => Number
  distance = function(wrap, full) {
    var half;
    // We don't want to check if we're wrapped for each distance calculation,
    // so just check once and return the appropriate function at the start.
    // -Jeremy B August 2020
    if (wrap) {
      half = full / 2;
      return function(p1, p2) {
        return distanceWrap(full, half, p1, p2);
      };
    } else {
      return distanceRaw;
    }
  };

  // (Topology) => (Int, Int) => Patch
  makePatchGetter = function(topology) {
    var allPatches, maxPycor, minPxcor, width;
    // The world's version of `getPatchAt()` does rounding and such on the
    // provided values.  We don't need that kind of safety here.
    // -Jeremy B August 2020
    width = topology.width;
    maxPycor = topology.maxPycor;
    minPxcor = topology.minPxcor;
    allPatches = topology._getPatches()._agentArr;
    // (Int, Int) => Patch
    return function(pxcor, pycor) {
      var patchIndex;
      patchIndex = (maxPycor - pycor) * width + (pxcor - minPxcor);
      return allPatches[patchIndex];
    };
  };

  // () => true
  theTruth = function() {
    return true;
  };

  // (Agentset, Agentset) => (Agent) => Boolean
  makeTargetChecker = function(agentset, globalName) {
    var specialName;
    // Instead of iterating over the agentset to find ones that might be in the radius,
    // We iterate over patches and only check agents on patches that could be within
    // the radius.  That's how desktop does it, so that's how we do it, too. But we
    // need an easy way to check if an agent from a patch is, you know, actually one
    // of the ones we're supposed to be looking for.
    // -Jeremy B August 2020
    specialName = agentset.getSpecialName();
    if (specialName === globalName) {
      return theTruth;
    } else if (specialName != null) {
      // Do not use `agent.isBreed()` because it calls `toUpperCase()` on the arguments, and they
      // should already be proper case.  -Jeremy B
      return function(agent) {
        return agent._breed.name === specialName;
      };
    } else {
      return function(agent) {
        return agentset.contains(agent);
      };
    }
  };

  // (Topology) => (Number, Number, Number, Number) => Number
  makeDistanceSq = function(topology) {
    var distanceX, distanceY;
    // (Number, Number) => Number
    distanceX = distance(topology._wrapInX, topology.width);
    // (Number, Number) => Number
    distanceY = distance(topology._wrapInY, topology.height);
    return function(x1, y1, x2, y2) {
      var dx, dy;
      dx = distanceX(x1, x2);
      dy = distanceY(y1, y2);
      return (dx * dx) + (dy * dy);
    };
  };

  // (Topology) => (Number, Number, Number, Number, Number) => Boolean
  makeInRadiusSq = function(topology) {
    // We do not ever take the square root of the distances we calculate, because we
    // can just compare the squared values.  -Jeremy B August 2020
    // (Number, Number, Number, Number, Number) => Boolean
    return function(radiusSq, x1, y1, x2, y2) {
      var distanceSq;
      distanceSq = topologyHelpers.distanceSq(x1, y1, x2, y2);
      return distanceSq <= radiusSq;
    };
  };

  // ((Number, Number, Number, Number, Number) => Boolean, Number, Number, Number) => (Number, Number) => Boolean
  makeInExactRadiusSq = function(inRadiusSq, x, y, radius) {
    var exactRadiusSq;
    exactRadiusSq = radius * radius;
    // (Number, Number) => Boolean
    return function(xcor, ycor) {
      return inRadiusSq(exactRadiusSq, x, y, xcor, ycor);
    };
  };

  // (Array[Patch], Patch | false) => Unit
  maybeAddPatch = function(patches, maybePatch) {
    if (maybePatch && !patches.includes(maybePatch)) {
      patches.push(maybePatch);
    }
  };

  // ((Int, Int) => Patch) => Array[Patch]
  getRadius1Patches = function(centerPatch) {
    var neighbors, patches;
    patches = [];
    patches.push(centerPatch);
    // We rely on `getNeighbors()` returning patches in the same order as desktop,
    // which it does, fortunately.  -Jeremy B August 2020.
    neighbors = centerPatch.getNeighbors()._unsafeIterator();
    neighbors.forEach(function(neighbor) {
      return patches.push(neighbor);
    });
    return patches;
  };

  // (Topology, Array[Patch]) => Array[Patch]
  getRadius2APatches = function(topology, patches) {
    var newPatches;
    newPatches = [];
    patches.forEach(function(p) {
      maybeAddPatch(newPatches, p);
      maybeAddPatch(newPatches, topology._getPatchNorth(p.pxcor, p.pycor));
      maybeAddPatch(newPatches, topology._getPatchNorthEast(p.pxcor, p.pycor));
      maybeAddPatch(newPatches, topology._getPatchEast(p.pxcor, p.pycor));
      maybeAddPatch(newPatches, topology._getPatchSouthEast(p.pxcor, p.pycor));
      maybeAddPatch(newPatches, topology._getPatchSouth(p.pxcor, p.pycor));
      maybeAddPatch(newPatches, topology._getPatchSouthWest(p.pxcor, p.pycor));
      maybeAddPatch(newPatches, topology._getPatchWest(p.pxcor, p.pycor));
      return maybeAddPatch(newPatches, topology._getPatchNorthWest(p.pxcor, p.pycor));
    });
    return newPatches;
  };

  // (Array[Patch]) => Array[Patch]
  getRadius2BPatches = function(patches) {
    var newPatches;
    newPatches = patches.slice(0);
    newPatches.push(patches[1]._optimalPatchNorth());
    newPatches.push(patches[2]._optimalPatchEast());
    newPatches.push(patches[3]._optimalPatchSouth());
    newPatches.push(patches[4]._optimalPatchWest());
    newPatches.push(patches[5]._optimalPatchNorth());
    newPatches.push(patches[5]._optimalPatchNorthEast());
    newPatches.push(patches[5]._optimalPatchEast());
    newPatches.push(patches[6]._optimalPatchEast());
    newPatches.push(patches[6]._optimalPatchSouthEast());
    newPatches.push(patches[6]._optimalPatchSouth());
    newPatches.push(patches[7]._optimalPatchSouth());
    newPatches.push(patches[7]._optimalPatchSouthWest());
    newPatches.push(patches[7]._optimalPatchWest());
    newPatches.push(patches[8]._optimalPatchWest());
    newPatches.push(patches[8]._optimalPatchNorthWest());
    newPatches.push(patches[8]._optimalPatchNorth());
    return newPatches;
  };

  // (Topology, Int, Int, Number, (Int, Int) => Patch) => Array[Patch]
  getSmallRadiusPatches = function(topology, patchX, patchY, radius) {
    var patches, smallWorldCheck;
    patches = getRadius1Patches(topologyHelpers.getPatchAt(patchX, patchY));
    // `radius is 0` is another quirk from desktop.  -Jeremy B August 2020
    if (radius > 1 || radius === 0) {
      smallWorldCheck = (topology._wrapInX && topology.width < 5) || (topology._wrapInY && topology.height < 5) || (!topology._wrapInX && (patchX - topology.minPxcor < 2 || topology.maxPxcor - patchX < 2)) || (!topology._wrapInY && (patchY - topology.minPycor < 2 || topology.maxPycor - patchY < 2));
      // I'm sure all of this makes perfect sense, consult the desktop version if you're curious about what
      // `smallWorldCheck` is doing and why.  The patch order we use here must match the order over there, and the order
      // differs between the two branches of this check.  -Jeremy B August 2020
      if (smallWorldCheck) {
        patches = getRadius2APatches(topology, patches);
      } else {
        patches = getRadius2BPatches(patches);
      }
    }
    return patches;
  };

  // (Topology) => (Int, Int, Int) => Array[Region]
  makeRegionGetter = function(topology) {
    var getRegions;
    getRegions = topology._wrapInX ? topology._wrapInY ? getRegionsTorus : getRegionsHorizontal : topology._wrapInY ? getRegionsVertical : getRegionsBox;
    return function(patchX, patchY, patchRadius) {
      return getRegions(topology, patchX, patchY, patchRadius);
    };
  };

  // (Int, Int, Array[Int]) => Region
  makeRegion = function(top, bottom, ...segmentValues) {
    var i, j, ref, segments;
    segments = [];
    for (i = j = 0, ref = segmentValues.length; j < ref; i = j += 2) {
      segments.push({
        left: segmentValues[i],
        right: segmentValues[i + 1]
      });
    }
    return {top, bottom, segments};
  };

  // The various `getRegions*` functions must return the patch coordinates in desktop order - maxPycor to minPycor outer,
  // mminPxcor to maxPxcor inner.  Hence the weirdness with making sure we get the "upper" and "lower" regions correctly
  // ordered, when they exist.
  // - Jeremy B September 2020

  // (Topology, Int, Int, Int) => Array[Region]
  getRegionsBox = function(topology, patchX, patchY, patchRadius) {
    var bottom, doubleRadius, left, right, top;
    doubleRadius = patchRadius * 2;
    left = NLMath.max(patchX - patchRadius, topology.minPxcor);
    right = NLMath.min(patchX + patchRadius, topology.maxPxcor);
    top = NLMath.min(patchY + patchRadius, topology.maxPycor);
    bottom = NLMath.max(patchY - patchRadius, topology.minPycor);
    return [makeRegion(top, bottom, left, right)];
  };

  // (Topology, Int, Int) => { upperTop, upperBottom, lowerTop, lowerBottom }
  topSplitLimits = function(topology, maybeTop, maybeBottom) {
    var lowerBottom, lowerTop, upperBottom, upperTop;
    upperTop = topology.maxPycor;
    upperBottom = maybeBottom;
    lowerTop = topology.minPycor + maybeTop - topology.maxPycor;
    lowerBottom = topology.minPycor;
    return {upperTop, upperBottom, lowerTop, lowerBottom};
  };

  // (Topology, Int, Int) => { upperTop, upperBottom, lowerTop, lowerBottom }
  bottomSplitLimits = function(topology, maybeTop, maybeBottom) {
    var lowerBottom, lowerTop, upperBottom, upperTop;
    upperTop = topology.maxPycor;
    upperBottom = topology.maxPycor + (maybeBottom - topology.minPycor);
    lowerTop = maybeTop;
    lowerBottom = topology.minPycor;
    return {upperTop, upperBottom, lowerTop, lowerBottom};
  };

  // (Topology, Int, Int, Int, Int) => Array[Region]
  splitVertical = function(topology, patchY, patchRadius, left, right) {
    var lower, maybeBottom, maybeTop, upper, vertical;
    maybeTop = patchY + patchRadius;
    maybeBottom = patchY - patchRadius;
    if (maybeTop > topology.maxPycor) {
      // wrap the top off -Jeremy B September 2020
      vertical = topSplitLimits(topology, maybeTop, maybeBottom);
      upper = makeRegion(vertical.upperTop, vertical.upperBottom, left, right);
      lower = makeRegion(vertical.lowerTop, vertical.lowerBottom, left, right);
      return [upper, lower];
    }
    if (maybeBottom < topology.minPycor) {
      // wrap the bottom off -Jeremy B September 2020
      vertical = bottomSplitLimits(topology, maybeTop, maybeBottom);
      upper = makeRegion(vertical.upperTop, vertical.upperBottom, left, right);
      lower = makeRegion(vertical.lowerTop, vertical.lowerBottom, left, right);
      return [upper, lower];
    }
    // else wrap neither! -Jeremy B September 2020
    return [makeRegion(maybeTop, maybeBottom, left, right)];
  };

  // (Topology, Int, Int, Int) => Array[Region]
  getRegionsVertical = function(topology, patchX, patchY, patchRadius) {
    var doubleRadius, left, right;
    doubleRadius = patchRadius * 2;
    left = NLMath.max(patchX - patchRadius, topology.minPxcor);
    right = NLMath.min(patchX + patchRadius, topology.maxPxcor);
    // handle the "whole world" case so we don't worry about it below. -Jeremy B September 2020
    if (doubleRadius >= (topology.height - 1)) {
      return [makeRegion(topology.maxPycor, topology.minPycor, left, right)];
    }
    return splitVertical(topology, patchY, patchRadius, left, right);
  };

  // (Topology, Int, Int) => Array[Int]
  leftSplitLimits = function(topology, maybeLeft, maybeRight) {
    var segment1Left, segment1Right, segment2Left, segment2Right;
    segment1Left = topology.minPxcor;
    segment1Right = maybeRight;
    segment2Left = topology.maxPxcor + (maybeLeft - topology.minPxcor);
    segment2Right = topology.maxPxcor;
    return [segment1Left, segment1Right, segment2Left, segment2Right];
  };

  // (Topology, Int, Int) => Array[Int]
  rightSplitLimits = function(topology, maybeLeft, maybeRight) {
    var segment1Left, segment1Right, segment2Left, segment2Right;
    segment1Left = topology.minPxcor;
    segment1Right = topology.minPxcor + (maybeRight - topology.maxPxcor);
    segment2Left = maybeLeft;
    segment2Right = topology.maxPxcor;
    return [segment1Left, segment1Right, segment2Left, segment2Right];
  };

  // (Topology, Int, Int, Int, Int) => Array[Region]
  splitHorizontal = function(topology, patchX, patchRadius, top, bottom) {
    var horizontal, maybeLeft, maybeRight;
    maybeLeft = patchX - patchRadius;
    maybeRight = patchX + patchRadius;
    if (maybeLeft < topology.minPxcor) {
      // wrap the left off -Jeremy B September 2020
      horizontal = leftSplitLimits(topology, maybeLeft, maybeRight);
      return [makeRegion(top, bottom, ...horizontal)];
    }
    if (maybeRight > topology.maxPxcor) {
      // wrap the right off -Jeremy B September 2020
      horizontal = rightSplitLimits(topology, maybeLeft, maybeRight);
      return [makeRegion(top, bottom, ...horizontal)];
    }
    // else wrap neither! -Jeremy B September 2020
    return [makeRegion(top, bottom, maybeLeft, maybeRight)];
  };

  // (Topology, Int, Int, Int) => Array[Region]
  getRegionsHorizontal = function(topology, patchX, patchY, patchRadius) {
    var bottom, doubleRadius, top;
    doubleRadius = patchRadius * 2;
    top = NLMath.min(patchY + patchRadius, topology.maxPycor);
    bottom = NLMath.max(patchY - patchRadius, topology.minPycor);
    // handle the "whole world" case so we don't worry about it below. -Jeremy B September 2020
    if (doubleRadius >= (topology.width - 1)) {
      return [makeRegion(top, bottom, topology.minPxcor, topology.maxPxcor)];
    }
    return splitHorizontal(topology, patchX, patchRadius, top, bottom);
  };

  // (Topology, Int, Int, Int) => Array[Region]
  getRegionsTorus = function(topology, patchX, patchY, patchRadius) {
    var bottom, doubleRadius, horizontal, isBottomInBounds, isLeftInBounds, isRightInBounds, isTopInBounds, left, lower, maybeBottom, maybeLeft, maybeRight, maybeTop, right, top, upper, vertical;
    doubleRadius = patchRadius * 2;
    // handle the "whole world" cases so we don't worry about it below. -Jeremy B September 2020
    if (doubleRadius >= (topology.width - 1)) {
      if (doubleRadius >= (topology.height - 1)) {
        return [makeRegion(topology.maxPycor, topology.minPycor, topology.minPxcor, topology.maxPxcor)];
      } else {
        // we wrapped the whole world width, so this should be a simple vertical wrapping thing. -Jeremy B September 2020
        left = topology.minPxcor;
        right = topology.maxPxcor;
        return splitVertical(topology, patchY, patchRadius, left, right);
      }
    }
    if (doubleRadius >= (topology.height - 1)) {
      // we wrapped the whole world height, so this should be a simple horizontal wrapping thing. -Jeremy B September 2020
      top = topology.maxPycor;
      bottom = topology.minPycor;
      return splitHorizontal(topology, patchX, patchRadius, top, bottom);
    }
    maybeLeft = patchX - patchRadius;
    maybeRight = patchX + patchRadius;
    maybeTop = patchY + patchRadius;
    maybeBottom = patchY - patchRadius;
    isLeftInBounds = maybeLeft >= topology.minPxcor;
    isRightInBounds = maybeRight <= topology.maxPxcor;
    isTopInBounds = maybeTop <= topology.maxPycor;
    isBottomInBounds = maybeBottom >= topology.minPycor;
    // handle the unwrapped case so we don't have to worry about that below. -Jeremy B September 2020
    if (isLeftInBounds && isRightInBounds && isTopInBounds && isBottomInBounds) {
      return [makeRegion(maybeTop, maybeBottom, maybeLeft, maybeRight)];
    }
    // We aren't "whole world" and we aren't unwrapped, so there are a few scenarios left:

    // - There is a single edge outside the world - a simple two region split like vertical/horizontal
    // - There are two adjacent edges outside the world - a point in a "corner" needing four wrapped regions

    // -Jeremy B September 2020
    if (isTopInBounds && isBottomInBounds) {
      return splitHorizontal(topology, patchX, patchRadius, maybeTop, maybeBottom);
    }
    if (isLeftInBounds && isRightInBounds) {
      return splitVertical(topology, patchY, patchRadius, maybeLeft, maybeRight);
    }
    vertical = !isTopInBounds ? topSplitLimits(topology, maybeTop, maybeBottom) : bottomSplitLimits(topology, maybeTop, maybeBottom);
    horizontal = !isLeftInBounds ? leftSplitLimits(topology, maybeLeft, maybeRight) : rightSplitLimits(topology, maybeLeft, maybeRight);
    upper = makeRegion(vertical.upperTop, vertical.upperBottom, ...horizontal);
    lower = makeRegion(vertical.lowerTop, vertical.lowerBottom, ...horizontal);
    return [upper, lower];
  };

  // (Region, (Int, Int) => Unit) => Unit
  searchRegion = function(region, checkAgentsHere) {
    var j, k, l, len, pxcor, pycor, ref, ref1, ref2, ref3, ref4, segment;
    for (pycor = j = ref = region.top, ref1 = region.bottom; (ref <= ref1 ? j <= ref1 : j >= ref1); pycor = ref <= ref1 ? ++j : --j) {
      ref2 = region.segments;
      for (k = 0, len = ref2.length; k < len; k++) {
        segment = ref2[k];
        for (pxcor = l = ref3 = segment.left, ref4 = segment.right; (ref3 <= ref4 ? l <= ref4 : l >= ref4); pxcor = ref3 <= ref4 ? ++l : --l) {
          checkAgentsHere(pxcor, pycor);
        }
      }
    }
  };

  // (Topology, Int, Int, Number, (Int, Int) => Unit) => Unit
  searchPatches = function(topology, patchX, patchY, radius, checkAgentsHere) {
    var j, len, patchRadius, patches, region, regions;
    // NetLogo desktop special-cases on radius length. -Jeremy B August 2020.
    if (radius <= 2) {
      patches = getSmallRadiusPatches(topology, patchX, patchY, radius);
      patches.forEach(function(patch) {
        return checkAgentsHere(patch.pxcor, patch.pycor);
      });
    } else {
      patchRadius = NLMath.ceil(radius);
      regions = topologyHelpers.getRegions(patchX, patchY, patchRadius);
      for (j = 0, len = regions.length; j < len; j++) {
        region = regions[j];
        searchRegion(region, checkAgentsHere);
      }
    }
  };

  // (Topology, Number, Number, TurtleSet, Number) -> TurtleSet
  filterTurtlesInRadius = function(topology, x, y, turtleset, radius) {
    var checkTurtlesHere, couldBeRadius, couldBeRadiusSq, inExactRadiusSq, isInTargetSet, mustBeRadius, mustBeRadiusSq, patchX, patchY, results;
    patchX = NLMath.round(x);
    patchY = NLMath.round(y);
    isInTargetSet = makeTargetChecker(turtleset, "turtles");
    inExactRadiusSq = makeInExactRadiusSq(topologyHelpers.inRadiusSq, x, y, radius);
    // If the source turtle is in a corner of its patch, the patch distances will be off by sqrt(2) / 2.  We correct
    // for this by "over-sampling" the patches. -Jeremy B September 2020
    couldBeRadius = radius + 0.71;
    couldBeRadiusSq = couldBeRadius * couldBeRadius;
    mustBeRadius = radius < 1.414 ? 0 : radius - 0.71;
    mustBeRadiusSq = mustBeRadius * mustBeRadius;
    results = [];
    // (Int, Int) => Unit
    checkTurtlesHere = function(pxcor, pycor) {
      var distanceSq, patch, patchTurtles;
      // This empty patch check may help with sparser models.  Because the bounding box check
      // should already have filtered out most of the patches, this is worth the expense of
      // getting the patch to check even if the patch might not be in radius, as the size check should
      // be pretty fast and often 0.  -Jeremy B August 2020
      patch = topologyHelpers.getPatchAt(pxcor, pycor);
      // This relies on patches removing their dead turtles, which they should do.  -Jeremy B August 2020
      patchTurtles = patch._turtles;
      if (patchTurtles.length === 0) {
        return;
      }
      distanceSq = topologyHelpers.distanceSq(x, y, pxcor, pycor);
      // We could do a `reduce` or `flatMap` or something over the patches
      // instead of mutating the closed-over `results` variable, but we do not want
      // to generate extra GC pressure from excess arrays getting created then
      // immediately dropped, nor spend time re-iterating over our results to
      // collect them into the final set.  -Jeremy B August 2020
      if (distanceSq < mustBeRadiusSq) {
        patchTurtles.forEach(function(turtle) {
          if (isInTargetSet(turtle)) {
            return results.push(turtle);
          }
        });
        return;
      }
      if (distanceSq <= couldBeRadiusSq) {
        patchTurtles.forEach(function(turtle) {
          if (isInTargetSet(turtle) && inExactRadiusSq(turtle.xcor, turtle.ycor)) {
            results.push(turtle);
          }
        });
      }
    };
    searchPatches(topology, patchX, patchY, radius, checkTurtlesHere);
    return new TurtleSet(results, turtleset._world);
  };

  // (Topology, Number, Number, PatchSet, Number) -> PatchSet
  filterPatchesInRadius = function(topology, x, y, patchset, radius) {
    var checkPatchHere, inExactRadiusSq, isInTarget, patchX, patchY, results;
    patchX = NLMath.round(x);
    patchY = NLMath.round(y);
    isInTarget = makeTargetChecker(patchset, "patches");
    inExactRadiusSq = makeInExactRadiusSq(topologyHelpers.inRadiusSq, x, y, radius);
    results = [];
    // (Int, Int) => Unit
    checkPatchHere = function(pxcor, pycor) {
      var patch;
      patch = topologyHelpers.getPatchAt(pxcor, pycor);
      if (isInTarget(patch) && inExactRadiusSq(patch.pxcor, patch.pycor)) {
        results.push(patch);
      }
    };
    searchPatches(topology, patchX, patchY, radius, checkPatchHere);
    return new PatchSet(results, patchset._world);
  };

  // (Topology, Number, Number, TurtleSet | PatchSet, Number) -> TurtleSet | PatchSet
  inRadius = function(topology, x, y, agentset, radius) {
    initialize(topology);
    switch (agentset._agentTypeName) {
      case "turtles":
        return filterTurtlesInRadius(topology, x, y, agentset, radius);
      case "patches":
        return filterPatchesInRadius(topology, x, y, agentset, radius);
      default:
        throw exceptions.internal("Cannot use `in-radius` on this agentset type.");
    }
  };

  /*

  Begin `in-cone` section.

  This code is updated to match the `in-radius` style above and to use some of those optimizations and caching, but it
  hasn't been fully converted or optimized.  Most critically, it gives the same ordering of resulting agents as desktop
  NetLogo.

  -Jeremy B August 2020

  */
  // this.type: Topology
  // [T] @ (Number, Number, Number, AbstractAgents[T], Number, Number) => AbstractAgentSet[T]
  inCone = function(x, y, turtleHeading, agents, distance, angle) {
    var checkAgentsHere, findWrapCount, isInCone, isInSector, isInTargetSet, isInWrappableSector, patchIsGood, pxcor, pycor, results, turtleIsGood, wrapCountInX, wrapCountInY;
    initialize(this);
    // (Number, Number) => Number
    findWrapCount = function(wrapsInDim, dimSize) {
      if (wrapsInDim) {
        return NLMath.ceil(distance / dimSize);
      } else {
        return 0;
      }
    };
    // (Number, Number, Number, Number, Number, Number) => Boolean
    isInSector = (ax, ay, cx, cy, radius, heading) => {
      var isTheSameSpot, isWithinArc, isWithinRange;
      isWithinArc = () => {
        var diff, half, theta;
        theta = this._towardsNotWrapped(cx, cy, ax, ay);
        diff = NLMath.abs(theta - heading);
        half = angle / 2;
        return (diff <= half) || ((360 - diff) <= half);
      };
      isWithinRange = function() {
        return NLMath.distance4_2D(cx, cy, ax, ay) <= radius;
      };
      isTheSameSpot = ax === cx && ay === cy;
      return isTheSameSpot || (isWithinRange() && isWithinArc());
    };
    // (Number, Number, Number, Number) => Boolean
    isInWrappableSector = (agentX, agentY, xBound, yBound) => {
      var j, k, ref, ref1, ref2, ref3, xWrapCoefficient, yWrapCoefficient;
      for (xWrapCoefficient = j = ref = -xBound, ref1 = xBound; (ref <= ref1 ? j <= ref1 : j >= ref1); xWrapCoefficient = ref <= ref1 ? ++j : --j) {
        for (yWrapCoefficient = k = ref2 = -yBound, ref3 = yBound; (ref2 <= ref3 ? k <= ref3 : k >= ref3); yWrapCoefficient = ref2 <= ref3 ? ++k : --k) {
          if (isInSector(agentX + this.width * xWrapCoefficient, agentY + this.height * yWrapCoefficient, x, y, distance, turtleHeading)) {
            return true;
          }
        }
      }
      return false;
    };
    // (Number, Number) => (Patch) => Boolean
    patchIsGood = (wrapCountInX, wrapCountInY) => {
      return (patch) => {
        return isInWrappableSector(patch.pxcor, patch.pycor, wrapCountInX, wrapCountInY);
      };
    };
    // (Number, Number) => (Turtle) => Boolean
    turtleIsGood = (wrapCountInX, wrapCountInY) => {
      return (turtle) => {
        return isInWrappableSector(turtle.xcor, turtle.ycor, wrapCountInX, wrapCountInY);
      };
    };
    ({pxcor, pycor} = this._getPatchAt(x, y));
    wrapCountInX = findWrapCount(this._wrapInX, this.width);
    wrapCountInY = findWrapCount(this._wrapInY, this.height);
    results = [];
    checkAgentsHere = (function() {
      if (checks.isPatchSet(agents)) {
        isInTargetSet = makeTargetChecker(agents, "patches");
        isInCone = patchIsGood(wrapCountInX, wrapCountInY);
        return function(pxcor, pycor) {
          var patch;
          patch = topologyHelpers.getPatchAt(pxcor, pycor);
          if (isInTargetSet(patch) && isInCone(patch)) {
            results.push(patch);
          }
        };
      } else if (checks.isTurtleSet(agents)) {
        isInTargetSet = makeTargetChecker(agents, "turtles");
        isInCone = turtleIsGood(wrapCountInX, wrapCountInY);
        return function(pxcor, pycor) {
          var patch;
          patch = topologyHelpers.getPatchAt(pxcor, pycor);
          patch._turtles.forEach((turtle) => {
            if (isInTargetSet(turtle) && isInCone(turtle)) {
              results.push(turtle);
            }
          });
        };
      } else {
        throw exceptions.internal("Cannot use `in-cone` on this agentset type.");
      }
    })();
    searchPatches(this, pxcor, pycor, distance, checkAgentsHere);
    return agents.copyWithNewAgents(results);
  };

  module.exports = {inRadius, inCone};

}).call(this);

},{"../typechecker":"engine/core/typechecker","util/exception":"util/exception","util/nlmath":"util/nlmath"}],"engine/core/topology/topology":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Diffuser, InRadiusOrCone, StrictMath, Topology, TopologyInterrupt, TowardsInterrupt, abstractMethod, filter, pipeline, unique;

  InRadiusOrCone = require('./inradiusorcone');

  Topology = require('./topology');

  Diffuser = require('./diffuser');

  StrictMath = require('shim/strictmath');

  abstractMethod = require('util/abstractmethoderror');

  ({filter, unique} = require('brazierjs/array'));

  ({pipeline} = require('brazierjs/function'));

  ({TopologyInterrupt, TowardsInterrupt} = require('util/interrupts'));

  module.exports = Topology = (function() {
    class Topology {
      // (Number, Number, Number, Number, () => PatchSet, (Number, Number) => Patch) => Topology
      constructor(minPxcor, maxPxcor, minPycor, maxPycor, _getPatches, _getPatchAt) {
        // (Number, Number, String, Number, Number) => Unit
        this._setPatchVariable = this._setPatchVariable.bind(this);
        // (Number, Number) => Number
        this._shortestX = this._shortestX.bind(this);
        this._shortestY = this._shortestY.bind(this);
        this.minPxcor = minPxcor;
        this.maxPxcor = maxPxcor;
        this.minPycor = minPycor;
        this.maxPycor = maxPycor;
        this._getPatches = _getPatches;
        this._getPatchAt = _getPatchAt;
        this.height = 1 + this.maxPycor - this.minPycor;
        this.width = 1 + this.maxPxcor - this.minPxcor;
        this.diffuser = new Diffuser(this._setPatchVariable, this.width, this.height, this._wrapInX, this._wrapInY);
        this._neighborCache = {};
        this._neighbor4Cache = {};
      }

      // (String, Number, Boolean) => Unit (side effect: diffuse varName by coeffecient among patches)
      diffuse(varName, coefficient, fourWay) {
        var mapAll, scratch, xx, yy;
        yy = this.height;
        xx = this.width;
        mapAll = function(f) {
          var i, ref, results, x, y;
          results = [];
          for (x = i = 0, ref = xx; (0 <= ref ? i < ref : i > ref); x = 0 <= ref ? ++i : --i) {
            results.push((function() {
              var j, ref1, results1;
              results1 = [];
              for (y = j = 0, ref1 = yy; (0 <= ref1 ? j < ref1 : j > ref1); y = 0 <= ref1 ? ++j : --j) {
                results1.push(f(x, y));
              }
              return results1;
            })());
          }
          return results;
        };
        scratch = mapAll((x, y) => {
          return this._getPatchAt(x + this.minPxcor, y + this.minPycor).getVariable(varName);
        });
        if (fourWay) {
          this.diffuser.diffuse4(varName, coefficient, scratch);
        } else {
          this.diffuser.diffuse8(varName, coefficient, scratch);
        }
      }

      _setPatchVariable(x, y, varName, newVal, oldVal) {
        if (newVal !== oldVal) {
          return this._getPatchAt(x + this.minPxcor, y + this.minPycor).setVariable(varName, newVal);
        }
      }

      // (Number, Number) => Array[Patch]
      getNeighbors(pxcor, pycor) {
        var key;
        key = `(${pxcor}, ${pycor})`;
        if (this._neighborCache.hasOwnProperty(key)) {
          return this._neighborCache[key];
        } else {
          return this._neighborCache[key] = this._filterNeighbors(this._getNeighbors(pxcor, pycor));
        }
      }

      // (Number, Number) => Array[Patch]
      getNeighbors4(pxcor, pycor) {
        var key;
        key = `(${pxcor}, ${pycor})`;
        if (this._neighbor4Cache.hasOwnProperty(key)) {
          return this._neighbor4Cache[key];
        } else {
          return this._neighbor4Cache[key] = this._filterNeighbors(this._getNeighbors4(pxcor, pycor));
        }
      }

      // Sadly, having topologies give out `false` and filtering it away seems to give the best balance between
      // NetLogo semantics, code clarity, and efficiency.  I tried to kill this `false`-based nonsense, but I
      // couldn't strike a better balance. --JAB (7/30/14)
      // (Array[Patch]) => Array[Patch]
      _filterNeighbors(neighbors) {
        return pipeline(filter(function(patch) {
          return patch !== false;
        }), unique)(neighbors);
      }

      // (Number, Number, Number, Number) => Number
      distanceXY(x1, y1, x2, y2) {
        var a2, b2;
        a2 = StrictMath.pow(this._shortestX(x1, x2), 2);
        b2 = StrictMath.pow(this._shortestY(y1, y2), 2);
        return StrictMath.sqrt(a2 + b2);
      }

      // (Number, Number, Turtle|Patch) => Number
      distance(x1, y1, agent) {
        var x2, y2;
        [x2, y2] = agent.getCoords();
        return this.distanceXY(x1, y1, x2, y2);
      }

      // (Number, Number, Number, Number) => Number
      distanceXYNotWrapped(x1, y1, x2, y2) {
        var a2, b2;
        a2 = StrictMath.pow(this._shortestNotWrapped(x1, x2), 2);
        b2 = StrictMath.pow(this._shortestNotWrapped(y1, y2), 2);
        return StrictMath.sqrt(a2 + b2);
      }

      // Some prims, like `layout-spring`, want the "visual" view distance rather than the wrapped distance, so this
      // lives here even for wrapping topologies. -Jeremy B August 2020
      // (Number, Number, Turtle|Patch) => Number
      distanceNotWrapped(x1, y1, agent) {
        var x2, y2;
        [x2, y2] = agent.getCoords();
        return this.distanceXYNotWrapped(x1, y1, x2, y2);
      }

      // (Number, Number, Number, Number, Number, Number) => Number
      distanceToLine(x1, y1, x2, y2, xcor, ycor) {
        var closestPoint, closestX, closestY, isInBounds, wrappedX1, wrappedX2, wrappedXcor, wrappedY1, wrappedY2, wrappedYcor, xDiff, yDiff;
        closestPoint = function(x1, y1, x2, y2, xDiff, yDiff) {
          var u, x, y;
          // all this math determines a point on the line defined by the endpoints of the
          // link nearest to the given point --??? (??/??/??)
          u = ((x1 - x2) * xDiff + (y1 - y2) * yDiff) / (xDiff * xDiff + yDiff * yDiff);
          x = x2 + u * xDiff;
          y = y2 + u * yDiff;
          return {x, y};
        };
        // since this is a segment not a continuous line we have to check the bounds
        // we know it's a point on the line, so if it's in the bounding box then
        // we're good and just return that point. ev 10/12/06
        isInBounds = function(x1, y1, x2, y2, pointX, pointY) {
          var bottom, left, right, top;
          [bottom, top] = y1 > y2 ? [y2, y1] : [y1, y2];
          [left, right] = x1 > x2 ? [x2, x1] : [x1, x2];
          return pointX <= right && pointX >= left && pointY <= top && pointY >= bottom;
        };
        wrappedX1 = this.wrapX(x1);
        wrappedX2 = this.wrapX(x2);
        wrappedXcor = this.wrapX(xcor);
        wrappedY1 = this.wrapY(y1);
        wrappedY2 = this.wrapY(y2);
        wrappedYcor = this.wrapY(ycor);
        xDiff = wrappedX2 - wrappedX1;
        yDiff = wrappedY2 - wrappedY1;
        ({
          x: closestX,
          y: closestY
        } = closestPoint(wrappedXcor, wrappedYcor, wrappedX1, wrappedY1, xDiff, yDiff));
        if (isInBounds(wrappedX1, wrappedY1, wrappedX2, wrappedY2, closestX, closestY)) {
          return this.distanceXY(closestX, closestY, wrappedXcor, wrappedYcor);
        } else {
          return Math.min(this.distanceXY(x1, y1, xcor, ycor), this.distanceXY(x2, y2, xcor, ycor));
        }
      }

      // (Number, Number, Number, Number) => Number | TowardsInterrupt
      towards(x1, y1, x2, y2) {
        return this._towards(x1, y1, x2, y2, this._shortestX, this._shortestY);
      }

      // (Number, Number) => Number
      midpointx(x1, x2) {
        var pos;
        pos = (x1 + (x1 + this._shortestX(x1, x2))) / 2;
        return this._wrap(pos, this.minPxcor - 0.5, this.maxPxcor + 0.5);
      }

      // (Number, Number) => Number
      midpointy(y1, y2) {
        var pos;
        pos = (y1 + (y1 + this._shortestY(y1, y2))) / 2;
        return this._wrap(pos, this.minPycor - 0.5, this.maxPycor + 0.5);
      }

      // [T] @ (Number, Number, Number, AbstractAgents[T], Number, Number) => AbstractAgentSet[T]
      inCone(x, y, heading, agents, distance, angle) {
        return InRadiusOrCone.inCone.call(this, x, y, heading, agents, distance, angle);
      }

      // [T] @ (Number, Number, AbstractAgents[T], Number) => AbstractAgentSet[T]
      inRadius(x, y, agents, radius) {
        return InRadiusOrCone.inRadius(this, x, y, agents, radius);
      }

      // (Number, Number) => Array[Patch]
      _getNeighbors(pxcor, pycor) {
        if (pxcor === this.maxPxcor && pxcor === this.minPxcor) {
          if (pycor === this.maxPycor && pycor === this.minPycor) {
            return [];
          } else {
            return [this._getPatchNorth(pxcor, pycor), this._getPatchSouth(pxcor, pycor)];
          }
        } else if (pycor === this.maxPycor && pycor === this.minPycor) {
          return [this._getPatchEast(pxcor, pycor), this._getPatchWest(pxcor, pycor)];
        } else {
          return [this._getPatchNorth(pxcor, pycor), this._getPatchEast(pxcor, pycor), this._getPatchSouth(pxcor, pycor), this._getPatchWest(pxcor, pycor), this._getPatchNorthEast(pxcor, pycor), this._getPatchSouthEast(pxcor, pycor), this._getPatchSouthWest(pxcor, pycor), this._getPatchNorthWest(pxcor, pycor)];
        }
      }

      // (Number, Number) => Array[Patch]
      _getNeighbors4(pxcor, pycor) {
        if (pxcor === this.maxPxcor && pxcor === this.minPxcor) {
          if (pycor === this.maxPycor && pycor === this.minPycor) {
            return [];
          } else {
            return [this._getPatchNorth(pxcor, pycor), this._getPatchSouth(pxcor, pycor)];
          }
        } else if (pycor === this.maxPycor && pycor === this.minPycor) {
          return [this._getPatchEast(pxcor, pycor), this._getPatchWest(pxcor, pycor)];
        } else {
          return [this._getPatchNorth(pxcor, pycor), this._getPatchEast(pxcor, pycor), this._getPatchSouth(pxcor, pycor), this._getPatchWest(pxcor, pycor)];
        }
      }

      // (Number, Number) => Number
      _shortestNotWrapped(cor1, cor2) {
        return StrictMath.abs(cor1 - cor2) * (cor1 > cor2 ? -1 : 1);
      }

      // (Number, Number, Number) => Number
      _shortestWrapped(cor1, cor2, limit) {
        var absDist;
        absDist = StrictMath.abs(cor1 - cor2);
        if (absDist > limit / 2) {
          return (limit - absDist) * (cor2 > cor1 ? -1 : 1);
        } else {
          return this._shortestNotWrapped(cor1, cor2);
        }
      }

      // (Number, Number) => Number
      _shortestXWrapped(cor1, cor2) {
        return this._shortestWrapped(cor1, cor2, this.width);
      }

      // (Number, Number) => Number
      _shortestYWrapped(cor1, cor2) {
        return this._shortestWrapped(cor1, cor2, this.height);
      }

      // (Number, Number, Number, Number, (Number, Number) => Number, (Number, Number) => Number) => Number | TowardsInterrupt
      _towards(x1, y1, x2, y2, findXDist, findYDist) {
        var dx, dy;
        if ((x1 !== x2) || (y1 !== y2)) {
          dx = findXDist(x1, x2);
          dy = findYDist(y1, y2);
          if (dx === 0) {
            if (dy >= 0) {
              return 0;
            } else {
              return 180;
            }
          } else if (dy === 0) {
            if (dx >= 0) {
              return 90;
            } else {
              return 270;
            }
          } else {
            return (270 + StrictMath.toDegrees(StrictMath.PI() + StrictMath.atan2(-dy, dx))) % 360;
          }
        } else {
          return TowardsInterrupt;
        }
      }

      // (Number, Number, Number, Number) => Number | TowardsInterrupt
      _towardsNotWrapped(x1, y1, x2, y2) {
        return this._towards(x1, y1, x2, y2, this._shortestNotWrapped, this._shortestNotWrapped);
      }

      // (Number, Number, Number) => Number
      _wrap(pos, min, max) {
        var result;
        if (pos >= max) {
          return min + ((pos - max) % (max - min));
        } else if (pos < min) {
          result = max - ((min - pos) % (max - min));
          if (result < max) {
            return result;
          } else {
            return min;
          }
        } else {
          return pos;
        }
      }

      // (Number) => Number | TopologyInterrupt
      _wrapXCautiously(pos) {
        return this._wrapCautiously(this.minPxcor, this.maxPxcor, pos);
      }

      // (Number) => Number
      _wrapXLeniently(pos) {
        return this._wrapLeniently(this.minPxcor, this.maxPxcor, pos);
      }

      // (Number) => Number | TopologyInterrupt
      _wrapYCautiously(pos) {
        return this._wrapCautiously(this.minPycor, this.maxPycor, pos);
      }

      // (Number) => Number
      _wrapYLeniently(pos) {
        return this._wrapLeniently(this.minPycor, this.maxPycor, pos);
      }

      // (Number, Number, Number) => Number | TopologyInterrupt
      _wrapCautiously(minCor, maxCor, pos) {
        var max, min;
        min = minCor - 0.5;
        max = maxCor + 0.5;
        if ((min <= pos && pos < max)) {
          return pos;
        } else {
          return TopologyInterrupt;
        }
      }

      // (Number, Number, Number) => Number
      _wrapLeniently(minCor, maxCor, pos) {
        return this._wrap(pos, minCor - 0.5, maxCor + 0.5);
      }

      // (Number) => Number | TopologyInterrupt
      wrapX(pos) {
        return abstractMethod('Topology.wrapX');
      }

      wrapY(pos) {
        return abstractMethod('Topology.wrapY');
      }

      _shortestX(x1, x2) {
        return abstractMethod('Topology._shortestX');
      }

      _shortestY(y1, y2) {
        return abstractMethod('Topology._shortestY');
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorth(x, y) {
        return abstractMethod('Topology._getPatchNorth');
      }

      _getPatchEast(x, y) {
        return abstractMethod('Topology._getPatchEast');
      }

      _getPatchSouth(x, y) {
        return abstractMethod('Topology._getPatchSouth');
      }

      _getPatchWest(x, y) {
        return abstractMethod('Topology._getPatchWest');
      }

      _getPatchNorthEast(x, y) {
        return abstractMethod('Topology._getPatchNorthEast');
      }

      _getPatchSouthEast(x, y) {
        return abstractMethod('Topology._getPatchSouthEast');
      }

      _getPatchSouthWest(x, y) {
        return abstractMethod('Topology._getPatchSouthWest');
      }

      _getPatchNorthWest(x, y) {
        return abstractMethod('Topology._getPatchNorthWest');
      }

    };

    Topology.prototype._wrapInX = void 0; // Boolean

    Topology.prototype._wrapInY = void 0; // Boolean

    Topology.prototype.height = void 0; // Number

    Topology.prototype.width = void 0; // Number

    Topology.prototype._neighborCache = void 0;

    Topology.prototype._neighbor4Cache = void 0;

    return Topology;

  }).call(this);

}).call(this);

},{"./diffuser":"engine/core/topology/diffuser","./inradiusorcone":"engine/core/topology/inradiusorcone","./topology":"engine/core/topology/topology","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","shim/strictmath":"shim/strictmath","util/abstractmethoderror":"util/abstractmethoderror","util/interrupts":"util/interrupts"}],"engine/core/topology/torus":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Topology, Torus, add, foldl, map, pipeline, rangeUntil,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  Topology = require('./topology');

  ({foldl, map} = require('brazierjs/array'));

  ({pipeline} = require('brazierjs/function'));

  ({rangeUntil} = require('brazierjs/number'));

  // Why our own custom add function?  To avoid anonymous functions getting created as part
  // of the fold below.  This bad boy will add any two numbers together, no problem.
  // -JMB 07/2017
  add = function(a, b) {
    return a + b;
  };

  module.exports = Torus = (function() {
    class Torus extends Topology {
      constructor() {
        super(...arguments);
        // (Number, Number) => Number
        this._shortestX = this._shortestX.bind(this);
        // (Number, Number) => Number
        this._shortestY = this._shortestY.bind(this);
      }

      
        // (Number) => Number
      wrapX(pos) {
        return this._wrapXLeniently(pos);
      }

      // (Number) => Number
      wrapY(pos) {
        return this._wrapYLeniently(pos);
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorth(pxcor, pycor) {
        if (pycor === this.maxPycor) {
          return this._getPatchAt(pxcor, this.minPycor);
        } else {
          return this._getPatchAt(pxcor, pycor + 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchSouth(pxcor, pycor) {
        if (pycor === this.minPycor) {
          return this._getPatchAt(pxcor, this.maxPycor);
        } else {
          return this._getPatchAt(pxcor, pycor - 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchEast(pxcor, pycor) {
        if (pxcor === this.maxPxcor) {
          return this._getPatchAt(this.minPxcor, pycor);
        } else {
          return this._getPatchAt(pxcor + 1, pycor);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchWest(pxcor, pycor) {
        if (pxcor === this.minPxcor) {
          return this._getPatchAt(this.maxPxcor, pycor);
        } else {
          return this._getPatchAt(pxcor - 1, pycor);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorthWest(pxcor, pycor) {
        if (pycor === this.maxPycor) {
          if (pxcor === this.minPxcor) {
            return this._getPatchAt(this.maxPxcor, this.minPycor);
          } else {
            return this._getPatchAt(pxcor - 1, this.minPycor);
          }
        } else if (pxcor === this.minPxcor) {
          return this._getPatchAt(this.maxPxcor, pycor + 1);
        } else {
          return this._getPatchAt(pxcor - 1, pycor + 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchSouthWest(pxcor, pycor) {
        if (pycor === this.minPycor) {
          if (pxcor === this.minPxcor) {
            return this._getPatchAt(this.maxPxcor, this.maxPycor);
          } else {
            return this._getPatchAt(pxcor - 1, this.maxPycor);
          }
        } else if (pxcor === this.minPxcor) {
          return this._getPatchAt(this.maxPxcor, pycor - 1);
        } else {
          return this._getPatchAt(pxcor - 1, pycor - 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchSouthEast(pxcor, pycor) {
        if (pycor === this.minPycor) {
          if (pxcor === this.maxPxcor) {
            return this._getPatchAt(this.minPxcor, this.maxPycor);
          } else {
            return this._getPatchAt(pxcor + 1, this.maxPycor);
          }
        } else if (pxcor === this.maxPxcor) {
          return this._getPatchAt(this.minPxcor, pycor - 1);
        } else {
          return this._getPatchAt(pxcor + 1, pycor - 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorthEast(pxcor, pycor) {
        if (pycor === this.maxPycor) {
          if (pxcor === this.maxPxcor) {
            return this._getPatchAt(this.minPxcor, this.minPycor);
          } else {
            return this._getPatchAt(pxcor + 1, this.minPycor);
          }
        } else if (pxcor === this.maxPxcor) {
          return this._getPatchAt(this.minPxcor, pycor + 1);
        } else {
          return this._getPatchAt(pxcor + 1, pycor + 1);
        }
      }

      _shortestX(x1, x2) {
        boundMethodCheck(this, Torus);
        return this._shortestXWrapped(x1, x2);
      }

      _shortestY(y1, y2) {
        boundMethodCheck(this, Torus);
        return this._shortestYWrapped(y1, y2);
      }

    };

    Torus.prototype._wrapInX = true; // Boolean

    Torus.prototype._wrapInY = true; // Boolean

    return Torus;

  }).call(this);

}).call(this);

},{"./topology":"engine/core/topology/topology","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/number":"brazier/number"}],"engine/core/topology/vertcylinder":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Topology, VertCylinder,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  Topology = require('./topology');

  module.exports = VertCylinder = (function() {
    class VertCylinder extends Topology {
      constructor() {
        super(...arguments);
        // (Number, Number) => Number
        this._shortestX = this._shortestX.bind(this);
        // (Number, Number) => Number
        this._shortestY = this._shortestY.bind(this);
      }

      
        // (Number) => Number
      wrapX(pos) {
        return this._wrapXLeniently(pos);
      }

      // (Number) => Number | TopologyInterrupt
      wrapY(pos) {
        return this._wrapYCautiously(pos);
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorth(pxcor, pycor) {
        return (pycor !== this.maxPycor) && this._getPatchAt(pxcor, pycor + 1);
      }

      // (Number, Number) => Patch|Boolean
      _getPatchSouth(pxcor, pycor) {
        return (pycor !== this.minPycor) && this._getPatchAt(pxcor, pycor - 1);
      }

      // (Number, Number) => Patch|Boolean
      _getPatchEast(pxcor, pycor) {
        if (pxcor === this.maxPxcor) {
          return this._getPatchAt(this.minPxcor, pycor);
        } else {
          return this._getPatchAt(pxcor + 1, pycor);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchWest(pxcor, pycor) {
        if (pxcor === this.minPxcor) {
          return this._getPatchAt(this.maxPxcor, pycor);
        } else {
          return this._getPatchAt(pxcor - 1, pycor);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorthWest(pxcor, pycor) {
        if (pycor === this.maxPycor) {
          return false;
        } else if (pxcor === this.minPxcor) {
          return this._getPatchAt(this.maxPxcor, pycor + 1);
        } else {
          return this._getPatchAt(pxcor - 1, pycor + 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchSouthWest(pxcor, pycor) {
        if (pycor === this.minPycor) {
          return false;
        } else if (pxcor === this.minPxcor) {
          return this._getPatchAt(this.maxPxcor, pycor - 1);
        } else {
          return this._getPatchAt(pxcor - 1, pycor - 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchSouthEast(pxcor, pycor) {
        if (pycor === this.minPycor) {
          return false;
        } else if (pxcor === this.maxPxcor) {
          return this._getPatchAt(this.minPxcor, pycor - 1);
        } else {
          return this._getPatchAt(pxcor + 1, pycor - 1);
        }
      }

      // (Number, Number) => Patch|Boolean
      _getPatchNorthEast(pxcor, pycor) {
        if (pycor === this.maxPycor) {
          return false;
        } else if (pxcor === this.maxPxcor) {
          return this._getPatchAt(this.minPxcor, pycor + 1);
        } else {
          return this._getPatchAt(pxcor + 1, pycor + 1);
        }
      }

      _shortestX(x1, x2) {
        boundMethodCheck(this, VertCylinder);
        return this._shortestXWrapped(x1, x2);
      }

      _shortestY(y1, y2) {
        boundMethodCheck(this, VertCylinder);
        return this._shortestNotWrapped(y1, y2);
      }

    };

    VertCylinder.prototype._wrapInX = true; // Boolean

    VertCylinder.prototype._wrapInY = false; // Boolean

    return VertCylinder;

  }).call(this);

}).call(this);

},{"./topology":"engine/core/topology/topology"}],"engine/core/turtle/makepenlines":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var NLMath, Trail, distanceFromLegs, lazyWrapValue, makePenLines, makePenLinesHelper, makeTrails;

  NLMath = require('util/nlmath');

  Trail = class Trail {
    constructor(x1, y1, x2, y2, dist) {
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x2;
      this.y2 = y2;
      this.dist = dist;
    }

    equals(t2) {
      return this.x1 === t2.x1 && this.x2 === t2.x2 && this.y1 === t2.y1 && this.y2 === t2.y2;
    }

  };

  // Ugh, Model Runs outputs the wrong updates for this
  // Make some simple tests
  lazyWrapValue = function(min, max) {
    return function(value) {
      if (value <= min) {
        return max;
      } else if (value >= max) {
        return min;
      } else {
        return value;
      }
    };
  };

  distanceFromLegs = function(l1, l2) {
    var square;
    square = function(x) {
      return NLMath.pow(x, 2);
    };
    return NLMath.sqrt(square(l1) + square(l2));
  };

  makeTrails = function(heading, minX, maxX, minY, maxY) {
    return function(x, y, jumpDist) {
      var baseTrails, dx, dy, interceptX, interceptY, makeTrailComponent, rawX, rawY, tan, xInterceptTrails, xcomp, yInterceptTrails, ycomp;
      xcomp = NLMath.squash(NLMath.sin(heading));
      ycomp = NLMath.squash(NLMath.cos(heading));
      tan = NLMath.squash(NLMath.tan(heading));
      rawX = x + xcomp * jumpDist;
      rawY = y + ycomp * jumpDist;
      baseTrails = [new Trail(x, y, rawX, rawY, jumpDist < 0 ? jumpDist * -1 : jumpDist)];
      makeTrailComponent = function(endX, endY, dx, dy) {
        return [new Trail(x, y, endX, endY, distanceFromLegs(dx, dy))];
      };
      yInterceptTrails = rawX > maxX ? (dx = maxX - x, dy = dx / tan, interceptY = y + dy, makeTrailComponent(maxX, interceptY, dx, dy)) : rawX < minX ? (dx = x - minX, dy = dx / tan, interceptY = y - dy, makeTrailComponent(minX, interceptY, dx, dy)) : [];
      xInterceptTrails = rawY > maxY ? (dy = maxY - y, dx = dy * tan, interceptX = x + dx, makeTrailComponent(interceptX, maxY, dx, dy)) : rawY < minY ? (dy = y - minY, dx = dy * tan, interceptX = x - dx, makeTrailComponent(interceptX, minY, dx, dy)) : [];
      return baseTrails.concat(xInterceptTrails, yInterceptTrails);
    };
  };

  // (Number, Number, Number, Number, Number, Number, Number, Number) => Array[Trail]
  makePenLines = function(x, y, heading, jumpDist, minX, maxX, minY, maxY) {
    var lazyWrapX, lazyWrapY, makeTrailsBy;
    makeTrailsBy = makeTrails(heading, minX, maxX, minY, maxY);
    lazyWrapX = lazyWrapValue(minX, maxX);
    lazyWrapY = lazyWrapValue(minY, maxY);
    return makePenLinesHelper(makeTrailsBy, lazyWrapX, lazyWrapY)(x, y, jumpDist, []);
  };

  // ((Number, Number, Number) => Array[Trail], (Number) => Number, (Number) => Number) => (Number, Number, Number, Array[Trail]) => Array[Trail]
  makePenLinesHelper = function(makeTrailsBy, lazyWrapX, lazyWrapY) {
    var inner;
    inner = function(x, y, jumpDist, acc) {
      var newX, newY, nextJumpDist, trail, trails;
      trails = makeTrailsBy(x, y, jumpDist);
      trail = trails.sort(function({
          dist: distA
        }, {
          dist: distB
        }) {
        if (distA < distB) {
          return -1;
        } else if (distA === distB) {
          return 0;
        } else {
          return 1;
        }
      })[0];
      if (acc.some(function(t) {
        return t.equals(trail);
      })) {
        return acc;
      } else {
        acc.push(trail);
        nextJumpDist = jumpDist >= 0 ? jumpDist - trail.dist : jumpDist + trail.dist;
        if (nextJumpDist === 0) {
          return acc;
        } else {
          newX = lazyWrapX(trail.x2);
          newY = lazyWrapY(trail.y2);
          return inner(newX, newY, nextJumpDist, acc);
        }
      }
    };
    return inner;
  };

  module.exports = makePenLines;

}).call(this);

},{"util/nlmath":"util/nlmath"}],"engine/core/turtle/turtlevariables":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ColorModel, ImmutableVariableSpec, MutableVariableSpec, NLMath, None, Setters, StrictMath, TopologyInterrupt, VariableSpecs, _handleTiesForHeadingChange, checks, clone, exceptions, getBreed, isSomething, maybe, setBreed, setBreedShape, setColor, setHeading, setIsHidden, setLabel, setLabelColor, setShape, setSize, setXcor, setYcor, validateColor;

  ColorModel = require('engine/core/colormodel');

  ({checks} = require('engine/core/typechecker'));

  StrictMath = require('shim/strictmath');

  NLMath = require('util/nlmath');

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({maybe, None, isSomething} = require('brazierjs/maybe'));

  ({clone} = require('brazierjs/object'));

  ({ImmutableVariableSpec, MutableVariableSpec} = require('../structure/variablespec'));

  ({TopologyInterrupt} = require('util/interrupts'));

  // (Number|RGB|RGBA) => Maybe[String]
  validateColor = function(color) {
    var hasBadLength, isBadCompNumber, isBadCompType;
    hasBadLength = function(xs) {
      return xs.length !== 3 && xs.length !== 4;
    };
    isBadCompNumber = function(x) {
      return !((0 <= x && x <= 255));
    };
    isBadCompType = function(x) {
      return !checks.isNumber(x);
    };
    if (checks.isList(color) && (hasBadLength(color) || color.some(isBadCompType))) {
      return maybe("Invalid RGB format");
    } else if (checks.isList(color) && (color.some(isBadCompNumber))) {
      return maybe("Invalid RGB number");
    } else {
      return None;
    }
  };

  // (Number, IDSet) => Maybe[TopologyInterrupt]
  setXcor = function(newX, seenTurtlesSet = {}) {
    var dx, f, oldX, originPatch, xcor;
    originPatch = this.getPatchHere();
    oldX = this.xcor;
    xcor = this.world.topology.wrapX(newX);
    if (xcor === TopologyInterrupt) {
      return maybe(TopologyInterrupt);
    } else {
      this.xcor = xcor;
      this._updateVarsByName("xcor");
      this._drawSetLine(oldX, this.ycor, newX, this.ycor);
      if (originPatch !== this.getPatchHere()) {
        originPatch.untrackTurtle(this);
        this.getPatchHere().trackTurtle(this);
      }
      this.linkManager._refresh();
      dx = newX - oldX;
      f = (seenTurtles) => {
        return (turtle) => {
          return setXcor.call(turtle, turtle.xcor + dx, seenTurtles);
        };
      };
      this._withEachTiedTurtle(f, seenTurtlesSet);
      return None;
    }
  };

  // (Number, IDSet) => Maybe[TopologyInterrupt]
  setYcor = function(newY, seenTurtlesSet = {}) {
    var dy, f, oldY, originPatch, ycor;
    originPatch = this.getPatchHere();
    oldY = this.ycor;
    ycor = this.world.topology.wrapY(newY);
    if (ycor === TopologyInterrupt) {
      return maybe(TopologyInterrupt);
    } else {
      this.ycor = ycor;
      this._updateVarsByName("ycor");
      this._drawSetLine(this.xcor, oldY, this.xcor, newY);
      if (originPatch !== this.getPatchHere()) {
        originPatch.untrackTurtle(this);
        this.getPatchHere().trackTurtle(this);
      }
      this.linkManager._refresh();
      dy = newY - oldY;
      f = (seenTurtles) => {
        return (turtle) => {
          return setYcor.call(turtle, turtle.ycor + dy, seenTurtles);
        };
      };
      this._withEachTiedTurtle(f, seenTurtlesSet);
      return None;
    }
  };

  // (String) => Unit
  setBreedShape = function(shape) {
    this._breedShape = shape.toLowerCase();
    if (this._givenShape == null) {
      this._genVarUpdate("shape");
    }
  };

  // (AbstractAgentSet|Breed|String) => Unit
  setBreed = function(breed) {
    var newNames, oldNames, ref, specialName, trueBreed;
    trueBreed = (function() {
      if (checks.isString(breed)) {
        return this.world.breedManager.get(breed);
      } else if (checks.isAgentSet(breed)) {
        specialName = breed.getSpecialName();
        if ((specialName != null) && !this.world.breedManager.get(specialName).isLinky()) {
          return this.world.breedManager.get(specialName);
        } else {
          throw exceptions.runtime("You can't set BREED to a non-breed agentset.", "set");
        }
      } else {
        return breed;
      }
    }).call(this);
    if ((this._breed != null) && this._breed !== trueBreed) {
      this._givenShape = void 0;
    }
    if (this._breed !== trueBreed) {
      trueBreed.add(this);
      if ((ref = this._breed) != null) {
        ref.remove(this);
      }
      newNames = this._varNamesForBreed(trueBreed);
      oldNames = this._varNamesForBreed(this._breed);
      this._varManager.refineBy(oldNames, newNames);
    }
    this._breed = trueBreed;
    this._genVarUpdate("breed");
    setBreedShape.call(this, trueBreed.getShape());
    this._refreshName();
    if (!this.world.breedManager.turtles().contains(this)) {
      this.world.breedManager.turtles().add(this);
    }
  };

  // (Number|RGB|RGBA) => Maybe[String]
  setColor = function(color) {
    var errorMaybe;
    errorMaybe = validateColor(color);
    if (!isSomething(errorMaybe)) {
      this._color = ColorModel.wrapColor(color);
      this._genVarUpdate("color");
    }
    return errorMaybe;
  };

  // (Number, IDSet) => Unit
  setHeading = function(heading, seenTurtlesSet = {}) {
    var dh, oldHeading;
    oldHeading = this._heading;
    this._heading = NLMath.normalizeHeading(heading);
    this._genVarUpdate("heading");
    dh = NLMath.subtractHeadings(this._heading, oldHeading);
    _handleTiesForHeadingChange.call(this, seenTurtlesSet, dh);
  };

  // (Boolean) => Unit
  setIsHidden = function(isHidden) {
    this._hidden = isHidden;
    this._genVarUpdate("hidden?");
  };

  // (String) => Unit
  setLabel = function(label) {
    this._label = label;
    this._genVarUpdate("label");
  };

  // (Number|RGB|RGBA) => Maybe[String]
  setLabelColor = function(color) {
    var errorMaybe;
    errorMaybe = validateColor(color);
    if (!isSomething(errorMaybe)) {
      this._labelcolor = ColorModel.wrapColor(color);
      this._genVarUpdate("label-color");
    }
    return errorMaybe;
  };

  // (String) => Unit
  setShape = function(shape) {
    this._givenShape = shape.toLowerCase();
    this._genVarUpdate("shape");
  };

  // (Number) => Unit
  setSize = function(size) {
    this._size = size;
    this._genVarUpdate("size");
  };

  // I have so many apologies for this code, but, hey,
  // it wasn't my idea to embed ties into NetLogo. --JAB (10/26/15)

  // (IDSet, Number) => Unit
  _handleTiesForHeadingChange = function(seenTurtlesSet, dh) {
    var filteredPairs, turtleModePairs, x, y;
    [x, y] = this.getCoords();
    turtleModePairs = this.linkManager.myOutLinks("LINKS").toArray().map(({end1, end2, tiemode}) => {
      return [(end1 === this ? end2 : end1), tiemode];
    });
    seenTurtlesSet[this.id] = true;
    filteredPairs = turtleModePairs.filter(function([{id}, mode]) {
      var result;
      result = (seenTurtlesSet[id] == null) && mode !== "none";
      seenTurtlesSet[id] = true;
      return result;
    });
    filteredPairs.forEach(([turtle, mode]) => {
      var newX, newY, r, result, theta;
      r = this.distance(turtle);
      if (r !== 0) {
        theta = this.towards(turtle) + dh;
        newX = x + r * NLMath.squash(NLMath.sin(theta));
        newY = y + r * NLMath.squash(NLMath.cos(theta));
        result = turtle.setXY(newX, newY, clone(seenTurtlesSet));
      }
      if (mode === "fixed" && result !== TopologyInterrupt) {
        return turtle.right(dh, clone(seenTurtlesSet));
      }
    });
  };

  Setters = {setXcor, setYcor, setBreed, setColor, setHeading, setIsHidden, setLabel, setLabelColor, setShape, setSize};

  getBreed = (function() {
    return this.world.turtleManager.turtlesOfBreed(this._breed.name);
  });

  VariableSpecs = [
    new ImmutableVariableSpec('who',
    function() {
      return this.id;
    }),
    new MutableVariableSpec('breed',
    getBreed,
    setBreed),
    new MutableVariableSpec('color',
    (function() {
      return this._color;
    }),
    setColor),
    new MutableVariableSpec('heading',
    (function() {
      return this._heading;
    }),
    setHeading),
    new MutableVariableSpec('hidden?',
    (function() {
      return this._hidden;
    }),
    setIsHidden),
    new MutableVariableSpec('label',
    (function() {
      return this._label;
    }),
    setLabel),
    new MutableVariableSpec('label-color',
    (function() {
      return this._labelcolor;
    }),
    setLabelColor),
    new MutableVariableSpec('pen-mode',
    (function() {
      return this.penManager.getMode().toString();
    }),
    (function(x) {
      return this.penManager.setPenMode(x);
    })),
    new MutableVariableSpec('pen-size',
    (function() {
      return this.penManager.getSize();
    }),
    (function(x) {
      return this.penManager.setSize(x);
    })),
    new MutableVariableSpec('shape',
    (function() {
      return this._getShape();
    }),
    setShape),
    new MutableVariableSpec('size',
    (function() {
      return this._size;
    }),
    setSize),
    new MutableVariableSpec('xcor',
    (function() {
      return this.xcor;
    }),
    setXcor),
    new MutableVariableSpec('ycor',
    (function() {
      return this.ycor;
    }),
    setYcor)
  ];

  module.exports = {Setters, VariableSpecs};

}).call(this);

},{"../structure/variablespec":"engine/core/structure/variablespec","brazierjs/maybe":"brazier/maybe","brazierjs/object":"brazier/object","engine/core/colormodel":"engine/core/colormodel","engine/core/typechecker":"engine/core/typechecker","shim/strictmath":"shim/strictmath","util/exception":"util/exception","util/interrupts":"util/interrupts","util/nlmath":"util/nlmath"}],"engine/core/turtlelinkmanager":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var All, In, LinkManager, LinkSet, Out, TurtleSet, filter, flatMap, linkBreedMatches, map, otherEnd, pipeline, unique;

  LinkSet = require('./linkset');

  TurtleSet = require('./turtleset');

  ({filter, flatMap, map, unique} = require('brazierjs/array'));

  ({pipeline} = require('brazierjs/function'));

  // data Directedness
  All = {};

  In = {};

  Out = {};

  // Number -> Link -> Turtle
  otherEnd = function(sourceID) {
    return function({end1, end2}) {
      if (end1.id === sourceID) {
        return end2;
      } else {
        return end1;
      }
    };
  };

  // String -> Directedness -> Number -> Link -> Boolean
  linkBreedMatches = function(breedName) {
    return function(directedness) {
      return function(ownerID) {
        return function(link) {
          return (breedName === "LINKS" || breedName === link.getBreedName()) && ((directedness === All) || (!link.isDirected) || (directedness === In && link.end2.id === ownerID) || (directedness === Out && link.end1.id === ownerID));
        };
      };
    };
  };

  module.exports = LinkManager = (function() {
    class LinkManager {
      
        // (Number, World) => LinkManager
      constructor(_ownerID, _world) {
        this._ownerID = _ownerID;
        this._world = _world;
        this.clear();
      }

      // (Link) => Unit
      add(link) {
        this._links.push(link);
      }

      // () => Unit
      clear() {
        var oldLinks, ref;
        oldLinks = (ref = this._links) != null ? ref : [];
        this._links = [];
        // Purposely done after resetting the array so that calls to `TurtleLinkManager.remove` in `Link.die` don't spend
        // a ton of time iterating through long arrays that are in the process of being wiped out. --JAB (11/24/14)
        oldLinks.forEach(function(link) {
          return link.die();
        });
      }

      // IN OR OUT

        // (String, Turtle) => Boolean
      isLinkNeighbor(breedName, turtle) {
        var i, len, link, ref;
        ref = this._links;
        for (i = 0, len = ref.length; i < len; i++) {
          link = ref[i];
          if ((breedName === "LINKS") || (breedName === link.getBreedName())) {
            if (otherEnd(this._ownerID)(link).id === turtle.id) {
              return true;
            }
          }
        }
        return false;
      }

      // (String, Turtle) => Link
      linkWith(breedName, otherTurtle) {
        return this._findLink(otherTurtle, breedName, All);
      }

      // (String) => TurtleSet
      linkNeighbors(breedName) {
        return this._neighbors(breedName, All);
      }

      // (String) => LinkSet
      myLinks(breedName) {
        return new LinkSet(this._links.filter(linkBreedMatches(breedName)(All)(this._ownerID)), this._world);
      }

      // OUT ONLY

        // (String, Turtle) => Boolean
      isOutLinkNeighbor(breedName, turtle) {
        var i, len, link, ref;
        ref = this._links;
        for (i = 0, len = ref.length; i < len; i++) {
          link = ref[i];
          if ((breedName === "LINKS") || (breedName === link.getBreedName())) {
            if (link.isDirected) {
              if (link.end1.id === this._ownerID && link.end2.id === turtle.id) {
                return true;
              }
            } else {
              if (otherEnd(this._ownerID)(link).id === turtle.id) {
                return true;
              }
            }
          }
        }
        return false;
      }

      // (String, Turtle) => Link
      outLinkTo(breedName, otherTurtle) {
        return this._findLink(otherTurtle, breedName, Out);
      }

      // (String) => TurtleSet
      outLinkNeighbors(breedName) {
        return this._neighbors(breedName, Out);
      }

      // (String) => LinkSet
      myOutLinks(breedName) {
        return new LinkSet(this._links.filter(linkBreedMatches(breedName)(Out)(this._ownerID)), this._world);
      }

      // IN ONLY

        // To mirror (pun intended) desktop's implementation of these prims, we don't have separate
      // versions of `isInLinkNeighbor()` and `inLinkFrom()`, we just flip the caller/callee in
      // LinkPrims to the `isOutLinkNeighbor()` and `outLinkTo()` calls.  -Jeremy B June 2023

        // (String) => TurtleSet
      inLinkNeighbors(breedName) {
        return this._neighbors(breedName, In);
      }

      // (String) => LinkSet
      myInLinks(breedName) {
        return new LinkSet(this._links.filter(linkBreedMatches(breedName)(In)(this._ownerID)), this._world);
      }

      // END LINK INTERROGATION PRIMITIVE METHODS

        // (Link) => Unit
      remove(link) {
        this._links.splice(this._links.indexOf(link), 1);
      }

      // Turtle -> String -> Directedness -> Agent
      _findLink(otherTurtle, breedName, directedness) {
        var linkDoesMatch, links;
        linkDoesMatch = (l) => {
          return otherEnd(this._ownerID)(l) === otherTurtle && linkBreedMatches(breedName)(directedness)(this._ownerID)(l);
        };
        links = this._links.filter(linkDoesMatch);
        if (links.length === 0) {
          return Nobody;
        } else if (links.length === 1) {
          return links[0];
        } else {
          return links[this._world.rng.nextInt(links.length)];
        }
      }

      // (LinkSet) => Array[Turtle]
      neighborsIn(linkSet) {
        var collectOtherEnd;
        collectOtherEnd = ({end1, end2}) => {
          var isEnd1, isEnd2;
          isEnd1 = end1.id === this._ownerID;
          isEnd2 = end2.id === this._ownerID;
          if (isEnd1 && (!isEnd2)) {
            return [end2];
          } else if (isEnd2 && (!isEnd1)) {
            return [end1];
          } else {
            return [];
          }
        };
        return pipeline(flatMap(collectOtherEnd), unique)(linkSet.toArray());
      }

      // String -> Directedness -> TurtleSet
      _neighbors(breedName, directedness) {
        return pipeline(filter(linkBreedMatches(breedName)(directedness)(this._ownerID)), map(otherEnd(this._ownerID)), unique, ((turtles) => {
          return new TurtleSet(turtles, this._world);
        }))(this._links);
      }

      // () => Unit
      _refresh() {
        this._links.forEach(function(link) {
          link.updateEndRelatedVars();
        });
      }

    };

    LinkManager._links = void 0; // Array[(Link, Directedness)]

    return LinkManager;

  }).call(this);

}).call(this);

},{"./linkset":"engine/core/linkset","./turtleset":"engine/core/turtleset","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function"}],"engine/core/turtleset":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AbstractAgentSet, DeadSkippingIterator, TurtleSet;

  AbstractAgentSet = require('./abstractagentset');

  DeadSkippingIterator = require('./structure/deadskippingiterator');

  module.exports = TurtleSet = class TurtleSet extends AbstractAgentSet {
    // [T <: Turtle] @ (Array[T], World, String) => TurtleSet
    constructor(agents, world, specialName) {
      super(agents, world, "turtles", specialName);
      this._agents = agents;
    }

    // () => Iterator[T]
    iterator() {
      return new DeadSkippingIterator(this._agents.slice(0));
    }

    // () => Iterator[T]
    _unsafeIterator() {
      return new DeadSkippingIterator(this._agents);
    }

  };

}).call(this);

},{"./abstractagentset":"engine/core/abstractagentset","./structure/deadskippingiterator":"engine/core/structure/deadskippingiterator"}],"engine/core/turtle":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AbstractAgentSet, ColorModel, Comparator, DeathInterrupt, Down, Erase, ExtraVariableSpec, NLMath, PenManager, Setters, Stamp, StampErase, StampMode, TopologyInterrupt, Turtle, TurtleLinkManager, TurtleSet, VariableManager, VariableSpecs, checks, exceptions, foldl, forEach, makePenLines, map, rangeUntil, uniqueBy;

  AbstractAgentSet = require('./abstractagentset');

  ColorModel = require('engine/core/colormodel');

  TurtleLinkManager = require('./turtlelinkmanager');

  TurtleSet = require('./turtleset');

  ({checks} = require('./typechecker'));

  VariableManager = require('./structure/variablemanager');

  makePenLines = require('./turtle/makepenlines');

  Comparator = require('util/comparator');

  NLMath = require('util/nlmath');

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({foldl, forEach, map, uniqueBy} = require('brazierjs/array'));

  ({rangeUntil} = require('brazierjs/number'));

  ({
    PenManager,
    PenStatus: {Down, Erase}
  } = require('./structure/penmanager'));

  ({ExtraVariableSpec} = require('./structure/variablespec'));

  ({DeathInterrupt, TopologyInterrupt} = require('util/interrupts'));

  ({Setters, VariableSpecs} = require('./turtle/turtlevariables'));

  StampMode = class StampMode {
    constructor(name1) { // (String) => StampMode
      this.name = name1;
    }

  };

  Stamp = new StampMode("normal");

  StampErase = new StampMode("erase");

  module.exports = Turtle = (function() {
    class Turtle {
      
        // The type signatures here can be found to the right of the parameters. --JAB (4/13/15)
      constructor(world, id1, _genUpdate, _registerLineDraw, _registerTurtleStamp, _registerDeath, _createTurtle, _removeTurtle, _color = 0, _heading = 0, xcor1 = 0, ycor1 = 0, breed = null, _label = "", _labelcolor = 9.9, _hidden = false, _size = 1.0, _givenShape, genPenManager = (self) => { // (Number) => Unit, Number, Number, Number, Number // Breed, String, Number, Boolean
          return new PenManager(this._genUpdate(self));
        }) { // Number, Boolean, Number, String, (Updatable) => PenManager
        var varNames;
        // (Number, Number) => Patch
        this.patchAt = this.patchAt.bind(this);
        this.world = world;
        this.id = id1;
        this._genUpdate = _genUpdate;
        this._registerLineDraw = _registerLineDraw;
        this._registerTurtleStamp = _registerTurtleStamp;
        this._registerDeath = _registerDeath;
        this._createTurtle = _createTurtle; // World, Number, (Updatable) => (String*) => Unit, RegLinkDrawFunc, RegTurtleStampFunc, (Number) => Unit, GenTurtleFunc
        this._removeTurtle = _removeTurtle;
        this._color = _color;
        this._heading = _heading;
        this.xcor = xcor1;
        this.ycor = ycor1;
        this._label = _label;
        this._labelcolor = _labelcolor;
        this._hidden = _hidden;
        this._size = _size;
        this._givenShape = _givenShape;
        breed = breed != null ? breed : this.world.breedManager.turtles();
        this._updateVarsByName = this._genUpdate(this);
        this.penManager = genPenManager(this);
        this.linkManager = new TurtleLinkManager(this.id, this.world);
        varNames = this._varNamesForBreed(breed);
        this._varManager = this._genVarManager(varNames);
        Setters.setBreed.call(this, breed);
        if (this._givenShape != null) {
          Setters.setShape.call(this, this._givenShape);
        }
        this.getPatchHere().trackTurtle(this);
      }

      // () => String
      getBreedName() {
        return this._breed.name;
      }

      // () => String
      getBreedNameSingular() {
        return this._breed.singular;
      }

      // Unit -> String
      getName() {
        return this._name;
      }

      // (Number) => Boolean
      canMove(distance) {
        return this.patchAhead(distance) !== Nobody;
      }

      // (Turtle|Patch) => Number
      distance(agent) {
        return this.world.topology.distance(this.xcor, this.ycor, agent);
      }

      // (Turtle|Patch) => Number
      distanceNotWrapped(agent) {
        return this.world.topology.distanceNotWrapped(this.xcor, this.ycor, agent);
      }

      // (Number, Number) => Number
      distanceXY(x, y) {
        return this.world.topology.distanceXY(this.xcor, this.ycor, x, y);
      }

      // () => (Number, Number)
      getCoords() {
        return [this.xcor, this.ycor];
      }

      // (Turtle|Patch) => Number | TowardsInterrupt
      towards(agent) {
        var x, y;
        [x, y] = agent.getCoords();
        return this.towardsXY(x, y);
      }

      // (Number, Number) => Number | TowardsInterrupt
      towardsXY(x, y) {
        return this.world.topology.towards(this.xcor, this.ycor, x, y);
      }

      // (Number, Number) => Unit
      faceXY(x, y) {
        if (x !== this.xcor || y !== this.ycor) {
          Setters.setHeading.call(this, this.world.topology.towards(this.xcor, this.ycor, x, y));
        }
      }

      // (Turtle|Patch) => Unit
      face(agent) {
        var x, y;
        [x, y] = agent.getCoords();
        this.faceXY(x, y);
      }

      // [T] @ (AbstractAgentSet[T], Number, Number) => AbstractAgentSet[T]
      inCone(agents, distance, angle) {
        if (distance < 0) {
          throw exceptions.runtime("IN-CONE cannot take a negative radius.", "in-cone");
        } else if (angle < 0) {
          throw exceptions.runtime("IN-CONE cannot take a negative angle.", "in-cone");
        } else if (angle > 360) {
          throw exceptions.runtime("IN-CONE cannot take an angle greater than 360.", "in-cone");
        } else {
          return this.world.topology.inCone(this.xcor, this.ycor, NLMath.normalizeHeading(this._heading), agents, distance, angle);
        }
      }

      // [T] @ (AbstractAgentSet[T], Number) => AbstractAgentSet[T]
      inRadius(agents, radius) {
        return this.world.topology.inRadius(this.xcor, this.ycor, agents, radius);
      }

      patchAt(dx, dy) {
        return this.world.getPatchAt(this.xcor + dx, this.ycor + dy);
      }

      // (Number, Number) => TurtleSet
      turtlesAt(dx, dy) {
        return this.getPatchHere().turtlesAt(dx, dy);
      }

      // (String, Number, Number) => TurtleSet
      breedAt(breedName, dx, dy) {
        return this.getPatchHere().breedAt(breedName, dx, dy);
      }

      // () => Turtle
      otherEnd() {
        if (this === this.world.selfManager.myself().end1) {
          return this.world.selfManager.myself().end2;
        } else {
          return this.world.selfManager.myself().end1;
        }
      }

      // (Number, Number) => Agent
      patchAtHeadingAndDistance(angle, distance) {
        return this.world.patchAtHeadingAndDistanceFrom(angle, distance, this.xcor, this.ycor);
      }

      // (Number, Number) => Agent
      patchRightAndAhead(angle, distance) {
        return this.patchAtHeadingAndDistance(this._heading + angle, distance);
      }

      // (Number, Number) => Agent
      // One might ask: why don't you use patchRightAndAhead here? The answer again: to reduce unnecessary function calls for frequently called prims.
      // In this case, removing the addition call does not add difficulty to maintenance; although the performance boost is supposed to be little as well.
      // -JC (1/30/23)
      patchLeftAndAhead(angle, distance) {
        return this.patchAtHeadingAndDistance(this._heading - angle, distance);
      }

      // (Number) => Agent
      patchAhead(distance) {
        return this.patchAtHeadingAndDistance(this._heading, distance);
      }

      // (() => Any) => Unit
      ask(f) {
        var base;
        if (!this.isDead()) {
          this.world.selfManager.askAgent(f)(this);
          if (typeof (base = this.world.selfManager.self()).isDead === "function" ? base.isDead() : void 0) {
            return DeathInterrupt;
          }
        } else {
          throw exceptions.runtime(`That ${this.getBreedNameSingular()} is dead.`, "ask");
        }
      }

      // [Result] @ (() => Result) => Result
      projectionBy(f) {
        if (!this.isDead()) {
          return this.world.selfManager.askAgent(f)(this);
        } else {
          throw exceptions.runtime(`That ${this._breed.singular} is dead.`, "of");
        }
      }

      // Unfortunately, further attempts to streamline this code are very likely to lead to
      // floating point arithmetic mismatches with JVM NetLogo....  Beware. --JAB (7/28/14)
      // (Number) => Unit
      fd(distance) {
        var increment, remaining;
        increment = distance > 0 ? 1 : -1;
        remaining = distance;
        if (distance > 0) {
          while (remaining >= increment && this.jumpIfAble(increment)) {
            remaining -= increment;
          }
        } else if (distance < 0) {
          while (remaining <= increment && this.jumpIfAble(increment)) {
            remaining -= increment;
          }
        }
        if (remaining !== 0) {
          this.jumpIfAble(remaining);
        }
      }

      // (Number) => Unit
      _optimalFdOne() {
        this.jumpIfAble(1);
      }

      // (Number) => Unit
      _optimalFdLessThan1(distance) {
        this.jumpIfAble(distance);
      }

      // (String) => Number
      _optimalNSum(varName) {
        return this.getPatchHere()._optimalNSum(varName);
      }

      // (String) => Number
      _optimalNSum4(varName) {
        return this.getPatchHere()._optimalNSum4(varName);
      }

      // (Number) => Boolean
      jumpIfAble(distance) {
        var canMove;
        canMove = this.canMove(distance);
        if (canMove) {
          this._jump(distance);
        }
        return canMove;
      }

      // (Number) => Unit
      _jump(distance) {
        this._drawJumpLine(this.xcor, this.ycor, distance, this._heading);
        this._setXandY(this.xcor + distance * this.dx(), this.ycor + distance * this.dy());
      }

      // () => Number
      dx() {
        return NLMath.squash(NLMath.sin(this._heading));
      }

      // () => Number
      dy() {
        return NLMath.squash(NLMath.cos(this._heading));
      }

      // (Number, IDSet) => Unit
      right(angle, seenTurtlesSet = {}) {
        var newHeading;
        newHeading = this._heading + angle;
        Setters.setHeading.call(this, newHeading, seenTurtlesSet);
      }

      // (Number, Number, IDSet) => Unit
      setXY(x, y, seenTurtlesSet = {}) {
        var origXcor, origYcor, result;
        origXcor = this.xcor;
        origYcor = this.ycor;
        result = this._setXandY(x, y, seenTurtlesSet);
        if (result === TopologyInterrupt) {
          this._setXandY(origXcor, origYcor, seenTurtlesSet);
          return TopologyInterrupt;
        }
        this._drawSetLine(origXcor, origYcor, x, y);
      }

      // Handy for when your turtles are drunk --JAB (8/18/15)
      // () => Unit
      goHome() {
        this.setXY(0, 0);
      }

      // (Boolean) => Unit
      hideTurtle(shouldHide) {
        Setters.setIsHidden.call(this, shouldHide);
      }

      // (String) => Boolean
      isBreed(breedName) {
        return this._breed.name.toUpperCase() === breedName.toUpperCase();
      }

      // () => Boolean
      isDead() {
        return this.id === -1;
      }

      // () => DeathInterrupt
      die() {
        this._breed.remove(this);
        if (!this.isDead()) {
          this._removeTurtle(this.id);
          this._seppuku();
          this.linkManager.clear();
          this.id = -1;
          this.getPatchHere().untrackTurtle(this);
          this.world.observer.unfocus(this);
        }
        return DeathInterrupt;
      }

      // (String) => Any
      getVariable(varName) {
        return this._varManager[varName];
      }

      // (String, Any) => Unit
      setVariable(varName, value) {
        this._varManager[varName] = value;
      }

      // (String, Any) => Maybe[Any]
      setIfValid(varName, value) {
        return this._varManager.setIfValid(varName, value);
      }

      // () => Patch
      getPatchHere() {
        return this.world.getPatchAt(this.xcor, this.ycor);
      }

      // (String) => Any
      getPatchVariable(varName) {
        return this.getPatchHere().getVariable(varName);
      }

      // (String, Any) => Unit
      setPatchVariable(varName, value) {
        this.getPatchHere().setVariable(varName, value);
      }

      // (String, Any) => Maybe[Any]
      setPatchVariableIfValid(varName, value) {
        return this.getPatchHere().setPatchVariableIfValid(varName, value);
      }

      // () => PatchSet
      getNeighbors() {
        return this.getPatchHere().getNeighbors();
      }

      // () => PatchSet
      getNeighbors4() {
        return this.getPatchHere().getNeighbors4();
      }

      // () => TurtleSet
      turtlesHere() {
        return this.getPatchHere().turtlesHere();
      }

      // (String) => TurtleSet
      breedHere(breedName) {
        return this.getPatchHere().breedHere(breedName);
      }

      // (String) => Array[Turtle]
      breedHereArray(breedName) {
        return this.getPatchHere().breedHereArray(breedName);
      }

      // (String) => Boolean
      anyBreedHere(breedName) {
        return this.getPatchHere().anyBreedHere(breedName);
      }

      // (Number, String) => TurtleSet
      hatch(n, breedName) {
        var breed, isNameValid, newTurtles, num;
        num = n >= 0 ? n : 0;
        isNameValid = (breedName != null) && breedName !== "";
        breed = isNameValid ? this.world.breedManager.get(breedName) : this._breed;
        newTurtles = map(() => {
          return this._makeTurtleCopy(breed);
        })(rangeUntil(0)(num));
        return new TurtleSet(newTurtles, this.world);
      }

      // (Breed) => Turtle
      _makeTurtleCopy(breed) {
        var shape, turtle, varNames;
        shape = breed === this._breed ? this._givenShape : void 0;
        turtle = this._createTurtle(this._color, this._heading, this.xcor, this.ycor, breed, this._label, this._labelcolor, this._hidden, this._size, shape, (self) => {
          return this.penManager.clone(this._genUpdate(self));
        });
        varNames = this._varNamesForBreed(breed);
        forEach((varName) => {
          var ref;
          turtle.setVariable(varName, (ref = this.getVariable(varName)) != null ? ref : 0);
        })(varNames);
        return turtle;
      }

      // (Breed) => Array[String]
      _varNamesForBreed(breed) {
        var turtlesBreed;
        turtlesBreed = this.world.breedManager.turtles();
        if (breed === turtlesBreed || (breed == null)) {
          return turtlesBreed.varNames;
        } else {
          return turtlesBreed.varNames.concat(breed.varNames);
        }
      }

      // (Turtle|Patch) => Unit
      moveTo(agent) {
        var x, y;
        [x, y] = agent.getCoords();
        this.setXY(x, y);
      }

      // () => Unit
      followMe() {
        this.world.observer.follow(this);
      }

      // () => Unit
      rideMe() {
        this.world.observer.ride(this);
      }

      // () => Unit
      watchMe() {
        this.world.observer.watch(this);
      }

      // () => Unit
      stamp() {
        this._drawStamp(Stamp);
      }

      // () => Unit
      stampErase() {
        this._drawStamp(StampErase);
      }

      // (Any) => Comparator
      compare(x) {
        if (checks.isTurtle(x)) {
          return Comparator.numericCompare(this.id, x.id);
        } else {
          return Comparator.NOT_EQUALS;
        }
      }

      // () => String
      toString() {
        if (!this.isDead()) {
          return `(${this.getName()})`;
        } else {
          return "nobody";
        }
      }

      // () => Boolean
      hasVariable(varName) {
        return this._varManager.has(varName);
      }

      // () => Array[String]
      varNames() {
        return this._varManager.names();
      }

      // (StampMode) => Unit
      _drawStamp(mode) {
        this._registerTurtleStamp(this.xcor, this.ycor, this._size, this._heading, ColorModel.colorToList(this._color), this._getShape(), mode.name);
      }

      // (Number, Number, Number) => Unit
      _drawJumpLine(x, y, dist, head) {
        var penMode;
        penMode = this.penManager.getMode();
        if (penMode === Down || penMode === Erase) {
          this._drawLines(x, y, dist, head);
        }
      }

      // (Number, Number, Number, Number) => Unit
      _drawSetLine(oldX, oldY, newX, newY) {
        var jumpDist, jumpHead, maxPxcor, maxPycor, minPxcor, minPycor, penMode, wrappedX, wrappedY;
        penMode = this.penManager.getMode();
        if ((penMode === Down || penMode === Erase) && (oldX !== newX || oldY !== newY)) {
          wrappedX = oldX + this.world.topology._shortestX(oldX, newX);
          wrappedY = oldY + this.world.topology._shortestY(oldY, newY);
          ({minPxcor, maxPxcor, minPycor, maxPycor} = this.world.topology);
          if (minPxcor < wrappedX && wrappedX < maxPxcor && minPycor < wrappedY && wrappedY < maxPycor) {
            this._registerLineDraw(oldX, oldY, wrappedX, wrappedY, ColorModel.colorToList(this._color), this.penManager.getSize(), this.penManager.getMode().toString());
          } else {
            jumpDist = NLMath.sqrt(NLMath.pow(oldX - wrappedX, 2) + NLMath.pow(oldY - wrappedY, 2));
            jumpHead = this.world.topology.towards(oldX, oldY, wrappedX, wrappedY);
            this._drawLines(oldX, oldY, jumpDist, jumpHead);
          }
        }
      }

      // (Number, Number, Number) => Unit
      _drawLines(x, y, dist, head) {
        var color, lines, maxPxcor, maxPycor, minPxcor, minPycor, mode, size;
        color = ColorModel.colorToList(this._color);
        size = this.penManager.getSize();
        mode = this.penManager.getMode().toString();
        ({minPxcor, maxPxcor, minPycor, maxPycor} = this.world.topology);
        lines = makePenLines(x, y, NLMath.normalizeHeading(head), dist, minPxcor - 0.5, maxPxcor + 0.5, minPycor - 0.5, maxPycor + 0.5);
        forEach(({x1, y1, x2, y2}) => {
          this._registerLineDraw(x1, y1, x2, y2, color, size, mode);
        })(lines);
      }

      // Unfortunately, we can't just throw out `_breedShape` and grab the shape from our
      // `Breed` object.  It would be pretty nice if we could, but the problem is that
      // `set-default-shape` only affects turtles created after its use, so turtles that
      // were using breed shape <X> before `set-default-shape` set the breed's shape to <Y>
      // still need to be using <X>. --JAB (12/5/14)
      // () => String
      _getShape() {
        var ref;
        return (ref = this._givenShape) != null ? ref : this._breedShape;
      }

      // (String) => (Link) => Boolean
      _linkBreedMatches(breedName) {
        return function(link) {
          return breedName === "LINKS" || breedName === link.getBreedName();
        };
      }

      // () => Unit
      _seppuku() {
        this._registerDeath(this.id);
      }

      // () => { "fixeds": Array[Turtle], "others": Array[Turtle] }
      _tiedTurtlesRaw() {
        var f, fixeds, links, others;
        links = this.linkManager.myOutLinks("LINKS").toArray().filter(function(l) {
          return l.tiemode !== "none";
        });
        f = ([fixeds, others], {end1, end2, tiemode}) => {
          var turtle;
          turtle = end1 === this ? end2 : end1;
          if (tiemode === "fixed") {
            return [fixeds.concat([turtle]), others];
          } else {
            return [fixeds, others.concat([turtle])];
          }
        };
        [fixeds, others] = foldl(f)([[], []])(links);
        return {
          fixeds: fixeds,
          others: others
        };
      }

      // () => Array[Turtle]
      _tiedTurtles() {
        var fixeds, others;
        ({fixeds, others} = this._tiedTurtlesRaw());
        return this._uniqueTurtles(fixeds.concat(others));
      }

      // () => Array[Turtle]
      _fixedTiedTurtles() {
        return this._uniqueTurtles(this._tiedTurtlesRaw().fixeds);
      }

      // (Array[Turtle]) => Array[Turtle]
      _uniqueTurtles(turtles) {
        return uniqueBy(function(t) {
          return t.id;
        })(turtles);
      }

      // (Array[String]) => VariableManager
      _genVarManager(extraVarNames) {
        var allSpecs, extraSpecs;
        extraSpecs = extraVarNames.map(function(name) {
          return new ExtraVariableSpec(name);
        });
        allSpecs = VariableSpecs.concat(extraSpecs);
        return new VariableManager(this, allSpecs);
      }

      // (String) => Unit
      _genVarUpdate(varName) {
        this._updateVarsByName(varName);
      }

      // Unit -> Unit
      _refreshName() {
        this._name = `${this._breed.singular} ${this.id}`;
      }

      // (Number, Number, IDSet) => Unit
      _setXandY(newX, newY, seenTurtlesSet = {}) {
        var dx, dy, f, oldX, oldY, originPatch, xcor, ycor;
        originPatch = this.getPatchHere();
        oldX = this.xcor;
        oldY = this.ycor;
        xcor = this.world.topology.wrapX(newX);
        ycor = this.world.topology.wrapY(newY);
        if (xcor === TopologyInterrupt || ycor === TopologyInterrupt) {
          return TopologyInterrupt;
        }
        // DO NOT SET `xcor` AND `ycor` DIRECTLY FROM `wrap*`.  `wrap*` can throw a `TopologyException`.
        // If we set only one of the coordinates and then bail with an interrupt (and without generating the View update),
        // it causes all sorts of bonkers stuff to happen. --JAB (10/17/17)
        this.xcor = xcor;
        this.ycor = ycor;
        this._updateVarsByName("xcor", "ycor");
        if (originPatch !== this.getPatchHere()) {
          originPatch.untrackTurtle(this);
          this.getPatchHere().trackTurtle(this);
        }
        this.linkManager._refresh();
        // It's important not to use the wrapped coordinates (`@xcor`, `@ycor`) here.
        // Using those will cause floating point arithmetic discrepancies. --JAB (10/22/15)
        dx = newX - oldX;
        dy = newY - oldY;
        f = (seenTurtles) => {
          return (turtle) => {
            return turtle._setXandY(turtle.xcor + dx, turtle.ycor + dy, seenTurtles);
          };
        };
        this._withEachTiedTurtle(f, seenTurtlesSet);
      }

      // ((IDSet) => (Turtle) => Any, IDSet) => Unit
      _withEachTiedTurtle(f, seenTurtlesSet) {
        var turtles;
        seenTurtlesSet[this.id] = true;
        turtles = this._tiedTurtles().filter(function({id}) {
          return seenTurtlesSet[id] == null;
        });
        turtles.forEach(function({id}) {
          return seenTurtlesSet[id] = true;
        });
        turtles.forEach(f(seenTurtlesSet));
      }

      // () => Patch
      _optimalPatchHereInternal() {
        return this.getPatchHere();
      }

      _optimalPatchNorth() {
        return this.getPatchHere()._optimalPatchNorth();
      }

      _optimalPatchEast() {
        return this.getPatchHere()._optimalPatchEast();
      }

      _optimalPatchSouth() {
        return this.getPatchHere()._optimalPatchSouth();
      }

      _optimalPatchWest() {
        return this.getPatchHere()._optimalPatchWest();
      }

      _optimalPatchNorthEast() {
        return this.getPatchHere()._optimalPatchNorthEast();
      }

      _optimalPatchSouthEast() {
        return this.getPatchHere()._optimalPatchSouthEast();
      }

      _optimalPatchSouthWest() {
        return this.getPatchHere()._optimalPatchSouthWest();
      }

      _optimalPatchNorthWest() {
        return this.getPatchHere()._optimalPatchNorthWest();
      }

    };

    // type GenTurtleFunc      = (Number, Number, Number, Number, Breed, String, Number, Boolean, Number, String, PenManager) => Turtle
    // type IDSet              = Object[ID, Boolean]
    // type RegLineDrawFunc    = (Number, Number, Number, Number, Boolean, Boolean, RGB, Number, String, String) => Unit
    // type RegTurtleStampFunc = (Number, Number, Number, Number, RGB, String, String) => Unit
    Turtle.prototype._breed = void 0; // Breed

    Turtle.prototype._breedShape = void 0; // String

    Turtle.prototype._name = void 0; // String

    Turtle.prototype._updateVarsByName = void 0; // (String*) => Unit

    Turtle.prototype._varManager = void 0; // VariableManager

    Turtle.prototype.linkManager = void 0; // TurtleLinkManager

    return Turtle;

  }).call(this);

}).call(this);

},{"./abstractagentset":"engine/core/abstractagentset","./structure/penmanager":"engine/core/structure/penmanager","./structure/variablemanager":"engine/core/structure/variablemanager","./structure/variablespec":"engine/core/structure/variablespec","./turtle/makepenlines":"engine/core/turtle/makepenlines","./turtle/turtlevariables":"engine/core/turtle/turtlevariables","./turtlelinkmanager":"engine/core/turtlelinkmanager","./turtleset":"engine/core/turtleset","./typechecker":"engine/core/typechecker","brazierjs/array":"brazier/array","brazierjs/number":"brazier/number","engine/core/colormodel":"engine/core/colormodel","util/comparator":"util/comparator","util/exception":"util/exception","util/interrupts":"util/interrupts","util/nlmath":"util/nlmath"}],"engine/core/typechecker":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise

  // There are three basic entry points here:

  // 1. The `nlTypes.checks.*` functions, that check if a value is of a given type.  These are appropriate to use
  //    for primitives like `is-turtle?` and other operations like equality checks or import/export.
  // 2. There are type instances in the `nlTypes.types.*`, which can be used to compose the types that a primitive
  //    accepts as arguments at runtime.
  // 3. The `nlTypes.getTypeOf()` function, which returns a definite type for a value.  This is really only useful
  //    when you need to spit out a runtime type mismatch error message for a value and you want to describe the
  //    value's type accurately.  It'll be slow since it runs checks until it determines the value's type for
  //    certain.

  // -Jeremy B December 2020
  var AbstractAgentSet, AgentSetType, AgentType, BooleanType, CommandLambdaType, Link, LinkSet, LinkSetType, LinkType, ListType, NLType, NobodyType, NumberType, Patch, PatchSet, PatchSetType, PatchType, ReporterLambdaType, StringType, Turtle, TurtleSet, TurtleSetType, TurtleType, WildcardType, checks, exceptions, getTypeOf, isAgent, isAgentSet, isBoolean, isBreed, isBreedSet, isCommandLambda, isDirectedLink, isFunction, isLink, isLinkSet, isList, isNobody, isNumber, isPatch, isPatchSet, isReporterLambda, isString, isTurtle, isTurtleSet, isUndirectedLink, isValidAgent, isValidDirectedLink, isValidLink, isValidTurtle, isValidUndirectedLink, types, unimplemented;

  getTypeOf = function(x) {
    switch (false) {
      case !isNumber(x):
        return types.Number;
      case !isList(x):
        return types.List;
      case !isString(x):
        return types.String;
      case !isBoolean(x):
        return types.Boolean;
      case !isTurtle(x):
        return types.Turtle;
      case !isPatch(x):
        return types.Patch;
      case !isLink(x):
        return types.Link;
      case !isPatchSet(x):
        return types.PatchSet;
      case !isTurtleSet(x):
        return types.TurtleSet;
      case !isLinkSet(x):
        return types.LinkSet;
      case !isAgentSet(x):
        return types.AgentSet;
      case !isNobody(x):
        return types.Nobody;
      case !isCommandLambda(x):
        return types.CommandLambda;
      case !isReporterLambda(x):
        return types.ReporterLambda;
      default:
        return types.WildcardType;
    }
  };

  // We have to do something wonky to deal with the cyclic dependencies here --JAB (3/2/15)
  // As an example, `turtlevariables.coffee` depends on this file and also `turtle.coffee`, which this file
  // depends on.  So when we call `require()` the `turtle.coffee` is read and it calls `require()` on
  // `turtlevariables.coffee` so when it calls `require()` for us again, it gets an empty object back.
  // So we have to "back-fill" our export to get around that. -Jeremy B December 2020
  types = {};

  checks = {};

  NLType = (function() {
    class NLType {};

    NLType.prototype.isOfType = unimplemented;

    NLType.prototype.niceName = unimplemented;

    return NLType;

  }).call(this);

  module.exports = {types, checks, getTypeOf, NLType};

  AbstractAgentSet = require('./abstractagentset');

  Link = require('./link');

  LinkSet = require('./linkset');

  Patch = require('./patch');

  PatchSet = require('./patchset');

  Turtle = require('./turtle');

  TurtleSet = require('./turtleset');

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  isFunction = function(x) {
    return typeof x === "function";
  };

  isCommandLambda = function(x) {
    return isFunction(x) && !x.isReporter;
  };

  isReporterLambda = function(x) {
    return isFunction(x) && x.isReporter;
  };

  // Micro-benchmarks showed this to be mildly faster than `typeof(x) is "boolean"`.
  // This is used in tight loops with `filter` and `sort`, so even a 2.5% increase is
  // worth it.  -Jeremy B December 2020
  isBoolean = function(x) {
    return x === true || x === false;
  };

  isList = function(x) {
    return Array.isArray(x);
  };

  isNumber = function(x) {
    return typeof x === "number";
  };

  isString = function(x) {
    return typeof x === "string";
  };

  isNobody = function(x) {
    return x === Nobody;
  };

  isTurtle = function(x) {
    return x instanceof Turtle;
  };

  isPatch = function(x) {
    return x instanceof Patch;
  };

  isLink = function(x) {
    return x instanceof Link;
  };

  isAgent = function(x) {
    return isTurtle(x) || isPatch(x) || isLink(x);
  };

  isBreed = function(breedName, x) {
    return (isTurtle(x) || isLink(x)) && !x.isDead() && x.isBreed(breedName);
  };

  isDirectedLink = function(x) {
    return isLink(x) && x.isDirected;
  };

  isUndirectedLink = function(x) {
    return isLink(x) && !x.isDirected;
  };

  isAgentSet = function(x) {
    return x instanceof AbstractAgentSet;
  };

  isTurtleSet = function(x) {
    return x instanceof TurtleSet;
  };

  isPatchSet = function(x) {
    return x instanceof PatchSet;
  };

  isLinkSet = function(x) {
    return x instanceof LinkSet;
  };

  isBreedSet = function(breedName, x) {
    return isAgentSet(x) && (x.getSpecialName() != null) && x.getSpecialName() === breedName;
  };

  isValidTurtle = function(x) {
    return isTurtle(x) && !x.isDead();
  };

  isValidLink = function(x) {
    return isLink(x) && !x.isDead();
  };

  isValidAgent = function(x) {
    return isValidTurtle(x) || isPatch(x) || isValidLink(x);
  };

  isValidDirectedLink = function(x) {
    return isValidLink(x) && x.isDirected;
  };

  isValidUndirectedLink = function(x) {
    return isValidLink(x) && !x.isDirected;
  };

  unimplemented = function() {
    throw exceptions.internal("Unimplemented abstract method!");
  };

  CommandLambdaType = (function() {
    class CommandLambdaType extends NLType {
      niceName() {
        return "anonymous command";
      }

    };

    CommandLambdaType.prototype.isOfType = isCommandLambda;

    return CommandLambdaType;

  }).call(this);

  ReporterLambdaType = (function() {
    class ReporterLambdaType extends NLType {
      niceName() {
        return "anonymous reporter";
      }

    };

    ReporterLambdaType.prototype.isOfType = isReporterLambda;

    return ReporterLambdaType;

  }).call(this);

  BooleanType = (function() {
    class BooleanType extends NLType {
      niceName() {
        return "TRUE/FALSE";
      }

    };

    BooleanType.prototype.isOfType = isBoolean;

    return BooleanType;

  }).call(this);

  ListType = (function() {
    class ListType extends NLType {
      niceName() {
        return "list";
      }

    };

    ListType.prototype.isOfType = isList;

    return ListType;

  }).call(this);

  NumberType = (function() {
    class NumberType extends NLType {
      niceName() {
        return "number";
      }

    };

    NumberType.prototype.isOfType = isNumber;

    return NumberType;

  }).call(this);

  StringType = (function() {
    class StringType extends NLType {
      niceName() {
        return "string";
      }

    };

    StringType.prototype.isOfType = isString;

    return StringType;

  }).call(this);

  NobodyType = (function() {
    class NobodyType extends NLType {
      niceName() {
        return "nobody";
      }

    };

    NobodyType.prototype.isOfType = isNobody;

    return NobodyType;

  }).call(this);

  AgentType = (function() {
    class AgentType extends NLType {
      niceName() {
        return "agent";
      }

    };

    AgentType.prototype.isOfType = isAgent;

    return AgentType;

  }).call(this);

  TurtleType = (function() {
    class TurtleType extends AgentType {
      niceName() {
        return "turtle";
      }

    };

    TurtleType.prototype.isOfType = isTurtle;

    return TurtleType;

  }).call(this);

  PatchType = (function() {
    class PatchType extends AgentType {
      niceName() {
        return "patch";
      }

    };

    PatchType.prototype.isOfType = isPatch;

    return PatchType;

  }).call(this);

  LinkType = (function() {
    class LinkType extends AgentType {
      niceName() {
        return "link";
      }

    };

    LinkType.prototype.isOfType = isLink;

    return LinkType;

  }).call(this);

  AgentSetType = (function() {
    class AgentSetType extends NLType {
      niceName() {
        return "agentset";
      }

    };

    AgentSetType.prototype.isOfType = isAgentSet;

    return AgentSetType;

  }).call(this);

  TurtleSetType = (function() {
    class TurtleSetType extends AgentSetType {
      niceName() {
        return "turtle agentset";
      }

    };

    TurtleSetType.prototype.isOfType = isTurtleSet;

    return TurtleSetType;

  }).call(this);

  PatchSetType = (function() {
    class PatchSetType extends AgentSetType {
      niceName() {
        return "patch agentset";
      }

    };

    PatchSetType.prototype.isOfType = isPatchSet;

    return PatchSetType;

  }).call(this);

  LinkSetType = (function() {
    class LinkSetType extends AgentSetType {
      niceName() {
        return "link agentset";
      }

    };

    LinkSetType.prototype.isOfType = isLinkSet;

    return LinkSetType;

  }).call(this);

  WildcardType = class WildcardType extends NLType {
    isOfType() {
      return true;
    }

    niceName() {
      return "anything";
    }

  };

  Object.assign(checks, {isAgent, isAgentSet, isBoolean, isBreed, isBreedSet, isCommandLambda, isDirectedLink, isLink, isLinkSet, isList, isNobody, isNumber, isPatch, isPatchSet, isReporterLambda, isString, isTurtle, isTurtleSet, isUndirectedLink, isValidAgent, isValidDirectedLink, isValidLink, isValidTurtle, isValidUndirectedLink});

  Object.assign(types, {
    Boolean: new BooleanType(),
    List: new ListType(),
    Number: new NumberType(),
    String: new StringType(),
    Nobody: new NobodyType(),
    CommandLambda: new CommandLambdaType(),
    ReporterLambda: new ReporterLambdaType(),
    Agent: new AgentType(),
    Turtle: new TurtleType(),
    Patch: new PatchType(),
    Link: new LinkType(),
    AgentSet: new AgentSetType(),
    TurtleSet: new TurtleSetType(),
    PatchSet: new PatchSetType(),
    LinkSet: new LinkSetType(),
    Wildcard: new WildcardType()
  });

}).call(this);

},{"./abstractagentset":"engine/core/abstractagentset","./link":"engine/core/link","./linkset":"engine/core/linkset","./patch":"engine/core/patch","./patchset":"engine/core/patchset","./turtle":"engine/core/turtle","./turtleset":"engine/core/turtleset","util/exception":"util/exception"}],"engine/core/world/export":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AgentReference, BreedNamePair, BreedReference, ExportAllPlotsData, ExportPlotData, ExportWorldData, ExportedAgent, ExportedAgentSet, ExportedColorNum, ExportedCommandLambda, ExportedExtension, ExportedGlobals, ExportedLink, ExportedLinkSet, ExportedPatch, ExportedPatchSet, ExportedPen, ExportedPlot, ExportedPlotManager, ExportedPoint, ExportedRGB, ExportedRGBA, ExportedReporterLambda, ExportedTurtle, ExportedTurtleSet, ExtensionsHandler, LinkReference, Metadata, NobodyReference, None, PatchReference, TurtleReference, checks, createAgentExporters, createExportWildcardValue, difference, displayModeToString, exceptions, exportAgent, exportAgentReference, exportBreedReference, exportColor, exportGlobals, exportLinkReference, exportMetadata, exportMiniGlobals, exportPatchReference, exportPlot, exportPlotManager, exportRawPlot, exportTurtleReference, exportWildcardVar, find, fold, id, isEmpty, linkBuiltins, maybe, patchBuiltins, penModeToBool, perspectiveToString, tee, toObject, turtleBuiltins, version;

  ({version} = require('meta'));

  ({AgentReference, BreedNamePair, BreedReference, ExportAllPlotsData, ExportedAgent, ExportedAgentSet, ExportedColorNum, ExportedCommandLambda, ExportedExtension, ExportedGlobals, ExportedLink, ExportedLinkSet, ExportedPatch, ExportedPatchSet, ExportedPen, ExportedPlot, ExportedPlotManager, ExportedPoint, ExportedReporterLambda, ExportedRGB, ExportedRGBA, ExportedTurtle, ExportedTurtleSet, ExportPlotData, ExportWorldData, LinkReference, Metadata, NobodyReference, PatchReference, TurtleReference} = require('serialize/exportstructures'));

  ({
    Perspective: {perspectiveToString}
  } = require('../observer'));

  ({linkBuiltins, patchBuiltins, turtleBuiltins} = require('../structure/builtins'));

  ({
    DisplayMode: {displayModeToString},
    PenMode: {penModeToBool}
  } = require('engine/plot/pen'));

  ExtensionsHandler = require('./extensionshandler');

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({difference, find, isEmpty, toObject} = require('brazierjs/array'));

  ({id, tee} = require('brazierjs/function'));

  ({fold, maybe, None} = require('brazierjs/maybe'));

  ({checks} = require('../typechecker'));

  // Yo!  This file expects that basically all of its functions will be called in the context
  // of the `World` object.  That is, they should be called within methods on `World`, using
  // `<function>.call(this)`. --JAB (12/10/17)

  // (String|(Number, Number, Number)|(Number, Number, Number, Number)) => ExportedColor
  exportColor = function(color) {
    var a, b, g, r;
    if (checks.isNumber(color)) {
      return new ExportedColorNum(color);
    } else if (checks.isList(color)) {
      [r, g, b, a] = color;
      if (a != null) {
        return new ExportedRGBA(r, g, b, a);
      } else {
        return new ExportedRGB(r, g, b);
      }
    } else {
      throw exceptions.internal(`Unrecognized color format: ${JSON.stringify(color)}`);
    }
  };

  // (String) => BreedReference
  exportBreedReference = function(breedName) {
    return new BreedReference(breedName.toLowerCase());
  };

  // (Patch) => PatchReference
  exportPatchReference = function(patch) {
    return new PatchReference(patch.pxcor, patch.pycor);
  };

  // (Turtle) => TurtleReference
  exportTurtleReference = function(turtle) {
    var breed;
    breed = new BreedNamePair(turtle.getBreedNameSingular(), turtle.getBreedName().toLowerCase());
    return new TurtleReference(breed, turtle.id);
  };

  // (Link) => LinkReference
  exportLinkReference = function(link) {
    var breed;
    breed = new BreedNamePair(link.getBreedNameSingular(), link.getBreedName().toLowerCase());
    return new LinkReference(breed, link.end1.id, link.end2.id);
  };

  // (Agent) => AgentReference
  exportAgentReference = function(agent) {
    if (checks.isNobody(agent) || agent.isDead()) {
      return NobodyReference;
    } else if (checks.isLink(agent)) {
      return exportLinkReference(agent);
    } else if (checks.isPatch(agent)) {
      return exportPatchReference(agent);
    } else if (checks.isTurtle(agent)) {
      return exportTurtleReference(agent);
    } else {
      throw exceptions.internal(`Cannot make agent reference out of: ${JSON.stringify(agent)}`);
    }
  };

  createExportWildcardValue = function(extensionExporter) {
    var exportWildcardValue;
    exportWildcardValue = function(value) {
      if (checks.isAgent(value) || checks.isNobody(value)) {
        return exportAgentReference(value);
      } else if ((typeof value.getSpecialName === "function" ? value.getSpecialName() : void 0) != null) {
        return new BreedReference(value.getSpecialName().toLowerCase());
      } else if (checks.isLinkSet(value)) {
        return new ExportedLinkSet(value.toArray().map(exportLinkReference));
      } else if (checks.isPatchSet(value)) {
        return new ExportedPatchSet(value.toArray().map(exportPatchReference));
      } else if (checks.isTurtleSet(value)) {
        return new ExportedTurtleSet(value.toArray().map(exportTurtleReference));
      } else if (checks.isCommandLambda(value)) {
        return new ExportedCommandLambda(value.nlogoBody);
      } else if (checks.isReporterLambda(value)) {
        return new ExportedReporterLambda(value.nlogoBody);
      } else if (checks.isList(value)) {
        return value.map(exportWildcardValue);
      } else if (extensionExporter.canHandle(value)) {
        return extensionExporter.exportObject(value, exportWildcardValue);
      } else {
        return value;
      }
    };
    return exportWildcardValue;
  };

  // (Agent, ExtensionsExporter) => (String) => Any
  exportWildcardVar = function(agent, extensionExporter) {
    return function(varName) {
      var exportWildcardValue;
      exportWildcardValue = createExportWildcardValue(extensionExporter);
      return exportWildcardValue(agent.getVariable(varName));
    };
  };

  // () => Object[Any]
  exportMetadata = function() {
    // TODO: Get filename from metadata from compiler, once NetLogo/NetLogo#1547 has been merged --JAB (2/8/18)
    return new Metadata(version, '[IMPLEMENT .NLOGO]', new Date());
  };

  // [T, U <: ExportedAgent[T]] @ (Class[U], Array[(String, (Any) => Any)], String, ExtensionExports) => (T) => U
  exportAgent = function(clazz, builtInsMappings, labelVarName, extensions) {
    return function(agent) {
      var builtInsNames, builtInsValues, extras, extrasNames, wildcard;
      wildcard = exportWildcardVar(agent, extensions);
      builtInsValues = builtInsMappings.map(function([name, f]) {
        if (name === labelVarName) {
          return wildcard(name);
        } else {
          return f(agent.getVariable(name));
        }
      });
      builtInsNames = builtInsMappings.map(function([name]) {
        return name;
      });
      extrasNames = difference(agent.varNames())(builtInsNames);
      extras = toObject(extrasNames.map(tee(id)(wildcard)));
      return new clazz(...builtInsValues, extras);
    };
  };

  // (Plot) => ExportedPlot
  exportPlot = function(plot) {
    var currentPenNameOrNull, exportPen, isAutoPlotX, isAutoPlotY, isLegendOpen, name, pens, xMax, xMin, yMax, yMin;
    exportPen = function(pen) {
      var color, exportPoint, interval, isPenDown, mode, name, points, x;
      exportPoint = function({x, y, penMode, color}) {
        return new ExportedPoint(x, y, penModeToBool(penMode), color);
      };
      color = pen.getColor();
      interval = pen.getInterval();
      isPenDown = penModeToBool(pen.getPenMode());
      mode = displayModeToString(pen.getDisplayMode());
      name = pen.name;
      points = pen.getPoints().map(exportPoint);
      x = pen.getPenX();
      return new ExportedPen(color, interval, isPenDown, mode, name, points, x);
    };
    currentPenNameOrNull = fold(function() {
      return null;
    })(function(cp) {
      return cp.name;
    })(plot.getCurrentPenMaybe());
    isAutoPlotX = plot.isAutoPlotX;
    isAutoPlotY = plot.isAutoPlotY;
    isLegendOpen = plot.isLegendEnabled;
    name = plot.name;
    pens = plot.getPens().map(exportPen);
    xMax = plot.xMax;
    xMin = plot.xMin;
    yMax = plot.yMax;
    yMin = plot.yMin;
    return new ExportedPlot(currentPenNameOrNull, isAutoPlotX, isAutoPlotY, isLegendOpen, name, pens, xMax, xMin, yMax, yMin);
  };

  // (String) => ExportedPlot
  exportRawPlot = function(plotName) {
    var desiredPlotMaybe, exporter, plot;
    desiredPlotMaybe = find(function(x) {
      return x.name === plotName;
    })(this._plotManager.getPlots());
    exporter = function(plot) {
      return exportPlot(plot);
    };
    return plot = fold(function() {
      throw exceptions.runtime(`no such plot: \"${plotName}\"`);
    })(exporter)(desiredPlotMaybe);
  };

  // (ExtensionExports) => ExportedPlotManager
  exportPlotManager = function(extensions) {
    var currentPlotNameOrNull, exporter, plots;
    currentPlotNameOrNull = fold(function() {
      return null;
    })(function(cp) {
      return cp.name;
    })(this._plotManager.getCurrentPlotMaybe());
    exporter = function(plot) {
      return exportPlot(plot, extensions);
    };
    plots = this._plotManager.getPlots().map(exporter);
    return new ExportedPlotManager(currentPlotNameOrNull, plots);
  };

  // (ExtensionExports) => Object[Any]
  exportMiniGlobals = function(extensions) {
    var namesNotDeleted;
    namesNotDeleted = this.observer.varNames().filter((name) => {
      return this.observer.getVariable(name) != null;
    }).sort();
    return toObject(namesNotDeleted.map(tee(id)(exportWildcardVar(this.observer, extensions))));
  };

  // (ExtensionExports) => ExportedGlobals
  exportGlobals = function(extensions) {
    var codeGlobals, linkDirectedness, maxPxcor, maxPycor, minPxcor, minPycor, nextWhoNumber, noUnbreededLinks, perspective, subject, ticks;
    noUnbreededLinks = isEmpty(this.links().toArray().filter(function(l) {
      return l.getBreedName().toUpperCase() === "LINKS";
    }));
    linkDirectedness = noUnbreededLinks ? 'neither' : this.breedManager.links().isDirected() ? 'directed' : 'undirected';
    maxPxcor = this.topology.maxPxcor;
    maxPycor = this.topology.maxPycor;
    minPxcor = this.topology.minPxcor;
    minPycor = this.topology.minPycor;
    nextWhoNumber = this.turtleManager.peekNextID();
    perspective = perspectiveToString(this.observer.getPerspective());
    subject = exportAgentReference(this.observer.subject());
    ticks = this.ticker.ticksAreStarted() ? this.ticker.tickCount() : -1;
    codeGlobals = exportMiniGlobals.call(this, extensions);
    return new ExportedGlobals(linkDirectedness, maxPxcor, maxPycor, minPxcor, minPycor, nextWhoNumber, perspective, subject, ticks, codeGlobals);
  };

  // () => ExportAllPlotsData
  module.exports.exportAllPlots = function() {
    var extensionExporter, metadata, miniGlobals, plots;
    metadata = exportMetadata.call(this);
    extensionExporter = ExtensionsHandler.makeExporter(this.extensionPorters);
    miniGlobals = exportMiniGlobals.call(this, extensionExporter);
    plots = this._plotManager.getPlots().map(exportPlot);
    return new ExportAllPlotsData(metadata, miniGlobals, plots);
  };

  // (String) => ExportedPlot
  module.exports.exportRawPlot = exportRawPlot;

  // (String) => ExportPlotData
  module.exports.exportPlot = function(plotName) {
    var extensionExporter, metadata, miniGlobals, plot;
    metadata = exportMetadata.call(this);
    extensionExporter = ExtensionsHandler.makeExporter(this.extensionPorters);
    miniGlobals = exportMiniGlobals.call(this, extensionExporter);
    plot = exportRawPlot.call(this, plotName);
    return new ExportPlotData(metadata, miniGlobals, plot);
  };

  // (ExtensionExports) => AgentExports
  createAgentExporters = function(extensionExporter) {
    var linkExport, linkMapper, makeMappings, patchExport, patchMapper, turtleExport, turtleMapper;
    makeMappings = function(builtins) {
      return function(mapper) {
        return builtins.map(tee(id)(mapper));
      };
    };
    patchMapper = function(varName) {
      switch (varName) {
        case "pcolor":
        case "plabel-color":
          return function(color) {
            return exportColor(color);
          };
        default:
          return id;
      }
    };
    turtleMapper = function(varName) {
      switch (varName) {
        case "breed":
          return function(breed) {
            return exportBreedReference(breed.toString());
          };
        case "color":
        case "label-color":
          return function(color) {
            return exportColor(color);
          };
        default:
          return id;
      }
    };
    linkMapper = function(varName) {
      switch (varName) {
        case "breed":
          return function(breed) {
            return exportBreedReference(breed.toString());
          };
        case "color":
        case "label-color":
          return function(color) {
            return exportColor(color);
          };
        case "end1":
        case "end2":
          return function(end) {
            return exportTurtleReference(end);
          };
        default:
          return id;
      }
    };
    patchExport = exportAgent(ExportedPatch, makeMappings(patchBuiltins)(patchMapper), "plabel", extensionExporter);
    turtleExport = exportAgent(ExportedTurtle, makeMappings(turtleBuiltins)(turtleMapper), "label", extensionExporter);
    linkExport = exportAgent(ExportedLink, makeMappings(linkBuiltins)(linkMapper), "llabel", extensionExporter);
    return {patchExport, turtleExport, linkExport};
  };

  // (World) => (Any) => JSON
  module.exports.createExportValue = function(world) {
    var agentExporters, exportAgentOrWildcard, exportWildcardValue, extensionExporter;
    extensionExporter = ExtensionsHandler.makeExporter(world.extensionPorters);
    agentExporters = createAgentExporters(extensionExporter);
    exportWildcardValue = createExportWildcardValue(extensionExporter);
    exportAgentOrWildcard = function(maybeAgent) {
      if (checks.isLink(maybeAgent)) {
        return agentExporters.linkExport(maybeAgent);
      } else if (checks.isPatch(maybeAgent)) {
        return agentExporters.patchExport(maybeAgent);
      } else if (checks.isTurtle(maybeAgent)) {
        return agentExporters.turtleExport(maybeAgent);
      } else {
        return exportWildcardValue(maybeAgent);
      }
    };
    return function(value) {
      if (checks.isLinkSet(value)) {
        return value.toArray().map(agentExporters.linkExport);
      } else if (checks.isPatchSet(value)) {
        return value.toArray().map(agentExporters.patchExport);
      } else if (checks.isTurtleSet(value)) {
        return value.toArray().map(agentExporters.turtleExport);
      } else if (checks.isList(value)) {
        return value.map(exportAgentOrWildcard);
      } else {
        return exportAgentOrWildcard(value);
      }
    };
  };

  // () => ExportWorldData
  module.exports.exportWorld = function() {
    var agentExporters, drawingM, extensionExporter, extensions, globals, links, metadata, output, patches, plotManager, randomState, turtles;
    extensionExporter = ExtensionsHandler.makeExporter(this.extensionPorters);
    agentExporters = createAgentExporters(extensionExporter);
    metadata = exportMetadata.call(this);
    randomState = this.rng.exportState();
    globals = exportGlobals.call(this, extensionExporter);
    patches = this.patches().toArray().map(agentExporters.patchExport);
    turtles = this.turtleManager.turtles().toArray().map(agentExporters.turtleExport);
    links = this.linkManager.links().toArray().map(agentExporters.linkExport);
    drawingM = !this._updater.drawingWasJustCleared() ? maybe([this.patchSize, this._getViewBase64()]) : None;
    output = this._getOutput();
    plotManager = exportPlotManager.call(this, extensionExporter);
    extensions = extensionExporter.export();
    return new ExportWorldData(metadata, randomState, globals, patches, turtles, links, drawingM, output, plotManager, extensions);
  };

}).call(this);

},{"../observer":"engine/core/observer","../structure/builtins":"engine/core/structure/builtins","../typechecker":"engine/core/typechecker","./extensionshandler":"engine/core/world/extensionshandler","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/maybe":"brazier/maybe","engine/plot/pen":"engine/plot/pen","meta":"meta","serialize/exportstructures":"serialize/exportstructures","util/exception":"util/exception"}],"engine/core/world/extensionshandler":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise

  // type ExtensionPorter[T] = {
  //   canHandle: (Any) => Boolean,

  //   dump: (T, (Any) => String) => String,

  //   exportObject: (T, (Any) => Any) => ExportedExtensionObject,
  //   export:       (Array[ExportedExtensionObject]) => ExportedExtension

  //   format:       (ExportedExtension, (Any) => String) => String
  //   formatObject: (ExportedExtensionObject, (Any) => String) => String

  //   readObject: (String, String, (String) => Any) => ExportedExtensionObject
  //   read:       (String, (String) => Any) => ExportedExtension

  //   import:       (ExportedExtension, (Any) => Any) => Unit
  //   importObject: (ExportedExtension, ExtensionPlaceholder, (Any) => Any)) => T

  // }
  var canHandleCheck, createPlaceholder, eitherCheck, exceptions, formatPlaceholder, isPlaceholder, makeCanHandle, makeDumper, makeExporter, makeFormatter, makeImporter, makeReader, makeTraverse, placeholderCheck, placeholderRegEx;

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  // (ExtensionPorter, Any) => Boolean
  canHandleCheck = function(p, x) {
    return p.canHandle(x);
  };

  // (ExtensionPorter, Any) => Boolean
  placeholderCheck = function(p, x) {
    return isPlaceholder(x) && p.extensionName === x.extensionName;
  };

  // (ExtensionPorter, Any) => Boolean
  eitherCheck = function(p, x) {
    return canHandleCheck(p, x) || placeholderCheck(p, x);
  };

  // (Array[ExtensionPorter], (ExtensionPorter, Any) => Boolean) => (Any) => Boolean
  makeCanHandle = function(extensionPorters, check) {
    return function(x) {
      var applicablePorters;
      applicablePorters = extensionPorters.filter(function(p) {
        return check(p, x);
      });
      if (applicablePorters.length > 1) {
        throw exceptions.internal(`Multiple extensions claim to know how to handle this object type: ${JSON.stringify(x)}`);
      }
      return applicablePorters.length === 1;
    };
  };

  // (Array[ExtensionPorter], (ExtensionPorter, Any, (Any) => Any) => Any) => ExtensionsHandler
  makeTraverse = function(extensionPorters, objectHandler, check) {
    var extensionReferences, inProgressMarker, traverse;
    extensionReferences = new Map();
    inProgressMarker = Object.freeze({
      type: "operation-in-progress"
    });
    // (Any, (Any) => Any) => Any
    traverse = function(x, helper) {
      var extensionObject, porter;
      if (!extensionReferences.has(x)) {
        porter = extensionPorters.filter(function(p) {
          return check(p, x);
        })[0];
        extensionReferences.set(x, inProgressMarker);
        extensionObject = objectHandler(porter, x, helper);
        extensionReferences.set(x, extensionObject);
        return extensionObject;
      } else {
        extensionObject = extensionReferences.get(x);
        if (extensionObject === inProgressMarker) {
          throw exceptions.internal("Circular references within extension objects are not supported.");
        }
        return extensionObject;
      }
    };
    return {traverse, extensionReferences};
  };

  // (String, String, Int) => ExtensionPlaceholder
  createPlaceholder = function(extensionName, subType, index) {
    return {
      type: "extension-object-placeholder",
      extensionName,
      subType,
      index
    };
  };

  // (Any) => Boolean
  isPlaceholder = function(x) {
    return (x.type != null) && x.type === "extension-object-placeholder";
  };

  // (ExtensionPlaceholder) => String
  formatPlaceholder = function(x) {
    return `{{${x.extensionName}:${x.subType} ${x.index}}}`;
  };

  // (Array[ExtensionPorter]) => ExtensionsDumper
  makeDumper = function(extensionPorters) {
    var dumpPorterObject, traverser;
    dumpPorterObject = function(porter, x, helper) {
      return porter.dump(x, helper);
    };
    traverser = makeTraverse(extensionPorters, dumpPorterObject, canHandleCheck);
    return {
      canHandle: makeCanHandle(extensionPorters, canHandleCheck),
      dump: traverser.traverse,
      reset: function() {
        return traverser.extensionReferences.clear();
      }
    };
  };

  // (Array[ExtensionPorter]) => ExtensionsExporter
  makeExporter = function(extensionPorters) {
    var exportExt, exportObject, extensionObjects;
    // Map[ExtensionPorter, Array[ExportedExtensionObject]]
    extensionObjects = new Map();
    exportObject = function(porter, x, helper) {
      var porterObject, porterObjects, pos;
      porterObjects = !extensionObjects.has(porter) ? (pos = [], extensionObjects.set(porter, pos), pos) : extensionObjects.get(porter);
      porterObject = porter.exportObject(x, helper);
      porterObjects.push(porterObject);
      return createPlaceholder(porter.extensionName, porterObject.subType, porterObjects.length - 1);
    };
    // () => Map[ExtensionPorter, ExportedExtension]
    exportExt = function() {
      var extensionStates;
      extensionStates = new Map();
      extensionPorters.forEach(function(porter) {
        var porterObjects;
        porterObjects = extensionObjects.get(porter);
        return extensionStates.set(porter, porter.export(porterObjects != null ? porterObjects : []));
      });
      return extensionStates;
    };
    return {
      canHandle: makeCanHandle(extensionPorters, canHandleCheck),
      exportObject: makeTraverse(extensionPorters, exportObject, canHandleCheck).traverse,
      export: exportExt
    };
  };

  // (Array[ExtensionPorter]) => ExtensionsFormatter
  makeFormatter = function(extensionPorters) {
    var format, formatPlaceholderObject;
    formatPlaceholderObject = function(_1, x, _2) {
      return formatPlaceholder(x);
    };
    // (Map[ExtensionPorter, ExportedExtension], (Any) => String) => String
    format = function(extensionExports, helper) {
      var porterStrings, porters;
      porters = Array.from(extensionExports.keys());
      // `sort()` to match the order desktop returns the extensions in -Jeremy B September 2020
      porters.sort(function(p1, p2) {
        return p1.extensionName.localeCompare(p2.extensionName);
      });
      porterStrings = porters.map(function(porter) {
        var extensionCSV;
        extensionCSV = porter.format(extensionExports.get(porter), helper);
        if (extensionCSV.trim() === '') {
          return '';
        } else {
          return `\"${porter.extensionName}\"\n${extensionCSV}`;
        }
      });
      return porterStrings.filter(function(str) {
        return str !== '';
      }).join("\n\n");
    };
    return {
      canHandle: makeCanHandle(extensionPorters, eitherCheck),
      formatPlaceholder: makeTraverse(extensionPorters, formatPlaceholderObject, placeholderCheck).traverse,
      format
    };
  };

  // (Array[ExtensionPorter], Map[ExtensionPorter, ExportedExtension]) => ExtensionsImporter
  makeImporter = function(extensionPorters, extensionExports) {
    var importExt, importObject, importedObjects;
    importedObjects = new Map();
    importObject = function(porter, placeholder, helper) {
      var exportedExt, importedObject;
      if (importedObjects.has(placeholder)) {
        return importedObjects.get(placeholder);
      } else {
        exportedExt = extensionExports.get(porter);
        importedObject = porter.importObject(exportedExt, placeholder, helper);
        importedObjects.set(placeholder, importedObject);
        return importedObject;
      }
    };
    importExt = function() {
      return extensionPorters.forEach(function(porter) {
        var objects, state;
        state = extensionExports.get(porter);
        objects = Array.from(importedObjects.values()).filter(function(eo) {
          return eo.extensionName === porter.extensionName;
        });
        return porter.import(state, objects);
      });
    };
    return {
      canHandle: makeCanHandle(extensionPorters, placeholderCheck),
      importObject: makeTraverse(extensionPorters, importObject, placeholderCheck).traverse,
      importState: importExt
    };
  };

  placeholderRegEx = /{{(.+)\:(.*) (\d+)}}/;

  // (Array[ExtensionPorter]) => ExtensionsReader
  makeReader = function(extensionPorters) {
    var extensionNames, matchesPlaceholder, readExtensions, readPlaceholder;
    matchesPlaceholder = function(x) {
      return x.match(placeholderRegEx);
    };
    readPlaceholder = function(match) {
      return createPlaceholder(match[1], match[2], parseFloat(match[3]));
    };
    extensionNames = extensionPorters.map(function(porter) {
      return porter.extensionName.toUpperCase();
    });
    readExtensions = function(porterSections, parseAny) {
      var extensionExps;
      extensionExps = new Map();
      Object.keys(porterSections).forEach(function(extensionName) {
        var extensionExp, porter, possiblePorters, section;
        possiblePorters = extensionPorters.filter(function(porter) {
          return porter.extensionName === extensionName;
        });
        if (possiblePorters.length === 0) {
          throw exceptions.internal("No extension porter found for this thing?");
        }
        if (possiblePorters.length > 1) {
          throw exceptions.internal("Multiple extension porters found for this thing?");
        }
        porter = possiblePorters[0];
        section = porterSections[extensionName];
        extensionExp = porter.read(section, parseAny);
        return extensionExps.set(porter, extensionExp);
      });
      return extensionExps;
    };
    return {matchesPlaceholder, readPlaceholder, extensionNames, readExtensions};
  };

  module.exports = {makeDumper, makeExporter, makeFormatter, makeImporter, makeReader};

}).call(this);

},{"util/exception":"util/exception"}],"engine/core/world/idmanager":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var IDManager;

  module.exports = IDManager = (function() {
    class IDManager {
      // () => IDManager
      constructor() {
        this.reset();
      }

      // () => Number
      getCount() {
        return this._count;
      }

      // () => Unit
      reset() {
        this._count = 0;
      }

      // Number
      next() {
        return this._count++;
      }

      // (Number) => Unit
      setCount(_count) {
        this._count = _count;
      }

      // (() => Any) => Unit
      suspendDuring(f) {
        var oldCount;
        oldCount = this._count;
        f();
        this._count = oldCount;
      }

    };

    // Number
    IDManager.prototype._count = void 0;

    return IDManager;

  }).call(this);

}).call(this);

},{}],"engine/core/world/import":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var BreedReference, ExportedColorNum, ExportedCommandLambda, ExportedLinkSet, ExportedPatchSet, ExportedRGB, ExportedRGBA, ExportedReporterLambda, ExportedTurtleSet, ExtensionsHandler, LinkReference, LinkSet, NobodyReference, PatchReference, PatchSet, TurtleReference, TurtleSet, checks, exceptions, fold, perspectiveFromString, reifyExported,
    indexOf = [].indexOf;

  ({checks} = require('../typechecker'));

  LinkSet = require('../linkset');

  PatchSet = require('../patchset');

  TurtleSet = require('../turtleset');

  ExtensionsHandler = require('./extensionshandler');

  ({
    Perspective: {perspectiveFromString}
  } = require('../observer'));

  ({BreedReference, ExportedColorNum, ExportedCommandLambda, ExportedLinkSet, ExportedPatchSet, ExportedRGB, ExportedRGBA, ExportedReporterLambda, ExportedTurtleSet, LinkReference, NobodyReference, PatchReference, TurtleReference} = require('serialize/exportstructures'));

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({fold} = require('brazier/maybe'));

  // ( (Number) => Agent
  // , (Number, Number) => Agent
  // , (Number, Number, String) => Agent
  // , () => PatchSet
  // , () => Breed
  // , World
  // , ExtensionsImporter
  // ) => (Any) => Any
  reifyExported = function(getTurtle, getPatch, getLink, getAllPatches, getBreed, world, extensionImporter) {
    var helper;
    return helper = function(x) {
      var fn, links, patches, turtles;
      if (checks.isList(x)) {
        return x.map(helper);
      } else if (checks.isBoolean(x) || checks.isNumber(x) || checks.isString(x)) {
        return x;
      } else if (x === NobodyReference) {
        return Nobody;
      } else if (x instanceof BreedReference) {
        switch (x.breedName) {
          case "PATCHES":
            return getAllPatches();
          default:
            return getBreed(x.breedName);
        }
      } else if (x instanceof LinkReference) {
        return getLink(x.id1, x.id2, x.breed.plural);
      } else if (x instanceof PatchReference) {
        return getPatch(x.pxcor, x.pycor);
      } else if (x instanceof TurtleReference) {
        return getTurtle(x.id);
      } else if (x instanceof ExportedLinkSet) {
        links = x.references.map(function({
            id1,
            id2,
            breed: {plural}
          }) {
          return getLink(id1, id2, plural);
        });
        return new LinkSet(links, world);
      } else if (x instanceof ExportedPatchSet) {
        patches = x.references.map(function({pxcor, pycor}) {
          return getPatch(pxcor, pycor);
        });
        return new PatchSet(patches, world);
      } else if (x instanceof ExportedTurtleSet) {
        turtles = x.references.map(function({id}) {
          return getTurtle(id);
        });
        return new TurtleSet(turtles, world);
      } else if (x instanceof ExportedCommandLambda) {
        fn = (function() {
          throw exceptions.internal("Importing and then running lambdas is not supported!");
        });
        fn.isReporter = false;
        fn.nlogoBody = x.source;
        return fn;
      } else if (x instanceof ExportedReporterLambda) {
        fn = (function() {
          throw exceptions.internal("Importing and then running lambdas is not supported!");
        });
        fn.isReporter = true;
        fn.nlogoBody = x.source;
        return fn;
      } else if (extensionImporter.canHandle(x)) {
        return extensionImporter.importObject(x, helper);
      } else {
        throw exceptions.internal(`Unknown item for reification: ${JSON.stringify(x)}`);
      }
    };
  };

  // (WorldState) => Unit
  module.exports.importWorld = function({
      globals: {
        linkDirectedness: directedLinks,
        maxPxcor,
        maxPycor,
        minPxcor,
        minPycor,
        nextWhoNumber,
        perspective,
        subject,
        ticks,
        codeGlobals
      },
      links,
      patches,
      plotManager,
      randomState,
      turtles,
      patchSize,
      drawingDataMaybe,
      output,
      extensions
    }) {
    var extensionImporter, extractColor, linkFinishFs, patchFinishFs, reify, trueSubject, turtleFinishFs, value, varName;
    extensionImporter = ExtensionsHandler.makeImporter(this.extensionPorters, extensions);
    reify = reifyExported(this.turtleManager.getTurtle.bind(this.turtleManager), this.getPatchAt.bind(this), this.linkManager.getLink.bind(this.linkManager), this.patches.bind(this), this.breedManager.get.bind(this.breedManager), this, extensionImporter);
    this.clearAll();
    if (directedLinks.toUpperCase() === "DIRECTED") {
      this._setUnbreededLinksDirected();
    } else {
      this._setUnbreededLinksUndirected();
    }
    this._resizeHelper(minPxcor, maxPxcor, minPycor, maxPycor, this.topology._wrapInX, this.topology._wrapInY);
    extractColor = function(color) {
      if (color instanceof ExportedColorNum) {
        return color.value;
      } else if (color instanceof ExportedRGB) {
        return [color.r, color.g, color.b];
      } else if (color instanceof ExportedRGBA) {
        return [color.r, color.g, color.b, color.a];
      } else {
        throw exceptions.internal(`Unknown color: ${JSON.stringify(color)}`);
      }
    };
    patchFinishFs = patches.map(({pxcor, pycor, pcolor, plabel, plabelColor, patchesOwns}) => {
      var patch;
      patch = this.getPatchAt(pxcor, pycor);
      patch.setVariable('pcolor', extractColor(pcolor));
      patch.setVariable('plabel-color', extractColor(plabelColor));
      return function() {
        var results, value, varName;
        patch.setVariable('plabel', reify(plabel));
        results = [];
        for (varName in patchesOwns) {
          value = patchesOwns[varName];
          if (indexOf.call(patch.varNames(), varName) >= 0) {
            results.push(patch.setVariable(varName, reify(value)));
          }
        }
        return results;
      };
    });
    turtleFinishFs = turtles.map(({
        who,
        color,
        heading,
        xcor,
        ycor,
        shape,
        label,
        labelColor,
        breed: {breedName},
        isHidden,
        size,
        penSize,
        penMode,
        breedsOwns
      }) => {
      var args, newTurtle, realBreed, ref;
      realBreed = (ref = this.breedManager.get(breedName)) != null ? ref : this.breedManager.turtles();
      args = [who, extractColor(color), heading, xcor, ycor, realBreed, "", extractColor(labelColor), isHidden, size, shape];
      newTurtle = this.turtleManager._createTurtle(...args);
      newTurtle.penManager.setPenMode(penMode);
      newTurtle.penManager.setSize(penSize);
      return function() {
        var results, value, varName;
        newTurtle.setVariable('label', reify(label));
        results = [];
        for (varName in breedsOwns) {
          value = breedsOwns[varName];
          if (indexOf.call(newTurtle.varNames(), varName) >= 0) {
            results.push(newTurtle.setVariable(varName, reify(value)));
          }
        }
        return results;
      };
    });
    this.turtleManager._idManager.setCount(nextWhoNumber);
    linkFinishFs = links.map(({
        breed: {breedName},
        end1,
        end2,
        color,
        isHidden,
        label,
        labelColor,
        shape,
        thickness,
        tieMode,
        breedsOwns
      }) => {
      var newLink, realBreed, realEnd1, realEnd2, ref;
      realEnd1 = this.turtleManager.getTurtleOfBreed(end1.breed.plural, end1.id);
      realEnd2 = this.turtleManager.getTurtleOfBreed(end2.breed.plural, end2.id);
      realBreed = (ref = this.breedManager.get(breedName)) != null ? ref : this.breedManager.links();
      newLink = this.linkManager._createLink(realBreed.isDirected(), realEnd1, realEnd2, realBreed.name);
      newLink.setVariable('color', extractColor(color));
      newLink.setVariable('hidden?', isHidden);
      newLink.setVariable('label-color', extractColor(labelColor));
      newLink.setVariable('shape', shape);
      newLink.setVariable('thickness', thickness);
      newLink.setVariable('tie-mode', tieMode);
      return function() {
        var results, value, varName;
        newLink.setVariable('label', reify(label));
        results = [];
        for (varName in breedsOwns) {
          value = breedsOwns[varName];
          if (indexOf.call(newLink.varNames(), varName) >= 0) {
            results.push(newLink.setVariable(varName, reify(value)));
          }
        }
        return results;
      };
    });
    // Reification time!  This might seem a bit unintuitive, but, e.g. labels can be agents, link ends
    // are agents, and `*-owns` vars can be agents.  So we need to import all the agents before we can
    // finish importing them.  I'm calling this "second pass" stage the "reification stage", which is
    // when we revisit the things that we couldn't safely import earlier. --JAB (12/14/17)
    [].concat(patchFinishFs, turtleFinishFs, linkFinishFs).forEach(function(f) {
      return f();
    });
    for (varName in codeGlobals) {
      value = codeGlobals[varName];
      if (indexOf.call(this.observer.varNames(), varName) >= 0) {
        this.observer.setGlobal(varName, reify(value));
      }
    }
    trueSubject = reify(subject);
    if (trueSubject !== Nobody) {
      this.observer.setPerspective(perspectiveFromString(perspective), trueSubject);
    }
    // Reification done. --JAB (12/14/17)
    this._plotManager.importState(plotManager);
    this.ticker.importTicks(ticks);
    this.rng.importState(randomState);
    extensionImporter.importState();
    fold(function() {})(([patchSize, drawing]) => {
      this.setPatchSize(patchSize);
      return this.importDrawing(drawing);
    })(drawingDataMaybe);
    if (output != null) {
      this._setOutput(output);
    }
  };

}).call(this);

},{"../linkset":"engine/core/linkset","../observer":"engine/core/observer","../patchset":"engine/core/patchset","../turtleset":"engine/core/turtleset","../typechecker":"engine/core/typechecker","./extensionshandler":"engine/core/world/extensionshandler","brazier/maybe":"brazier/maybe","serialize/exportstructures":"serialize/exportstructures","util/exception":"util/exception"}],"engine/core/world/linkmanager":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise

  // As far as dependencies and private access go, I'm treating this as if it's a part of `World` --JAB (8/5/14)
  var Builtins, IDManager, Link, LinkManager, LinkSet, SortedLinks, contains, exceptions, exists, filter, isEmpty, map, pairs, pipeline, stableSort, values;

  Link = require('../link');

  LinkSet = require('../linkset');

  Builtins = require('../structure/builtins');

  IDManager = require('./idmanager');

  SortedLinks = require('./sortedlinks');

  stableSort = require('util/stablesort');

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({contains, exists, filter, isEmpty, map} = require('brazierjs/array'));

  ({pipeline} = require('brazierjs/function'));

  ({pairs, values} = require('brazierjs/object'));

  module.exports = LinkManager = (function() {
    class LinkManager {
      
        // (World, BreedManager, Updater, () => Unit, () => Unit) => LinkManager
      constructor(_world, _breedManager, _updater, _notifyIsDirected, _notifyIsUndirected) {
        // (String) => LinkSet
        this.linksOfBreed = this.linksOfBreed.bind(this);
        // (Link) => Unit
        this._removeLink = this._removeLink.bind(this);
        // ((Turtle) => Link) => (TurtleSet) => LinkSet
        this._createLinksBy = this._createLinksBy.bind(this);
        this._world = _world;
        this._breedManager = _breedManager;
        this._updater = _updater;
        this._notifyIsDirected = _notifyIsDirected;
        this._notifyIsUndirected = _notifyIsUndirected;
        this.clear();
      }

      // () => Unit
      clear() {
        this._linkArrCache = void 0;
        this._links = new SortedLinks();
        this._linksFrom = {};
        this._idManager = new IDManager();
        return this._linksTo = {};
      }

      // (Turtle, Turtle, String) => Link
      createDirectedLink(from, to, breedName) {
        if (breedName.toUpperCase() === "LINKS") {
          this._notifyIsDirected();
        }
        return this._createLink(true, from, to, breedName);
      }

      // (Turtle, TurtleSet, String) => LinkSet
      createDirectedLinks(source, others, breedName) {
        if (breedName.toUpperCase() === "LINKS") {
          this._notifyIsDirected();
        }
        return this._createLinksBy((turtle) => {
          return this._createLink(true, source, turtle, breedName);
        })(others);
      }

      // (Turtle, TurtleSet, String) => LinkSet
      createReverseDirectedLinks(source, others, breedName) {
        if (breedName.toUpperCase() === "LINKS") {
          this._notifyIsDirected();
        }
        return this._createLinksBy((turtle) => {
          return this._createLink(true, turtle, source, breedName);
        })(others);
      }

      // (Turtle, Turtle, String) => Link
      createUndirectedLink(source, other, breedName) {
        return this._createLink(false, source, other, breedName);
      }

      // (Turtle, TurtleSet, String) => LinkSet
      createUndirectedLinks(source, others, breedName) {
        return this._createLinksBy((turtle) => {
          return this._createLink(false, source, turtle, breedName);
        })(others);
      }

      // (Number, Number, String) => Agent
      getLink(fromId, toId, breedName = "LINKS") {
        var findFunc, isDirected, ref;
        isDirected = this._breedManager.get(breedName).isDirected();
        findFunc = function(link) {
          return link.getBreedName().toLowerCase() === breedName.toLowerCase() && ((link.end1.id === fromId && link.end2.id === toId) || (!isDirected && link.end1.id === toId && link.end2.id === fromId));
        };
        return (ref = this._links.find(findFunc)) != null ? ref : Nobody;
      }

      // (Object[Any]) => Unit
      importState(linkState) {
        linkState.forEach(({breed, end1, end2, color, isHidden, labelColor, shape, thickness, tieMode}) => {
          var newLink;
          newLink = this._createLink(breed.isDirected(), end1, end2, breed.name);
          newLink.setVariable('color', color);
          newLink.setVariable('hidden?', isHidden);
          newLink.setVariable('label-color', labelColor);
          newLink.setVariable('shape', shape);
          newLink.setVariable('thickness', thickness);
          newLink.setVariable('tie-mode', tieMode);
        });
      }

      // () => LinkSet
      links() {
        var thunk;
        thunk = (() => {
          return this._linkArray();
        });
        return new LinkSet(thunk, this._world, "links");
      }

      linksOfBreed(breedName) {
        var thunk;
        thunk = (() => {
          return stableSort(this._breedManager.get(breedName).members)(function(x, y) {
            return x.compare(y).toInt;
          });
        });
        return new LinkSet(thunk, this._world, breedName);
      }

      // () => Array[Link]
      _linkArray() {
        if (this._linkArrCache == null) {
          this._linkArrCache = this._links.toArray();
        }
        return this._linkArrCache;
      }

      // Link -> Breed -> String -> Unit
      trackBreedChange(link, breed, oldBreedName) {
        var end1, end2, existingLink, isDirected;
        ({end1, end2, isDirected} = link);
        this._errorIfBreedIsIncompatible(breed.name);
        existingLink = this.getLink(end1.id, end2.id, breed.name);
        if (existingLink !== link && existingLink !== Nobody) {
          throw exceptions.runtime(`there is already a ${breed.singular.toUpperCase()} with endpoints ${end1.getName()} and ${end2.getName()}`, "set");
        } else {
          this._removeFromSets(end1.id, end2.id, isDirected, oldBreedName);
          this._insertIntoSets(end1.id, end2.id, isDirected, breed.name);
        }
      }

      _removeLink(link) {
        var l;
        l = this._links.find(function({id}) {
          return id === link.id;
        });
        this._links = this._links.remove(l);
        this._linkArrCache = void 0;
        if (this._links.isEmpty()) {
          this._notifyIsUndirected();
        }
        this._removeFromSets(link.end1.id, link.end2.id, link.isDirected, link.getBreedName());
      }

      // (Boolean, Turtle, Turtle, String) => Link
      _createLink(isDirected, from, to, breedName) {
        var breed, end1, end2, link;
        [end1, end2] = from.id < to.id || isDirected ? [from, to] : [to, from];
        if (!this._linkExists(end1.id, end2.id, isDirected, breedName)) {
          breed = this._breedManager.get(breedName);
          link = new Link(this._idManager.next(), isDirected, end1, end2, this._world, this._updater.updated, this._updater.registerDeadLink, this._removeLink, this._updater.registerLinkStamp, this.linksOfBreed, breed);
          this._updater.updated(link)(...Builtins.linkBuiltins);
          this._updater.updated(link)(...Builtins.linkExtras);
          this._links.insert(link);
          this._linkArrCache = void 0;
          return link;
        } else {
          return Nobody;
        }
      }

      _createLinksBy(mkLink) {
        return (turtles) => {
          var isLink, links;
          isLink = function(other) {
            return other !== Nobody;
          };
          links = pipeline(map(mkLink), filter(isLink))(turtles.toArray());
          return new LinkSet(links, this._world);
        };
      }

      // String -> Unit
      _errorIfBreedIsIncompatible(breedName) {
        if ((breedName === "LINKS" && this._hasBreededs()) || (breedName !== "LINKS" && this._hasUnbreededs())) {
          throw exceptions.runtime("You cannot have both breeded and unbreeded links in the same world.", "set");
        }
      }

      // Unit -> Boolean
      _hasBreededs() {
        var allPairs;
        allPairs = pairs(this._linksTo).concat(pairs(this._linksFrom));
        return exists(function([key, value]) {
          return key !== "LINKS" && exists(function(x) {
            return !isEmpty(x);
          })(values(value));
        })(allPairs);
      }

      // Unit -> Boolean
      _hasUnbreededs() {
        var hasUnbreededs;
        hasUnbreededs = function(bin) {
          var ref;
          return exists(function(x) {
            return !isEmpty(x);
          })(values((ref = bin["LINKS"]) != null ? ref : {}));
        };
        return hasUnbreededs(this._linksFrom) || hasUnbreededs(this._linksTo);
      }

      // (Number, Number, Boolean, String) => Unit
      _insertIntoSets(fromID, toID, isDirected, breedName) {
        var insertIntoSet;
        insertIntoSet = function(set, id1, id2) {
          var neighbors;
          if (set[breedName] == null) {
            set[breedName] = {};
          }
          neighbors = set[breedName][id1];
          if (neighbors != null) {
            return neighbors.push(id2);
          } else {
            return set[breedName][id1] = [id2];
          }
        };
        insertIntoSet(this._linksFrom, fromID, toID);
        if (!isDirected) {
          insertIntoSet(this._linksTo, toID, fromID);
        }
      }

      // (Number, Number, Boolean, String) => Boolean
      _linkExists(id1, id2, isDirected, breedName) {
        var ref, ref1, ref2, ref3, weCanHaz;
        weCanHaz = pipeline(values, contains(id2));
        return weCanHaz((ref = (ref1 = this._linksFrom[breedName]) != null ? ref1[id1] : void 0) != null ? ref : {}) || (!isDirected && weCanHaz((ref2 = (ref3 = this._linksTo[breedName]) != null ? ref3[id1] : void 0) != null ? ref2 : {}));
      }

      // Number -> Number -> Boolean -> String -> Unit
      _removeFromSets(fromID, toID, isDirected, breedName) {
        var remove;
        remove = function(set, id1, id2) {
          if ((set != null ? set[id1] : void 0) != null) {
            return set[id1] = filter(function(x) {
              return x !== id2;
            })(set[id1]);
          }
        };
        remove(this._linksFrom[breedName], fromID, toID);
        if (!isDirected) {
          remove(this._linksTo[breedName], toID, fromID);
        }
      }

    };

    LinkManager.prototype._linkArrCache = void 0; // Array[Link]

    LinkManager.prototype._links = void 0; // SortedLinks

    LinkManager.prototype._linksFrom = void 0; // Object[String, Object[Number, Number]]

    LinkManager.prototype._idManager = void 0; // IDManager

    LinkManager.prototype._linksTo = void 0; // Object[String, Object[Number, Number]]

    return LinkManager;

  }).call(this);

}).call(this);

},{"../link":"engine/core/link","../linkset":"engine/core/linkset","../structure/builtins":"engine/core/structure/builtins","./idmanager":"engine/core/world/idmanager","./sortedlinks":"engine/core/world/sortedlinks","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/object":"brazier/object","util/exception":"util/exception","util/stablesort":"util/stablesort"}],"engine/core/world/singleobjectextensionporter":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ExportedExtensionObject, ExportedSimpleExtension, SingleObjectExtensionPorter, exceptions, porterStringRegEx;

  ({ExportedExtensionObject, ExportedSimpleExtension} = require('../../../serialize/exportstructures'));

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  porterStringRegEx = /{{(.+)\:(.*) (\d+)\:  ?(.+)}}/;

  SingleObjectExtensionPorter = class SingleObjectExtensionPorter {
    constructor(extensionName1, canHandle, dumpObjectData, exportObjectData, formatObjectData, readObjectData, importObjectData) {
      this.extensionName = extensionName1;
      this.canHandle = canHandle;
      this.dumpObjectData = dumpObjectData;
      this.exportObjectData = exportObjectData;
      this.formatObjectData = formatObjectData;
      this.readObjectData = readObjectData;
      this.importObjectData = importObjectData;
    }

    dump(extObj, dumper) {
      return `{{${this.extensionName}: ${this.dumpObjectData(extObj, dumper)}}}`;
    }

    exportObject(extObj, exportValue) {
      return new ExportedExtensionObject(this.extensionName, "", this.exportObjectData(extObj, exportValue));
    }

    export(objects) {
      return new ExportedSimpleExtension(this.extensionName, objects);
    }

    formatObject(index, exportedObj, formatAny) {
      return `\"{{${this.extensionName}: ${index}: ${this.formatObjectData(exportedObj, formatAny)}}}\"`;
    }

    format(exportedExt, formatAny) {
      return exportedExt.objects.map((exportedObj, index) => {
        return this.formatObject(index, exportedObj, formatAny);
      }).join("\n");
    }

    readObject(text, parseAny) {
      return new ExportedExtensionObject(this.extensionName, "", this.readObjectData(text, parseAny));
    }

    readObjects(porterStrings, helper) {
      var porterObjects;
      porterObjects = [];
      porterStrings.forEach((porterString) => {
        var extensionName, formattedData, index, match, porterObject, subType;
        match = porterString.match(porterStringRegEx);
        if (match == null) {
          throw exceptions.internal(`Cannot read this extension object string: ${porterString}`);
        }
        extensionName = match[1];
        subType = match[2];
        index = parseFloat(match[3]);
        formattedData = match[4];
        if (this.extensionName !== extensionName) {
          throw exceptions.internal(`This extension porter (${this.extensionName}) does not match the extension object: ${porterString}`);
        }
        porterObject = this.readObject(formattedData, helper);
        return porterObjects[index] = porterObject;
      });
      return porterObjects;
    }

    read(sectionLines, parseAny) {
      return new ExportedSimpleExtension(this.extensionName, this.readObjects(sectionLines, parseAny));
    }

    importObject(exportedExt, placeholder, reify) {
      var exportedObj;
      exportedObj = exportedExt.objects[placeholder.index];
      return this.importObjectData(exportedObj, reify);
    }

    import(_1, _2) {}

  };

  module.exports = SingleObjectExtensionPorter;

}).call(this);

},{"../../../serialize/exportstructures":"serialize/exportstructures","util/exception":"util/exception"}],"engine/core/world/sortedlinks":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Mori, SortedLinks, linkCompare;

  linkCompare = require('../structure/linkcompare');

  Mori = require('mori');

  module.exports = SortedLinks = (function() {
    class SortedLinks {
      
        // () => SortedLinks
      constructor() {
        this._links = Mori.sortedSetBy(linkCompare);
      }

      // Side-effecting ops
      insert(link) {
        this._links = Mori.conj(this._links, link);
        return this;
      }

      remove(link) {
        this._links = Mori.disj(this._links, link);
        return this;
      }

      
        // Pure ops
      find(pred) {
        return Mori.first(Mori.filter(pred, this._links)); // Mori's `filter` is lazy, so it's all cool --JAB (3/26/14) # ((Link) => Boolean) => Link
      }

      isEmpty() {
        return Mori.isEmpty(this._links); // () => Boolean
      }

      toArray() {
        return Mori.toJs(this._links); // () => Array[Link]
      }

    };

    SortedLinks._links = void 0; // Mori.SortedSet[Link]

    return SortedLinks;

  }).call(this);

}).call(this);

},{"../structure/linkcompare":"engine/core/structure/linkcompare","mori":"mori"}],"engine/core/world/ticker":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var EvilSentinel, Ticker, exceptions;

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  EvilSentinel = -1;

  module.exports = Ticker = (function() {
    class Ticker {
      // (() => Unit, () => Unit, (String*) => Unit) => Ticker
      constructor(_onReset, _onTick, _updateFunc) {
        this._onReset = _onReset;
        this._onTick = _onTick;
        this._updateFunc = _updateFunc;
        this._count = EvilSentinel;
      }

      // () => Unit
      reset() {
        this._updateTicks(function() {
          return 0;
        });
        this._onReset();
        this._onTick();
      }

      // () => Unit
      clear() {
        this._updateTicks(function() {
          return EvilSentinel;
        });
      }

      // (Number) => Unit
      importTicks(numTicks) {
        this._updateTicks(function() {
          return numTicks;
        });
      }

      // () => Unit
      tick() {
        if (this.ticksAreStarted()) {
          this._updateTicks(function(counter) {
            return counter + 1;
          });
        } else {
          throw exceptions.runtime("The tick counter has not been started yet. Use RESET-TICKS.", "tick");
        }
        this._onTick();
      }

      // (Number) => Unit
      tickAdvance(n) {
        if (n < 0) {
          throw exceptions.runtime("Cannot advance the tick counter by a negative amount.", "tick-advance");
        } else if (this.ticksAreStarted()) {
          return this._updateTicks(function(counter) {
            return counter + n;
          });
        } else {
          throw exceptions.runtime("The tick counter has not been started yet. Use RESET-TICKS.", "tick-advance");
        }
      }

      // () => Boolean
      ticksAreStarted() {
        return this._count !== EvilSentinel;
      }

      // () => Number
      tickCount() {
        if (this.ticksAreStarted()) {
          return this._count;
        } else {
          throw exceptions.runtime("The tick counter has not been started yet. Use RESET-TICKS.", "ticks");
        }
      }

      // ((Number) => Number) => Unit
      _updateTicks(updateCountFunc) {
        this._count = updateCountFunc(this._count);
        this._updateFunc("ticks");
      }

    };

    // Number
    Ticker.prototype._count = void 0;

    return Ticker;

  }).call(this);

}).call(this);

},{"util/exception":"util/exception"}],"engine/core/world/turtlemanager":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Builtins, ColorModel, IDManager, Turtle, TurtleManager, TurtleSet, map, rangeUntil;

  ColorModel = require('engine/core/colormodel');

  Turtle = require('../turtle');

  TurtleSet = require('../turtleset');

  Builtins = require('../structure/builtins');

  IDManager = require('./idmanager');

  ({map} = require('brazierjs/array'));

  ({rangeUntil} = require('brazierjs/number'));

  module.exports = TurtleManager = (function() {
    class TurtleManager {
      
        // (World, Updater, BreedManager, (Number) => Number) => TurtleManager
      constructor(_world, _breedManager, _updater, _nextInt) {
        // (String) => TurtleSet
        this.turtlesOfBreed = this.turtlesOfBreed.bind(this);
        // (Number, Number, Number, Number, Breed, String, Number, Boolean, Number, String, (Updatable) => PenManager) => Turtle
        this._createNewTurtle = this._createNewTurtle.bind(this);
        // (Number) => Unit
        this._removeTurtle = this._removeTurtle.bind(this);
        this._world = _world;
        this._breedManager = _breedManager;
        this._updater = _updater;
        this._nextInt = _nextInt;
        this._idManager = new IDManager();
        this._turtles = [];
        this._turtlesById = {};
      }

      // () => Unit
      clearTurtles() {
        this.turtles().forEach(function(turtle) {
          return turtle.die();
        });
        this._idManager.reset();
      }

      // (Number, String) => TurtleSet
      createOrderedTurtles(n, breedName) {
        var num, turtles;
        num = n >= 0 ? n : 0;
        turtles = map((index) => {
          var color, heading;
          color = ColorModel.nthColor(index);
          heading = (360 * index) / num;
          return this._createNewTurtle(color, heading, 0, 0, this._breedManager.get(breedName));
        })(rangeUntil(0)(num));
        return new TurtleSet(turtles, this._world);
      }

      // (Number, String, Number, Number) => TurtleSet
      createTurtles(n, breedName, xcor = 0, ycor = 0) {
        var num, turtles;
        num = n >= 0 ? n : 0;
        turtles = map(() => {
          var color, heading;
          color = ColorModel.randomColor(this._nextInt);
          heading = this._nextInt(360);
          return this._createNewTurtle(color, heading, xcor, ycor, this._breedManager.get(breedName));
        })(rangeUntil(0)(num));
        return new TurtleSet(turtles, this._world);
      }

      // (Number) => Agent
      getTurtle(id) {
        var ref;
        return (ref = this._turtlesById[id]) != null ? ref : Nobody;
      }

      // (String, Number) => Agent
      getTurtleOfBreed(breedName, id) {
        var turtle;
        turtle = this.getTurtle(id);
        if (turtle.getBreedName().toUpperCase() === breedName.toUpperCase()) {
          return turtle;
        } else {
          return Nobody;
        }
      }

      // (Object[Any], Number) => Unit
      importState(turtleState, nextIndex) {
        turtleState.forEach(({who, color, heading, xcor, ycor, shape, labelColor, breed, isHidden, size, penSize, penMode}) => {
          var newTurtle;
          newTurtle = this._createTurtle(who, color, heading, xcor, ycor, breed, "", labelColor, isHidden, size, shape);
          newTurtle.penManager.setPenMode(penMode);
          return newTurtle.penManager.setSize(penSize);
        });
        this._idManager.setCount(nextIndex);
      }

      // () => Number
      peekNextID() {
        return this._idManager.getCount();
      }

      // () => TurtleSet
      turtles() {
        return new TurtleSet(this._turtles, this._world, "turtles");
      }

      turtlesOfBreed(breedName) {
        var breed;
        breed = this._breedManager.get(breedName);
        return new TurtleSet(breed.members, this._world, breedName);
      }

      // () => Unit
      _clearTurtlesSuspended() {
        this._idManager.suspendDuring(() => {
          return this.clearTurtles();
        });
      }

      _createNewTurtle(color, heading, xcor, ycor, breed, label, lcolor, isHidden, size, shape, genPenManager) {
        return this._createTurtle(this._idManager.next(), color, heading, xcor, ycor, breed, label, lcolor, isHidden, size, shape, genPenManager);
      }

      // (Number, Number, Number, Number, Number, Breed, String, Number, Boolean, Number, String, (Updatable) => PenManager) => Turtle
      _createTurtle(id, color, heading, xcor, ycor, breed, label, lcolor, isHidden, size, shape, genPenManager) {
        var turtle;
        turtle = new Turtle(this._world, id, this._updater.updated, this._updater.registerPenTrail, this._updater.registerTurtleStamp, this._updater.registerDeadTurtle, this._createNewTurtle, this._removeTurtle, color, heading, xcor, ycor, breed, label, lcolor, isHidden, size, shape, genPenManager);
        this._updater.updated(turtle)(...Builtins.turtleBuiltins);
        this._turtles.push(turtle);
        this._turtlesById[id] = turtle;
        return turtle;
      }

      _removeTurtle(id) {
        var turtle;
        turtle = this._turtlesById[id];
        this._turtles.splice(this._turtles.indexOf(turtle), 1);
        delete this._turtlesById[id];
      }

    };

    TurtleManager.prototype._idManager = void 0; // IDManager

    TurtleManager.prototype._turtles = void 0; // Array[Turtle]

    TurtleManager.prototype._turtlesById = void 0; // Object[Number, Turtle]

    return TurtleManager;

  }).call(this);

}).call(this);

},{"../structure/builtins":"engine/core/structure/builtins","../turtle":"engine/core/turtle","../turtleset":"engine/core/turtleset","./idmanager":"engine/core/world/idmanager","brazierjs/array":"brazier/array","brazierjs/number":"brazier/number","engine/core/colormodel":"engine/core/colormodel"}],"engine/core/world":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var LinkManager, NLMath, Observer, Patch, PatchSet, Ticker, TopologyInterrupt, TurtleManager, World, allPlotsDataToCSV, exceptions, exportAllPlots, exportPlot, exportRawPlot, exportWorld, filter, flatMap, importWorld, linkBuiltins, patchBuiltins, pipeline, plotDataToCSV, rawPlotToCSV, topologyFactory, turtleBuiltins, values, worldDataToCSV;

  Patch = require('./patch');

  PatchSet = require('./patchset');

  topologyFactory = require('./topology/factory');

  LinkManager = require('./world/linkmanager');

  Ticker = require('./world/ticker');

  TurtleManager = require('./world/turtlemanager');

  NLMath = require('util/nlmath');

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({filter, flatMap} = require('brazier/array'));

  ({pipeline} = require('brazier/function'));

  ({values} = require('brazier/object'));

  ({Observer} = require('./observer'));

  ({linkBuiltins, patchBuiltins, turtleBuiltins} = require('./structure/builtins'));

  ({allPlotsDataToCSV, plotDataToCSV, rawPlotToCSV, worldDataToCSV} = require('serialize/exportcsv'));

  ({TopologyInterrupt} = require('util/interrupts'));

  ({exportWorld, exportPlot, exportRawPlot, exportAllPlots} = require('./world/export'));

  ({importWorld} = require('./world/import'));

  module.exports = World = (function() {
    class World {
      constructor(miniWorkspace, _config, _getViewBase64, _outputClear, _getOutput, _setOutput, extensionPorters, globalNames, interfaceGlobalNames, patchesOwnNames, minPxcor, maxPxcor, minPycor, maxPycor, patchSize, wrappingAllowedInX, wrappingAllowedInY, turtleShapeMap, linkShapeMap, onTickFunction) { // MiniWorkspace // Array[String] // Array[String] // Number // Number // Number // Number // Boolean // Boolean // () => Unit
        var onTick;
        // () => PatchSet
        this.patches = this.patches.bind(this);
        // (Number, Number) => Patch | Nobody
        this.getPatchAt = this.getPatchAt.bind(this);
        // The wrapping and rounding below is setup to avoid creating extra anonymous functions.
        // We could just use @ and fat arrows => but CoffeeScript uses anon funcs to bind `this`.
        // Those anon funcs cause GC pressure and runtime slowdown, so we have to manually setup
        // the context somehow.  A lot of rounding and wrapping goes on in models.  -JMB 07/2017

        // (Number) => Number
        this._thisWrapX = this._thisWrapX.bind(this);
        // (Number) => Number
        this._thisWrapY = this._thisWrapY.bind(this);
        // () => Unit
        this._incrementPatchLabelCount = this._incrementPatchLabelCount.bind(this);
        // () => Unit
        this._decrementPatchLabelCount = this._decrementPatchLabelCount.bind(this);
        // () => Unit
        this._setUnbreededLinksDirected = this._setUnbreededLinksDirected.bind(this);
        // () => Unit
        this._setUnbreededLinksUndirected = this._setUnbreededLinksUndirected.bind(this);
        // () => Unit
        this._declarePatchesNotAllBlack = this._declarePatchesNotAllBlack.bind(this);
        this._config = _config; // WorldConfig
        this._getViewBase64 = _getViewBase64; // () => String
        this._outputClear = _outputClear; // () => Unit
        this._getOutput = _getOutput; // () => String
        this._setOutput = _setOutput; // (Any) => String
        this.extensionPorters = extensionPorters; // Array[ExtensionPorter]
        this.patchesOwnNames = patchesOwnNames; // Array[String]
        this.patchSize = patchSize; // Number
        this.turtleShapeMap = turtleShapeMap; // ShapeMap
        this.linkShapeMap = linkShapeMap; // ShapeMap
        ({
          selfManager: this.selfManager,
          updater: this._updater,
          rng: this.rng,
          breedManager: this.breedManager,
          plotManager: this._plotManager
        } = miniWorkspace);
        this._patchesAllBlack = true;
        this._patchesWithLabels = 0;
        this._updater.collectUpdates();
        this._updater.registerWorldState({
          worldWidth: maxPxcor - minPxcor + 1,
          worldHeight: maxPycor - minPycor + 1,
          minPxcor: minPxcor,
          minPycor: minPycor,
          maxPxcor: maxPxcor,
          maxPycor: maxPycor,
          linkBreeds: this.breedManager.orderedLinkBreeds(),
          linkShapeList: this.linkShapeMap,
          patchSize: this.patchSize,
          patchesAllBlack: this._patchesAllBlack,
          patchesWithLabels: this._patchesWithLabels,
          ticks: -1,
          turtleBreeds: this.breedManager.orderedTurtleBreeds(),
          turtleShapeList: this.turtleShapeMap,
          unbreededLinksAreDirected: false,
          wrappingAllowedInX: wrappingAllowedInX,
          wrappingAllowedInY: wrappingAllowedInY
        });
        onTick = () => {
          this.rng.withAux(onTickFunction);
          return this._plotManager.updatePlots();
        };
        this.linkManager = new LinkManager(this, this.breedManager, this._updater, this._setUnbreededLinksDirected, this._setUnbreededLinksUndirected);
        this.observer = new Observer(this._updater.updated, globalNames, interfaceGlobalNames);
        this.ticker = new Ticker(this._plotManager.setupPlots, onTick, this._updater.updated(this));
        this.topology = null;
        this.turtleManager = new TurtleManager(this, this.breedManager, this._updater, this.rng.nextInt);
        this._patches = [];
        this._resizeHelper(minPxcor, maxPxcor, minPycor, maxPycor, wrappingAllowedInX, wrappingAllowedInY);
      }

      // () => LinkSet
      links() {
        return this.linkManager.links();
      }

      // () => TurtleSet
      turtles() {
        return this.turtleManager.turtles();
      }

      patches() {
        return new PatchSet(this._patches, this, "patches");
      }

      // (Number, Number, Number, Number, Boolean, Boolean) => Unit
      resize(minPxcor, maxPxcor, minPycor, maxPycor, wrapsInX = this.topology._wrapInX, wrapsInY = this.topology._wrapInY) {
        this._resizeHelper(NLMath.trunc(minPxcor), NLMath.trunc(maxPxcor), NLMath.trunc(minPycor), NLMath.trunc(maxPycor), wrapsInX, wrapsInY);
        return this.clearDrawing();
      }

      // (Number, Number, Number, Number, Boolean, Boolean) => Unit
      _resizeHelper(minPxcor, maxPxcor, minPycor, maxPycor, wrapsInX = this.topology._wrapInX, wrapsInY = this.topology._wrapInY) {
        var ref, ref1, ref2, ref3;
        if (!((minPxcor <= 0 && 0 <= maxPxcor) && (minPycor <= 0 && 0 <= maxPycor))) {
          throw exceptions.runtime("You must include the point (0, 0) in the world.", "resize-world");
        }
        if (minPxcor !== ((ref = this.topology) != null ? ref.minPxcor : void 0) || minPycor !== ((ref1 = this.topology) != null ? ref1.minPycor : void 0) || maxPxcor !== ((ref2 = this.topology) != null ? ref2.maxPxcor : void 0) || maxPycor !== ((ref3 = this.topology) != null ? ref3.maxPycor : void 0)) {
          this._config.resizeWorld();
          // For some reason, JVM NetLogo doesn't restart `who` ordering after `resize-world`; even the test for this is existentially confused. --JAB (4/3/14)
          this.turtleManager._clearTurtlesSuspended();
          this.setTopology(wrapsInX, wrapsInY, minPxcor, maxPxcor, minPycor, maxPycor);
          this._createPatches();
          this._declarePatchesAllBlack();
          this._resetPatchLabelCount();
          this._updater.updated(this)("width", "height", "minPxcor", "minPycor", "maxPxcor", "maxPycor");
        }
      }

      // (Boolean, Boolean, Number, Number, Number, Number) => Unit
      setTopology(wrapsInX, wrapsInY, minX = this.topology.minPxcor, maxX = this.topology.maxPxcor, minY = this.topology.minPycor, maxY = this.topology.maxPycor) {
        this.topology = topologyFactory(wrapsInX, wrapsInY, minX, maxX, minY, maxY, this.patches, this.getPatchAt);
        this._updater.updated(this)("wrappingAllowedInX", "wrappingAllowedInY");
      }

      getPatchAt(x, y) {
        var index, roundedX, roundedY;
        roundedX = this._roundXCor(x);
        roundedY = this._roundYCor(y);
        if (roundedX === TopologyInterrupt || roundedY === TopologyInterrupt) {
          return Nobody;
        } else {
          index = (this.topology.maxPycor - roundedY) * this.topology.width + (roundedX - this.topology.minPxcor);
          return this._patches[index];
        }
      }

      // (Number, Number, Number, Number) => Agent
      patchAtHeadingAndDistanceFrom(angle, distance, x, y) {
        var heading, targetX, targetY;
        heading = NLMath.normalizeHeading(angle);
        targetX = x + distance * NLMath.squash(NLMath.sin(heading));
        targetY = y + distance * NLMath.squash(NLMath.cos(heading));
        return this.getPatchAt(targetX, targetY);
      }

      // (Number) => Unit
      setPatchSize(patchSize) {
        this.patchSize = patchSize;
        this._updater.updated(this)("patchSize");
        this._updater.rescaleDrawing();
      }

      // () => Unit
      clearAll() {
        this.observer.clearCodeGlobals();
        this.observer.resetPerspective();
        this.turtleManager.clearTurtles();
        this.clearPatches();
        this.clearLinks();
        this._declarePatchesAllBlack();
        this._resetPatchLabelCount();
        this.ticker.clear();
        this._plotManager.clearAllPlots();
        this._outputClear();
        this.clearDrawing();
        // Depending on global state for `Extensions` is not great, but Extensions depends on the workspace
        // and the workspace makes the world when it is created.  -Jeremy B July 19th
        Object.keys(Extensions).forEach(function(extensionName) {
          var base;
          return typeof (base = Extensions[extensionName]).clearAll === "function" ? base.clearAll() : void 0;
        });
      }

      // This is a "legacy prim" that could be auto-inserted by the code converter in NetLogo 5 -Jeremy B 2023
      // () => Unit
      clearAllAndResetTicks() {
        this.clearAll();
        this.ticker.reset();
      }

      // () => Unit
      clearDrawing() {
        this._updater.clearDrawing();
      }

      // (String) => Unit
      importDrawing(imageBase64) {
        this._updater.importDrawing(imageBase64);
      }

      // () => Unit
      clearLinks() {
        this.linkManager.clear();
        this.turtles().ask((() => {
          return this.selfManager.self().linkManager.clear();
        }), false);
      }

      // () => Unit
      clearPatches() {
        this.patches().forEach(function(patch) {
          patch.reset();
        });
        this._declarePatchesAllBlack();
        this._resetPatchLabelCount();
      }

      // () => Object[Any]
      exportState() {
        return exportWorld.call(this);
      }

      // () => String
      exportAllPlotsCSV() {
        return allPlotsDataToCSV(exportAllPlots.call(this), this.extensionPorters);
      }

      // (String) => String
      exportPlotCSV(name) {
        return plotDataToCSV(exportPlot.call(this, name), this.extensionPorters);
      }

      // (String) => String
      exportRawPlotCSV(name) {
        return rawPlotToCSV(exportRawPlot.call(this, name), this.extensionPorters);
      }

      // () => String
      exportCSV() {
        var allLinksOwnsNames, allTurtlesOwnsNames, state, varNamesForBreedsMatching;
        varNamesForBreedsMatching = (pred) => {
          return pipeline(values, filter(pred), flatMap(function(x) {
            return x.varNames;
          }))(this.breedManager.breeds());
        };
        allTurtlesOwnsNames = varNamesForBreedsMatching(function(breed) {
          return !breed.isLinky();
        });
        allLinksOwnsNames = varNamesForBreedsMatching(function(breed) {
          return breed.isLinky();
        });
        state = exportWorld.call(this);
        return worldDataToCSV(allTurtlesOwnsNames, allLinksOwnsNames, patchBuiltins, turtleBuiltins, linkBuiltins, this.extensionPorters)(state);
      }

      // (Number, Number) => PatchSet
      getNeighbors(pxcor, pycor) {
        return new PatchSet(this.topology.getNeighbors(pxcor, pycor), this);
      }

      // (Number, Number) => PatchSet
      getNeighbors4(pxcor, pycor) {
        return new PatchSet(this.topology.getNeighbors4(pxcor, pycor), this);
      }

      // (WorldState) => Unit
      importState() {
        return importWorld.apply(this, arguments);
      }

      _thisWrapX(x) {
        return this.topology.wrapX(x);
      }

      _thisWrapY(y) {
        return this.topology.wrapY(y);
      }

      // (Number) => Number
      _roundXCor(x) {
        var wrappedX;
        wrappedX = this._thisWrapX(x);
        return this._roundCoordinate(wrappedX);
      }

      // (Number) => Number
      _roundYCor(y) {
        var wrappedY;
        wrappedY = this._thisWrapY(y);
        return this._roundCoordinate(wrappedY);
      }

      // Boy, oh, boy!  Headless has only this to say about this code: "floor() is slow so we
      // don't use it".  I have a lot more to say!  This code is kind of nuts, but we can't
      // live without it unless something is done about Headless' uses of `World.roundX` and
      // and `World.roundY`.  The previous Tortoise code was somewhat sensible about patch
      // boundaries, but had to be supplanted by this in order to become compliant with NL
      // Headless, which interprets `0.4999999999999999167333` as being one patch over from
      // `0` (whereas, sensically, we should only do that starting at `0.5`).  But... we
      // don't live in an ideal world, so I'll just replicate Headless' silly behavior here.
      // --JAB (12/6/14)
      // (Number) => Number
      _roundCoordinate(wrappedC) {
        var fractional, integral;
        if (wrappedC === TopologyInterrupt) {
          return wrappedC;
        } else if (wrappedC > 0) {
          return (wrappedC + 0.5) | 0;
        } else {
          integral = wrappedC | 0;
          fractional = integral - wrappedC;
          if (fractional > 0.5) {
            return integral - 1;
          } else {
            return integral;
          }
        }
      }

      // () => Unit
      _createPatches() {
        var i, id, len, nested, patch, ref, x, y;
        this._patches.forEach(function(patch) {
          patch._die();
        });
        nested = (function() {
          var i, ref, ref1, results;
          results = [];
          for (y = i = ref = this.topology.maxPycor, ref1 = this.topology.minPycor; (ref <= ref1 ? i <= ref1 : i >= ref1); y = ref <= ref1 ? ++i : --i) {
            results.push((function() {
              var j, ref2, ref3, results1;
              results1 = [];
              for (x = j = ref2 = this.topology.minPxcor, ref3 = this.topology.maxPxcor; (ref2 <= ref3 ? j <= ref3 : j >= ref3); x = ref2 <= ref3 ? ++j : --j) {
                id = (this.topology.width * (this.topology.maxPycor - y)) + x - this.topology.minPxcor;
                results1.push(new Patch(id, x, y, this, this._updater.updated, this._declarePatchesNotAllBlack, this._decrementPatchLabelCount, this._incrementPatchLabelCount));
              }
              return results1;
            }).call(this));
          }
          return results;
        }).call(this);
        this._patches = [].concat(...nested);
        ref = this._patches;
        for (i = 0, len = ref.length; i < len; i++) {
          patch = ref[i];
          this._updater.updated(patch)("pxcor", "pycor", "pcolor", "plabel", "plabel-color");
        }
      }

      // (Number) => PatchSet
      _optimalPatchCol(xcor) {
        var maxX, maxY, minX, minY;
        ({
          maxPxcor: maxX,
          maxPycor: maxY,
          minPxcor: minX,
          minPycor: minY
        } = this.topology);
        return this._optimalPatchSequence(xcor, minX, maxX, minY, maxY, (y) => {
          return this.getPatchAt(xcor, y);
        });
      }

      // (Number) => PatchSet
      _optimalPatchRow(ycor) {
        var maxX, maxY, minX, minY;
        ({
          maxPxcor: maxX,
          maxPycor: maxY,
          minPxcor: minX,
          minPycor: minY
        } = this.topology);
        return this._optimalPatchSequence(ycor, minY, maxY, minX, maxX, (x) => {
          return this.getPatchAt(x, ycor);
        });
      }

      // (Number, Number, Number, Number, Number, (Number) => Agent) => PatchSet
      _optimalPatchSequence(cor, boundaryMin, boundaryMax, seqStart, seqEnd, getPatch) {
        var n, ret;
        ret = (boundaryMin <= cor && cor <= boundaryMax) ? [].concat(...(function() {
          var i, ref, ref1, results;
          results = [];
          for (n = i = ref = seqStart, ref1 = seqEnd; (ref <= ref1 ? i <= ref1 : i >= ref1); n = ref <= ref1 ? ++i : --i) {
            results.push(getPatch(n));
          }
          return results;
        })()) : [];
        return new PatchSet(ret, this);
      }

      _incrementPatchLabelCount() {
        this._setPatchLabelCount(function(count) {
          return count + 1;
        });
      }

      _decrementPatchLabelCount() {
        this._setPatchLabelCount(function(count) {
          return count - 1;
        });
      }

      // () => Unit
      _resetPatchLabelCount() {
        this._setPatchLabelCount(function() {
          return 0;
        });
      }

      // ((Number) => Number) => Unit
      _setPatchLabelCount(updateCountFunc) {
        this._patchesWithLabels = updateCountFunc(this._patchesWithLabels);
        this._updater.updated(this)("patchesWithLabels");
      }

      _setUnbreededLinksDirected() {
        this.breedManager.setUnbreededLinksDirected();
        this._updater.updated(this)("unbreededLinksAreDirected");
      }

      _setUnbreededLinksUndirected() {
        this.breedManager.setUnbreededLinksUndirected();
        this._updater.updated(this)("unbreededLinksAreDirected");
      }

      // () => Unit
      _declarePatchesAllBlack() {
        if (!this._patchesAllBlack) {
          this._patchesAllBlack = true;
          this._updater.updated(this)("patchesAllBlack");
        }
      }

      _declarePatchesNotAllBlack() {
        if (this._patchesAllBlack) {
          this._patchesAllBlack = false;
          this._updater.updated(this)("patchesAllBlack");
        }
      }

    };

    // type ShapeMap = Object[Shape]
    World.prototype.id = 0; // Number

    World.prototype.breedManager = void 0; // BreedManager

    World.prototype.linkManager = void 0; // LinkManager

    World.prototype.observer = void 0; // Observer

    World.prototype.rng = void 0; // RNG

    World.prototype.selfManager = void 0; // SelfManager

    World.prototype.ticker = void 0; // Ticker

    World.prototype.topology = void 0; // Topology

    World.prototype.turtleManager = void 0; // TurtleManager

    World.prototype._patches = void 0; // Array[Patch]

    World.prototype._plotManager = void 0; // PlotManager

    World.prototype._updater = void 0; // Updater

    World.prototype._outputClear = void 0; // () => Unit

    
    // Optimization-related variables
    World.prototype._patchesAllBlack = void 0; // Boolean

    World.prototype._patchesWithLabels = void 0; // Number

    return World;

  }).call(this);

}).call(this);

},{"./observer":"engine/core/observer","./patch":"engine/core/patch","./patchset":"engine/core/patchset","./structure/builtins":"engine/core/structure/builtins","./topology/factory":"engine/core/topology/factory","./world/export":"engine/core/world/export","./world/import":"engine/core/world/import","./world/linkmanager":"engine/core/world/linkmanager","./world/ticker":"engine/core/world/ticker","./world/turtlemanager":"engine/core/world/turtlemanager","brazier/array":"brazier/array","brazier/function":"brazier/function","brazier/object":"brazier/object","serialize/exportcsv":"serialize/exportcsv","util/exception":"util/exception","util/interrupts":"util/interrupts","util/nlmath":"util/nlmath"}],"engine/dump":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ExtensionsHandler, Tasks, apply, checks, dump, find, flip, fold, map, pipeline;

  ({checks} = require('./core/typechecker'));

  Tasks = require('./prim/tasks');

  ExtensionsHandler = require('./core/world/extensionshandler');

  ({find, map} = require('brazierjs/array'));

  ({apply, flip, pipeline} = require('brazierjs/function'));

  ({fold} = require('brazierjs/maybe'));

  // Needs a name here since it's recursive --JAB (4/16/14)
  // (Array[ExtensionPorter]) => (Any, Boolean) => String
  dump = function(extensionPorters) {
    var extensions, helper, startDump;
    extensions = ExtensionsHandler.makeDumper(extensionPorters);
    helper = function(x, isReadable = false) {
      var itemStr;
      if (checks.isList(x)) {
        itemStr = map(function(y) {
          return helper(y, isReadable);
        })(x).join(" ");
        return `[${itemStr}]`;
      } else if (checks.isReporterLambda(x)) {
        return `(anonymous reporter: ${x.nlogoBody})`;
      } else if (checks.isCommandLambda(x)) {
        return `(anonymous command: ${x.nlogoBody})`;
      } else if (checks.isString(x)) {
        if (isReadable) {
          return '"' + x + '"';
        } else {
          return x;
        }
      } else if (checks.isNumber(x)) {
        return String(x).toUpperCase(); // For scientific notation, handles correct casing of the 'E' --JAB (8/28/17)
      } else if (extensions.canHandle(x)) {
        return extensions.dump(x, helper);
      } else {
        return String(x);
      }
    };
    startDump = function(x, isReadable) {
      extensions.reset();
      return helper(x, isReadable);
    };
    return startDump;
  };

  module.exports = dump;

}).call(this);

},{"./core/typechecker":"engine/core/typechecker","./core/world/extensionshandler":"engine/core/world/extensionshandler","./prim/tasks":"engine/prim/tasks","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/maybe":"brazier/maybe"}],"engine/hasher":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AbstractAgentSet, Hasher, Link, Turtle, checks, foldl;

  AbstractAgentSet = require('./core/abstractagentset');

  Link = require('./core/link');

  Turtle = require('./core/turtle');

  ({checks} = require('./core/typechecker'));

  ({foldl} = require('brazierjs/array'));

  // Function given a name for the sake of recursion --JAB (7/31/14)
  // (Any) => String
  Hasher = function(x) {
    var f;
    if (checks.isTurtle(x) || checks.isLink(x)) {
      return `${x.constructor.name} | ${x.id}`;
    } else if (checks.isNobody(x)) {
      return "nobody: -1";
    } else if (checks.isList(x)) {
      f = function(acc, x) {
        return "31 *" + acc + (x != null ? Hasher(x) : "0");
      };
      return (foldl(f)(1)(x)).toString();
    } else if (checks.isAgentSet(x)) {
      return `${x.toString()} | ${Hasher(x.sort())}`;
    } else {
      return x.toString();
    }
  };

  module.exports = Hasher;

}).call(this);

},{"./core/abstractagentset":"engine/core/abstractagentset","./core/link":"engine/core/link","./core/turtle":"engine/core/turtle","./core/typechecker":"engine/core/typechecker","brazierjs/array":"brazier/array"}],"engine/plot/pen":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Bar, ColorModel, Counter, Down, Line, Pen, PlotPoint, Point, State, StrictMath, Up, countBy, displayModeFromNum, displayModeFromString, displayModeToNum, displayModeToString, exceptions, filter, forEach, id, isNumber, map, pairs, pipeline;

  StrictMath = require('shim/strictmath');

  ({countBy, filter, forEach, map} = require('brazierjs/array'));

  ({id, pipeline} = require('brazierjs/function'));

  ({pairs} = require('brazierjs/object'));

  ({isNumber} = require('brazierjs/type'));

  ColorModel = require('engine/core/colormodel');

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  // data PenMode =
  Up = Object.freeze({
    _debugInfo: "UP"
  });

  Down = Object.freeze({
    _debugInfo: "DOWN"
  });

  module.exports.PenMode = {
    Up,
    Down,
    penModeToBool: function(penDown) {
      if (penDown === Up) {
        return false;
      } else {
        return true;
      }
    }
  };

  // data DisplayMode =
  Line = Object.freeze({
    _debugInfo: "LINE"
  });

  Bar = Object.freeze({
    _debugInfo: "BAR"
  });

  Point = Object.freeze({
    _debugInfo: "POINT"
  });

  // (Number) => DisplayMode
  displayModeFromNum = function(num) {
    switch (num) {
      case 0:
        return Line;
      case 1:
        return Bar;
      case 2:
        return Point;
      default:
        throw exceptions.internal(`Pen display mode expected \`0\` (line), \`1\` (bar), or \`2\` (point), but got \`${num}\``);
    }
  };

  // (DisplayMode) => Number
  displayModeToNum = function(mode) {
    switch (mode) {
      case Line:
        return 0;
      case Bar:
        return 1;
      case Point:
        return 2;
      default:
        throw exceptions.internal(`Invalid display mode: ${mode}`);
    }
  };

  // (String) => DisplayMode
  displayModeFromString = function(num) {
    switch (num) {
      case 'line':
        return Line;
      case 'bar':
        return Bar;
      case 'point':
        return Point;
      default:
        throw exceptions.internal(`Pen display mode expected 'line', 'bar', or 'point', but got \`${num}\``);
    }
  };

  // (DisplayMode) => String
  displayModeToString = function(mode) {
    switch (mode) {
      case Line:
        return 'line';
      case Bar:
        return 'bar';
      case Point:
        return 'point';
      default:
        throw exceptions.internal(`Invalid display mode: ${mode}`);
    }
  };

  module.exports.DisplayMode = {Line, Bar, Point, displayModeFromNum, displayModeFromString, displayModeToNum, displayModeToString};

  PlotPoint = class PlotPoint {
    // (Number, Number, PenMode, Number) => PlotPoint
    constructor(x1, y1, penMode1, color1) {
      this.x = x1;
      this.y = y1;
      this.penMode = penMode1;
      this.color = color1;
    }

  };

  Counter = class Counter {
    // Who's at first?  Me, ya punk!  --JAB (10/15/14)
    // I don't even know what that means....  --JAB (12/10/17)
    // (Number, Boolean) => Counter
    constructor(_count = 0, _atFirst = true) {
      this._count = _count;
      this._atFirst = _atFirst;
    }

    // (Number) => Number
    next(interval) {
      if (this._atFirst) {
        this._atFirst = false;
        return 0;
      } else {
        return this._count += interval;
      }
    }

  };

  module.exports.State = State = (function() {
    class State {
      
        // (Number, Number, DisplayMode, PenMode, Boolean) => State
      constructor(color1 = 0, interval1 = 1, displayMode = Line, mode1 = Down) {
        this.color = color1;
        this.interval = interval1;
        this.displayMode = displayMode;
        this.mode = mode1;
        this.resetCounter();
      }

      // () => State
      clone() {
        return new State(this.color, this.interval, this.displayMode, this.mode);
      }

      // (Number) => Unit
      leapCounterTo(x) {
        this._counter = new Counter(x, false);
      }

      // () => Number
      getPenX() {
        return this._counter._count;
      }

      // () => Number
      nextX() {
        return this._counter.next(this.interval);
      }

      // () => State
      partiallyReset() {
        return new State(this.color, this.interval, this.displayMode, Down);
      }

      // () => Unit
      resetCounter() {
        this._counter = new Counter();
      }

    };

    State.prototype._counter = void 0; // Counter

    return State;

  }).call(this);

  module.exports.Pen = Pen = (function() {
    class Pen {
      
        // (String, (Pen) => PenOps, Boolean, State, () => (Unit|Stop), () => (Unit|Stop)) => Pen
      constructor(name, genOps, isTemp = false, _defaultState = new State(), _setupThis = (function() {}), _updateThis = (function() {})) {
        this.name = name;
        this.isTemp = isTemp;
        this._defaultState = _defaultState;
        this._setupThis = _setupThis;
        this._updateThis = _updateThis;
        this._ops = genOps(this);
        this.reset();
      }

      // (Number) => Number
      addValue(y) {
        var nextX;
        nextX = this._state.nextX();
        this._addPoint(nextX, y);
        return nextX;
      }

      // (Number, Number) => Unit
      addXY(x, y) {
        this._addPoint(x, y);
        this._state.leapCounterTo(x);
      }

      // () => (Number, Number, Number, Number)
      bounds() {
        return this._bounds;
      }

      // (Array[Number], Number, Number) => Unit
      drawHistogramFrom(ys, xMin, xMax) {
        var determineBucket, interval, isValid, plotBucket;
        this.reset(true);
        interval = this.getInterval();
        isValid = (x) => {
          return ((xMin / interval) <= x && x <= (xMax / interval));
        };
        determineBucket = function(x) {
          return StrictMath.floor((x / interval) * (1 + 3.2e-15)); // See 'Histogram.scala' in Headless for explanation --JAB (10/21/15)
        };
        plotBucket = (([bucketNum, count]) => {
          this.addXY(Number(bucketNum) * interval, count);
        });
        pipeline(filter(isNumber), map(determineBucket), filter(isValid), countBy(id), pairs, forEach(plotBucket))(ys);
      }

      // () => Number
      getColor() {
        return this._state.color;
      }

      // () => PenMode
      getPenMode() {
        return this._state.mode;
      }

      // () => DisplayMode
      getDisplayMode() {
        return this._state.displayMode;
      }

      // () => Number
      getInterval() {
        return this._state.interval;
      }

      // () => Number
      getPenX() {
        return this._state.getPenX();
      }

      // () => Array[PlotPoint]
      getPoints() {
        return this._points;
      }

      // (ExportedPen) => Unit
      importState({
          color: penColor,
          interval,
          mode,
          isPenDown,
          points,
          x: penX
        }) {
        var xs, ys;
        points.forEach(({
            color,
            isPenDown: isPointVisible,
            x,
            y
          }) => {
          var penMode;
          penMode = isPointVisible ? (this.lower(), Down) : (this.raise(), Up);
          this._points.push(new PlotPoint(x, y, penMode, color));
          this._ops.addPoint(x, y);
        });
        xs = this._points.map(function(p) {
          return p.x;
        });
        ys = this._points.map(function(p) {
          return p.y;
        });
        this._bounds = [Math.min(...xs), Math.max(...xs), Math.min(...ys), Math.max(...ys)];
        if (isPenDown) {
          this.lower();
        } else {
          this.raise();
        }
        this.setColor(penColor);
        this.setInterval(interval);
        this._state.leapCounterTo(penX);
        this.updateDisplayMode(displayModeFromString(mode));
      }

      // () => Unit
      lower() {
        this._state.mode = Down;
      }

      // () => Unit
      raise() {
        this._state.mode = Up;
      }

      // (Boolean) => Unit
      reset(isSoftResetting = false) {
        this._bounds = void 0;
        this._state = (this._state != null) && (isSoftResetting || this.isTemp) ? this._state.partiallyReset() : this._defaultState.clone();
        this._points = [];
        this._ops.reset();
        this._ops.updateMode(this._state.displayMode);
      }

      // (Number|RGB) => Unit
      setColor(color) {
        var trueColor;
        trueColor = isNumber(color) ? color : ColorModel.nearestColorNumberOfRGB(...color);
        this._state.color = trueColor;
        this._ops.updateColor(trueColor);
      }

      // P.S. I find it _hilarious_ that this can take '0' and negative numbers --JAB (9/22/14)
      // (Number) => Unit
      setInterval(interval) {
        this._state.interval = interval;
      }

      // () => Unit
      setup() {
        this._setupThis();
      }

      // () => Unit
      update() {
        this._updateThis();
      }

      // (DisplayMode) => Unit
      updateDisplayMode(newMode) {
        this._state.displayMode = newMode;
        this._ops.updateMode(newMode);
      }

      // (Number, Number) => Unit
      _addPoint(x, y) {
        this._points.push(new PlotPoint(x, y, this._state.mode, this._state.color));
        this._updateBounds(x, y);
        this._ops.addPoint(x, y);
      }

      // (Number, Number) => Unit
      _updateBounds(x, y) {
        var maxX, maxY, minX, minY;
        this._bounds = this._bounds != null ? ([minX, maxX, minY, maxY] = this._bounds, [Math.min(minX, x), Math.max(maxX, x), Math.min(minY, y), Math.max(maxY, y)]) : [x, x, y, y];
      }

    };

    Pen.prototype._bounds = void 0; // (Number, Number, Number, Number)

    Pen.prototype._ops = void 0; // PenOps

    Pen.prototype._points = void 0; // Array[PlotPoint]

    Pen.prototype._state = void 0; // State

    return Pen;

  }).call(this);

}).call(this);

},{"brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/object":"brazier/object","brazierjs/type":"brazier/type","engine/core/colormodel":"engine/core/colormodel","shim/strictmath":"shim/strictmath","util/exception":"util/exception"}],"engine/plot/plotmanager":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var None, PlotManager, displayModeFromNum, exceptions, filter, flatMapMaybe, flip, fold, forEach, isNumber, map, mapMaybe, maybe, pipeline, toObject, values, zip;

  ({
    DisplayMode: {displayModeFromNum}
  } = require('./pen'));

  ({filter, forEach, map, toObject, zip} = require('brazierjs/array'));

  ({flip, pipeline} = require('brazierjs/function'));

  ({
    flatMap: flatMapMaybe,
    fold,
    map: mapMaybe,
    maybe,
    None
  } = require('brazierjs/maybe'));

  ({values} = require('brazierjs/object'));

  ({isNumber} = require('brazierjs/type'));

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  module.exports = PlotManager = (function() {
    class PlotManager {
      
        // (Array[Plot]) => PlotManager
      constructor(plots) {
        var toName;
        // () => Unit
        this.setupPlots = this.setupPlots.bind(this);
        // () => Unit
        this.updatePlots = this.updatePlots.bind(this);
        toName = function(p) {
          return p.name.toUpperCase();
        };
        this._currentPlotMaybe = maybe(plots[plots.length - 1]);
        this._plotMap = pipeline(map(toName), flip(zip)(plots), toObject)(plots);
      }

      // (Plot) => Unit
      addPlot(plot) {
        var name;
        name = plot.name.toUpperCase();
        if (this._plotMap[name] == null) {
          this._plotMap[name] = plot;
        }
      }

      // () => Unit
      clearAllPlots() {
        this._forAllPlots(function(plot) {
          return plot.clear();
        });
      }

      // () => Unit
      clearPlot() {
        this._withPlot(function(plot) {
          return plot.clear();
        });
      }

      // (String) => Unit
      createTemporaryPen(name) {
        this._withPlot(function(plot) {
          return plot.createTemporaryPen(name);
        });
      }

      // () => Unit
      disableAutoplotting() {
        this._withPlot(function(plot) {
          return plot.disableAutoplotting();
        });
      }

      // () => Unit
      disableAutoplotX() {
        this._withPlot(function(plot) {
          return plot.disableAutoplotX();
        });
      }

      // () => Unit
      disableAutoplotY() {
        this._withPlot(function(plot) {
          return plot.disableAutoplotY();
        });
      }

      // (Array[Any]) => Unit
      drawHistogramFrom(list) {
        this._withPlot(function(plot) {
          var numbers;
          numbers = filter(isNumber)(list);
          return plot.drawHistogramFrom(numbers);
        });
      }

      // () => Unit
      enableAutoplotting() {
        this._withPlot(function(plot) {
          return plot.enableAutoplotting();
        });
      }

      // () => Unit
      enableAutoplotX() {
        this._withPlot(function(plot) {
          return plot.enableAutoplotX();
        });
      }

      // () => Unit
      enableAutoplotY() {
        this._withPlot(function(plot) {
          return plot.enableAutoplotY();
        });
      }

      // () => Maybe[Plot]
      getCurrentPlotMaybe() {
        return this._currentPlotMaybe;
      }

      // () => String
      getPlotName() {
        return this._withPlot(function(plot) {
          return plot.name;
        });
      }

      // () => Array[Plot]
      getPlots() {
        return values(this._plotMap);
      }

      // () => Number
      getPlotXMax() {
        return this._withPlot(function(plot) {
          return plot.xMax;
        });
      }

      // () => Number
      getPlotXMin() {
        return this._withPlot(function(plot) {
          return plot.xMin;
        });
      }

      // () => Number
      getPlotYMax() {
        return this._withPlot(function(plot) {
          return plot.yMax;
        });
      }

      // () => Number
      getPlotYMin() {
        return this._withPlot(function(plot) {
          return plot.yMin;
        });
      }

      // (String) => Boolean
      hasPenWithName(name) {
        return this._withPlot(function(plot) {
          return plot.hasPenWithName(name);
        });
      }

      // (ExportedPlotManager) => Unit
      importState({currentPlotNameOrNull, plots}) {
        plots.forEach((plot) => {
          var ref;
          return (ref = this._lookupPlot(plot.name)) != null ? ref.importState(plot) : void 0;
        });
        this._currentPlotMaybe = flatMapMaybe((name) => {
          return maybe(this._lookupPlot(name));
        })(maybe(currentPlotNameOrNull));
      }

      // () => Boolean
      isAutoPlotting() {
        return this._withPlot(function(plot) {
          return plot.isAutoPlotting();
        });
      }

      // () => Boolean
      isAutoPlotX() {
        return this._withPlot(function(plot) {
          return plot.isAutoPlotX;
        });
      }

      // () => Boolean
      isAutoPlotY() {
        return this._withPlot(function(plot) {
          return plot.isAutoPlotY;
        });
      }

      // () => Unit
      lowerPen() {
        this._withPlot(function(plot) {
          return plot.lowerPen();
        });
      }

      plotPoint(x, y) {
        this._withPlot(function(plot) {
          return plot.plotPoint(x, y);
        });
      }

      // (Number) => Unit
      plotValue(value) {
        this._withPlot(function(plot) {
          return plot.plotValue(value);
        });
      }

      // () => Unit
      raisePen() {
        this._withPlot(function(plot) {
          return plot.raisePen();
        });
      }

      // (String) => Unit
      removePlot(name) {
        var f, target, upperName;
        upperName = name.toUpperCase();
        target = this._lookupPlot(upperName);
        if (target != null) {
          f = function(p) {
            if (p === target) {
              return this._currentPlotMaybe = None;
            }
          };
          fold(function() {})(f)(this._currentPlotMaybe);
          delete this._plotMap[upperName];
        }
      }

      // () => Unit
      resetPen() {
        this._withPlot(function(plot) {
          return plot.resetPen();
        });
      }

      // (String) => Unit
      setCurrentPen(name) {
        this._withPlot(function(plot) {
          return plot.setCurrentPen(name);
        });
      }

      // (String) => Unit
      setCurrentPlot(name) {
        var plot;
        plot = this._lookupPlot(name);
        if (plot != null) {
          this._currentPlotMaybe = maybe(plot);
        } else {
          throw exceptions.runtime(`no such plot: \"${name}\"`, "set-current-plot");
        }
      }

      // (Number) => Unit
      setHistogramBarCount(num) {
        if (num > 0) {
          this._withPlot(function(plot) {
            return plot.setHistogramBarCount(num);
          });
        } else {
          throw exceptions.runtime(`You cannot make a histogram with ${num} bars.`, "set-histogram-num-bars");
        }
      }

      // (Number) => Unit
      setPenColor(color) {
        this._withPlot(function(plot) {
          return plot.setPenColor(color);
        });
      }

      // (Number) => Unit
      setPenInterval(color) {
        this._withPlot(function(plot) {
          return plot.setPenInterval(color);
        });
      }

      // (Number) => Unit
      setPenMode(num) {
        this._withPlot(function(plot) {
          return plot.updateDisplayMode(displayModeFromNum(num));
        });
      }

      setupPlots() {
        this._forAllPlots(function(plot) {
          return plot.setup();
        });
      }

      // (Number, Number) => Unit
      setXRange(min, max) {
        this._withPlot(function(plot) {
          return plot.setXRange(min, max);
        });
      }

      // (Number, Number) => Unit
      setYRange(min, max) {
        this._withPlot(function(plot) {
          return plot.setYRange(min, max);
        });
      }

      updatePlots() {
        this._forAllPlots(function(plot) {
          return plot.update();
        });
      }

      // [T] @ (String, String) => (() => T) => T
      withTemporaryContext(plotName, penName) {
        return (f) => {
          var oldPlotMaybe, result, tempPlotMaybe;
          oldPlotMaybe = this._currentPlotMaybe;
          tempPlotMaybe = maybe(this._lookupPlot(plotName));
          this._currentPlotMaybe = tempPlotMaybe;
          result = penName != null ? mapMaybe(function(tempPlot) {
            return tempPlot.withTemporaryContext(penName)(f);
          })(tempPlotMaybe) : f();
          this._currentPlotMaybe = oldPlotMaybe;
          return result;
        };
      }

      // ((Plot) => Unit) => Unit
      _forAllPlots(f) {
        pipeline(values, forEach(f))(this._plotMap);
      }

      // (String) => Plot
      _lookupPlot(name) {
        var f, plot, ref, upperName;
        upperName = name.toUpperCase();
        plot = this._plotMap[upperName];
        if (plot != null) {
          return plot;
        } else {
          f = function([k, v]) {
            return k.match(`__HNW_ROLE_[^_]+_${upperName}`) != null;
          };
          return (ref = Object.entries(this._plotMap).find(f)) != null ? ref[1] : void 0;
        }
      }

      // [T] @ ((Plot) => T) => T
      _withPlot(f) {
        var error;
        error = new Error("There is no current plot. Please select a current plot using the set-current-plot command.");
        return fold(function() {
          throw error;
        })(f)(this._currentPlotMaybe);
      }

    };

    PlotManager.prototype._currentPlotMaybe = void 0; // Maybe[Plot]

    PlotManager.prototype._plotMap = void 0; // Object[String, Plot]

    return PlotManager;

  }).call(this);

}).call(this);

},{"./pen":"engine/plot/pen","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/maybe":"brazier/maybe","brazierjs/object":"brazier/object","brazierjs/type":"brazier/type","util/exception":"util/exception"}],"engine/plot/plotops":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ColorModel, PenOps, PlottingOps;

  ColorModel = require('../core/colormodel');

  PenOps = (function() {
    class PenOps {
      constructor(plottingOps, pen) {
        this.addPoint = plottingOps.addPoint(pen);
        this.reset = plottingOps.resetPen(pen);
        this.updateMode = plottingOps.updatePenMode(pen);
        this.updateColor = plottingOps.updatePenColor(pen);
      }

    };

    PenOps.prototype.addPoint = void 0; // (Number, Number) => Unit

    PenOps.prototype.reset = void 0; // () => Unit

    PenOps.prototype.updateMode = void 0; // (Pen.Mode) => Unit

    PenOps.prototype.updateColor = void 0; // (NLColor) => Unit

    return PenOps;

  }).call(this);

  module.exports = PlottingOps = class PlottingOps {
    // ((Number, Number, Number, Number) => Unit, (Plot) => Unit, (Pen) => Unit, (Pen) => () => Unit, (Pen) => (Number, Number) => Unit, (Pen) => (Pen.DisplayMode) => Unit, (Pen) => (NLColor) => Unit) => PlotOps
    constructor(resize, reset, registerPen, resetPen, addPoint, updatePenMode, updatePenColor) {
      // (Pen) => PenOps
      this.makePenOps = this.makePenOps.bind(this);
      this.resize = resize;
      this.reset = reset;
      this.registerPen = registerPen;
      this.resetPen = resetPen;
      this.addPoint = addPoint;
      this.updatePenMode = updatePenMode;
      this.updatePenColor = updatePenColor;
    }

    // (Number) => String
    colorToRGBString(color) {
      var b, g, r;
      [r, g, b] = ColorModel.colorToRGB(color);
      return `rgb(${r}, ${g}, ${b})`;
    }

    makePenOps(pen) {
      return new PenOps(this, pen);
    }

  };

}).call(this);

},{"../core/colormodel":"engine/core/colormodel"}],"engine/plot/plot":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Pen, Plot, StopInterrupt, StrictMath, exceptions, filter, flatMapMaybe, flip, fold, forEach, id, isEmpty, isSomething, lookup, map, maxBy, maybe, pipeline, toObject, values, zip;

  ({Pen} = require('./pen'));

  StrictMath = require('shim/strictmath');

  ({filter, forEach, isEmpty, map, maxBy, toObject, zip} = require('brazierjs/array'));

  ({flip, id, pipeline} = require('brazierjs/function'));

  ({
    flatMap: flatMapMaybe,
    fold,
    isSomething,
    maybe
  } = require('brazierjs/maybe'));

  ({lookup, values} = require('brazierjs/object'));

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({StopInterrupt} = require('util/interrupts'));

  module.exports = Plot = (function() {
    class Plot {
      
        // (String, Array[Pen], PlotOps, String, String, Boolean, Boolean, Boolean,
      //    Number, Number, Number, Number, () => (Unit | StopInterrupt), () => (Unit | StopInterrupt)) => Plot
      constructor(name1, pens = [], _ops, xLabel, yLabel, isLegendEnabled = true, isAutoPlotX = true, isAutoPlotY = true, xMin = 0, xMax = 10, yMin = 0, yMax = 10, _setupThis = (function() {}), _updateThis = (function() {})) {
        var toName;
        // (String) => Maybe[Pen]
        this._getPenMaybeByName = this._getPenMaybeByName.bind(this);
        this.name = name1;
        this._ops = _ops;
        this.xLabel = xLabel;
        this.yLabel = yLabel;
        this.isLegendEnabled = isLegendEnabled;
        this.isAutoPlotX = isAutoPlotX;
        this.isAutoPlotY = isAutoPlotY;
        this.xMin = xMin;
        this.xMax = xMax;
        this.yMin = yMin;
        this.yMax = yMax;
        this._setupThis = _setupThis;
        this._updateThis = _updateThis;
        toName = function(p) {
          return p.name.toUpperCase();
        };
        this._currentPenMaybe = maybe(pens[0]);
        this._originalBounds = [this.xMin, this.xMax, this.yMin, this.yMax];
        this._penMap = pipeline(map(toName), flip(zip)(pens), toObject)(pens);
        this.clear();
      }

      // () => Unit
      clear() {
        var deletePen, pens, resetPen;
        [this.xMin, this.xMax, this.yMin, this.yMax] = this._originalBounds;
        this._ops.reset(this);
        this._resize();
        pens = this.getPens();
        deletePen = ((x) => {
          delete this._penMap[x.name.toUpperCase()];
        });
        resetPen = ((pen) => {
          pen.reset();
          this._ops.registerPen(pen);
        });
        pipeline(filter(function(x) {
          return x.isTemp;
        }), forEach(deletePen))(pens);
        pipeline(filter(function(x) {
          return !x.isTemp;
        }), forEach(resetPen))(pens);
        if ((this._currentPenMaybe == null) || fold(function() {
          return false;
        })(function(cp) {
          return cp.isTemp;
        })(this._currentPenMaybe)) {
          this._currentPenMaybe = maybe(isEmpty(pens) ? (this._penMap.DEFAULT = new Pen("DEFAULT", this._ops.makePenOps), this._penMap.DEFAULT) : pens[0]);
        }
      }

      // (String) => Unit
      createTemporaryPen(name) {
        this._currentPenMaybe = maybe(this._createAndReturnTemporaryPen(name));
      }

      // () => Unit
      disableAutoplotting() {
        this.isAutoPlotX = false;
        this.isAutoPlotY = false;
      }

      // () => Unit
      disableAutoplotX() {
        this.isAutoPlotX = false;
      }

      // () => Unit
      disableAutoplotY() {
        this.isAutoPlotY = false;
      }

      // (Array[Number]) => Unit
      drawHistogramFrom(list) {
        this._withPen((pen) => {
          if (pen.getInterval() > 0) {
            pen.drawHistogramFrom(list, this.xMin, this.xMax);
            return this._verifyHistogramSize(pen);
          } else {
            throw exceptions.runtime(`You cannot histogram with a plot-pen-interval of ${pen.interval}.`, "histogram");
          }
        });
      }

      // () => Unit
      enableAutoplotting() {
        this.isAutoPlotX = true;
        this.isAutoPlotY = true;
      }

      // () => Unit
      enableAutoplotX() {
        this.isAutoPlotX = true;
      }

      // () => Unit
      enableAutoplotY() {
        this.isAutoPlotY = true;
      }

      // () => Boolean
      isAutoPlotting() {
        return this.isAutoPlotX && this.isAutoPlotY;
      }

      // () => Maybe[Pen]
      getCurrentPenMaybe() {
        return this._currentPenMaybe;
      }

      // () => Array[Pen]
      getPens() {
        return values(this._penMap);
      }

      // (String) => Boolean
      hasPenWithName(name) {
        return pipeline(this._getPenMaybeByName, isSomething)(name);
      }

      // (ExportedPlot) => Unit
      importState({
          currentPenNameOrNull,
          isAutoPlotX,
          isAutoPlotY,
          isLegendOpen: isLegendEnabled,
          pens,
          xMax,
          xMin,
          yMax,
          yMin
        }) {
        this.isAutoPlotX = isAutoPlotX;
        this.isAutoPlotY = isAutoPlotY;
        this.isLegendEnabled = isLegendEnabled;
        this.xMax = xMax;
        this.xMin = xMin;
        this.yMax = yMax;
        this.yMin = yMin;
        pens.forEach((pen) => {
          return this._createAndReturnTemporaryPen(pen.name).importState(pen);
        });
        this._currentPenMaybe = this._getPenMaybeByName(currentPenNameOrNull);
        this._resize();
      }

      // () => Unit
      lowerPen() {
        this._withPen(function(pen) {
          return pen.lower();
        });
      }

      // (Number, Number) => Unit
      plotPoint(x, y) {
        this._withPen((pen) => {
          pen.addXY(x, y);
          return this._verifySize(x, y);
        });
      }

      // (Number) => Unit
      plotValue(value) {
        this._withPen((pen) => {
          var x;
          x = pen.addValue(value);
          return this._verifySize(x, value);
        });
      }

      // () => Unit
      raisePen() {
        this._withPen(function(pen) {
          return pen.raise();
        });
      }

      // () => Unit
      resetPen() {
        this._withPen(function(pen) {
          return pen.reset();
        });
      }

      // (String) => Unit
      setCurrentPen(name) {
        var penMaybe;
        penMaybe = this._getPenMaybeByName(name);
        if (isSomething(penMaybe)) {
          this._currentPenMaybe = penMaybe;
        } else {
          throw exceptions.runtime(`There is no pen named \"${name}\" in the current plot`, "set-current-plot-pen");
        }
      }

      // (Number) => Unit
      setHistogramBarCount(num) {
        this._withPen((pen) => {
          var interval;
          if (num >= 1) {
            interval = (this.xMax - this.xMin) / num;
            return pen.setInterval(interval);
          } else {
            throw exceptions.runtime(`You cannot make a histogram with ${num} bars.`, "set-histogram-num-bars");
          }
        });
      }

      // (Number|RGB) => Unit
      setPenColor(color) {
        this._withPen(function(pen) {
          return pen.setColor(color);
        });
      }

      // (Number) => Unit
      setPenInterval(num) {
        this._withPen(function(pen) {
          return pen.setInterval(num);
        });
      }

      // () => Unit
      setup() {
        var setupResult;
        setupResult = this._setupThis();
        if (!(setupResult === StopInterrupt)) {
          this.getPens().forEach(function(pen) {
            return pen.setup();
          });
        }
      }

      // (Number, Number) => Unit
      setXRange(min, max) {
        if (min >= max) {
          throw exceptions.runtime(`the minimum must be less than the maximum, but ${min} is greater than or equal to ${max}`, "set-plot-x-range");
        }
        this.xMin = min;
        this.xMax = max;
        this._resize();
      }

      // (Number, Number) => Unit
      setYRange(min, max) {
        if (min >= max) {
          throw exceptions.runtime(`the minimum must be less than the maximum, but ${min} is greater than or equal to ${max}`, "set-plot-y-range");
        }
        this.yMin = min;
        this.yMax = max;
        this._resize();
      }

      // () => Unit
      update() {
        var updateResult;
        updateResult = this._updateThis();
        if (!(updateResult === StopInterrupt)) {
          this.getPens().forEach(function(pen) {
            return pen.update();
          });
        }
      }

      // (DisplayMode) => Unit
      updateDisplayMode(newMode) {
        this._withPen(function(pen) {
          return pen.updateDisplayMode(newMode);
        });
      }

      // (String) => (() => Unit) => Unit
      withTemporaryContext(penName) {
        return (f) => {
          var oldPenMaybe;
          oldPenMaybe = this._currentPenMaybe;
          this._currentPenMaybe = this._getPenMaybeByName(penName);
          f();
          this._currentPenMaybe = oldPenMaybe;
        };
      }

      // (String) => Pen
      _createAndReturnTemporaryPen(name) {
        var makeNew;
        makeNew = () => {
          var pen;
          pen = new Pen(name, this._ops.makePenOps, true);
          this._penMap[pen.name.toUpperCase()] = pen;
          this._ops.registerPen(pen);
          return pen;
        };
        return pipeline(this._getPenMaybeByName, fold(makeNew)(id))(name);
      }

      _getPenMaybeByName(name) {
        return flatMapMaybe((name) => {
          return lookup(name.toUpperCase())(this._penMap);
        })(maybe(name));
      }

      // (Number, Number, Number, Number) => Unit
      _resize() {
        return this._ops.resize(this.xMin, this.xMax, this.yMin, this.yMax);
      }

      // The below functions `_prettyRange()` and `_expandRange()` are copied directly from the NetLogo desktop versions.
      // More comments on them are in that repo.  -Jeremy B May 2025

        // (Number) -> Number
      _prettyRange(range) {
        var tmag;
        tmag = Math.pow(10, Math.floor(Math.log10(range)) - 1) * 2;
        return Math.ceil(range / tmag) * tmag;
      }

      // (Number, Number, Number) -> Number
      _expandRange(min, max, newValue) {
        var newMax, newMin, newRange, shift, tempMax, tempMin, tempRange, tempValue;
        shift = -min;
        tempMin = 0;
        tempMax = max + shift;
        tempValue = newValue + shift;
        if (tempValue < 0) {
          tempRange = tempMax - tempValue;
          newRange = this._prettyRange(tempRange);
          newMin = (tempMax - newRange) - shift;
          return newMin;
        } else {
          tempRange = tempValue - tempMin;
          newRange = this._prettyRange(tempRange);
          newMax = (newRange + tempMin) - shift;
          return newMax;
        }
      }

      // Histograms can only change the size of the plot by increasing the maximum Y value
      // (and only when autoplotting is on). --JAB (2/11/15)

      // (Pen) => Unit
      _verifyHistogramSize(pen) {
        var isWithinBounds, penYMax;
        isWithinBounds = ({x}) => {
          return x >= this.xMin && x <= this.xMax;
        };
        if (this.isAutoPlotY) {
          penYMax = pipeline(filter(isWithinBounds), map(function(p) {
            return p.y;
          }), maxBy(id), fold(function() {
            return 0;
          })(id))(pen.getPoints());
          if (penYMax > this.yMax) {
            this.yMax = this._expandRange(this.yMin, this.yMax, penYMax);
          }
        }
        this._resize();
      }

      // (Number, Number) => Unit
      _verifySize(x, y) {
        var bumpMax, bumpMin, newXMax, newXMin, newYMax, newYMin;
        bumpMin = (newMin, currentMin, currentMax) => {
          if (newMin < currentMin) {
            return this._expandRange(currentMin, currentMax, newMin);
          } else {
            return currentMin;
          }
        };
        bumpMax = (newMax, currentMin, currentMax) => {
          if (newMax > currentMax) {
            return this._expandRange(currentMin, currentMax, newMax);
          } else {
            return currentMax;
          }
        };
        newXMin = bumpMin(x, this.xMin, this.xMax);
        newXMax = bumpMax(x, this.xMin, this.xMax);
        newYMin = bumpMin(y, this.yMin, this.yMax);
        newYMax = bumpMax(y, this.yMin, this.yMax);
        // If bounds extended, we must resize, regardless of whether or not autoplotting is enabled, because some
        // libraries force autoscaling, but we only _expand_ the boundaries when autoplotting. --JAB (10/10/14)
        if (newXMin !== this.xMin || newXMax !== this.xMax || newYMin !== this.yMin || newYMax !== this.yMax) {
          if (this.isAutoPlotX) {
            this.xMin = newXMin;
            this.xMax = newXMax;
          }
          if (this.isAutoPlotY) {
            this.yMin = newYMin;
            this.yMax = newYMax;
          }
          this._resize();
        }
      }

      // [T] @ ((Pen) => T) => T
      _withPen(f) {
        return fold(() => {
          throw exceptions.runtime(`Plot '${this.name}' has no pens!`, "plot");
        })(f)(this._currentPenMaybe);
      }

    };

    Plot.prototype._currentPenMaybe = void 0; // Maybe[Pen]

    Plot.prototype._originalBounds = void 0; // (Number, Number, Number, Number)

    Plot.prototype._penMap = void 0; // Object[String, Pen]

    Plot.prototype.name = void 0; // String

    return Plot;

  }).call(this);

}).call(this);

},{"./pen":"engine/plot/pen","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/maybe":"brazier/maybe","brazierjs/object":"brazier/object","shim/strictmath":"shim/strictmath","util/exception":"util/exception","util/interrupts":"util/interrupts"}],"engine/prim-checks/agentset-checks":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AgentSetChecks, Comparator, checks, getTypeOf, types;

  ({checks, getTypeOf, types} = require('engine/core/typechecker'));

  Comparator = require('util/comparator');

  AgentSetChecks = class AgentSetChecks {
    // `getSelf()` is necessary because the predicates used for `with` and its optimized relatives
    // do not actually take in the agents they check, they assume the `selfManager` on the world
    // will be kept up-to-date for them.  As such this was the best way I could find to get
    // the proper agent to use when those predicates return incorrect values.
    // -Jeremy B February 2021
    constructor(validator, dumper, prims, getSelf) {
      this.validator = validator;
      this.dumper = dumper;
      this.prims = prims;
      this.getSelf = getSelf;
    }

    // (Any) => Boolean
    static isPoint(point) {
      return point.length === 2 && checks.isNumber(point[0]) && checks.isNumber(point[1]);
    }

    // (Any) => Boolean
    static isListOfPoints(points) {
      return points.every(function(point) {
        return checks.isList(point) && AgentSetChecks.isPoint(point);
      });
    }

    // (String, Int, Int, () => Boolean) => (T) => Boolean
    makeCheckedF(prim, sourceStart, sourceEnd, f) {
      return () => {
        var result;
        result = f();
        if (!checks.isBoolean(result)) {
          this.validator.error(prim, sourceStart, sourceEnd, '_ expected a true/false value from _, but got _ instead.', prim, this.getSelf(), this.dumper(result));
        }
        return result;
      };
    }

    // I think it's a little strange that there are three different error messages for the `*-set` agentset creation prims having bad arguments,
    // but at the moment it doesn't seem worth changing desktop to unify them.  -Jeremy B February 2021

      // (String, Int, Int, PatchType | TurtleType | LinkType, PatchSetType | TurtleSetType | LinkSetType, Array[Any]) => Unit
    setCreationListCheck(prim, sourceStart, sourceEnd, agentType, agentSetType, list) {
      return list.forEach((value) => {
        if (checks.isList(value)) {
          return this.setCreationListCheck(prim, sourceStart, sourceEnd, agentType, agentSetType, value);
        } else if (!agentType.isOfType(value) && !agentSetType.isOfType(value) && !checks.isNobody(value)) {
          if (checks.isAgentSet(value)) {
            return this.validator.error(prim, sourceStart, sourceEnd, 'List inputs to _ must only contain _, _ agentset, or list elements.  The list _ contained a different type agentset: _.', prim.toUpperCase(), agentType.niceName(), this.dumper(list), this.dumper(value));
          } else {
            return this.validator.error(prim, sourceStart, sourceEnd, 'List inputs to _ must only contain _, _ agentset, or list elements.  The list _ contained _ which is NOT a _ or _ agentset.', prim.toUpperCase(), agentType.niceName(), this.dumper(list), this.dumper(value));
          }
        }
      });
    }

    // (String, Int, Int, PatchType | TurtleType | LinkType, PatchSetType | TurtleSetType | LinkSetType, Array[Any]) => Unit
    setCreationArgsCheck(prim, sourceStart, sourceEnd, agentType, agentSetType, values) {
      return values.forEach((value) => {
        if (checks.isList(value)) {
          return this.setCreationListCheck(prim, sourceStart, sourceEnd, agentType, agentSetType, value);
        } else if (!agentType.isOfType(value) && !agentSetType.isOfType(value) && !checks.isNobody(value)) {
          return this.validator.error(prim, sourceStart, sourceEnd, '_ expected input to be a _ agentset or _ but got _ instead.', prim.toUpperCase(), agentType.niceName(), this.validator.valueToString(value));
        }
      });
    }

    // (AgentSet[T]) => Boolean
    any(agentset) {
      return !agentset.isEmpty();
    }

    // (Int, Int, AgentSet[T], () => Boolean) => Boolean
    anyOtherWith(sourceStart, sourceEnd, agentset, f) {
      this.validator.commonArgChecks.agentSet("WITH", sourceStart, sourceEnd, Array.from(arguments).slice(2));
      return agentset._optimalAnyOtherWith(this.makeCheckedF("WITH", sourceStart, sourceEnd, f));
    }

    // (Int, Int, AgentSet[T], () => Boolean) => Boolean
    anyWith(sourceStart, sourceEnd, agentset, f) {
      this.validator.commonArgChecks.agentSet("WITH", sourceStart, sourceEnd, Array.from(arguments).slice(2));
      return agentset._optimalAnyWith(this.makeCheckedF("WITH", sourceStart, sourceEnd, f));
    }

    // (Int, Int, AgentSet[T], (T) => Boolean) => Boolean
    all(sourceStart, sourceEnd, agentset, f) {
      return agentset.agentAll(this.makeCheckedF("ALL?", sourceStart, sourceEnd, f));
    }

    // (Int, Int, AgentSet[T], Array[Array[Number]]) => AgentSet
    atPoints(sourceStart, sourceEnd, agentset, coords) {
      if (!AgentSetChecks.isListOfPoints(coords)) {
        this.validator.error('at-points', sourceStart, sourceEnd, 'Invalid list of points: _', this.dumper(coords));
      }
      return agentset.atPoints(coords);
    }

    // (String, Patch | Turtle | PatchSet | TurtleSet) => AgentSet
    breedOn(breedName, target) {
      if (checks.isAgentSet(target)) {
        return this.prims.breedOnAgentSet(breedName, target);
      } else {
        return this.prims.breedOnAgent(breedName, target);
      }
    }

    // (String, Patch | Turtle | PatchSet | TurtleSet) => Boolean
    anyBreedOn(breedName, target) {
      if (checks.isAgentSet(target)) {
        return this.prims.anyBreedOnAgentSet(breedName, target);
      } else {
        return this.prims.anyBreedOnAgent(breedName, target);
      }
    }

    // (AgentSet[T]) => Number
    count(agentset) {
      return agentset.size();
    }

    // (Int, Int, AgentSet[T], () => Boolean) => Number
    countOtherWith(sourceStart, sourceEnd, agentset, f) {
      this.validator.commonArgChecks.agentSet("WITH", sourceStart, sourceEnd, Array.from(arguments).slice(2));
      return agentset._optimalCountOtherWith(this.makeCheckedF("WITH", sourceStart, sourceEnd, f));
    }

    // (Int, Int, AgentSet[T], () => Boolean) => Number
    countWith(sourceStart, sourceEnd, agentset, f) {
      this.validator.commonArgChecks.agentSet("WITH", sourceStart, sourceEnd, Array.from(arguments).slice(2));
      return agentset._optimalCountWith(this.makeCheckedF("WITH", sourceStart, sourceEnd, f));
    }

    // [T <: (Array[Link]|Link|AbstractAgentSet[Link])] @ (Int, Int, T*) => LinkSet
    linkSet(sourceStart, sourceEnd, ...values) {
      this.setCreationArgsCheck('link-set', sourceStart, sourceEnd, types.Link, types.LinkSet, values);
      return this.prims.linkSet(values);
    }

    // (Int, Int, AgentSet[T], Number, (T) => Number) => AgentSet[T]
    maxNOf(sourceStart, sourceEnd, agentset, n, f) {
      if (n > agentset.size()) {
        this.validator.error('max-n-of', sourceStart, sourceEnd, 'Requested _ random agents from a set of only _ agents.', n, agentset.size());
      }
      if (n < 0) {
        this.validator.error('max-n-of', sourceStart, sourceEnd, 'First input to _ can_t be negative.', "MAX-N-OF");
      }
      return agentset.maxNOf(n, f);
    }

    // (AgentSet[T], (T) => Number) => AgentSet
    maxOneOf(agentset, f) {
      return agentset.maxOneOf(f);
    }

    // (Int, Int, AgentSet[T], Number, (T) => Number) => AgentSet[T]
    minNOf(sourceStart, sourceEnd, agentset, n, f) {
      if (n > agentset.size()) {
        this.validator.error('min-n-of', sourceStart, sourceEnd, 'Requested _ random agents from a set of only _ agents.', n, agentset.size());
      }
      if (n < 0) {
        this.validator.error('min-n-of', sourceStart, sourceEnd, 'First input to _ can_t be negative.', "MIN-N-OF");
      }
      return agentset.minNOf(n, f);
    }

    // (AgentSet[T], (T) => Number) => AgentSet
    minOneOf(agentset, f) {
      return agentset.minOneOf(f);
    }

    // (T | AgentSet[T], (T) => U) => U | List[U]
    of(agentOrAgentset, f) {
      return agentOrAgentset.projectionBy(f);
    }

    // (Int, Int, AgentSet[T], () => Boolean) => T
    oneOfWith(sourceStart, sourceEnd, agentset, f) {
      this.validator.commonArgChecks.agentSet("WITH", sourceStart, sourceEnd, Array.from(arguments).slice(2));
      return agentset._optimalOneOfWith(this.makeCheckedF("WITH", sourceStart, sourceEnd, f));
    }

    // (Int, Int, AgentSet[T], Number, (Number, Number) => Boolean) => Boolean
    optimizeCount(sourceStart, sourceEnd, agentset, n, operator) {
      this.validator.commonArgChecks.agentSet("COUNT", sourceStart, sourceEnd, Array.from(arguments).slice(2));
      return agentset._optimalCheckCount(n, operator);
    }

    // (Int, Int, AgentSet[T], () => Boolean) => AgentSet[T]
    otherWith(sourceStart, sourceEnd, agentset, f) {
      this.validator.commonArgChecks.agentSet("WITH", sourceStart, sourceEnd, Array.from(arguments).slice(2));
      return agentset._optimalOtherWith(this.makeCheckedF("WITH", sourceStart, sourceEnd, f));
    }

    // [T <: (Array[Patch]|Patch|AbstractAgentSet[Patch])] @ (Int, Int, T*) => PatchSet
    patchSet(sourceStart, sourceEnd, ...values) {
      this.setCreationArgsCheck('patch-set', sourceStart, sourceEnd, types.Patch, types.PatchSet, values);
      return this.prims.patchSet(values);
    }

    // (Int, Int, AgentSet[T], () => Number | String | Agent) => AgentSet[T]
    sortOn(sourceStart, sourceEnd, agentset, f) {
      var badFirstType, compare, sortingFunc;
      compare = null;
      badFirstType = false;
      sortingFunc = (arg, arg1) => {
        var arg, arg1, name1, name2, o1, o2, type1, type2;
        arg[0], o1 = arg[1];
        arg1[0], o2 = arg1[1];
        // Picking out the compare functions is a little more logic than I'd like in this error checking layer.
        // But it does move some type checks here, which is good, and it's the easiest way to get the error
        // checks to match up with desktop/headless.  -Jeremy B Fabruary 2021
        if (compare === null) {
          compare = checks.isNumber(o1) ? function(n1, n2) {
            return Comparator.numericCompare(n1, n2).toInt;
          } : checks.isString(o1) ? function(s1, s2) {
            return Comparator.stringCompare(s1, s2).toInt;
          } : checks.isAgent(o1) ? function(a1, a2) {
            return a1.compare(a2).toInt;
          } : (badFirstType = true, null);
        }
        type1 = getTypeOf(o1);
        type2 = getTypeOf(o2);
        if (type1 !== type2 || badFirstType) {
          name1 = this.validator.addIndefiniteArticle(type1.niceName());
          name2 = this.validator.addIndefiniteArticle(type2.niceName());
          // The order swap of `name1` and `name2` is intentional to get identical errors to desktop. -Jeremy B February 2021
          this.validator.error('sort-on', sourceStart, sourceEnd, 'SORT-ON works on numbers, strings, or agents of the same type, but not on _ and _', name2, name1);
        }
        return compare(o1, o2);
      };
      return agentset.sortOn(f, sortingFunc);
    }

    // (Agent | AgentSet) => TurtleSet
    turtlesOn(agentOrAgentset) {
      if (checks.isAgentSet(agentOrAgentset)) {
        return this.prims.turtlesOnAgentSet(agentOrAgentset);
      } else {
        return this.prims.turtlesOnAgent(agentOrAgentset);
      }
    }

    // (Agent | AgentSet) => Boolean
    anyTurtlesOn(agentOrAgentset) {
      if (checks.isAgentSet(agentOrAgentset)) {
        return this.prims.anyTurtlesOnAgentSet(agentOrAgentset);
      } else {
        return this.prims.anyTurtlesOnAgent(agentOrAgentset);
      }
    }

    // [T <: (Array[Turtle]|Turtle|AbstractAgentSet[Turtle])] @ (Int, Int, T*) => TurtleSet
    turtleSet(sourceStart, sourceEnd, ...values) {
      this.setCreationArgsCheck('turtle-set', sourceStart, sourceEnd, types.Turtle, types.TurtleSet, values);
      return this.prims.turtleSet(values);
    }

    // (Int, Int, AgentSet[T], Agent | AgentSet[U]) => AgentSet[T]
    whoAreNot(sourceStart, sourceEnd, source, remove) {
      if (checks.isAgentSet(remove)) {
        return source.removeAll(remove);
      } else {
        return source.remove(remove);
      }
    }

    // (Int, Int, AgentSet[T], () => Boolean) => AgentSet[T]
    with(sourceStart, sourceEnd, agentset, f) {
      return agentset.agentFilter(this.makeCheckedF("WITH", sourceStart, sourceEnd, f));
    }

    // (AgentSet[T], () => Number) => AgentSet[T]
    withMax(agentset, f) {
      return agentset.maxesBy(f);
    }

    // (AgentSet[T], () => Number) => AgentSet[T]
    withMin(agentset, f) {
      return agentset.minsBy(f);
    }

  };

  module.exports = AgentSetChecks;

}).call(this);

},{"engine/core/typechecker":"engine/core/typechecker","util/comparator":"util/comparator"}],"engine/prim-checks/checker":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AgentSetChecks, Checker, ColorChecks, ControlChecks, LinkChecks, ListChecks, MathChecks, PatchChecks, ProcedureChecks, Something, TaskChecks, TurtleChecks, Validator, WorldChecks, checks, exceptions;

  ({Something} = require('brazier/maybe'));

  ({checks} = require('../core/typechecker'));

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  AgentSetChecks = require('./agentset-checks');

  ColorChecks = require('./color-checks');

  ControlChecks = require('./control-checks');

  LinkChecks = require('./link-checks');

  ListChecks = require('./list-checks');

  MathChecks = require('./math-checks');

  PatchChecks = require('./patch-checks');

  ProcedureChecks = require('./procedure-checks');

  TaskChecks = require('./task-checks');

  TurtleChecks = require('./turtle-checks');

  WorldChecks = require('./world-checks');

  Validator = require('./validator');

  Checker = class Checker {
    constructor(i18nBundle, dumper, miscPrims, listPrims, randomPrims, stringPrims, procedurePrims, selfPrims, world) {
      var getSelf;
      getSelf = world.selfManager.self;
      this.validator = new Validator(i18nBundle, dumper);
      this.agentset = new AgentSetChecks(this.validator, dumper, miscPrims, getSelf);
      this.color = new ColorChecks(this.validator);
      this.list = new ListChecks(this.validator, dumper, listPrims, stringPrims);
      this.math = new MathChecks(this.validator, randomPrims);
      this.procedure = new ProcedureChecks(this.validator, procedurePrims);
      this.turtle = new TurtleChecks(this.validator, getSelf, world.turtleManager, world.breedManager);
      this.patch = new PatchChecks(this.validator, getSelf);
      this.link = new LinkChecks(this.validator, getSelf, selfPrims);
      this.task = new TaskChecks(this.validator);
      this.control = new ControlChecks(this.validator);
      this.world = new WorldChecks(this.validator, world);
      this.turtleOrLink = {
        getVariable: (sourceStart, sourceEnd, name) => {
          var bundle;
          bundle = checks.isTurtle(getSelf()) ? this.turtle : this.link;
          return bundle.getVariable(sourceStart, sourceEnd, name);
        },
        setVariable: (sourceStart, sourceEnd, name, value) => {
          var bundle;
          bundle = checks.isTurtle(getSelf()) ? this.turtle : this.link;
          return bundle.setVariable(sourceStart, sourceEnd, name, value);
        }
      };
    }

    // (Int, Int, String) => Unit
    errorPrim(sourceStart, sourceEnd, message) {
      throw exceptions.runtime(message, "error", Something(sourceStart), Something(sourceEnd));
    }

    // (String, Int, Int) => Unit
    imperfectImport(primName, sourceStart, sourceEnd) {
      return this.validator.error(primName, sourceStart, sourceEnd, 'Unfortunately, no perfect equivalent to `_` can be implemented in NetLogo Web.  However, the \'import-a\' and \'fetch\' extensions offer primitives that can accomplish this in both NetLogo and NetLogo Web.', primName);
    }

  };

  module.exports = Checker;

}).call(this);

},{"../core/typechecker":"engine/core/typechecker","./agentset-checks":"engine/prim-checks/agentset-checks","./color-checks":"engine/prim-checks/color-checks","./control-checks":"engine/prim-checks/control-checks","./link-checks":"engine/prim-checks/link-checks","./list-checks":"engine/prim-checks/list-checks","./math-checks":"engine/prim-checks/math-checks","./patch-checks":"engine/prim-checks/patch-checks","./procedure-checks":"engine/prim-checks/procedure-checks","./task-checks":"engine/prim-checks/task-checks","./turtle-checks":"engine/prim-checks/turtle-checks","./validator":"engine/prim-checks/validator","./world-checks":"engine/prim-checks/world-checks","brazier/maybe":"brazier/maybe","util/exception":"util/exception"}],"engine/prim-checks/color-checks":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ColorChecks, ColorModel, checks, invalidColorMsg, isInRange, isProperlySized, isValidColor;

  ColorModel = require('engine/core/colormodel');

  ({checks} = require('engine/core/typechecker'));

  // (Array[_]) => Boolean
  isProperlySized = function(xs) {
    return xs.length === 3 || xs.length === 4;
  };

  // (Number) => Boolean
  isInRange = function(comp) {
    return comp >= 0 && comp <= 255;
  };

  // (Any) => Boolean
  isValidColor = function(color) {
    return checks.isNumber(color) || (checks.isList(color) && isProperlySized(color) && color.every(isInRange));
  };

  invalidColorMsg = 'Color must be a number or a valid RGB/A color list with 3 - 4 numbers that have values between 0 and 255.';

  ColorChecks = class ColorChecks {
    // (Validator)
    constructor(validator) {
      this.validator = validator;
    }

    // (Int, Int, ColorNumber|RGB|ColorName) => RGB
    extractRGB(sourceStart, sourceEnd, color) {
      if (isValidColor(color)) {
        return ColorModel.colorToRGB(color);
      } else {
        return this.validator.error('extract-rgb', sourceStart, sourceEnd, invalidColorMsg);
      }
    }

  };

  module.exports = ColorChecks;

}).call(this);

},{"engine/core/colormodel":"engine/core/colormodel","engine/core/typechecker":"engine/core/typechecker"}],"engine/prim-checks/control-checks":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ControlChecks, checks;

  ({checks} = require('engine/core/typechecker'));

  ControlChecks = class ControlChecks {
    constructor(validator) {
      this.validator = validator;
    }

    multiAssignHasEnoughArgs(sourceStart, sourceEnd, vars, argos) {
      var varsSoFars;
      if (!Array.isArray(argos)) {
        this.validator.error('LET', sourceStart, sourceEnd, "The list of values for _ must be at least as long as the list of names.  We need _ value(s) but only got _ from the list _.", 'LET', vars.length, 0, this.validator.dumper(argos));
      }
      if (argos.length < vars.length) {
        this.validator.error('LET', sourceStart, sourceEnd, "The list of values for _ must be at least as long as the list of names.  We need _ value(s) but only got _ from the list _.", 'LET', vars.length, argos.length, this.validator.dumper(argos));
      }
      varsSoFars = vars.map((v, i) => {
        var a;
        a = argos[i];
        if (v === 0) {
          return [a];
        } else {
          return this.multiAssignHasEnoughArgs(sourceStart, sourceEnd, v, a);
        }
      });
      return argos;
    }

    // (Array[SetVarArray], Array[Any]) => Array[Any]
    linearizeAndValidateArgs(sourceStart, sourceEnd, vars, argos) {
      var varsSoFars;
      if (!Array.isArray(argos)) {
        this.validator.error('SET', sourceStart, sourceEnd, "The list of values for _ must be at least as long as the list of names.  We need _ value(s) but only got _ from the list _.", 'SET', vars.length, 0, this.validator.dumper(argos));
      }
      if (argos.length < vars.length) {
        this.validator.error('SET', sourceStart, sourceEnd, "The list of values for _ must be at least as long as the list of names.  We need _ value(s) but only got _ from the list _.", 'SET', vars.length, argos.length, this.validator.dumper(argos));
      }
      varsSoFars = vars.map((v, i) => {
        var a;
        a = argos[i];
        if (v === 0) {
          return [a];
        } else {
          return this.linearizeAndValidateArgs(sourceStart, sourceEnd, v, a);
        }
      });
      return varsSoFars.flat();
    }

  };

  module.exports = ControlChecks;

}).call(this);

},{"engine/core/typechecker":"engine/core/typechecker"}],"engine/prim-checks/link-checks":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var LinkChecks, TowardsInterrupt, fold, genSetter;

  ({fold} = require('brazierjs/maybe'));

  ({TowardsInterrupt} = require('util/interrupts'));

  // (() => Agent, Validator) => (String, Map[Any, String]) => (Any) => Unit
  genSetter = function(getSelf, validator) {
    return function(name, mappings) {
      return (value) => {
        var link;
        link = getSelf();
        fold(function() {})((error) => {
          var defaultMsg, msg;
          msg = mappings.get(error);
          defaultMsg = `An unknown error occurred when setting the '${name}' of '${link}': ${error}`;
          return validator.error('set', null, null, msg != null ? msg : defaultMsg);
        })(link.setIfValid(name, value));
      };
    };
  };

  LinkChecks = (function() {
    class LinkChecks {
      
        // (Validator, () => Number|Agent, SelfPrims)
      constructor(validator1, getSelf1, selfPrims) {
        var asSetter, colorSetterMappings, invalidRGBMsg, invalidRGBNumberMsg, toSetterPair;
        this.validator = validator1;
        this.getSelf = getSelf1;
        this.selfPrims = selfPrims;
        this._setterChecks = new Map();
        invalidRGBMsg = "An rgb list must contain 3 or 4 numbers 0-255";
        invalidRGBNumberMsg = "RGB values must be 0-255";
        colorSetterMappings = new Map([["Invalid RGB format", invalidRGBMsg], ["Invalid RGB number", invalidRGBNumberMsg]]);
        asSetter = genSetter(this.getSelf, this.validator);
        toSetterPair = function([varName, mappings]) {
          return [varName, asSetter(varName, mappings)];
        };
        this._setterChecks = new Map([["color", colorSetterMappings], ["label-color", colorSetterMappings]].map(toSetterPair));
      }

      // (Int, Int) => Int
      linkHeading(sourceStart, sourceEnd) {
        var heading;
        heading = this.selfPrims.linkHeading();
        if (heading === TowardsInterrupt) {
          this.validator.error('link-heading', sourceStart, sourceEnd, 'there is no heading of a link whose endpoints are in the same position');
        }
        return heading;
      }

      // (Int, Int, String, Any) => Unit
      setVariable(sourceStart, sourceEnd, name, value) {
        var check, link, msgKey, upperName;
        link = this.getSelf();
        if (!link.hasVariable(name)) {
          msgKey = "_ breed does not own variable _";
          upperName = name.toUpperCase();
          this.validator.error('set', sourceStart, sourceEnd, msgKey, link.getBreedName(), upperName);
        } else if (this._setterChecks.has(name)) {
          check = this._setterChecks.get(name);
          check(value);
        } else {
          link.setVariable(name, value);
        }
      }

      // (Int, Int, String) => Any
      getVariable(sourceStart, sourceEnd, name) {
        var link, msgKey, upperName;
        link = this.getSelf();
        if (!link.hasVariable(name)) {
          msgKey = "_ breed does not own variable _";
          upperName = name.toUpperCase();
          return this.validator.error(upperName, sourceStart, sourceEnd, msgKey, link.getBreedName(), upperName);
        } else {
          return link.getVariable(name);
        }
      }

    };

    LinkChecks.prototype._setterChecks = null; // Map[String, (Any) => Unit]

    return LinkChecks;

  }).call(this);

  module.exports = LinkChecks;

}).call(this);

},{"brazierjs/maybe":"brazier/maybe","util/interrupts":"util/interrupts"}],"engine/prim-checks/list-checks":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ListChecks, checks, getTypeOf, types;

  ({checks, getTypeOf, types} = require('engine/core/typechecker'));

  ListChecks = class ListChecks {
    constructor(validator, dumper, listPrims, stringPrims) {
      this.validator = validator;
      this.dumper = dumper;
      this.listPrims = listPrims;
      this.stringPrims = stringPrims;
    }

    // (String, Int, Int, Number, Array[Any] | String) => Unit
    indexBoundsChecks(prim, sourceStart, sourceEnd, index, listOrString, inclusive = true) {
      if (index < 0) {
        this.validator.error(prim, sourceStart, sourceEnd, '_ isn_t greater than or equal to zero.', index);
      }
      if (index > listOrString.length || (inclusive && index === listOrString.length)) {
        this.validator.error(prim, sourceStart, sourceEnd, 'Can_t find element _ of the _ _, which is only of length _.', index, getTypeOf(listOrString).niceName(), this.dumper(listOrString), listOrString.length);
      }
    }

    // (String, Array | String) => Unit
    checkNotEmpty(prim, sourceStart, sourceEnd, listOrString) {
      var argType, primName;
      if (listOrString.length === 0) {
        argType = getTypeOf(listOrString);
        primName = argType === types.String ? prim : prim.toUpperCase();
        return this.validator.error(prim, sourceStart, sourceEnd, '_ got an empty _ as input.', primName, argType.niceName());
      }
    }

    // (String, Int, Int, Array | String) => Array | String
    butFirst(prim, sourceStart, sourceEnd, listOrString) {
      this.checkNotEmpty(prim, sourceStart, sourceEnd, listOrString);
      return this.listPrims.butFirst(listOrString);
    }

    // (String, Int, Int, Array | String) => Array | String
    butLast(prim, sourceStart, sourceEnd, listOrString) {
      this.checkNotEmpty(prim, sourceStart, sourceEnd, listOrString);
      return this.listPrims.butLast(listOrString);
    }

    // (Array[Any] | String) => Boolean
    empty(listOrString) {
      return this.listPrims.empty(listOrString);
    }

    // (Int, Int, (T) => Boolean, Array[T]) => Array[T]
    filter(sourceStart, sourceEnd, f, list) {
      var checkedF;
      checkedF = (item) => {
        var result;
        result = f(item);
        return this.validator.commonValueChecks.boolean("FILTER", sourceStart, sourceEnd, result);
      };
      return this.listPrims.filter(checkedF, list);
    }

    // (Int, Int, Array[Any] | String) => Any | String
    first(sourceStart, sourceEnd, listOrString) {
      if (listOrString.length === 0) {
        this.validator.error('first', sourceStart, sourceEnd, 'List is empty.');
      }
      return this.listPrims.first(listOrString);
    }

    // (Any, Array[Any]) => Array[Any]
    fput(item, list) {
      return this.listPrims.fput(item, list);
    }

    // (Int, Int, Number, Array[Any] | String, Any) => Array[Any] | String
    insertItem(sourceStart, sourceEnd, index, listOrString, item) {
      var inclusive;
      this.indexBoundsChecks('insert-item', sourceStart, sourceEnd, index, listOrString, inclusive = false);
      if (checks.isString(listOrString)) {
        if (!checks.isString(item)) {
          this.validator.throwTypeError("INSERT-ITEM", sourceStart, sourceEnd, item, types.String);
        }
        return this.stringPrims.insertItem(index, listOrString, item);
      } else {
        return this.listPrims.insertItem(index, listOrString, item);
      }
    }

    // (Int, Int, Number, Array[Any] | String) => Any | String
    item(sourceStart, sourceEnd, index, listOrString) {
      this.indexBoundsChecks('item', sourceStart, sourceEnd, index, listOrString);
      return this.listPrims.item(index, listOrString);
    }

    // (Int, Int, Array[Any] | String) => Any | String
    last(sourceStart, sourceEnd, listOrString) {
      if (listOrString.length === 0) {
        this.validator.error('last', sourceStart, sourceEnd, 'List is empty.');
      }
      return this.listPrims.last(listOrString);
    }

    // (Array[Any] | String) => Number
    length(listOrString) {
      return this.listPrims.length(listOrString);
    }

    // (Any, Array[Any]) => Array[Any]
    lput(item, list) {
      return this.listPrims.lput(item, list);
    }

    // (Int, Int, Array[Any]) => Number
    max(sourceStart, sourceEnd, values) {
      var nums;
      nums = values.filter(checks.isNumber);
      if (nums.length < 1) {
        this.validator.error('max', sourceStart, sourceEnd, 'Can_t find the _ of a list with no numbers: __', "maximum", this.dumper(values), "");
      }
      return this.listPrims.max(nums);
    }

    // (Int, Int, Array[Any]) => Number
    mean(sourceStart, sourceEnd, values) {
      var nums;
      nums = values.filter(checks.isNumber);
      if (nums.length < 1) {
        this.validator.error('mean', sourceStart, sourceEnd, 'Can_t find the _ of a list with no numbers: __', "mean", this.dumper(values), ".");
      }
      return this.listPrims.mean(nums);
    }

    // (Int, Int, Array[Any]) => Number
    median(sourceStart, sourceEnd, values) {
      var nums;
      nums = values.filter(checks.isNumber);
      if (nums.length < 1) {
        this.validator.error('median', sourceStart, sourceEnd, 'Can_t find the _ of a list with no numbers: __', "median", this.dumper(values), ".");
      }
      return this.validator.checkNumber('median', sourceStart, sourceEnd, this.listPrims.median(nums));
    }

    // (Any, Array[Any] | AbstractAgentSet | String) => Boolean
    member(item, items) {
      if (checks.isList(items)) {
        return this.listPrims.member(item, items);
      } else if (checks.isString(items)) {
        return this.stringPrims.member(item, items); // agentset
      } else {
        return items.exists(function(a) {
          return item === a;
        });
      }
    }

    // (Int, Int, Array[Any]) => Number
    min(sourceStart, sourceEnd, values) {
      var nums;
      nums = values.filter(checks.isNumber);
      if (nums.length < 1) {
        this.validator.error('min', sourceStart, sourceEnd, 'Can_t find the _ of a list with no numbers: __', "minimum", this.dumper(values), "");
      }
      return this.validator.checkNumber('min', sourceStart, sourceEnd, this.listPrims.min(nums));
    }

    // (Array[Any]) => Array[Any]
    modes(list) {
      return this.listPrims.modes(list);
    }

    // (Int, Int, Number, Array[Any] | AbstractAgentSet) => Array[Any] | AbstractAgentSet
    nOf(sourceStart, sourceEnd, count, agentSetOrList) {
      if (count < 0) {
        this.validator.error('n-of', sourceStart, sourceEnd, 'First input to _ can_t be negative.', "N-OF");
      }
      if (checks.isList(agentSetOrList)) {
        if (agentSetOrList.length < count) {
          this.validator.error('n-of', sourceStart, sourceEnd, 'Requested _ random items from a list of length _.', count, agentSetOrList.length);
        }
        return this.listPrims.nOfList(count, agentSetOrList); // agentset
      } else {
        if (agentSetOrList.size() < count) {
          this.validator.error('n-of', sourceStart, sourceEnd, 'Requested _ random agents from a set of only _ agents.', count, agentSetOrList.size());
        }
        return this.listPrims.nOfAgentSet(count, agentSetOrList);
      }
    }

    // (Int, Int, AbstractAgentSet | Array[Any]) => Agent | Any
    oneOf(sourceStart, sourceEnd, agentSetOrList) {
      if (checks.isList(agentSetOrList)) {
        if (agentSetOrList.length === 0) {
          this.validator.error('one-of', sourceStart, sourceEnd, '_ got an empty _ as input.', "ONE-OF", types.List.niceName());
        }
        return this.listPrims.oneOf(agentSetOrList); // agentset
      } else {
        return agentSetOrList.randomAgent();
      }
    }

    // (Any, Array[Any] | String) => Number
    position(item, listOrString) {
      if (checks.isList(listOrString)) {
        return this.listPrims.position(item, listOrString); // string
      } else {
        return this.stringPrims.position(item, listOrString);
      }
    }

    // (Int, Int, (T, U) => U, Array[T]) => U
    reduce(sourceStart, sourceEnd, f, list) {
      if (list.length === 0) {
        this.validator.error('reduce', sourceStart, sourceEnd, 'The list argument to reduce must not be empty.');
      }
      return this.listPrims.reduce(f, list);
    }

    // (Int, Int, Number...) => Array[Number]
    rangeVariadic(sourceStart, sourceEnd, ...args) {
      if (args.length > 3) {
        this.validator.error('range', sourceStart, sourceEnd, 'range expects at most three arguments');
      }
      switch (args.length) {
        case 1:
          return this.listPrims.rangeUnary(args[0]);
        case 2:
          return this.listPrims.rangeBinary(args[0], args[1]);
        default:
          return this.rangeTernary(sourceStart, sourceEnd, args[0], args[1], args[2]);
      }
    }

    // (Int, Int, Number, Number, Number) => Array[Number]
    rangeTernary(sourceStart, sourceEnd, lowerBound, upperBound, stepSize) {
      if (stepSize === 0) {
        this.validator.error('range', sourceStart, sourceEnd, 'The step-size for range must be non-zero.');
      }
      return this.listPrims.range(lowerBound, upperBound, stepSize);
    }

    // (Int, Int, Any | String, Array[Any] | String) => Array[Any] | String
    remove(sourceStart, sourceEnd, item, listOrString) {
      if (checks.isString(listOrString)) {
        if (!checks.isString(item)) {
          this.validator.throwTypeError("REMOVE", sourceStart, sourceEnd, item, types.String);
        }
        return this.stringPrims.remove(item, listOrString); // list
      } else {
        return this.listPrims.remove(item, listOrString);
      }
    }

    // (Array[Any]) => Array[Any]
    removeDuplicates(list) {
      return this.listPrims.removeDuplicates(list);
    }

    // (Int, Int, Number, Array[Any] | String) => Array[Any] | String
    removeItem(sourceStart, sourceEnd, index, listOrString) {
      this.indexBoundsChecks('remove-item', sourceStart, sourceEnd, index, listOrString);
      if (checks.isString(listOrString)) {
        return this.stringPrims.removeItem(index, listOrString); // list
      } else {
        return this.listPrims.removeItem(index, listOrString);
      }
    }

    // (Int, Int, Number, Array[Any] | String, Any | String) => Array[Any] | String
    replaceItem(sourceStart, sourceEnd, index, listOrString, item) {
      this.indexBoundsChecks('replace-item', sourceStart, sourceEnd, index, listOrString);
      if (checks.isString(listOrString)) {
        if (!checks.isString(item)) {
          this.validator.throwTypeError("REPLACE-ITEM", sourceStart, sourceEnd, item, types.String);
        }
        return this.stringPrims.replaceItem(index, listOrString, item); // list
      } else {
        return this.listPrims.replaceItem(index, listOrString, item);
      }
    }

    // (Array[Any] | String) => Array[Any] | String
    reverse(listOrString) {
      if (checks.isString(listOrString)) {
        return this.stringPrims.reverse(listOrString); // list
      } else {
        return this.listPrims.reverse(listOrString);
      }
    }

    // (Array[Any]) => Array[Any]
    shuffle(list) {
      return this.listPrims.shuffle(list);
    }

    // (Array[Any] | AbstractAgentSet) => Array[Any]
    sort(agentSetOrList) {
      if (checks.isList(agentSetOrList)) {
        return this.listPrims.sort(agentSetOrList); // agentset
      } else {
        return agentSetOrList.sort();
      }
    }

    // (Int, Int, (Any, Any) => Boolean, Array[Any] | AbstractAgentSet) => Array[Any]
    sortBy(sourceStart, sourceEnd, f, agentSetOrList) {
      var checkedF;
      checkedF = (a, b) => {
        var result;
        result = f(a, b);
        return this.validator.commonValueChecks.boolean("SORT-BY", sourceStart, sourceEnd, result);
      };
      if (checks.isList(agentSetOrList)) {
        return this.listPrims.sortByList(checkedF, agentSetOrList); // agentset
      } else {
        return this.listPrims.sortByAgentSet(checkedF, agentSetOrList);
      }
    }

    // (Int, Int, Array[Any]) => Number
    standardDeviation(sourceStart, sourceEnd, values) {
      var nums;
      nums = values.filter(checks.isNumber);
      if (nums.length < 2) {
        this.validator.error('standard-deviation', sourceStart, sourceEnd, 'Can_t find the _ of a list without at least two numbers: __', "standard deviation", this.dumper(values), "");
      }
      return this.validator.checkNumber('standard-deviation', sourceStart, sourceEnd, this.listPrims.standardDeviation(nums));
    }

    // (Int, rray[Any], Number, Number) => Array[Any]
    sublist(sourceStart, sourceEnd, list, startIndex, endIndex) {
      if (startIndex < 0) {
        this.validator.error('sublist', sourceStart, sourceEnd, '_ is less than zero.', startIndex);
      }
      if (endIndex > list.length) {
        this.validator.error('sublist', sourceStart, sourceEnd, '_ is greater than the length of the input list (_).', endIndex, list.length);
      }
      if (endIndex < startIndex) {
        this.validator.error('sublist', sourceStart, sourceEnd, '_ is less than _.', endIndex, startIndex);
      }
      return this.listPrims.sublist(list, startIndex, endIndex);
    }

    // (String, Number, Number) => String
    substring(text, startIndex, endIndex) {
      return this.stringPrims.substring(text, startIndex, endIndex);
    }

    // (Int, Int, Array[Any]) => Number
    sum(sourceStart, sourceEnd, values) {
      var nums;
      nums = values.filter(checks.isNumber);
      return this.validator.checkNumber('sum', sourceStart, sourceEnd, this.listPrims.sum(nums));
    }

    // (Int, Int, Number, Array[Any] | AbstractAgentSet) => Array[Any] | AbstractAgentSet
    upToNOf(sourceStart, sourceEnd, count, agentSetOrList) {
      if (count < 0) {
        this.validator.error('up-to-n-of', sourceStart, sourceEnd, 'First input to _ can_t be negative.', "UP-TO-N-OF");
      }
      if (checks.isList(agentSetOrList)) {
        return this.listPrims.upToNOfList(count, agentSetOrList); // agentset
      } else {
        return this.listPrims.upToNOfAgentSet(count, agentSetOrList);
      }
    }

    // (Int, Int, Array[Any]) => Number
    variance(sourceStart, sourceEnd, values) {
      var nums;
      nums = values.filter(checks.isNumber);
      if (nums.length < 2) {
        this.validator.error('variance', sourceStart, sourceEnd, 'Can_t find the _ of a list without at least two numbers: __', "variance", this.dumper(values), ".");
      }
      return this.validator.checkNumber('variance', sourceStart, sourceEnd, this.listPrims.variance(nums));
    }

  };

  module.exports = ListChecks;

}).call(this);

},{"engine/core/typechecker":"engine/core/typechecker"}],"engine/prim-checks/math-checks":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var MathChecks, NLMath, formatFloat;

  NLMath = require('util/nlmath');

  formatFloat = require('util/formatfloat');

  MathChecks = class MathChecks {
    constructor(validator, randomPrims) {
      this.validator = validator;
      this.randomPrims = randomPrims;
    }

    // (Number) => Number
    abs(d) {
      return NLMath.abs(d);
    }

    // (Int, Int, Number) => Number
    acos(sourceStart, sourceEnd, d) {
      return this.validator.checkNumber('acos', sourceStart, sourceEnd, NLMath.acos(d));
    }

    // (Int, Int, Number) => Number
    asin(sourceStart, sourceEnd, d) {
      return this.validator.checkNumber('asin', sourceStart, sourceEnd, NLMath.asin(d));
    }

    // (Int, Int, Number, Number) => Number
    atan(sourceStart, sourceEnd, d1, d2) {
      if (d1 === 0 && d2 === 0) {
        this.validator.error('atan', sourceStart, sourceEnd, 'atan is undefined when both inputs are zero.');
      }
      return NLMath.atan(d1, d2);
    }

    // (Number) => Number
    ceil(d) {
      return NLMath.ceil(d);
    }

    // (Number) => Number
    cos(d) {
      return NLMath.cos(d);
    }

    // (Int, Int, Number, Number) => Number
    div(sourceStart, sourceEnd, n, d) {
      if (d === 0) {
        this.validator.error('/', sourceStart, sourceEnd, 'Division by zero.');
      }
      return n / d;
    }

    // (Int, Int, Number) => Number
    exp(sourceStart, sourceEnd, p) {
      return this.validator.checkNumber('exp', sourceStart, sourceEnd, NLMath.exp(p));
    }

    // (Number) => Number
    floor(d) {
      return NLMath.floor(d);
    }

    // (Int, Int, Number) => Number
    int(sourceStart, sourceEnd, n) {
      return StrictMath.trunc(this.validator.checkLong('int', sourceStart, sourceEnd, n));
    }

    // (Int, Int, Number) => Number
    ln(sourceStart, sourceEnd, n) {
      if (n <= 0) {
        this.validator.error('ln', sourceStart, sourceEnd, 'Can_t take logarithm of _.', n);
      }
      return NLMath.ln(n);
    }

    // (Int, Int, Number, Number) => Number
    log(sourceStart, sourceEnd, n, b) {
      if (n <= 0) {
        this.validator.error('log', sourceStart, sourceEnd, 'Can_t take logarithm of _.', n);
      }
      if (b <= 0) {
        this.validator.error('log', sourceStart, sourceEnd, '_ isn_t a valid base for a logarithm.', b);
      }
      return NLMath.log(n, b);
    }

    // (Int, Int, Number, Number) => Number
    minus(sourceStart, sourceEnd, a, b) {
      return this.validator.checkNumber('-', sourceStart, sourceEnd, a - b);
    }

    // (Int, Int, Number, Number) => Number
    mod(sourceStart, sourceEnd, p, q) {
      if (q === 0) {
        this.validator.error('mod', sourceStart, sourceEnd, 'Division by zero.');
      }
      return NLMath.mod(p, q);
    }

    // (Int, Int, Number, Number) => Number
    mult(sourceStart, sourceEnd, a, b) {
      return this.validator.checkNumber('*', sourceStart, sourceEnd, a * b);
    }

    // (Boolean) => Boolean
    not(a) {
      return !a;
    }

    // (Int, Int, Number, Number) => Number
    plus(sourceStart, sourceEnd, a, b) {
      return this.validator.checkNumber('+', sourceStart, sourceEnd, a + b);
    }

    // (Int, Int, Number, Number) => Number
    pow(sourceStart, sourceEnd, b, p) {
      return this.validator.checkNumber('pow', sourceStart, sourceEnd, NLMath.pow(b, p));
    }

    // (Number, Number) => Number
    precision(n, places) {
      return NLMath.precision(n, places);
    }

    // (Int, Int, Number) => Number
    random(sourceStart, sourceEnd, n) {
      return this.randomPrims.random(this.validator.checkLong('random', sourceStart, sourceEnd, n));
    }

    // (Int, Int, Number) => Number
    randomExponential(sourceStart, sourceEnd, mean) {
      return this.validator.checkNumber('random-exponential', sourceStart, sourceEnd, this.randomPrims.randomExponential(mean));
    }

    // (Number) => Number
    randomFloat(n) {
      return this.randomPrims.randomFloat(n);
    }

    // (Int, Int, Number, Number) => Number
    randomGamma(sourceStart, sourceEnd, alpha, lambda) {
      if (alpha <= 0 || lambda <= 0) {
        this.validator.error('random-gamma', sourceStart, sourceEnd, 'Both Inputs to RANDOM-GAMMA must be positive.');
      }
      return this.randomPrims.randomGamma(alpha, lambda);
    }

    // (Int, Int, Number, Number) => Number
    randomNormal(sourceStart, sourceEnd, mean, stdDev) {
      if (stdDev < 0) {
        this.validator.error('random-normal', sourceStart, sourceEnd, 'random-normal_s second input can_t be negative.');
      }
      return this.validator.checkNumber('random-normal', sourceStart, sourceEnd, this.randomPrims.randomNormal(mean, stdDev));
    }

    // (Number) => Number
    randomPoisson(mean) {
      return this.randomPrims.randomPoisson(mean);
    }

    // (Int, Int, Number) => Unit
    randomSeed(sourceStart, sourceEnd, seed) {
      if (seed < -2147483648 || seed > 2147483647) {
        this.validator.error('random-seed', sourceStart, sourceEnd, '_ is not in the allowable range for random seeds (-2147483648 to 2147483647)', formatFloat(seed));
      }
      this.randomPrims.randomSeed(seed);
    }

    // (Number, Number) => Number
    remainder(a, b) {
      return a % b;
    }

    // (Number) => Number
    round(n) {
      return NLMath.round(n);
    }

    // (Number) => Number
    sin(d) {
      return NLMath.sin(d);
    }

    // (Int, Int, Number) => Number
    sqrt(sourceStart, sourceEnd, n) {
      if (n < 0) {
        this.validator.error('sqrt', sourceStart, sourceEnd, 'The square root of _ is an imaginary number.', n);
      }
      return NLMath.sqrt(n);
    }

    // (Number, Number) => Number
    subtractHeadings(h1, h2) {
      return NLMath.subtractHeadings(h1, h2);
    }

    // (Int, Int, Number) => Number
    tan(sourceStart, sourceEnd, d) {
      var mod;
      mod = d % 180;
      if (mod === 90 || mod === -90) {
        this.validator.raiseInfinityError('tan', sourceStart, sourceEnd);
      }
      // This `mod is 0` logic should technically be in the NLMath implementation, but
      // this saves us from re-calculating the modulo there as well.  We could
      // just send the `mod` in as the argument, but that will make small
      // differences with the existing results from NetLogo due to floating
      // point arithmetic in the degrees to radians conversions.
      // -Jeremy B November 2021
      if (mod === 0) {
        return 0;
      } else {
        return NLMath.tan(d);
      }
    }

    // (Number) => Number
    unaryminus(a) {
      return -a;
    }

    // (Boolean, Boolean) => Boolean
    xor(a, b) {
      return a !== b;
    }

  };

  module.exports = MathChecks;

}).call(this);

},{"util/formatfloat":"util/formatfloat","util/nlmath":"util/nlmath"}],"engine/prim-checks/patch-checks":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var PatchChecks, checks, fold, genSetter;

  ({fold} = require('brazierjs/maybe'));

  ({checks} = require('engine/core/typechecker'));

  // (() => Agent, Validator) => (String, Map[Any, String]) => (Any) => Unit
  genSetter = function(getSelf, validator) {
    return function(name, mappings) {
      return function(value) {
        var pot;
        pot = getSelf(); // pot: patchOrTurtle
        fold(function() {})((error) => {
          var defaultMsg, environment, msg, target;
          target = checks.isPatch(pot) ? pot : pot.getPatchHere();
          environment = {
            myType: "patch",
            varName: name,
            target
          };
          msg = mappings.get(error);
          defaultMsg = `An unknown error occurred when setting the '${name}' of '${pot}': ${error}`;
          return validator.error('set', null, null, msg != null ? msg : defaultMsg, environment);
        })(pot.setPatchVariableIfValid(name, value));
      };
    };
  };

  PatchChecks = (function() {
    class PatchChecks {
      
        // (Validator, () => Number|Agent)
      constructor(validator1, getSelf1) {
        var asSetter, invalidColorTypeMsg, invalidRGBMsg3Or4, invalidRGBNumberMsg, pcolorMappings, plabelColorMappings, toSetterPair;
        this.validator = validator1;
        this.getSelf = getSelf1;
        this._setterChecks = new Map();
        invalidColorTypeMsg = "can't set _ variable _ to non-number _";
        invalidRGBMsg3Or4 = "An rgb list must contain 3 or 4 numbers 0-255";
        invalidRGBNumberMsg = "RGB values must be 0-255";
        pcolorMappings = new Map([["Invalid RGB format", invalidRGBMsg3Or4], ["Invalid RGB number", invalidRGBNumberMsg], ["Invalid color type", invalidColorTypeMsg]]);
        plabelColorMappings = new Map([["Invalid RGB format", invalidRGBMsg3Or4], ["Invalid RGB number", invalidRGBNumberMsg], ["Invalid color type", invalidColorTypeMsg]]);
        asSetter = genSetter(this.getSelf, this.validator);
        toSetterPair = function([varName, mappings]) {
          return [varName, asSetter(varName, mappings)];
        };
        this._setterChecks = new Map([["pcolor", pcolorMappings], ["plabel-color", plabelColorMappings]].map(toSetterPair));
      }

      // (Int, Int, String, Any) => Unit
      setVariable(sourceStart, sourceEnd, name, value) {
        var check, patchOrTurtle;
        patchOrTurtle = this.getSelf();
        if (this._setterChecks.has(name)) {
          check = this._setterChecks.get(name);
          check(value);
        } else {
          patchOrTurtle.setPatchVariable(name, value);
        }
      }

      // (Int, Int, String) => Any
      getVariable(sourceStart, sourceEnd, name) {
        return this.getSelf().getPatchVariable(name);
      }

    };

    PatchChecks.prototype._setterChecks = null; // Map[String, (Any) => Unit]

    return PatchChecks;

  }).call(this);

  module.exports = PatchChecks;

}).call(this);

},{"brazierjs/maybe":"brazier/maybe","engine/core/typechecker":"engine/core/typechecker"}],"engine/prim-checks/procedure-checks":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var DeathInterrupt, ProcedureChecks, StopInterrupt, checks, removeRepeatable;

  ({checks} = require('engine/core/typechecker'));

  ({DeathInterrupt, StopInterrupt} = require('util/interrupts'));

  ({removeRepeatable} = require('engine/prim-checks/syntax'));

  ProcedureChecks = class ProcedureChecks {
    constructor(validator, procedurePrims) {
      this.validator = validator;
      this.procedurePrims = procedurePrims;
    }

    // (String, Int, Int, Number, Number) => Unit
    runArgCountCheck(primName, sourceStart, sourceEnd, needed, given) {
      if (given < needed) {
        this.validator.error(primName, sourceStart, sourceEnd, 'anonymous procedure expected _ input_, but only got _', needed, given);
      }
    }

    // (Int, Int, String, Array[Any]) => Any
    callReporter(sourceStart, sourceEnd, name, ...args) {
      var result;
      result = this.procedurePrims.callReporter(name, ...args);
      if (result === void 0) {
        this.validator.error('report', sourceStart, sourceEnd, 'Reached end of reporter procedure without REPORT being called.');
      }
      return result;
    }

    // (Int, Int, Any) => Any
    preReturnCheck(sourceStart, sourceEnd, value) {
      if (value === StopInterrupt) {
        if (!this.procedurePrims.stack().currentContext().isStopAllowed()) {
          this.validator.error('stop', sourceStart, sourceEnd, 'STOP is not allowed inside TO-REPORT.');
        }
      } else {
        if (value !== DeathInterrupt && !this.procedurePrims.stack().currentContext().isReportAllowed()) {
          this.validator.error('report', sourceStart, sourceEnd, 'REPORT can only be used inside TO-REPORT.');
        }
      }
      return value;
    }

    // (Int, Int, Any) => Any
    report(sourceStart, sourceEnd, reporter) {
      return this.preReturnCheck(sourceStart, sourceEnd, reporter);
    }

    // (Int, Int, String | () => Any, Array[Any]) => Any
    run(sourceStart, sourceEnd, fOrString, ...args) {
      return this.runCode(sourceStart, sourceEnd, fOrString, false, ...args);
    }

    // (Int, Int, String | () => Any, Array[Any]) => Any
    runResult(sourceStart, sourceEnd, fOrString, ...args) {
      return this.runCode(sourceStart, sourceEnd, fOrString, true, ...args);
    }

    // (Int, Int, String | () => Any, Boolean, Array[Any]) => Any
    runCode(sourceStart, sourceEnd, fOrString, isRunResult, ...args) {
      var prim;
      if (checks.isString(fOrString)) {
        if (args.length !== 0) {
          prim = isRunResult ? "runresult" : "run";
          this.validator.error(prim, sourceStart, sourceEnd, '_ doesn_t accept further inputs if the first is a string', prim);
        }
        return this.procedurePrims.runString(fOrString, isRunResult);
      } else {
        return this.procedurePrims.runFunction(fOrString, ...args);
      }
    }

    // (Int, Int, ) => StopInterrupt
    stop(sourceStart, sourceEnd) {
      return this.preReturnCheck(sourceStart, sourceEnd, this.procedurePrims.stop());
    }

  };

  module.exports = ProcedureChecks;

}).call(this);

},{"engine/core/typechecker":"engine/core/typechecker","engine/prim-checks/syntax":"engine/prim-checks/syntax","util/interrupts":"util/interrupts"}],"engine/prim-checks/syntax":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var NLType, REPEATABLE_TYPE, UnknownType, exceptions, getTypesFromSyntax, hasType, isRepeatable, removeRepeatable, syntaxToTypes, types, unknown;

  ({types, NLType} = require('engine/core/typechecker'));

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  REPEATABLE_TYPE = 262144;

  UnknownType = class UnknownType extends NLType {
    constructor(typeName) {
      super();
      this.typeName = typeName;
    }

    isOfType(x) {
      throw exceptions.internal(`We encountered a '${this.typeName}' type, but we don't know how to handle checking that.`);
    }

    niceName() {
      return `${this.typeName} type (should not be used)`;
    }

  };

  unknown = function(name) {
    return new UnknownType(name);
  };

  // The third item in these arrays is the "error message order" as copied
  // from `TypeNames.scala` in desktop.  I'm sure there is a better way to
  // handle this.  -Jeremy B February 2021
  syntaxToTypes = [[1, types.Number, 5], [2, types.Boolean, 6], [4, types.String, 7], [8, types.List, 8], [16, types.TurtleSet, 10], [32, types.PatchSet, 11], [64, types.LinkSet, 12], [112, types.AgentSet, 9], [128, types.Nobody, 18], [256, types.Turtle, 13], [512, types.Patch, 14], [1024, types.Link, 15], [1792, types.Agent, 4], [2048, types.CommandLambda, 17], [4096, types.ReporterLambda, 16], [8191, types.Wildcard, 3], [8192, unknown('reference'), 99], [16384, unknown('command block'), 99], [32768, unknown('boolean block'), 99], [65536, unknown('number block'), 99], [131072, unknown('other block'), 99], [REPEATABLE_TYPE, unknown('repeatable'), 99], [524288, unknown('optional'), 99], [1048576, unknown('code block'), 99], [2097152, unknown('symbol'), 99]].reverse(); // The reverse is important so we check syntax values from largest to smallest. -Jeremy B February 2021

  hasType = function(type, check) {
    return (check >= type) && (type & check) !== 0;
  };

  // (Int) => Array[NLType]
  getTypesFromSyntax = function(syntax) {
    return syntaxToTypes.filter(function([check, type, _]) {
      var has;
      has = hasType(check, syntax);
      if (has) {
        syntax = syntax - check;
      }
      return has;
    }).sort(function(a, b) {
      return a[2] - b[2];
    }).map(function([_1, type, _2]) {
      return type;
    });
  };

  removeRepeatable = function(syntax) {
    return syntax - (syntax & REPEATABLE_TYPE);
  };

  isRepeatable = function(check) {
    return hasType(REPEATABLE_TYPE, check);
  };

  module.exports = {getTypesFromSyntax, removeRepeatable, isRepeatable};

}).call(this);

},{"engine/core/typechecker":"engine/core/typechecker","util/exception":"util/exception"}],"engine/prim-checks/task-checks":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var NLMath, TaskChecks, TaskPrims, isRepeatable, removeRepeatable;

  NLMath = require('util/nlmath');

  TaskPrims = require('../prim/tasks');

  ({isRepeatable, removeRepeatable} = require('./syntax'));

  TaskChecks = class TaskChecks {
    constructor(validator1) {
      this.validator = validator1;
    }

    // (Int, Int, Function, String, Boolean, Boolean) => Function
    checked(sourceStart, sourceEnd, fn, body, isReporter, isVariadic) {
      var checkedTask, primName, validator;
      primName = isReporter ? "runresult" : "run";
      // we cannot bind the task function itself since that'll change the arguments, too.
      validator = this.validator;
      checkedTask = function() {
        var given, needed;
        needed = fn.length;
        given = arguments.length;
        if (given < needed) {
          validator.error(primName, sourceStart, sourceEnd, 'anonymous procedure expected _ input_, but only got _', needed, given);
        }
        return fn(...arguments);
      };
      checkedTask.minArgCount = fn.length;
      checkedTask.isReporter = isReporter;
      checkedTask.isVariadic = isVariadic;
      checkedTask.nlogoBody = body;
      return checkedTask;
    }

    // (String, Int, Int, Array[Int], Array[Any])
    checkVarArgs(primName, sourceStart, sourceEnd, expectedTypes, ...args) {
      var postVarArgs, preVarArgs, varArgs, varEndIndex, varStartIndex, varType;
      // assume if no args given, then there is only one expected type, and it is variadic
      // other checks will catch the length mismatch if not.  -Jeremy B June 2022
      if (args.length !== 0) {
        varStartIndex = expectedTypes.findIndex(isRepeatable);
        varEndIndex = args.length - (expectedTypes.length - varStartIndex);
        preVarArgs = args.slice(0, varStartIndex);
        varArgs = args.slice(varStartIndex, varEndIndex + 1);
        postVarArgs = args.slice(varEndIndex + 1);
        varType = removeRepeatable(expectedTypes[varStartIndex]);
        preVarArgs.forEach((arg, i) => {
          return this.validator.checkArg(primName, sourceStart, sourceEnd, expectedTypes[i], arg);
        });
        varArgs.forEach((arg, i) => {
          return this.validator.checkArg(primName, sourceStart, sourceEnd, varType, arg);
        });
        postVarArgs.forEach((arg, i) => {
          return this.validator.checkArg(primName, sourceStart, sourceEnd, expectedTypes[i + varEndIndex], arg);
        });
      }
      return args;
    }

    // (Int, Int, Array[T]*, (T) => Unit) => Unit
    forEach(sourceStart, sourceEnd) {
      var args, fn, lists;
      args = Array.from(arguments);
      lists = args.slice(2, args.length - 1);
      fn = args[args.length - 1];
      this.areListsSameLength('foreach', sourceStart, sourceEnd, lists);
      return Tasks.forEach(fn, lists);
    }

    map(sourceStart, sourceEnd, fn, ...lists) {
      this.areListsSameLength('map', sourceStart, sourceEnd, lists);
      return Tasks.map(fn, lists);
    }

    // (Int, Int, Number, (Int) => T) => Array[T]
    nValues(sourceStart, sourceEnd, n, fn) {
      if (n < 0) {
        this.validator.error("n-values", sourceStart, sourceEnd, "_ cannot take a negative number.", "N-VALUES");
      }
      return Tasks.nValues(NLMath.floor(n), fn);
    }

    areListsSameLength(primName, sourceStart, sourceEnd, lists) {
      var head;
      head = lists[0];
      if (!lists.every(function(l) {
        return l.length === head.length;
      })) {
        return this.validator.error(primName, sourceStart, sourceEnd, "All the list arguments to _ must be the same length.", primName.toUpperCase());
      }
    }

  };

  module.exports = TaskChecks;

}).call(this);

},{"../prim/tasks":"engine/prim/tasks","./syntax":"engine/prim-checks/syntax","util/nlmath":"util/nlmath"}],"engine/prim-checks/turtle-checks":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var TopologyInterrupt, TowardsInterrupt, TurtleChecks, fold, genSetter;

  ({fold} = require('brazierjs/maybe'));

  ({TopologyInterrupt, TowardsInterrupt} = require('util/interrupts'));

  // (() => Agent, Validator) => (String, Map[Any, String]) => (Any) => Unit
  genSetter = function(getSelf, validator) {
    return function(name, mappings) {
      return (value) => {
        var turtle;
        turtle = getSelf();
        fold(function() {})((error) => {
          var defaultMsg, msg;
          msg = mappings.get(error);
          defaultMsg = `An unknown error occurred when setting the '${name}' of '${turtle}': ${error}`;
          return validator.error('set', null, null, msg != null ? msg : defaultMsg);
        })(turtle.setIfValid(name, value));
      };
    };
  };

  TurtleChecks = (function() {
    class TurtleChecks {
      
        // (Validator, () => Agent, TurtleManager, BreedManager)
      constructor(validator1, getSelf1, turtleManager, breedManager) {
        var asSetter, cannotMoveMsg, colorSetterMappings, corSetterMappings, invalidRGBMsg, invalidRGBNumberMsg, toSetterPair;
        this.validator = validator1;
        this.getSelf = getSelf1;
        this.turtleManager = turtleManager;
        this.breedManager = breedManager;
        this._getterChecks = new Map();
        cannotMoveMsg = "Cannot move turtle beyond the world_s edge.";
        invalidRGBMsg = "An rgb list must contain 3 or 4 numbers 0-255";
        invalidRGBNumberMsg = "RGB values must be 0-255";
        corSetterMappings = new Map([[TopologyInterrupt, cannotMoveMsg]]);
        colorSetterMappings = new Map([["Invalid RGB format", invalidRGBMsg], ["Invalid RGB number", invalidRGBNumberMsg]]);
        asSetter = genSetter(this.getSelf, this.validator);
        toSetterPair = function([varName, mappings]) {
          return [varName, asSetter(varName, mappings)];
        };
        this._setterChecks = new Map([["xcor", corSetterMappings], ["ycor", corSetterMappings], ["color", colorSetterMappings], ["label-color", colorSetterMappings]].map(toSetterPair));
      }

      // (Int, Int, Number) => Agent
      getTurtle(sourceStart, sourceEnd, id) {
        if (!Number.isInteger(id)) {
          this.validator.error('turtle', sourceStart, sourceEnd, '_ is not an integer', id);
        }
        return this.turtleManager.getTurtle(id);
      }

      // (Int, Int, String, Number) => Agent
      getTurtleOfBreed(sourceStart, sourceEnd, breedName, id) {
        var agent, isValid, lowerName, targetSingular, turtleStr;
        agent = this.getTurtle(sourceStart, sourceEnd, id);
        isValid = agent.id !== -1;
        if (isValid && agent.getBreedName().toUpperCase() !== breedName.toUpperCase()) {
          lowerName = breedName.toLowerCase();
          targetSingular = this.breedManager.get(breedName).singular.toUpperCase();
          turtleStr = `${agent.getBreedNameSingular()} ${agent.id}`;
          this.validator.error(lowerName, sourceStart, sourceEnd, '_ is not a _', turtleStr, targetSingular);
        }
        return agent;
      }

      // (Int, Int, String) => Any
      getVariable(sourceStart, sourceEnd, name) {
        var check, msgKey, turtle, upperName;
        turtle = this.getSelf();
        if (!turtle.hasVariable(name)) {
          msgKey = "_ breed does not own variable _";
          upperName = name.toUpperCase();
          return this.validator.error(upperName, sourceStart, sourceEnd, msgKey, turtle.getBreedName(), upperName);
        } else if (this._getterChecks.has(name)) {
          check = this._getterChecks.get(name);
          return check(name);
        } else {
          return turtle.getVariable(name);
        }
      }

      // (Int, Int, String, Any) => Unit
      setVariable(sourceStart, sourceEnd, name, value) {
        var check, msgKey, turtle, upperName;
        turtle = this.getSelf();
        if (!turtle.hasVariable(name)) {
          msgKey = "_ breed does not own variable _";
          upperName = name.toUpperCase();
          this.validator.error('set', sourceStart, sourceEnd, msgKey, turtle.getBreedName(), upperName);
        } else if (this._setterChecks.has(name)) {
          check = this._setterChecks.get(name);
          check(value);
        } else {
          turtle.setVariable(name, value);
        }
      }

      // (Int, Int, Number, Number) => Unit
      setXY(sourceStart, sourceEnd, x, y) {
        var result;
        result = this.getSelf().setXY(x, y);
        if (result === TopologyInterrupt) {
          this.validator.error('setxy', sourceStart, sourceEnd, 'The point [ _ , _ ] is outside of the boundaries of the world and wrapping is not permitted in one or both directions.', x, y);
        }
      }

      // (Int, Int, Agent) => Number
      towards(sourceStart, sourceEnd, agent) {
        var heading, x, y;
        heading = this.getSelf().towards(agent);
        if (heading === TowardsInterrupt) {
          [x, y] = agent.getCoords();
          this.validator.error('towards', sourceStart, sourceEnd, 'No heading is defined from a point (_,_) to that same point.', x, y);
        }
        return heading;
      }

      // (Int, Int, Number, Number) => Number
      towardsXY(sourceStart, sourceEnd, x, y) {
        var heading;
        heading = this.getSelf().towardsXY(x, y);
        if (heading === TowardsInterrupt) {
          this.validator.error('towardsxy', sourceStart, sourceEnd, 'No heading is defined from a point (_,_) to that same point.', x, y);
        }
        return heading;
      }

    };

    TurtleChecks.prototype._getterChecks = null; // Map[String, (Any) => Unit]

    TurtleChecks.prototype._setterChecks = null; // Map[String, (Any) => Unit]

    return TurtleChecks;

  }).call(this);

  module.exports = TurtleChecks;

}).call(this);

},{"brazierjs/maybe":"brazier/maybe","util/interrupts":"util/interrupts"}],"engine/prim-checks/validator":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var StrictMath, Validator, checks, exceptions, formatFloat, getTypeOf, getTypesFromSyntax, maybe, types;

  ({maybe} = require('brazier/maybe'));

  StrictMath = require('shim/strictmath');

  formatFloat = require('util/formatfloat');

  ({checks, getTypeOf, types} = require('engine/core/typechecker'));

  ({getTypesFromSyntax} = require('engine/prim-checks/syntax'));

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  Validator = (function() {
    class Validator {
      constructor(bundle, dumper) {
        var agentSet, boolean;
        this.bundle = bundle;
        this.dumper = dumper;
        this._cachedRuntimeTypes = new Map();
        // These arrays of types and the common checks below are pre-computed so that all prims
        // can share them without making loads of extra array instances and extra functions.
        // -Jeremy B December 2020
        // Most of these have gone away in favor of the compiler-based arg type checks.
        // -Jeremy B February 2021
        agentSet = [types.AgentSet];
        boolean = [types.Boolean];
        this.commonArgChecks = {
          agentSet: this.makeArgTypeCheck(agentSet),
          boolean: this.makeArgTypeCheck(boolean)
        };
        this.commonValueChecks = {
          boolean: this.makeValueTypeCheck(...boolean)
        };
      }

      // (String, Int | null, Int | null, String, Array[Any]) => Unit
      error(prim, sourceStart, sourceEnd, messageKey, ...messageValues) {
        var message;
        message = this.bundle.get(messageKey, ...messageValues.map(function(val) {
          if (typeof val === "function") {
            return val();
          } else {
            return val;
          }
        }));
        throw exceptions.runtime(message, prim, maybe(sourceStart), maybe(sourceEnd), messageKey);
      }

      // (String, Int, Int, Number) => Number
      checkLong(prim, sourceStart, sourceEnd, value) {
        if (value > 9007199254740992 || value < -9007199254740992) {
          this.error(prim, sourceStart, sourceEnd, '_ is too large to be represented exactly as an integer in NetLogo', formatFloat(value));
        }
        return value;
      }

      // (String, Int, Int, Number) => Number
      checkNumber(prim, sourceStart, sourceEnd, result) {
        if (Number.isNaN(result)) {
          this.error(prim, sourceStart, sourceEnd, 'math operation produced a non-number');
        }
        if (result === 2e308) {
          this.raiseInfinityError(prim);
        }
        return result;
      }

      // (String, Int, Int) => Unit
      raiseInfinityError(prim, sourceStart, sourceEnd) {
        return this.error(prim, sourceStart, sourceEnd, 'math operation produced a number too large for NetLogo');
      }

      // (String) => String
      addIndefiniteArticle(text) {
        if (['A', 'E', 'I', 'O', 'U'].includes(text.charAt(0).toUpperCase())) {
          return `an ${text}`;
        } else {
          return `a ${text}`;
        }
      }

      // (Array[NLType]) => String
      listTypeNames(typesToName) {
        var nameList, names;
        names = typesToName.map(function(type) {
          return type.niceName();
        });
        nameList = names.join(" or ");
        return this.addIndefiniteArticle(nameList);
      }

      // (Any) => String
      valueToString(value) {
        var valueType;
        valueType = getTypeOf(value);
        if (valueType === types.Nobody) {
          return "NOBODY";
        } else if (valueType === types.Wildcard) {
          return "any value";
        } else {
          return `the ${valueType.niceName()} ${this.dumper(value)}`;
        }
      }

      // (String, Any, Array[NLType]) => String
      typeError(prim, value, expectedTypes) {
        var expectedText, valueText;
        valueText = this.valueToString(value);
        expectedText = this.listTypeNames(expectedTypes);
        return this.bundle.get("_ expected input to be _ but got _ instead.", prim.toUpperCase(), expectedText, valueText);
      }

      // (String, Int, Int, Any, Array[NLType]) => Unit
      throwTypeError(prim, sourceStart, SourceEnd, value, ...expectedTypes) {
        throw exceptions.runtime(this.typeError(prim, value, expectedTypes), prim, maybe(sourceStart), maybe(SourceEnd), "_ expected input to be _ but got _ instead.");
      }

      // (Array[Array[NLType]]) => (String, Array[Any]) => Unit
      makeArgTypeCheck(...argTypes) {
        return (prim, sourceStart, sourceEnd, args) => {
          var i, k, ref;
// We could use `zip()` or `foreach()` or whatever here, but I don't want to use anything that would
// generate extra closures as this code will get called a whole lot.  So we'll leave it ugly but
// hopefully "optimized" -Jeremy B December 2020
          for (i = k = 0, ref = argTypes.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
            this.checkValueTypes(prim, sourceStart, sourceEnd, argTypes[i], args[i]);
          }
        };
      }

      // (Array[NLType]) => (String, Any) => Any
      makeValueTypeCheck(...allowedTypes) {
        return (prim, sourceStart, sourceEnd, value) => {
          return this.checkValueTypes(prim, sourceStart, sourceEnd, allowedTypes, value);
        };
      }

      // (String, Int, Int, Array[NLType], Any) => Any
      checkValueTypes(prim, sourceStart, sourceEnd, allowedTypes, value) {
        var j, k, match, ref;
        // And we could use `some()` here, but that also could generate transient closure objects. -Jeremy B December 2020
        match = false;
        for (j = k = 0, ref = allowedTypes.length; (0 <= ref ? k < ref : k > ref); j = 0 <= ref ? ++k : --k) {
          if (allowedTypes[j].isOfType(value)) {
            match = true;
            break;
          }
        }
        if (!match) {
          this.throwTypeError(prim, sourceStart, sourceEnd, value, ...allowedTypes);
        }
        return value;
      }

      // (Int) => Array[NLType]
      syntaxTypeToRuntimeTypes(syntax) {
        var allowedTypes;
        if (this._cachedRuntimeTypes.has(syntax)) {
          return this._cachedRuntimeTypes.get(syntax);
        } else {
          allowedTypes = getTypesFromSyntax(syntax);
          this._cachedRuntimeTypes.set(syntax, allowedTypes);
          return allowedTypes;
        }
      }

      // (String, Int, Int, Int, Any) => Any
      checkArg(prim, sourceStart, sourceEnd, syntax, argValue) {
        var allowedTypes;
        allowedTypes = this.syntaxTypeToRuntimeTypes(syntax);
        return this.checkValueTypes(prim, sourceStart, sourceEnd, allowedTypes, argValue);
      }

    };

    // Map[Int, Array[NLType]]
    Validator.prototype._cachedRuntimeTypes = null;

    return Validator;

  }).call(this);

  module.exports = Validator;

}).call(this);

},{"brazier/maybe":"brazier/maybe","engine/core/typechecker":"engine/core/typechecker","engine/prim-checks/syntax":"engine/prim-checks/syntax","shim/strictmath":"shim/strictmath","util/exception":"util/exception","util/formatfloat":"util/formatfloat"}],"engine/prim-checks/world-checks":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var WorldChecks;

  WorldChecks = class WorldChecks {
    constructor(validator, world) {
      this.validator = validator;
      this.world = world;
    }

    setPatchSize(sourceStart, sourceEnd, newSize) {
      if (newSize <= 0) {
        this.validator.error('set-patch-size', sourceStart, sourceEnd, 'Patch size must be greater than zero.');
      }
      return this.world.setPatchSize(newSize);
    }

  };

  module.exports = WorldChecks;

}).call(this);

},{}],"engine/prim/evalprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var EvalPrims, compileFromString, exceptions, globalEval, readFromString, runEvalCache, runFromString, runResultEvalCache;

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  globalEval = eval;

  // (String) => Number | Boolean | String | Array
  readFromString = function(str) {
    var ex;
    try {
      return Converter.stringToJSValue(str);
    } catch (error) {
      ex = error;
      throw exceptions.internal(ex.message);
    }
  };

  runEvalCache = {};

  runResultEvalCache = {};

  // (String, Array[Widget], String, Boolean, Array[String]) => Function
  compileFromString = function(code, widgets, runString, isRunResult, varNames) {
    var compileParams, evalCache, fun, js, runKey, varString;
    evalCache = isRunResult ? runResultEvalCache : runEvalCache;
    varString = varNames.join(' ');
    runKey = `${varString} => ${runString}`;
    if ((evalCache[runKey] != null)) {
      return evalCache[runKey];
    } else {
      compileParams = {
        code: code,
        widgets: widgets,
        commands: [],
        reporters: [],
        turtleShapes: [],
        linkShapes: []
      };
      js = Converter.compileRunString(compileParams, runString, isRunResult, varNames);
      fun = globalEval(js);
      evalCache[runKey] = fun;
      return fun;
    }
  };

  // (String, Array[Widget], String, Boolean, Map[String, Any]) => Any
  runFromString = function(code, widgets, runString, isRunResult, procVars) {
    var ex, result, runFun, varNames;
    varNames = Array.from(procVars.keys()).sort(); // must be sorted as order can vary depending on procedure structure
    runFun = (function() {
      try {
        return compileFromString(code, widgets, runString, isRunResult, varNames);
      } catch (error) {
        ex = error;
        throw exceptions.runtime(ex.message, isRunResult ? 'runresult' : 'run');
      }
    })();
    result = runFun(...varNames.map((vn) => {
      return procVars.get(vn);
    }));
    if (isRunResult) {
      return result;
    } else {

    }
  };

  module.exports = EvalPrims = class EvalPrims {
    // (String, Array[Widget], (String) => Any) => EvalConfig
    constructor(code, widgets, readFromString1 = readFromString) {
      this.readFromString = readFromString1;
      this.runCode = function(runString, isRunResult, procVars) {
        return runFromString(code, widgets, runString, isRunResult, procVars);
      };
      this.compileFromString = function(runString, isRunResult, procVars) {
        var varNames;
        varNames = Array.from(procVars.keys()).sort(); // must be sorted
        return compileFromString(code, widgets, runString, isRunResult, varNames);
      };
    }

  };

}).call(this);

},{"util/exception":"util/exception"}],"engine/prim/gamma":[function(require,module,exports){
(function() {
  var StrictMath, calcQ, calcQ0, calcT, calcVars, calcW, gdsFromAcceptanceRejection, gdsFromDoubleExponential;

  StrictMath = require('shim/strictmath');

  calcQ = function(t, s, ss, q0) {
    var a1, a2, a3, a4, a5, a6, a7, a8, a9, v;
    a1 = 0.333333333;
    a2 = -0.249999949;
    a3 = 0.199999867;
    a4 = -0.166677482;
    a5 = 0.142873973;
    a6 = -0.124385581;
    a7 = 0.110368310;
    a8 = -0.112750886;
    a9 = 0.104089866;
    v = t / (s + s);
    if (StrictMath.abs(v) > 0.25) {
      return q0 - s * t + 0.25 * t * t + (ss + ss) * StrictMath.log(1 + v);
    } else {
      return q0 + 0.5 * t * t * ((((((((a9 * v + a8) * v + a7) * v + a6) * v + a5) * v + a4) * v + a3) * v + a2) * v + a1) * v;
    }
  };

  calcQ0 = function(alpha) {
    var q1, q2, q3, q4, q5, q6, q7, q8, q9, r;
    q1 = 0.0416666664;
    q2 = 0.0208333723;
    q3 = 0.0079849875;
    q4 = 0.0015746717;
    q5 = -0.0003349403;
    q6 = 0.0003340332;
    q7 = 0.0006053049;
    q8 = -0.0004701849;
    q9 = 0.0001710320;
    r = 1 / alpha;
    return ((((((((q9 * r + q8) * r + q7) * r + q6) * r + q5) * r + q4) * r + q3) * r + q2) * r + q1) * r;
  };

  calcT = function(randomGenerator) {
    var generateVs, v1, v12;
    generateVs = function() {
      var v1, v12, v2;
      v1 = 2 * randomGenerator.nextDouble() - 1;
      v2 = 2 * randomGenerator.nextDouble() - 1;
      v12 = v1 * v1 + v2 * v2;
      if (v12 <= 1) {
        return [v1, v12];
      } else {
        return generateVs();
      }
    };
    [v1, v12] = generateVs();
    return v1 * StrictMath.sqrt(-2 * StrictMath.log(v12) / v12);
  };

  calcVars = function(b, si, randomGenerator) {
    var e, signU, t, u, uTemp;
    e = -StrictMath.log(randomGenerator.nextDouble());
    uTemp = randomGenerator.nextDouble();
    u = uTemp + uTemp - 1;
    signU = u > 0 ? 1 : -1;
    t = b + (e * si) * signU;
    if (t > -0.71874483771719) {
      return [e, signU, u, t];
    } else {
      return calcVars(b, si, randomGenerator);
    }
  };

  calcW = function(q) {
    var e1, e2, e3, e4, e5, e6, e7;
    e1 = 1.000000000;
    e2 = 0.499999994;
    e3 = 0.166666848;
    e4 = 0.041664508;
    e5 = 0.008345522;
    e6 = 0.001353826;
    e7 = 0.000247453;
    if (q > 0.5) {
      return StrictMath.exp(q) - 1.0;
    } else {
      return ((((((e7 * q + e6) * q + e5) * q + e4) * q + e3) * q + e2) * q + e1) * q;
    }
  };

  gdsFromAcceptanceRejection = function(alpha, randomGenerator) {
    var b, generateNumbersUntilHappy;
    b = 1 + 0.36788794412 * alpha;
    generateNumbersUntilHappy = function() {
      var gdsHighP, gdsLowP, logRand, p;
      p = b * randomGenerator.nextDouble();
      logRand = StrictMath.log(randomGenerator.nextDouble());
      gdsLowP = StrictMath.exp(StrictMath.log(p) / alpha);
      gdsHighP = -StrictMath.log((b - p) / alpha);
      if (p <= 1 && logRand <= -gdsLowP) {
        return gdsLowP;
      } else if (p > 1 && logRand <= ((alpha - 1) * StrictMath.log(gdsHighP))) {
        return gdsHighP;
      } else {
        return generateNumbersUntilHappy();
      }
    };
    return generateNumbersUntilHappy();
  };

  gdsFromDoubleExponential = function(b, si, c, s, ss, q0, randomGenerator) {
    var tryAgain;
    tryAgain = function() {
      var e, q, signU, t, u, x;
      [e, signU, u, t] = calcVars(b, si, randomGenerator);
      // Step 12. Hat acceptance
      q = calcQ(t, s, ss, q0);
      if ((q > 0) && (c * u * signU <= calcW(q) * StrictMath.exp(e - 0.5 * t * t))) {
        x = s + 0.5 * t;
        return x * x;
      } else {
        return tryAgain();
      }
    };
    return tryAgain();
  };

  /*

  Gamma Distribution - Acceptance Rejection combined with Acceptance Complement

  See: J.H. Ahrens, U. Dieter (1974): Computer methods for sampling from gamma, beta, Poisson and binomial distributions, Computing 12, 223-246.
  See: J.H. Ahrens, U. Dieter (1982): Generating gamma variates by a modified rejection technique, Communications of the ACM 25, 47-54.

  */
  module.exports = function(randomGenerator, alpha, lambda) {
    var b, c, d, gds, q0, s, si, ss, t, u, x;
    
      // Set-up for hat case
    gds = alpha < 1 ? gdsFromAcceptanceRejection(alpha, randomGenerator) : (ss = alpha - 0.5, s = StrictMath.sqrt(ss), d = 5.656854249 - 12 * s, t = calcT(randomGenerator), x = s + 0.5 * t, t >= 0 ? x * x : (u = randomGenerator.nextDouble(), d * u <= t * t * t ? x * x : (q0 = calcQ0(alpha), (x > 0) && (StrictMath.log(1 - u) <= calcQ(t, s, ss, q0)) ? x * x : ([b, si, c] = alpha > 13.022 ? [1.77, 0.75, 0.1515 / s] : alpha > 3.686 ? [1.654 + 0.0076 * ss, 1.68 / s + 0.275, 0.062 / s + 0.024] : [0.463 + s - 0.178 * ss, 1.235, 0.195 / s - 0.079 + 0.016 * s], gdsFromDoubleExponential(b, si, c, s, ss, q0, randomGenerator))))); // CASE A: Acceptance rejection algorithm gs // CASE B: Acceptance complement algorithm gd (gaussian distribution, box muller transformation) // Squeeze acceptance // Step 7. Quotient acceptance // Step 8. Double exponential deviate t
    return gds / lambda;
  };

}).call(this);

},{"shim/strictmath":"shim/strictmath"}],"engine/prim/importexportprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ImportExportConfig, ImportExportPrims;

  module.exports.Config = ImportExportConfig = class ImportExportConfig {
    constructor(exportFile = (function() {
        return function() {}; // (String) => (String) => Unit
      }), exportBlob = (function() {
        return function() {}; // (Blob) => (String) => Unit
      }), getNlogo = (function() {
        return ""; // () => String
      }), getOutput = (function() {
        return ""; // () => String
      }), getViewBase64 = (function() {
        return "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCAABAAEDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD/AD/6KKKAP//Z"; // () => String
      }), getViewBlob = (function() {}), importFile1 = (function() { // ((Blob) => Unit) => Unit
        return function() {}; // (String) => ((String) => Unit) => Unit
      })) {
      this.exportFile = exportFile;
      this.exportBlob = exportBlob;
      this.getNlogo = getNlogo;
      this.getOutput = getOutput;
      this.getViewBase64 = getViewBase64;
      this.getViewBlob = getViewBlob;
      this.importFile = importFile1;
    }

  };

  module.exports.Prims = ImportExportPrims = class ImportExportPrims {
    // (ImportExportConfig, () => String, () => String, (String) => String, (String) => Unit, (Boolean) => (String) => Unit, (String) => Unit) => ImportExportPrims
    constructor({
        exportFile: exportFile,
        exportBlob: exportBlob,
        getNlogo: exportNlogoRaw,
        getOutput: exportOutputRaw,
        getViewBase64: exportViewRaw,
        getViewBlob: exportViewBlob,
        importFile
      }, exportWorldRaw, exportAllPlotsRaw, exportPlotRaw, exportPlotNoHeadersRaw, importDrawingRaw, importPColorsRaw, importWorldRaw) {
      this.exportFile = exportFile;
      this.exportBlob = exportBlob;
      this.exportNlogoRaw = exportNlogoRaw;
      this.exportOutputRaw = exportOutputRaw;
      this.exportViewRaw = exportViewRaw;
      this.exportViewBlob = exportViewBlob;
      this.exportWorldRaw = exportWorldRaw;
      this.exportAllPlotsRaw = exportAllPlotsRaw;
      this.exportPlotRaw = exportPlotRaw;
      this.exportPlotNoHeadersRaw = exportPlotNoHeadersRaw;
      this.importDrawingRaw = importDrawingRaw;
      this.importPColorsRaw = importPColorsRaw;
      this.importWorldRaw = importWorldRaw;
      this.exportAllPlots = (filename) => {
        return this.exportFile(this.exportAllPlotsRaw())(filename);
      };
      this.exportOutput = (filename) => {
        return this.exportFile(this.exportOutputRaw())(filename);
      };
      this.exportPlot = (plot, filename) => {
        return this.exportFile(this.exportPlotRaw(plot))(filename);
      };
      this.exportView = (filename) => {
        return this.exportViewBlob((blob) => {
          return this.exportBlob(blob)(filename);
        });
      };
      this.exportWorld = (filename) => {
        return this.exportFile(this.exportWorldRaw())(filename);
      };
      this.importDrawing = (filename) => {
        return importFile(filename)(this.importDrawingRaw);
      };
      this.importPColors = (filename) => {
        return importFile(filename)(this.importPColorsRaw(true));
      };
      this.importPColorsRGB = (filename) => {
        return importFile(filename)(this.importPColorsRaw(false));
      };
      this.importWorld = (filename) => {
        return importFile(filename)(this.importWorldRaw);
      };
    }

  };

}).call(this);

},{}],"engine/prim/importpcolors":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ColorModel, NLMath, StrictMath, genCoords, genPColorUpdates, id, importPColorsBase64, importPColorsImage, lookupNLColor, map, pipeline, tee, toObject;

  ColorModel = require('../core/colormodel');

  NLMath = require('util/nlmath');

  StrictMath = require('shim/strictmath');

  ({map, toObject} = require('brazier/array'));

  ({id, pipeline, tee} = require('brazier/function'));

  // type RGBA = (Number, Number, Number, Number)
  lookupNLColor = (function() {
    var cache;
    cache = {};
    return function(rgb) {
      var nlc, value;
      value = cache[rgb];
      if (value != null) {
        return value;
      } else {
        nlc = ColorModel.nearestColorNumberOfRGB(...rgb);
        cache[rgb] = nlc;
        return nlc;
      }
    };
  })();

  // (Number, Number, Number, Number) => (Number, Number, Object[Number, Number])
  genCoords = function(patchSize, ratio, worldDim, imageDim) {
    var dimRatio, endPatch, patchNumToPixel, patchOffset, scaledImageDim, startPatch, startPixels, worldPixelDim;
    worldPixelDim = patchSize * worldDim;
    scaledImageDim = imageDim * ratio;
    patchOffset = (worldPixelDim - scaledImageDim) / patchSize / 2;
    startPatch = StrictMath.floor(patchOffset);
    endPatch = worldDim - StrictMath.ceil(patchOffset);
    dimRatio = imageDim / (endPatch - startPatch);
    patchNumToPixel = function(patchNum) {
      return StrictMath.floor((patchNum - startPatch) * dimRatio);
    };
    startPixels = pipeline(map(tee(id)(patchNumToPixel)), toObject)((function() {
      var results = [];
      for (var j = startPatch; startPatch <= endPatch ? j < endPatch : j > endPatch; startPatch <= endPatch ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this));
    return [startPatch, endPatch, startPixels];
  };

  // (Topology, Number, Array[RGBA], Number, Number) => Array[{ x, y, color }]
  genPColorUpdates = function({
      height: worldHeight,
      minPxcor,
      minPycor,
      width: worldWidth
    }, patchSize, rgbs, imageWidth, imageHeight) {
    var maxX, maxY, minX, minY, pixel, ratio, updates, x, xEnd, xStart, xStarts, xcor, y, yEnd, yStart, yStarts, ycor;
    ratio = NLMath.min(patchSize * worldWidth / imageWidth, patchSize * worldHeight / imageHeight);
    [xStart, xEnd, xStarts] = genCoords(patchSize, ratio, worldWidth, imageWidth);
    [yStart, yEnd, yStarts] = genCoords(patchSize, ratio, worldHeight, imageHeight);
    updates = (function() {
      var j, ref, ref1, results;
      results = [];
      for (xcor = j = ref = xStart, ref1 = xEnd; (ref <= ref1 ? j < ref1 : j > ref1); xcor = ref <= ref1 ? ++j : --j) {
        results.push((function() {
          var k, ref2, ref3, ref4, ref5, results1;
          results1 = [];
          for (ycor = k = ref2 = yStart, ref3 = yEnd; (ref2 <= ref3 ? k < ref3 : k > ref3); ycor = ref2 <= ref3 ? ++k : --k) {
            minX = xStarts[xcor];
            minY = yStarts[ycor];
            maxX = NLMath.max(minX + 1, (ref4 = xStarts[xcor + 1]) != null ? ref4 : imageWidth);
            maxY = NLMath.max(minY + 1, (ref5 = yStarts[ycor + 1]) != null ? ref5 : imageHeight);
            // I just use the color of the center pixel of the bitmap section.
            // I originally tried averaging the pixels in the bitmap section.  That is
            // also not what desktop does.  Desktop does this by scaling down and then
            // scaling back up, using a Java library.  How that library decides which
            // pixel to keep when shrinking a section, I do not know.  It's not
            // something simple like averaging or choosing the center pixel.  But I
            // don't really care to find out what it is.  Averaging would give grays
            // too often, so I went with center pixel. --JAB (11/19/18)
            x = StrictMath.floor((minX + maxX) / 2);
            y = StrictMath.floor((minY + maxY) / 2);
            pixel = rgbs[x + (y * imageWidth)];
            results1.push({
              x: minPxcor + xcor,
              y: minPycor + ((worldHeight - 1) - ycor),
              color: pixel
            });
          }
          return results1;
        })());
      }
      return results;
    })();
    return [].concat(...updates).filter(function({
        color: [r, g, b, a]
      }) {
      return a !== 0;
    });
  };

  // (() => Topology, () => Number, (Number, Number) => Agent, (String) => ImageData) => (Boolean) => (String) => Unit
  importPColorsBase64 = function(getTopology, getPatchSize, getPatchAt, base64ToImageData) {
    return function(isNetLogoColorspace) {
      return function(base64) {
        return importPColorsImage(getTopology, getPatchSize, getPatchAt, isNetLogoColorspace, base64ToImageData(base64));
      };
    };
  };

  // (() => Topology, () => Number, (Number, Number) => Agent, Boolean, ImageData) => Unit
  importPColorsImage = function(getTopology, getPatchSize, getPatchAt, isNetLogoColorspace, {data, height, width}) {
    var colorGetter, ref, rgbas, toArray, updates;
    toArray = Array.from != null ? (function(xs) {
      return Array.from(xs);
    }) : (function(xs) {
      return Array.prototype.slice.call(xs);
    });
    rgbas = (function() {
      var results = [];
      for (var j = 0, ref = data.length / 4; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this).map(function(i) {
      return toArray(data.slice(i * 4, (i * 4) + 4));
    });
    updates = genPColorUpdates(getTopology(), getPatchSize(), rgbas, width, height);
    colorGetter = isNetLogoColorspace ? function(x) {
      return lookupNLColor(x);
    } : function(x) {
      return ColorModel.rgbList(x);
    };
    updates.forEach(function({x, y, color}) {
      return getPatchAt(x, y).setVariable('pcolor', colorGetter(color));
    });
  };

  module.exports = {importPColorsBase64, importPColorsImage};

}).call(this);

},{"../core/colormodel":"engine/core/colormodel","brazier/array":"brazier/array","brazier/function":"brazier/function","shim/strictmath":"shim/strictmath","util/nlmath":"util/nlmath"}],"engine/prim/inspectionprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var InspectionConfig, InspectionPrims, exceptions;

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  module.exports.Config = InspectionConfig = class InspectionConfig {
    // ((Agent) => Unit, (Agent) => Unit, () => Unit) => InspectionConfig
    constructor(inspect1 = (function() {}), stopInspecting = (function() {}), clearDead = (function() {})) {
      this.inspect = inspect1;
      this.stopInspecting = stopInspecting;
      this.clearDead = clearDead;
    }

  };

  module.exports.Prims = InspectionPrims = class InspectionPrims {
    // (InspectionConfig) => InspectionPrims
    constructor({inspect, stopInspecting, clearDead}) {
      this.stopInspecting = stopInspecting;
      this.clearDead = clearDead;
      this.inspect = function(agent) {
        if (!agent.isDead()) {
          return inspect(agent);
        } else {
          throw exceptions.runtime(`That ${agent.getBreedNameSingular()} is dead.`, "inspect");
        }
      };
    }

  };

}).call(this);

},{"util/exception":"util/exception"}],"engine/prim/layoutmanager":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var LayoutManager, NLMath, TreeNode, checks, contains, filter, flatMap, fold, foldl, forEach, id, map, maxBy, pipeline, rangeUntil, unique, values, zip;

  NLMath = require('util/nlmath');

  ({checks} = require('../core/typechecker'));

  ({contains, filter, flatMap, foldl, forEach, map, maxBy, unique, zip} = require('brazierjs/array'));

  ({id, pipeline} = require('brazierjs/function'));

  ({fold} = require('brazierjs/maybe'));

  ({rangeUntil} = require('brazierjs/number'));

  ({values} = require('brazierjs/object'));

  TreeNode = (function() {
    class TreeNode {
      
        // Turtle -> Number -> TreeNode
      constructor(_turtle, _depth) {
        this._turtle = _turtle;
        this._depth = _depth;
        this._angle = 0.0;
        this._children = [];
      }

      // Turtle -> Unit
      addChild(child) {
        this._children.push(child);
      }

      // Unit -> Number
      getAngle() {
        return this._angle;
      }

      // Unit -> Number
      getDepth() {
        return this._depth;
      }

      // Unit -> Turtle
      getTurtle() {
        return this._turtle;
      }

      getWeight() {
        var maxChildWeight;
        maxChildWeight = pipeline(map(function(c) {
          return c.getWeight();
        }), maxBy(id), fold(function() {
          return 0;
        })(id))(this._children);
        return NLMath.max(maxChildWeight * 0.8, this._children.length + 1);
      }

      layoutRadial(arcStart, arcEnd) {
        var f, weightSum;
        this._angle = (arcStart + arcEnd) / 2;
        weightSum = foldl(function(acc, x) {
          return acc + x.getWeight();
        })(0)(this._children);
        f = function(childStart, child) {
          var childEnd;
          childEnd = childStart + (arcEnd - arcStart) * child.getWeight() / weightSum;
          child.layoutRadial(childStart, childEnd);
          return childEnd;
        };
        return foldl(f)(arcStart)(this._children);
      }

    };

    TreeNode.prototype._angle = void 0; // Number

    TreeNode.prototype._children = void 0; // Array[Turtle]

    TreeNode.prototype._depth = void 0; // Number

    TreeNode.prototype._val = void 0; // Turtle

    return TreeNode;

  }).call(this);

  module.exports = LayoutManager = class LayoutManager {
    // (World, () => Number) => LayoutManager
    constructor(_world, _nextDouble) {
      this._world = _world;
      this._nextDouble = _nextDouble;
    }

    // (TurtleSet, Number) => Unit
    layoutCircle(agentsOrList, radius) {
      var midx, midy, n, turtles;
      turtles = checks.isList(agentsOrList) ? agentsOrList : agentsOrList.shufflerator().toArray();
      n = turtles.length;
      midx = this._world.topology.minPxcor + NLMath.floor(this._world.topology.width / 2);
      midy = this._world.topology.minPycor + NLMath.floor(this._world.topology.height / 2);
      return rangeUntil(0)(n).forEach(function(i) {
        var heading, turtle;
        heading = (i * 360) / n;
        turtle = turtles[i];
        turtle.patchAtHeadingAndDistance(heading, radius);
        turtle.setXY(midx, midy);
        turtle.setVariable("heading", heading);
        return turtle.jumpIfAble(radius);
      });
    }

    // (TurtleSet, LinkSet, Number, Number, Number) => Unit
    layoutSpring(nodeSet, linkSet, spr, len, rep) {
      var agt, ax, ay, degCounts, nodeCount, tMap;
      if (!nodeSet.isEmpty()) {
        [ax, ay, tMap, agt] = this._initialize(nodeSet);
        nodeCount = nodeSet.size();
        degCounts = this._calcDegreeCounts(linkSet, tMap, nodeCount);
        this._updateXYArraysForNeighbors(ax, ay, linkSet, tMap, degCounts, spr, len);
        this._updateXYArraysForAll(ax, ay, agt, degCounts, nodeCount, rep);
        this._moveTurtles(ax, ay, agt, nodeCount);
      }
    }

    // (TurtleSet, LinkSet, Number) => Unit
    layoutTutte(nodeSet, linkSet, radius) {
      var anchors, turtleXYTriplets;
      anchors = pipeline(flatMap(function({end1, end2}) {
        return [end1, end2];
      }), unique, filter(function(t) {
        return !nodeSet.contains(t);
      }))(linkSet.toArray());
      this.layoutCircle(anchors, radius);
      turtleXYTriplets = nodeSet.shuffled().toArray().map((turtle) => {
        var allOfMyLinks, compute, computeCor, degree, neighbors, relevantLinks, x, y;
        computeCor = function(turtle, neighbors, degree) {
          return function(getCor, max, min) {
            var adjustedValue, limit, limitedValue, readjustedValue, value;
            value = pipeline(map(getCor), foldl(function(a, b) {
              return a + b;
            })(0))(neighbors);
            adjustedValue = (value / degree) - getCor(turtle);
            limit = 100; // This voodoo magic makes absolutely no sense to me --JAB (11/7/16)
            limitedValue = adjustedValue > limit ? limit : adjustedValue < -limit ? -limit : adjustedValue;
            readjustedValue = limitedValue + getCor(turtle);
            if (readjustedValue > max) {
              return max;
            } else if (readjustedValue < min) {
              return min;
            } else {
              return readjustedValue;
            }
          };
        };
        allOfMyLinks = turtle.linkManager.myLinks("LINKS").toArray();
        relevantLinks = pipeline(unique, filter(function(link) {
          return linkSet.contains(link);
        }))(allOfMyLinks);
        neighbors = relevantLinks.map(function({end1, end2}) {
          if (end1 === turtle) {
            return end2;
          } else {
            return end1;
          }
        });
        degree = relevantLinks.length;
        compute = computeCor(turtle, neighbors, degree);
        x = compute((function(t) {
          return t.xcor;
        }), this._world.topology.maxPxcor, this._world.topology.minPxcor);
        y = compute((function(t) {
          return t.ycor;
        }), this._world.topology.maxPycor, this._world.topology.minPycor);
        return [turtle, x, y];
      });
      turtleXYTriplets.forEach(function([turtle, x, y]) {
        return turtle.setXY(x, y);
      });
    }

    // (TurtleSet, LinkSet, RootAgent) => Unit
    layoutRadial(nodeSet, linkSet, root) {
      var adjustPosition, allowedTurtleIDs, lastNode, layerGap, maxDepth, maxPxcor, maxPycor, minPxcor, minPycor, nodeTable, queue, rootNode, rootX, rootY, turtleIsAllowed, visitNeighbors, xDistToEdge, yDistToEdge;
      ({maxPxcor, maxPycor, minPxcor, minPycor} = this._world.topology);
      rootX = (maxPxcor + minPxcor) / 2;
      rootY = (maxPycor + minPycor) / 2;
      rootNode = new TreeNode(root, 0);
      queue = [rootNode];
      nodeTable = {};
      nodeTable[rootNode.getTurtle().id] = rootNode;
      turtleIsAllowed = linkSet.getSpecialName() == null ? (allowedTurtleIDs = pipeline(flatMap(function({end1, end2}) {
        return [end1, end2];
      }), foldl(function(acc, {id}) {
        acc[id] = true;
        return acc;
      })({}))(linkSet.toArray()), function({id}) {
        return allowedTurtleIDs[id] === true;
      }) : function() {
        return true;
      };
      visitNeighbors = function(queue, last) {
        var node;
        if (queue.length === 0) {
          return last;
        } else {
          node = queue.shift();
          node.getTurtle().linkManager.neighborsIn(linkSet).forEach(function(t) {
            var child;
            if (nodeSet.contains(t) && (nodeTable[t.id] == null) && turtleIsAllowed(t)) {
              child = new TreeNode(t, node.getDepth() + 1);
              node.addChild(child);
              nodeTable[t.id] = child;
              queue.push(child);
            }
          });
          return visitNeighbors(queue, node);
        }
      };
      lastNode = visitNeighbors(queue, rootNode);
      rootNode.layoutRadial(0, 360);
      maxDepth = NLMath.max(1, lastNode.getDepth() + .2);
      xDistToEdge = NLMath.min(maxPxcor - rootX, rootX - minPxcor);
      yDistToEdge = NLMath.min(maxPycor - rootY, rootY - minPycor);
      layerGap = NLMath.min(xDistToEdge, yDistToEdge) / maxDepth;
      adjustPosition = function(node) {
        var turtle;
        turtle = node.getTurtle();
        turtle.setXY(rootX, rootY);
        turtle.setVariable("heading", node.getAngle());
        turtle.jumpIfAble(node.getDepth() * layerGap);
      };
      pipeline(values, forEach(adjustPosition))(nodeTable);
    }

    // (TurtleSet) => (Array[Number], Array[Number], Object[Number, Number], Array[Turtle])
    _initialize(nodeSet) {
      var agt, ax, ay, tMap, turtles;
      ax = [];
      ay = [];
      tMap = [];
      agt = [];
      turtles = nodeSet.shuffled().toArray();
      forEach(function(i) {
        var turtle;
        turtle = turtles[i];
        agt[i] = turtle;
        tMap[turtle.id] = i;
        ax[i] = 0.0;
        ay[i] = 0.0;
      })(rangeUntil(0)(turtles.length));
      return [ax, ay, tMap, agt];
    }

    // (LinkSet, Object[Number, Number], Number) => Array[Number]
    _calcDegreeCounts(links, idToIndexMap, nodeCount) {
      var baseCounts;
      baseCounts = map(function() {
        return 0;
      })(rangeUntil(0)(nodeCount));
      links.forEach(function({
          end1: t1,
          end2: t2
        }) {
        var f;
        f = function(turtle) {
          var index;
          index = idToIndexMap[turtle.id];
          if (index != null) {
            return baseCounts[index]++;
          }
        };
        f(t1);
        f(t2);
      });
      return baseCounts;
    }

    // WARNING: Mutates `ax` and `ay` --JAB (7/28/14)
    // (Array[Number], Array[Number], LinkSet, Object[Number, Number], Array[Number], Number, Number) => Unit
    _updateXYArraysForNeighbors(ax, ay, links, idToIndexMap, degCounts, spr, len) {
      var indexAndCountOf;
      indexAndCountOf = function(turtle) {
        var index;
        index = idToIndexMap[turtle.id];
        if (index != null) {
          return [index, degCounts[index]];
        } else {
          return [-1, 0];
        }
      };
      links.forEach(function({
          end1: t1,
          end2: t2
        }) {
        var degCount1, degCount2, dist, div, dx, dy, f, newDX, newDY, t1Index, t2Index;
        [t1Index, degCount1] = indexAndCountOf(t1);
        [t2Index, degCount2] = indexAndCountOf(t2);
        dist = t1.distanceNotWrapped(t2);
        // links that are connecting high degree nodes should not
        // be as springy, to help prevent "jittering" behavior -FD
        div = NLMath.max((degCount1 + degCount2) / 2.0, 1.0);
        [dx, dy] = dist === 0 ? [
          (spr * len) / div,
          0 // arbitrary x-dir push-off --FD
        ] : (f = spr * (dist - len) / div, newDX = f * (t2.xcor - t1.xcor) / dist, newDY = f * (t2.ycor - t1.ycor) / dist, [newDX, newDY]);
        if (t1Index !== -1) {
          ax[t1Index] += dx;
          ay[t1Index] += dy;
        }
        if (t2Index !== -1) {
          ax[t2Index] -= dx;
          ay[t2Index] -= dy;
        }
      });
    }

    // WARNING: Mutates `ax` and `ay` --JAB (7/28/14)
    // (Array[Number], Array[Number], Array[Turtle], Array[Number], Number, Number) => Unit
    _updateXYArraysForAll(ax, ay, agents, degCounts, nodeCount, rep) {
      var ang, dist, div, dx, dy, f, i, j, k, l, newDX, newDY, ref, ref1, ref2, t1, t2;
      for (i = k = 0, ref = nodeCount; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
        t1 = agents[i];
        for (j = l = ref1 = i + 1, ref2 = nodeCount; (ref1 <= ref2 ? l < ref2 : l > ref2); j = ref1 <= ref2 ? ++l : --l) {
          t2 = agents[j];
          div = NLMath.max((degCounts[i] + degCounts[j]) / 2.0, 1.0);
          [dx, dy] = t2.xcor === t1.xcor && t2.ycor === t1.ycor ? (ang = 360 * this._nextDouble(), newDX = -(rep / div * NLMath.squash(NLMath.sin(ang))), newDY = -(rep / div * NLMath.squash(NLMath.cos(ang))), [newDX, newDY]) : (dist = t1.distanceNotWrapped(t2), f = rep / (dist * dist) / div, newDX = -(f * (t2.xcor - t1.xcor) / dist), newDY = -(f * (t2.ycor - t1.ycor) / dist), [newDX, newDY]);
          ax[i] += dx;
          ay[i] += dy;
          ax[j] -= dx;
          ay[j] -= dy;
        }
      }
    }

    // WARNING: Mutates `ax` and `ay` --JAB (7/28/14)
    // (Array[Number], Array[Number], Array[Turtle], Number) => Unit
    _moveTurtles(ax, ay, agt, nodeCount) {
      var bounded, calculateLimit, calculateXCor, calculateYCor, height, limit, maxX, maxY, minX, minY, perturbment, width;
      maxX = this._world.topology.maxPxcor;
      minX = this._world.topology.minPxcor;
      maxY = this._world.topology.maxPycor;
      minY = this._world.topology.minPycor;
      height = this._world.topology.height;
      width = this._world.topology.width;
      // we need to bump some node a small amount, in case all nodes
      // are stuck on a single line --FD
      if (nodeCount > 1) {
        perturbment = (width + height) / 1.0e10;
        ax[0] += this._nextDouble() * perturbment - perturbment / 2.0;
        ay[0] += this._nextDouble() * perturbment - perturbment / 2.0;
      }
      // try to choose something that's reasonable perceptually --
      // for temporal aliasing, don't want to jump too far on any given timestep. --FD
      limit = (width + height) / 50.0;
      bounded = function(min, max) {
        return function(x) {
          if (x < min) {
            return min;
          } else if (x > max) {
            return max;
          } else {
            return x;
          }
        };
      };
      calculateLimit = bounded(-limit, limit);
      calculateXCor = bounded(minX, maxX);
      calculateYCor = bounded(minY, maxY);
      forEach(function(i) {
        var newX, newY, turtle;
        turtle = agt[i];
        newX = calculateXCor(turtle.xcor + calculateLimit(ax[i]));
        newY = calculateYCor(turtle.ycor + calculateLimit(ay[i]));
        turtle.setXY(newX, newY);
      })(rangeUntil(0)(nodeCount));
    }

  };

}).call(this);

},{"../core/typechecker":"engine/core/typechecker","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/maybe":"brazier/maybe","brazierjs/number":"brazier/number","brazierjs/object":"brazier/object","util/nlmath":"util/nlmath"}],"engine/prim/linkprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var LinkPrims;

  module.exports = LinkPrims = (function() {
    class LinkPrims {
      
        // (World) => LinkPrims
      constructor({linkManager, selfManager}) {
        this._linkManager = linkManager;
        this._self = selfManager.self;
      }

      // (Turtle, String) => Link
      createLinkFrom(otherTurtle, breedName) {
        return this._linkManager.createDirectedLink(otherTurtle, this._self(), breedName);
      }

      // (TurtleSet, String) => LinkSet
      createLinksFrom(otherTurtles, breedName) {
        return this._linkManager.createReverseDirectedLinks(this._self(), otherTurtles.shuffled(), breedName);
      }

      // (Turtle, String) => Link
      createLinkTo(otherTurtle, breedName) {
        return this._linkManager.createDirectedLink(this._self(), otherTurtle, breedName);
      }

      // (TurtleSet, String) => LinkSet
      createLinksTo(otherTurtles, breedName) {
        return this._linkManager.createDirectedLinks(this._self(), otherTurtles.shuffled(), breedName);
      }

      // (Turtle, String) => Link
      createLinkWith(otherTurtle, breedName) {
        return this._linkManager.createUndirectedLink(this._self(), otherTurtle, breedName);
      }

      // (TurtleSet, String) => LinkSet
      createLinksWith(otherTurtles, breedName) {
        return this._linkManager.createUndirectedLinks(this._self(), otherTurtles.shuffled(), breedName);
      }

      // IN OR OUT

        // (String, Turtle) => Boolean
      isLinkNeighbor(breedName, otherTurtle) {
        return this._self().linkManager.isLinkNeighbor(breedName, otherTurtle);
      }

      // (String, Turtle) => Link
      linkWith(breedName, otherTurtle) {
        return this._self().linkManager.linkWith(breedName, otherTurtle);
      }

      // (String) => TurtleSet
      linkNeighbors(breedName) {
        return this._self().linkManager.linkNeighbors(breedName);
      }

      // (String) => LinkSet
      myLinks(breedName) {
        return this._self().linkManager.myLinks(breedName);
      }

      // OUT ONLY

        // (String, Turtle) => Boolean
      isOutLinkNeighbor(breedName, otherTurtle) {
        return this._self().linkManager.isOutLinkNeighbor(breedName, otherTurtle);
      }

      // (String, Turtle) => Link
      outLinkTo(breedName, otherTurtle) {
        return this._self().linkManager.outLinkTo(breedName, otherTurtle);
      }

      // (String) => TurtleSet
      outLinkNeighbors(breedName) {
        return this._self().linkManager.outLinkNeighbors(breedName);
      }

      // (String) => LinkSet
      myOutLinks(breedName) {
        return this._self().linkManager.myOutLinks(breedName);
      }

      // IN ONLY

        // (String, Turtle) => Boolean
      isInLinkNeighbor(breedName, otherTurtle) {
        return otherTurtle.linkManager.isOutLinkNeighbor(breedName, this._self());
      }

      // (String, Turtle) => Link
      inLinkFrom(breedName, otherTurtle) {
        return otherTurtle.linkManager.outLinkTo(breedName, this._self());
      }

      // (String) => TurtleSet
      inLinkNeighbors(breedName) {
        return this._self().linkManager.inLinkNeighbors(breedName);
      }

      // (String) => LinkSet
      myInLinks(breedName) {
        return this._self().linkManager.myInLinks(breedName);
      }

    };

    LinkPrims._linkManager = void 0; // LinkManager

    LinkPrims._self = void 0; // () => Turtle

    return LinkPrims;

  }).call(this);

}).call(this);

},{}],"engine/prim/listprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AbstractAgentSet, Comparator, Link, ListPrims, NLMath, Patch, StrictMath, Turtle, all, arrayLength, checks, exceptions, exists, filter, find, findIndex, fold, foldl, id, isEmpty, last, pipeline, sortBy, stableSort, tail;

  AbstractAgentSet = require('../core/abstractagentset');

  Link = require('../core/link');

  Patch = require('../core/patch');

  Turtle = require('../core/turtle');

  ({checks} = require('../core/typechecker'));

  StrictMath = require('shim/strictmath');

  Comparator = require('util/comparator');

  NLMath = require('util/nlmath');

  stableSort = require('util/stablesort');

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({
    all,
    exists,
    filter,
    find,
    findIndex,
    foldl,
    isEmpty,
    length: arrayLength,
    last,
    sortBy,
    tail
  } = require('brazierjs/array'));

  ({id, pipeline} = require('brazierjs/function'));

  ({fold} = require('brazierjs/maybe'));

  module.exports = ListPrims = class ListPrims {
    // type ListOrSet[T] = AbstractAgentSet|Array[T]

      // (() => String, Hasher, (Any, Any) => Boolean, (Number) => Number) => ListPrims
    constructor(_dump, _hasher, _equality, _nextInt) {
      this._dump = _dump;
      this._hasher = _hasher;
      this._equality = _equality;
      this._nextInt = _nextInt;
    }

    // [T] @ (Array[T]|String) => Array[T]|String
    butFirst(xs) {
      return tail(xs);
    }

    // [T] @ (Array[T]|String) => Array[T]|String
    butLast(xs) {
      return xs.slice(0, xs.length - 1);
    }

    // [T] @ (String|Array[T]) => Boolean
    empty(xs) {
      return isEmpty(xs);
    }

    // ((T) => Boolean, Array[T]) => Array[T]
    filter(f, xs) {
      return xs.filter(f);
    }

    // [Item] @ (Array[Item]) => Item
    first(xs) {
      return xs[0];
    }

    // [Item] @ (Item, Array[Item]) => Array[Item]
    fput(x, xs) {
      return [x].concat(xs);
    }

    // [Item] @ (Number, Array[Item], Item) => Array[Item]
    insertItem(n, xs, x) {
      var clone;
      clone = xs.slice(0);
      clone.splice(n, 0, x);
      return clone;
    }

    // [Item] @ (Number, Array[Item]) => Item
    item(n, xs) {
      return xs[NLMath.floor(n)];
    }

    // [Item] @ (Array[Item]) => Item
    last(xs) {
      return last(xs);
    }

    // [T] @ (Array[T]) => Number
    length(xs) {
      return arrayLength(xs);
    }

    // [T] @ (T*) => Array[T]
    list(...xs) {
      return xs;
    }

    // [Item] @ (Item, Array[Item]) => Array[Item]
    lput(x, xs) {
      var result;
      result = xs.slice(0);
      result.push(x);
      return result;
    }

    // (Array[Any]) => Number
    max(xs) {
      return Math.max(...xs);
    }

    // (Array[Any]) => Number
    mean(xs) {
      var sum;
      sum = xs.reduce((function(a, b) {
        return a + b;
      }), 0);
      return sum / xs.length;
    }

    // (Array[Any]) => Number
    median(xs) {
      var length, middleIndex, middleNum, nums, subMiddleNum;
      nums = sortBy(id)(xs);
      length = nums.length;
      middleIndex = StrictMath.floor(length / 2);
      middleNum = nums[middleIndex];
      if (length % 2 === 1) {
        return middleNum;
      } else {
        subMiddleNum = nums[middleIndex - 1];
        return (middleNum + subMiddleNum) / 2;
      }
    }

    // (Array[Item], Item) => Boolean
    member(x, xs) {
      return exists((y) => {
        return this._equality(x, y);
      })(xs);
    }

    // (Array[Any]) => Number
    min(xs) {
      return Math.min(...xs);
    }

    // [T] @ (Array[T]) => Array[T]
    modes(items) {
      var calculateModes, genItemCountPairs, ref, result;
      genItemCountPairs = (xs) => {
        var incrementCount, k, len, pairMaybe, pairs, pushNewPair, x;
        pairs = [];
        for (k = 0, len = xs.length; k < len; k++) {
          x = xs[k];
          pushNewPair = function() {
            return pairs.push([x, 1]);
          };
          incrementCount = function(pair) {
            return pair[1] += 1;
          };
          pairMaybe = find(([item, c]) => {
            return this._equality(item, x);
          })(pairs);
          fold(pushNewPair)(incrementCount)(pairMaybe);
        }
        return pairs;
      };
      calculateModes = function(xsToCounts) {
        var f;
        f = function([bests, bestCount], [item, count]) {
          if (count > bestCount) {
            return [[item], count];
          } else if (count < bestCount) {
            return [bests, bestCount];
          } else {
            return [bests.concat([item]), bestCount];
          }
        };
        return foldl(f)([[], 0])(xsToCounts);
      };
      ref = calculateModes(genItemCountPairs(items)), result = ref[0], ref[1];
      return result;
    }

    // (Number, AbstractAgentSet) => AbstractAgentSet
    nOfAgentSet(n, agentSet) {
      var items, newItems;
      items = agentSet.iterator().toArray();
      newItems = this._nOfArray(n, items);
      return agentSet.copyWithNewAgents(newItems);
    }

    // (Number, Array[Any]) => Array[Any]
    nOfList(n, list) {
      if (n === list.length) {
        return list;
      } else {
        return this._nOfArray(n, list);
      }
    }

    // (Number, AbstractAgentSet) => AbstractAgentSet
    upToNOfAgentSet(n, agentSet) {
      var items, newItems;
      if (n >= agentSet.size()) {
        return agentSet;
      } else {
        items = agentSet.iterator().toArray();
        newItems = this._nOfArray(n, items);
        return agentSet.copyWithNewAgents(newItems);
      }
    }

    // (Number, Array[Any]) => Array[Any]
    upToNOfList(n, list) {
      if (n >= list.length) {
        return list;
      } else {
        return this._nOfArray(n, list);
      }
    }

    // [Item] @ (ListOrSet[Item]) => Item
    oneOf(list) {
      return list[this._nextInt(list.length)];
    }

    // (Any, Array[Any]) => Number | Boolean
    position(x, xs) {
      var index;
      index = pipeline(findIndex((y) => {
        return this._equality(x, y);
      }), fold(function() {
        return -1;
      })(id))(xs);
      if (index !== -1) {
        return index;
      } else {
        return false;
      }
    }

    // (Number, Number, Number) => Array[Number]
    range(lowerBound, upperBound, stepSize) {
      var k, ref, ref1, ref2, results, x;
      results = [];
      for (x = k = ref = lowerBound, ref1 = upperBound, ref2 = stepSize; ref2 !== 0 && (ref2 > 0 ? k < ref1 : k > ref1); x = k += ref2) {
        results.push(x);
      }
      return results;
    }

    // (Number) => Array[Number]
    rangeUnary(upperBound) {
      return this.range(0, upperBound, 1);
    }

    // (Number, Number) => Array[Number]
    rangeBinary(lowerBound, upperBound) {
      return this.range(lowerBound, upperBound, 1);
    }

    // ((T, T) => U, Array[T]) => U
    reduce(f, xs) {
      // Most of the time NetLogo functions don't care about the extra args JavaScript passes in for `reduce`, but with
      // variadic concise prims those args need to be stripped off.  -Jeremy B October 2022
      if (f.isVariadic) {
        return xs.reduce(function(previous, current, i, arr) {
          return f(previous, current);
        });
      } else {
        return xs.reduce(f);
      }
    }

    // (Any, Array[Any]) => Array[Any]
    remove(x, xs) {
      return filter((y) => {
        return !this._equality(x, y);
      })(xs);
    }

    // [T] @ (Array[T]) => Array[T]
    removeDuplicates(xs) {
      var f, out, ref;
      if (xs.length < 2) {
        return xs;
      } else {
        f = ([accArr, accSet], x) => {
          var hash, values;
          hash = this._hasher(x);
          values = accSet[hash];
          if (values != null) {
            if (!exists((y) => {
              return this._equality(x, y);
            })(values)) {
              accArr.push(x);
              values.push(x);
            }
          } else {
            accArr.push(x);
            accSet[hash] = [x];
          }
          return [accArr, accSet];
        };
        ref = xs.reduce(f, [[], {}]), out = ref[0], ref[1];
        return out;
      }
    }

    // (Number, Array[Any]) => Array[Any]
    removeItem(n, xs) {
      var temp;
      temp = xs.slice(0);
      temp.splice(n, 1); // Cryptic, but effective --JAB (5/26/14)
      return temp;
    }

    // (Number, Array[Any], Any) => Array[Any]
    replaceItem(n, xs, x) {
      var temp;
      temp = xs.slice(0);
      temp.splice(n, 1, x);
      return temp;
    }

    // (Array[Any]) => Array[Any]
    reverse(xs) {
      return xs.slice(0).reverse();
    }

    // [T] @ (Array[Array[T]|T]) => Array[T]
    sentence(...xs) {
      var f;
      f = function(acc, x) {
        if (checks.isList(x)) {
          return acc.concat(x);
        } else {
          acc.push(x);
          return acc;
        }
      };
      return foldl(f)([])(xs);
    }

    // [T] @ (Array[T]) => Array[T]
    shuffle(xs) {
      var i, out, swap;
      swap = function(arr, i, j) {
        var tmp;
        tmp = arr[i];
        arr[i] = arr[j];
        return arr[j] = tmp;
      };
      out = xs.slice(0);
      i = out.length;
      while (i > 1) {
        swap(out, i - 1, this._nextInt(i));
        i--;
      }
      return out;
    }

    // (Array[Any]) => Array[Any]
    sort(xs) {
      var Agent, None, Number, String, f, filteredItems, filteredType;
      // data SortableType =
      Number = {};
      String = {};
      Agent = {};
      None = {};
      f = function(acc, x) {
        var arr, type, xType;
        xType = checks.isNumber(x) ? Number : checks.isString(x) ? String : checks.isAgent(x) && (x.id !== -1) ? Agent : None;
        [type, arr] = acc;
        switch (xType) {
          case Number: // Numbers trump all
            switch (type) {
              case Number:
                return [Number, arr.concat([x])];
              default:
                return [Number, [x]];
            }
            break;
          case String: // Strings trump agents
            switch (type) {
              case String:
                return [String, arr.concat([x])];
              case Agent:
              case None:
                return [String, [x]];
              default:
                return acc;
            }
            break;
          case Agent:
            switch (type) {
              case Agent:
                return [Agent, arr.concat([x])];
              case None:
                return [Agent, [x]];
              default:
                return acc;
            }
            break;
          default:
            return acc;
        }
      };
      [filteredType, filteredItems] = foldl(f)([None, []])(xs);
      switch (filteredType) {
        case None:
          return filteredItems;
        case Number:
          return filteredItems.sort(function(x, y) {
            return Comparator.numericCompare(x, y).toInt;
          });
        case String:
          return filteredItems.sort();
        case Agent:
          return stableSort(filteredItems)(function(x, y) {
            return x.compare(y).toInt;
          });
        default:
          throw exceptions.internal("We don't know how to sort your kind here!");
      }
    }

    // ((Agent, Agent) => Boolean, AbstractAgentSet) => Array[Agent]
    sortByAgentSet(task, agentSet) {
      return this.sortByList(task, agentSet.shufflerator().toArray());
    }

    // ((T, T) => Boolean, Array[T]) => Array[T]
    sortByList(task, xs) {
      var f;
      f = function(x, y) {
        var xy, yx;
        xy = task(x, y);
        yx = task(y, x);
        if (xy === yx) {
          return 0;
        } else if (xy) {
          return -1;
        } else {
          return 1;
        }
      };
      return stableSort(xs)(f);
    }

    // (Array[Any]) => Number
    standardDeviation(xs) {
      var mean, squareDiff, stdDev;
      mean = this.sum(xs) / xs.length;
      squareDiff = foldl(function(acc, x) {
        return acc + StrictMath.pow(x - mean, 2);
      })(0)(xs);
      stdDev = StrictMath.sqrt(squareDiff / (xs.length - 1));
      return stdDev;
    }

    // [T] @ (Array[T], Number, Number) => Array[T]
    sublist(xs, n1, n2) {
      return xs.slice(n1, n2);
    }

    // (Array[Any]) => Number
    sum(xs) {
      return xs.reduce((function(a, b) {
        return a + b;
      }), 0);
    }

    // [T] @ (Array[T]) => Number
    variance(xs) {
      var count, mean, squareOfDifference, sum;
      count = xs.length;
      sum = xs.reduce((function(acc, x) {
        return acc + x;
      }), 0);
      mean = sum / count;
      squareOfDifference = xs.reduce((function(acc, x) {
        return acc + StrictMath.pow(x - mean, 2);
      }), 0);
      return squareOfDifference / (count - 1);
    }

    // Prodding at this code is like poking a beehive with a stick... --JAB (7/30/14)
    // [Item] @ (Number, Array[Item]) => Array[Item]
    _nOfArray(n, items) {
      var i, index1, index2, j, newIndex1, newIndex2, result;
      switch (n) {
        case 0:
          return [];
        case 1:
          return [items[this._nextInt(items.length)]];
        case 2:
          index1 = this._nextInt(items.length);
          index2 = this._nextInt(items.length - 1);
          [newIndex1, newIndex2] = index2 >= index1 ? [index1, index2 + 1] : [index2, index1];
          return [items[newIndex1], items[newIndex2]];
        default:
          n = NLMath.floor(n);
          i = 0;
          j = 0;
          result = [];
          while (j < n) {
            if (this._nextInt(items.length - i) < n - j) {
              result.push(items[i]);
              j += 1;
            }
            i += 1;
          }
          return result;
      }
    }

  };

}).call(this);

},{"../core/abstractagentset":"engine/core/abstractagentset","../core/link":"engine/core/link","../core/patch":"engine/core/patch","../core/turtle":"engine/core/turtle","../core/typechecker":"engine/core/typechecker","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/maybe":"brazier/maybe","shim/strictmath":"shim/strictmath","util/comparator":"util/comparator","util/exception":"util/exception","util/nlmath":"util/nlmath","util/stablesort":"util/stablesort"}],"engine/prim/mouseprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var MouseConfig, MousePrims;

  module.exports.Config = MouseConfig = class MouseConfig {
    // (() => Boolean, () => Boolean, () => Number, () => Number)
    constructor(peekIsDown = (function() {
        return false;
      }), peekIsInside = (function() {
        return false;
      }), peekX = (function() {
        return 0;
      }), peekY = (function() {
        return 0;
      })) {
      this.peekIsDown = peekIsDown;
      this.peekIsInside = peekIsInside;
      this.peekX = peekX;
      this.peekY = peekY;
    }

  };

  module.exports.Prims = MousePrims = class MousePrims {
    // (MouseConfig) => MousePrims
    constructor({
        peekIsDown: isDown,
        peekIsInside: isInside,
        peekX: getX,
        peekY: getY
      }) {
      this.isDown = isDown;
      this.isInside = isInside;
      this.getX = getX;
      this.getY = getY;
    }

  };

}).call(this);

},{}],"engine/prim/outputprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var OutputConfig, OutputPrims, genPrintBundle;

  genPrintBundle = require('./printbundle');

  // type PrintFunc = (String) => Unit
  module.exports.Config = OutputConfig = class OutputConfig {
    // (() => Unit, PrintFunc) => OutputConfig
    constructor(clear1 = (function() {}), write1 = (function() {})) {
      this.clear = clear1;
      this.write = write1;
    }

  };

  module.exports.Prims = OutputPrims = (function() {
    class OutputPrims {
      
        // (OutputConfig, (String) => Unit, () => Unit, (Any, Boolean) => String) => OutputPrims
      constructor({clear, write}, writeToStore, clearStored, dump) {
        var writePlus;
        this.clear = (function() {
          clearStored();
          return clear();
        });
        writePlus = (function(x) {
          writeToStore(x);
          return write(x);
        });
        ({print: this.print, show: this.show, type: this.type, write: this.write} = genPrintBundle(writePlus, dump));
      }

    };

    OutputPrims.prototype.clear = void 0; // () => Unit

    OutputPrims.prototype.print = void 0; // PrintFunc

    OutputPrims.prototype.show = void 0; // (() => Number|Agent) => PrintFunc

    OutputPrims.prototype.type = void 0; // PrintFunc

    OutputPrims.prototype.write = void 0; // PrintFunc

    return OutputPrims;

  }).call(this);

}).call(this);

},{"./printbundle":"engine/prim/printbundle"}],"engine/prim/prims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var AbstractAgentSet, EQ, GT, LT, Link, LinkSet, Patch, PatchSet, Prims, StrictMath, Timer, Turtle, TurtleSet, checks, exceptions, flatMap, flattenDeep, getNeighbors, getNeighbors4, getTypeOf, greaterThan, isEmpty, lessThan, map, notImplemented;

  AbstractAgentSet = require('../core/abstractagentset');

  Link = require('../core/link');

  LinkSet = require('../core/linkset');

  Patch = require('../core/patch');

  PatchSet = require('../core/patchset');

  Turtle = require('../core/turtle');

  TurtleSet = require('../core/turtleset');

  ({checks, getTypeOf} = require('../core/typechecker'));

  StrictMath = require('shim/strictmath');

  Timer = require('util/timer');

  notImplemented = require('util/notimplemented');

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({flatMap, flattenDeep, isEmpty, map} = require('brazierjs/array'));

  ({
    EQUALS: EQ,
    GREATER_THAN: GT,
    LESS_THAN: LT
  } = require('util/comparator'));

  getNeighbors = function(patch) {
    return patch.getNeighbors();
  };

  getNeighbors4 = function(patch) {
    return patch.getNeighbors4();
  };

  lessThan = function(a, b) {
    return a < b;
  };

  greaterThan = function(a, b) {
    return a > b;
  };

  module.exports = Prims = (function() {
    class Prims {
      
        // (Dump, Hasher, RNG, World) => Prims
      constructor(_dumper, _hasher, _rng, _world, _printPrims) {
        this._dumper = _dumper;
        this._hasher = _hasher;
        this._rng = _rng;
        this._world = _world;
        this._printPrims = _printPrims;
        this._everyMap = {};
      }

      // () => Nothing
      boom() {
        throw exceptions.runtime("boom!", "boom");
      }

      // (String, Agent) -> TurtleSet
      breedOnAgent(breedName, agent) {
        var turtles;
        turtles = agent.breedHereArray(breedName);
        return new TurtleSet(turtles, this._world);
      }

      // (String, Turtle | Patch) -> TurtleSet
      anyBreedOnAgent(breedName, agent) {
        return agent.anyBreedHere(breedName);
      }

      // (String, AgentSet) -> TurtleSet
      breedOnAgentSet(breedName, agents) {
        var turtles;
        turtles = flatMap(function(p) {
          return p.breedHereArray(breedName);
        })(agents.toArray());
        return new TurtleSet(turtles, this._world);
      }

      // (String, TurtleSet | PatchSet) -> Boolean
      anyBreedOnAgentSet(breedName, agents) {
        var j, k, len, len1, patch, ref, ref1, seenPatches, turtle;
        if (checks.isPatchSet(agents)) {
          ref = agents.toArray();
          for (j = 0, len = ref.length; j < len; j++) {
            patch = ref[j];
            if (patch.anyBreedHere(breedName)) {
              return true;
            }
          }
        } else {
          seenPatches = [];
          ref1 = agents.toArray();
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            turtle = ref1[k];
            patch = turtle.getPatchHere();
            if (!seenPatches.includes(patch)) {
              seenPatches.push(patch);
              if (patch.anyBreedHere(breedName)) {
                return true;
              }
            }
          }
        }
        return false;
      }

      // (Any, String) => Boolean
      booleanCheck(b, primName) {
        if (checks.isBoolean(b)) {
          return b;
        } else {
          throw exceptions.runtime(`${primName} expected input to be a TRUE/FALSE but got the ${getTypeOf(b).niceName()} ${this._dumper(b)} instead.`, primName);
        }
      }

      // () => Unit
      display() {
        if (!this._hasDisplayed) {
          this._hasDisplayed = true;
          notImplemented('display', void 0);
        }
      }

      // (Any) => Boolean
      ifElseValueBooleanCheck(b) {
        return this.booleanCheck(b, "IFELSE-VALUE");
      }

      // () => Unit
      ifElseValueMissingElse() {
        throw exceptions.runtime("IFELSE-VALUE found no true conditions and no else branch. If you don't wish to error when no conditions are true, add a final else branch.", "ifelse-value");
      }

      // (Any, Any) => Boolean
      equality(a, b) {
        var subsumes;
        if ((a != null) && (b != null)) {
          return (a === b) || checks.isBreedSet(typeof b.getSpecialName === "function" ? b.getSpecialName() : void 0, a) || checks.isBreedSet(typeof a.getSpecialName === "function" ? a.getSpecialName() : void 0, b) || (checks.isNobody(a) && (typeof b.isDead === "function" ? b.isDead() : void 0)) || (checks.isNobody(b) && (typeof a.isDead === "function" ? a.isDead() : void 0)) || ((checks.isTurtle(a) || (checks.isLink(a) && !checks.isNobody(b))) && a.compare(b) === EQ) || (checks.isList(a) && checks.isList(b) && a.length === b.length && a.every((elem, i) => {
            return this.equality(elem, b[i]);
          })) || (checks.isAgentSet(a) && checks.isAgentSet(b) && a.size() === b.size() && Object.getPrototypeOf(a) === Object.getPrototypeOf(b) && (subsumes = (xs, ys) => {
            var index, j, len, x;
            for (index = j = 0, len = xs.length; j < len; index = ++j) {
              x = xs[index];
              if (!this.equality(ys[index], x)) {
                return false;
              }
            }
            return true;
          }, subsumes(a.sort(), b.sort())));
        } else {
          throw exceptions.internal("Checking equality on undefined is an invalid condition");
        }
      }

      // () => String
      dateAndTime() {
        var amOrPM, calendarComponent, clockTime, d, date, hours, hoursNum, millis, minutes, modHours, month, numberToMonth, seconds, withThreeDigits, withTwoDigits, year;
        withTwoDigits = function(x) {
          return (x < 10 ? "0" : "") + x;
        };
        withThreeDigits = function(x) {
          return (x < 10 ? "00" : x < 100 ? "0" : "") + x;
        };
        numberToMonth = {
          1: "Jan",
          2: "Feb",
          3: "Mar",
          4: "Apr",
          5: "May",
          6: "Jun",
          7: "Jul",
          8: "Aug",
          9: "Sep",
          10: "Oct",
          11: "Nov",
          12: "Dec"
        };
        d = new Date();
        hoursNum = d.getHours();
        modHours = hoursNum === 0 || hoursNum === 12 ? 12 : hoursNum % 12;
        hours = withTwoDigits(modHours);
        minutes = withTwoDigits(d.getMinutes());
        seconds = withTwoDigits(d.getSeconds());
        clockTime = `${hours}:${minutes}:${seconds}`;
        millis = withThreeDigits(d.getMilliseconds());
        amOrPM = hoursNum >= 12 ? "PM" : "AM";
        date = withTwoDigits(d.getDate());
        month = numberToMonth[d.getMonth() + 1];
        year = d.getFullYear();
        calendarComponent = `${date}-${month}-${year}`;
        return `${clockTime}.${millis} ${amOrPM} ${calendarComponent}`;
      }

      // (String, Agent|Number, Number) => Boolean
      isThrottleTimeElapsed(commandID, agent, timeLimit) {
        var entry;
        entry = this._everyMap[this._genEveryKey(commandID, agent)];
        return (entry == null) || entry.elapsed() >= timeLimit;
      }

      // (String, Agent|Number) => Unit
      resetThrottleTimerFor(commandID, agent) {
        return this._everyMap[this._genEveryKey(commandID, agent)] = new Timer();
      }

      // (Any, Any) => Boolean
      gt(a, b) {
        if ((checks.isNumber(a) && checks.isNumber(b)) || (checks.isString(a) && checks.isString(b))) {
          return a > b;
        } else if (typeof a === typeof b && (a.compare != null) && (b.compare != null)) {
          return a.compare(b) === GT;
        } else {
          throw exceptions.internal("Invalid operands to `gt`");
        }
      }

      // (Any, Any) => Boolean
      gte(a, b) {
        var result;
        if ((checks.isNumber(a) && checks.isNumber(b)) || (checks.isString(a) && checks.isString(b))) {
          return a >= b;
        } else if (typeof a === typeof b && (a.compare != null) && (b.compare != null)) {
          result = a.compare(b);
          return result === GT || result === EQ;
        } else {
          throw exceptions.internal("Invalid operands to `gt`");
        }
      }

      // [T <: (Array[Link]|Link|AbstractAgentSet[Link])] @ (T*) => LinkSet
      linkSet(inputs) {
        return this._createAgentSet(inputs, Link, LinkSet);
      }

      // (Any, Any) => Boolean
      lt(a, b) {
        if ((checks.isNumber(a) && checks.isNumber(b)) || (checks.isString(a) && checks.isString(b))) {
          return a < b;
        } else if (typeof a === typeof b && (a.compare != null) && (b.compare != null)) {
          return a.compare(b) === LT;
        } else {
          throw exceptions.internal("Invalid operands to `lt`");
        }
      }

      // (Any, Any) => Boolean
      // Why don't we simply use lt + eq (and in gte's case, gt + eq?) Because it will cause many unnecessary type checks.
      // In many cases, the goal for those prims - very frequently executed by NL code - is not to keep short, but rather to achieve the best performance,
      // even if it means additional amount of code. --JC (01/30/23)
      lte(a, b) {
        var result;
        if ((checks.isNumber(a) && checks.isNumber(b)) || (checks.isString(a) && checks.isString(b))) {
          return a <= b;
        } else if (typeof a === typeof b && (a.compare != null) && (b.compare != null)) {
          result = a.compare(b);
          return result === LT || result === EQ;
        } else {
          throw exceptions.internal("Invalid operands to `lt`");
        }
      }

      // Some complications here....

      // First, this will not yield the same results as the equivalent primitive in JVM NetLogo.
      // The Java documentation for `System.nanoTime` explains that its nanotimes are set against an arbitrary origin time
      // that isn't even guaranteed to be consistent across JVM instances.  Naturally, JS engines can't reproduce it,
      // either.

      // Secondly, the resolution here is inconsistent.  In any modern browser, we can use the "High Resolution Time" API
      // but, right now, it's only a "Recommendation" and not a "Standard", so it is actually not implemented yet in
      // Nashorn.  Because of that, we use `performance.now()` if we can, but fall back to `Date.now()` if High Performance
      // Time is not available.

      // Thirdly, though, even when we have `performance.now()`, the time resolution is only guaranteed to be microsecond
      // precision.  When we use `Date.now()`, the time resolution is in milliseconds.  Regardless of the resolution,
      // though, the value is converted to nanoseconds.

      // So, in summary, the resolution of this implementation of `__nano-time` is inconsistent and not actually
      // nanoseconds, and is not consistent with the times provided in JVM NetLogo, but the Java Docs for
      // `System.nanoTime()` state that it is only to be used for measuring elapsed time, and that should still be
      // reasonably possible with the prim behavior supplied here. --JAB (1/11/16)

      // () => Number
      nanoTime() {
        var nanos, ref;
        nanos = ((ref = typeof performance !== "undefined" && performance !== null ? typeof performance.now === "function" ? performance.now() : void 0 : void 0) != null ? ref : Date.now()) * 1e6;
        return StrictMath.floor(nanos);
      }

      // [T <: (Array[Patch]|Patch|AbstractAgentSet[Patch])] @ (T*) => PatchSet
      patchSet(inputs) {
        return this._createAgentSet(inputs, Patch, PatchSet);
      }

      // (Any) => Unit
      stdout(x) {
        var dumpedX;
        dumpedX = this._dumper(x);
        if (typeof console !== "undefined" && console !== null) {
          console.log(dumpedX);
        } else if (typeof print !== "undefined" && print !== null) {
          print(dumpedX);
        } else {
          throw exceptions.internal(`We don't know how to output text on this platform.  But, if it helps you any, here's the thing you wanted to see: ${dumpedX}`);
        }
      }

      // [T <: (Array[Turtle]|Turtle|AbstractAgentSet[Turtle])] @ (T*) => TurtleSet
      turtleSet(inputs) {
        return this._createAgentSet(inputs, Turtle, TurtleSet);
      }

      // (Patch|Turtle) => TurtleSet
      turtlesOnAgent(agent) {
        return agent.turtlesHere();
      }

      // (Patch|Turtle) => Boolean
      anyTurtlesOnAgent(agent) {
        return checks.isTurtle(agent) || !agent.turtlesHere().isEmpty();
      }

      // (PatchSet|TurtleSet) => TurtleSet
      turtlesOnAgentSet(agents) {
        var turtles;
        turtles = flatMap(function(agent) {
          return agent.turtlesHere().toArray();
        })(agents.iterator().toArray());
        return new TurtleSet(Array.from(new Set(turtles)), this._world);
      }

      // (PatchSet|TurtleSet) => Boolean
      anyTurtlesOnAgentSet(agents) {
        var agent, j, len;
        if (checks.isTurtleSet(agents)) {
          return !agents.isEmpty();
        }
// This is intentionally written as a loop for the `_anyturtleson` compiler optimization early exit -Jeremy B March
// 2024
        for (j = 0, len = agents.length; j < len; j++) {
          agent = agents[j];
          if (!agent.turtlesHere().isEmpty()) {
            return true;
          }
        }
        return false;
      }

      // (Number) => Unit
      wait(seconds) {
        if (!this._hasWaited) {
          this._hasWaited = true;
          this._printPrims.print('NOTE: This model uses the `wait` primitive, but it is not yet properly implemented.\nUsing `wait` will not cause time to pass but the model will run normally.');
          notImplemented('wait', void 0);
        }
      }

      // (String) => Unit
      uphill(varName) {
        this._moveUpOrDownhill(-2e308, greaterThan, getNeighbors, varName);
      }

      // (String) => Unit
      uphill4(varName) {
        this._moveUpOrDownhill(-2e308, greaterThan, getNeighbors4, varName);
      }

      // (String) => Unit
      downhill(varName) {
        this._moveUpOrDownhill(2e308, lessThan, getNeighbors, varName);
      }

      // (String) => Unit
      downhill4(varName) {
        this._moveUpOrDownhill(2e308, lessThan, getNeighbors4, varName);
      }

      // (Number, (Number, Number) => Boolean, (Patch) => PatchSet, String) => Unit
      _moveUpOrDownhill(worstPossible, findIsBetter, getNeighbors, varName) {
        var patch, turtle, winner, winners, winningValue;
        turtle = SelfManager.self();
        patch = turtle.getPatchHere();
        winningValue = worstPossible;
        winners = [];
        getNeighbors(patch).forEach(function(neighbor) {
          var value;
          value = neighbor.getPatchVariable(varName);
          if (checks.isNumber(value)) {
            if (findIsBetter(value, winningValue)) {
              winningValue = value;
              return winners = [neighbor];
            } else if (winningValue === value) {
              return winners.push(neighbor);
            }
          }
        });
        if (winners.length !== 0 && findIsBetter(winningValue, patch.getPatchVariable(varName))) {
          winner = winners[this._rng.nextInt(winners.length)];
          turtle.face(winner);
          turtle.moveTo(winner);
        }
      }

      // (String, Agent|Number) => String
      _genEveryKey(commandID, agent) {
        var agentID;
        agentID = agent === 0 ? "observer" : this._dumper(agent);
        return `${commandID}__${agentID}`;
      }

      // [T <: Agent, U <: AbstractAgentSet[T], V <: (Array[T]|T|AbstractAgentSet[T])] @ (Array[V], T.Class, U.Class) => U
      _createAgentSet(inputs, tClass, outClass) {
        var addT, buildFromAgentSet, buildItems, flattened, hashIt, hashSet, head, makeOutie, result;
        flattened = flattenDeep(inputs);
        makeOutie = (agents) => {
          return new outClass(agents, this._world);
        };
        if (isEmpty(flattened)) {
          return makeOutie([]);
        } else if (flattened.length === 1) {
          head = flattened[0];
          if (head instanceof outClass) {
            return makeOutie(head.toArray());
          } else if (head instanceof tClass) {
            return makeOutie([head]);
          } else {
            return makeOutie([]);
          }
        } else {
          result = [];
          hashSet = {};
          hashIt = this._hasher;
          addT = function(p) {
            var hash;
            hash = hashIt(p);
            if (!hashSet.hasOwnProperty(hash)) {
              result.push(p);
              hashSet[hash] = true;
            }
          };
          buildFromAgentSet = function(agentSet) {
            return agentSet.forEach(addT);
          };
          buildItems = (inputs) => {
            var input, j, len, results;
            results = [];
            for (j = 0, len = inputs.length; j < len; j++) {
              input = inputs[j];
              if (checks.isList(input)) {
                results.push(buildItems(input));
              } else if (input instanceof tClass) {
                results.push(addT(input));
              } else if (input !== Nobody) {
                results.push(buildFromAgentSet(input));
              } else {
                results.push(void 0);
              }
            }
            return results;
          };
          buildItems(flattened);
          return makeOutie(result);
        }
      }

    };

    // type ListOrSet[T] = Array[T]|AbstractAgentSet[T]
    Prims.prototype._everyMap = void 0; // Object[String, Timer]

    Prims.prototype._hasDisplayed = false;

    Prims.prototype._hasWaited = false;

    return Prims;

  }).call(this);

}).call(this);

},{"../core/abstractagentset":"engine/core/abstractagentset","../core/link":"engine/core/link","../core/linkset":"engine/core/linkset","../core/patch":"engine/core/patch","../core/patchset":"engine/core/patchset","../core/turtle":"engine/core/turtle","../core/turtleset":"engine/core/turtleset","../core/typechecker":"engine/core/typechecker","brazierjs/array":"brazier/array","shim/strictmath":"shim/strictmath","util/comparator":"util/comparator","util/exception":"util/exception","util/notimplemented":"util/notimplemented","util/timer":"util/timer"}],"engine/prim/printbundle":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var PrintBundle, pipeline;

  ({pipeline} = require('brazierjs/function'));

  // type PrintFunc = (String) => Unit

    // (PrintFunc, (Any, Boolean) => String) => PrintBundle
  PrintBundle = class PrintBundle {
    // (PrintFunc, PrintFunc, PrintFunc, (() => Number|Agent) => PrintFunc) => PrintBundle
    constructor(print1, type1, write1, show1) {
      this.print = print1;
      this.type = type1;
      this.write = write1;
      this.show = show1;
    }

  };

  module.exports = function(printFunc, dump) {
    var dumpWrapped, newLine, preSpace, prependAgent, print, show, type, write, writeAfter;
    preSpace = function(s) {
      return " " + s;
    };
    newLine = function(s) {
      return s + "\n";
    };
    dumpWrapped = function(s) {
      return dump(s, true);
    };
    prependAgent = function(thunk) {
      return function(s) {
        var agentOrZero, agentStr;
        agentOrZero = thunk();
        agentStr = agentOrZero === 0 ? "observer" : dump(agentOrZero);
        return `${agentStr}: ${s}`;
      };
    };
    writeAfter = function(...fs) {
      return pipeline(...fs, printFunc);
    };
    print = writeAfter(dump, newLine);
    type = writeAfter(dump);
    write = writeAfter(dumpWrapped, preSpace);
    show = function(agentThunk) {
      return writeAfter(dumpWrapped, prependAgent(agentThunk), newLine);
    };
    return new PrintBundle(print, type, write, show);
  };

}).call(this);

},{"brazierjs/function":"brazier/function"}],"engine/prim/printprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var PrintConfig, PrintPrims, genPrintBundle;

  genPrintBundle = require('./printbundle');

  // type PrintFunc = (String) => Unit
  module.exports.Config = PrintConfig = class PrintConfig {
    // (PrintFunc) => PrintConfig
    constructor(write1 = (function() {})) {
      this.write = write1;
    }

  };

  module.exports.Prims = PrintPrims = (function() {
    class PrintPrims {
      
        // (PrintConfig, (Any, Boolean) => String) => PrintPrims
      constructor({write}, dump) {
        ({print: this.print, show: this.show, type: this.type, write: this.write} = genPrintBundle(write, dump));
      }

    };

    PrintPrims.prototype.print = void 0; // PrintFunc

    PrintPrims.prototype.show = void 0; // (() => Number|Agent) => PrintFunc

    PrintPrims.prototype.type = void 0; // PrintFunc

    PrintPrims.prototype.write = void 0; // PrintFunc

    return PrintPrims;

  }).call(this);

}).call(this);

},{"./printbundle":"engine/prim/printbundle"}],"engine/prim/procedure-context":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var CommandContext, PlotContext, ProcedureContext, ProcedureStack, RawContext, ReporterContext, StringCommandTaskContext, StringReporterTaskContext, StringTaskContext;

  ProcedureContext = (function() {
    class ProcedureContext {
      constructor(name1) {
        this.name = name1;
        this._stringRunLetVars = new Map();
      }

      // This is for procedure arguments only, so as to skip the ask/task checks.  -Jeremy B March 2021
      // (String, Any) => Unit
      registerStringRunArg(name, value) {
        this._stringRunLetVars.set(name, value);
      }

      // (String, Any) => Unit
      registerStringRunVar(name, value) {
        // `run` with strings only sees proc args and let vars, not those defined inside `ask`
        // blocks or anonymous procedures.  -Jeremy B March 2021
        if (!(this.isInsideAsk() || this.isInsideTask())) {
          this._stringRunLetVars.set(name, value);
        }
      }

      // (String, Any) => Unit
      updateStringRunVar(name, value) {
        if (this._stringRunLetVars.has(name)) {
          this._stringRunLetVars.set(name, value);
        }
      }

      // () => Map[String, Any]
      stringRunVars() {
        if (this.isInsideTask()) {
          return new Map();
        } else {
          return new Map(this._stringRunLetVars);
        }
      }

      // () => Unit
      startAsk() {
        this._askDepth = this._askDepth + 1;
      }

      // () => Unit
      endAsk() {
        this._askDepth = this._askDepth - 1;
      }

      // () => Unit
      startTask() {
        this._taskDepth = this._taskDepth + 1;
      }

      // () => Unit
      endTask() {
        this._taskDepth = this._taskDepth - 1;
      }

      // () => Boolean
      isInsideAsk() {
        return this._askDepth !== 0;
      }

      // () => Boolean
      isInsideTask() {
        return this._taskDepth !== 0;
      }

    };

    // It might seem weird to track these seperately and just as numbers, but at the moment
    // there isn't really any extra context information that we need.  -Jeremy B March 2021
    ProcedureContext.prototype._askDepth = 0; // Int

    ProcedureContext.prototype._taskDepth = 0; // Int

    
    // Map[String, Any]
    ProcedureContext.prototype._stringRunLetVars = null;

    return ProcedureContext;

  }).call(this);

  CommandContext = class CommandContext extends ProcedureContext {
    constructor(name, location) {
      super(name);
      this.location = location;
    }

    isReportAllowed() {
      return false;
    }

    isStopAllowed() {
      return true;
    }

    trace() {
      return {
        type: "command",
        name: this.name,
        location: this.location
      };
    }

  };

  ReporterContext = class ReporterContext extends ProcedureContext {
    constructor(name, location) {
      super(name);
      this.location = location;
    }

    isReportAllowed() {
      return true;
    }

    isStopAllowed() {
      return this.isInsideAsk();
    }

    trace() {
      return {
        type: "reporter",
        name: this.name,
        location: this.location
      };
    }

  };

  PlotContext = class PlotContext extends ProcedureContext {
    isReportAllowed() {
      return false;
    }

    isStopAllowed() {
      return true;
    }

    trace() {
      return {
        type: "plot",
        name: this.name
      };
    }

    // In the plot context, no lets allowed.  -Jeremy B March 2021
    registerStringRunVar() {}

    updateStringRunVar() {}

  };

  StringTaskContext = class StringTaskContext extends ProcedureContext {
    constructor(outerContext) {
      super("");
      this._askDepth = outerContext._askDepth;
      this._taskDepth = outerContext._taskDepth;
      this._stringRunLetVars = new Map(outerContext._stringRunLetVars);
      return;
    }

  };

  StringCommandTaskContext = class StringCommandTaskContext extends StringTaskContext {
    isReportAllowed() {
      return false;
    }

    isStopAllowed() {
      return true;
    }

    trace() {
      return {
        type: "run"
      };
    }

  };

  StringReporterTaskContext = class StringReporterTaskContext extends StringTaskContext {
    isReportAllowed() {
      return false;
    }

    isStopAllowed() {
      return false;
    }

    trace() {
      return {
        type: "runresult"
      };
    }

    // String reporter should be a single expression, no lets allowed.  -Jeremy B September 2021
    registerStringRunVar() {}

    updateStringRunVar() {}

  };

  RawContext = class RawContext extends ProcedureContext {
    constructor() {
      super("");
    }

    trace() {
      return {
        type: "raw"
      };
    }

    isReportAllowed() {
      return true;
    }

    isStopAllowed() {
      return true;
    }

    // In the raw context, no lets allowed.  -Jeremy B March 2021
    registerStringRunVar() {}

    updateStringRunVar() {}

  };

  ProcedureStack = (function() {
    class ProcedureStack {
      constructor() {
        this._stack = [new RawContext()];
      }

      // () => Array[{ type: "command" | "reporter" | "run" | "runresult" | "plot" | "raw", name: String }]
      trace() {
        return this._stack.map(function(context) {
          return context.trace();
        }).filter(function(frame) {
          return frame.type !== "raw";
        }).reverse();
      }

      // () => ProcedureContext
      currentContext() {
        return this._stack[this._stack.length - 1];
      }

      // (Command) => Unit
      startCommand(command) {
        this._stack.push(new CommandContext(command.name, command.location));
      }

      // (Reporter) => Unit
      startReporter(reporter) {
        this._stack.push(new ReporterContext(reporter.name, reporter.location));
      }

      // (String) => Unit
      startPlot(name) {
        this._stack.push(new PlotContext(name));
      }

      startStringCommandTask() {
        this._stack.push(new StringCommandTaskContext(this.currentContext()));
      }

      startStringReporterTask() {
        this._stack.push(new StringReporterTaskContext(this.currentContext()));
      }

      // () => Unit
      endCall() {
        this._stack.pop();
      }

      // () => Unit
      reset() {
        this._stack = [new RawContext()];
      }

    };

    // Array[ProcedureContext]
    ProcedureStack.prototype._stack = null;

    return ProcedureStack;

  }).call(this);

  module.exports = {CommandContext, ReporterContext, RawContext, ProcedureStack};

}).call(this);

},{}],"engine/prim/procedureprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Command, ProcedurePrims, ProcedureStack, Reporter, StopInterrupt;

  ({Command, Reporter} = require('./procedure'));

  ({ProcedureStack} = require('./procedure-context'));

  ({StopInterrupt} = require('util/interrupts'));

  ProcedurePrims = (function() {
    class ProcedurePrims {
      constructor(evalPrims, plotManager, rng) {
        this.evalPrims = evalPrims;
        this.plotManager = plotManager;
        this.rng = rng;
        this._commands = new Map();
        this._reporters = new Map();
        this._stack = new ProcedureStack();
      }

      // () => ProcedureStack
      stack() {
        return this._stack;
      }

      // (String, Int, Int, () => Unit) => Unit
      defineCommand(name, start, end, command) {
        this._commands.set(name, new Command(name, start, end, command));
      }

      // (String, Int, Int, () => Any) => Unit
      defineReporter(name, start, end, reporter) {
        this._reporters.set(name, new Reporter(name, start, end, reporter));
      }

      // (Agent|AgentSet, () => Any, Boolean) => Unit | DeathInterrupt
      ask(agents, f, shuffle) {
        this._stack.currentContext().startAsk();
        try {
          return agents.ask(f, shuffle);
        } finally {
          this._stack.currentContext().endAsk();
        }
      }

      // (String) => Boolean
      hasCommand(name) {
        return this._commands.has(name);
      }

      // (String) => Boolean
      hasReporter(name) {
        return this._reporters.has(name);
      }

      // (String, Array[Any]) => StopInterrupt | undefined
      callCommand(name, ...args) {
        var command;
        command = this._commands.get(name);
        this._stack.startCommand(command);
        try {
          return command.call(...args);
        } finally {
          this._stack.endCall();
        }
      }

      // (String, Array[Any]) => Any
      callReporter(name, ...args) {
        var reporter;
        reporter = this._reporters.get(name);
        this._stack.startReporter(reporter);
        try {
          return reporter.call(...args);
        } finally {
          this._stack.endCall();
        }
      }

      // (String) => String
      checkSyntax(str) {
        var e;
        try {
          this.evalPrims.compileFromString(str, false, this._stack.currentContext().stringRunVars());
          return "";
        } catch (error) {
          e = error;
          return e.message;
        }
      }

      // (String, String | undefined, () => Any) => Any
      runInPlotContext(plotName, penName, f) {
        this._stack.startPlot(plotName);
        try {
          return this.rng.withPlot(() => {
            return this.plotManager.withTemporaryContext(plotName, penName)(f);
          });
        } finally {
          this._stack.endCall();
        }
      }

      // (String) => Any
      readFromString(str) {
        return this.evalPrims.readFromString(str);
      }

      // (String, Boolean) => Any
      runString(str, isRunResult) {
        if (isRunResult) {
          this._stack.startStringReporterTask();
        } else {
          this._stack.startStringCommandTask();
        }
        try {
          return this.evalPrims.runCode(str, isRunResult, this._stack.currentContext().stringRunVars());
        } finally {
          this._stack.endCall();
        }
      }

      // (() => Any, Array[Any]) => Any
      runFunction(f, ...args) {
        try {
          this._stack.currentContext().startTask();
          return f(...args);
        } finally {
          this._stack.currentContext().endTask();
        }
      }

      // () => StopInterrupt
      stop() {
        return StopInterrupt;
      }

    };

    ProcedurePrims.prototype._commands = null; // Map[String, Reporter]

    ProcedurePrims.prototype._reporters = null; // Map[String, Command]

    ProcedurePrims.prototype._stack = null; // ProcedureStack

    return ProcedurePrims;

  }).call(this);

  module.exports = ProcedurePrims;

}).call(this);

},{"./procedure":"engine/prim/procedure","./procedure-context":"engine/prim/procedure-context","util/interrupts":"util/interrupts"}],"engine/prim/procedure":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Command, Procedure, Reporter;

  Procedure = class Procedure {
    // (String, SourceLocation, () => Any)
    constructor(name, start, end, call) {
      this.name = name;
      this.call = call;
      this.location = Object.freeze({start, end});
      return;
    }

  };

  Reporter = class Reporter extends Procedure {};

  Command = class Command extends Procedure {};

  module.exports = {Command, Reporter};

}).call(this);

},{}],"engine/prim/randomprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Gamma, RandomPrims, StrictMath, getRandomSeedInt;

  ({getRandomSeedInt} = require('shim/random'));

  StrictMath = require('shim/strictmath');

  Gamma = require('./gamma');

  RandomPrims = (function() {
    class RandomPrims {
      constructor(_rng) {
        this._rng = _rng;
      }

      // (Number) => Number
      random(n) {
        var truncated;
        truncated = n >= 0 ? StrictMath.ceil(n) : StrictMath.floor(n);
        if (truncated === 0) {
          return 0;
        } else if (truncated > 0) {
          return this._rng.nextLong(truncated);
        } else {
          return -this._rng.nextLong(-truncated);
        }
      }

      // This is for `_randomconst`, `n` must also be >0. -Jeremy B September 2020
      // (Long) => Long
      randomLong(n) {
        return this._rng.nextLong(n);
      }

      // (Number, Number) => Number
      randomInRange(min, max) {
        return min + this._rng.nextInt(max - min + 1);
      }

      // (Number, Number) => Number
      randomFloatInRange(min, max) {
        return min - 0.5 + this._rng.nextDouble() * (max - min + 1);
      }

      // (Number) => Number
      randomExponential(mean) {
        return -mean * StrictMath.log(this._rng.nextDouble());
      }

      // (Number) => Number
      randomFloat(n) {
        return n * this._rng.nextDouble();
      }

      // (Number, Number) => Number
      randomGamma(alpha, lambda) {
        return Gamma(this._rng, alpha, lambda);
      }

      // (Number, Number) => Number
      randomNormal(mean, stdDev) {
        return mean + stdDev * this._rng.nextGaussian();
      }

      // (Number) => Number
      randomPoisson(mean) {
        var q, sum;
        q = 0;
        sum = -StrictMath.log(1 - this._rng.nextDouble());
        while (sum <= mean) {
          q += 1;
          sum -= StrictMath.log(1 - this._rng.nextDouble());
        }
        return q;
      }

      randomSeed(seed) {
        return this._rng.setSeed(seed);
      }

      randomState() {
        return this._rng.exportState();
      }

    };

    // () => Number
    RandomPrims.prototype.generateNewSeed = (function() {
      var helper, lastSeed;
      lastSeed = 0; // Rather than adding a global, scope this permanent state here --JAB (9/25/15)
      helper = function() {
        var seed;
        // NetLogo desktop just uses a `new MersenneTwisterFast().nextInt()` here, but in NetLogo Web we have a potential
        // issue where a model presenter might ask thousands of people to load a page at once, and that presenter might
        // want to generate unique IDs for each viewer, and because of reduced moment-in-time time precision due to Spectre
        // attacks and the like, multiple viewers might then get the same "random" "unique" IDs as MTF uses the
        // moment-in-time as the seed.  The `crypto.getRandomValues()` used by `getRandomSeedInt()` is arguable a better
        // way to fetch a seed in any case, as we can trust our platform API to get some better entropy for us than what a
        // time stamp provides.  -Jeremy B September 2022
        seed = getRandomSeedInt();
        if (seed !== lastSeed) {
          lastSeed = seed;
          return seed;
        } else {
          return helper();
        }
      };
      return helper;
    })();

    return RandomPrims;

  }).call(this);

  module.exports = RandomPrims;

}).call(this);

},{"./gamma":"engine/prim/gamma","shim/random":"shim/random","shim/strictmath":"shim/strictmath"}],"engine/prim/selfprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var SelfPrims, TypeSet, checks, exceptions, getTypeOf, linkType, mempty, observerType, patchType, turtleType;

  ({checks, getTypeOf} = require('../core/typechecker'));

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  TypeSet = class TypeSet {
    // (Boolean, Boolean, Boolean, Boolean) => TypeSet
    constructor(link1, observer1, patch1, turtle1) {
      this.link = link1;
      this.observer = observer1;
      this.patch = patch1;
      this.turtle = turtle1;
    }

    // (TypeSet) => TypeSet
    mergeWith({link, observer, patch, turtle}) {
      return new TypeSet(this.link || link, this.observer || observer, this.patch || patch, this.turtle || turtle);
    }

    // (TypeSet) => TypeSet
    mappend(ts) {
      return this.mergeWith(ts);
    }

  };

  mempty = new TypeSet(false, false, false, false);

  linkType = new TypeSet(true, false, false, false);

  observerType = new TypeSet(false, true, false, false);

  patchType = new TypeSet(false, false, true, false);

  turtleType = new TypeSet(false, false, false, true);

  module.exports = SelfPrims = class SelfPrims {
    // (() => Agent) => Prims
    constructor(_getSelf) {
      this._getSelf = _getSelf;
    }

    // [T] @ (AbstractAgentSet[T]) => AbstractAgentSet[T]
    other(agentSet) {
      var self;
      self = this._getSelf();
      return agentSet.filter((agent) => {
        return agent !== self;
      });
    }

    // [T] @ (AbstractAgentSet[T]) => Boolean
    _optimalAnyOther(agentSet) {
      var self;
      self = this._getSelf();
      return agentSet.exists(function(agent) {
        return agent !== self;
      });
    }

    // [T] @ (AbstractAgentSet[T]) => Number
    _optimalCountOther(agentSet) {
      var self;
      self = this._getSelf();
      return (agentSet.filter(function(agent) {
        return agent !== self;
      })).size();
    }

    // () => Number | TowardsInterrupt
    linkHeading() {
      return this._getSelfSafe(linkType, "link-heading").getHeading();
    }

    // () => Number
    linkLength() {
      return this._getSelfSafe(linkType, "link-length").getSize();
    }

    // (TypeSet) => Agent
    _getSelfSafe(typeSet, primName) {
      var agentStr, allowsL, allowsP, allowsT, part1, part2, self;
      ({
        link: allowsL,
        patch: allowsP,
        turtle: allowsT
      } = typeSet);
      self = this._getSelf();
      if ((checks.isTurtle(self) && allowsT) || (checks.isPatch(self) && allowsP) || (checks.isLink(self) && allowsL)) {
        return self;
      } else {
        part1 = `this code can't be run by a ${getTypeOf(self).niceName()}`;
        agentStr = this._typeSetToAgentString(typeSet);
        part2 = agentStr.length !== 0 ? `, only by ${agentStr}` : "";
        throw exceptions.runtime(part1 + part2, primName);
      }
    }

    // (TypeSet) => String
    _typeSetToAgentString(typeSet) {
      if (typeSet.turtle) {
        return "a turtle";
      } else if (typeSet.patch) {
        return "a patch";
      } else if (typeSet.link) {
        return "a link";
      } else {
        return "";
      }
    }

  };

}).call(this);

},{"../core/typechecker":"engine/core/typechecker","util/exception":"util/exception"}],"engine/prim/stringprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var StringPrims, escapeRegEx;

  ({escapeRegEx} = require('util/regex'));

  StringPrims = class StringPrims {
    constructor(_dump) {
      this._dump = _dump;
    }

    // (Number, String, String) => String
    insertItem(n, xs, x) {
      var chars;
      chars = xs.split('');
      chars.splice(n, 0, x);
      return chars.join('');
    }

    // (String, String) => Boolean
    member(chunk, text) {
      return text.indexOf(chunk) !== -1;
    }

    // (String, String) => Number | Boolean
    position(chunk, text) {
      var index;
      index = text.indexOf(chunk);
      if (index !== -1) {
        return index;
      } else {
        return false;
      }
    }

    // (String, String) => String
    remove(chunk, text) {
      return text.replace(new RegExp(escapeRegEx(chunk), "g"), "");
    }

    // (Number, String) => String
    removeItem(n, text) {
      var post, pre;
      pre = text.slice(0, n);
      post = text.slice(n + 1);
      return pre + post;
    }

    // (Number, String, String) => String
    replaceItem(n, text, chunk) {
      var post, pre;
      pre = text.slice(0, n);
      post = text.slice(n + 1);
      return pre + chunk + post;
    }

    // (String) => String
    reverse(text) {
      return text.split("").reverse().join("");
    }

    // (String, Number, Number) => String
    substring(text, n1, n2) {
      return text.substr(n1, n2 - n1);
    }

    // (Array[Any]) => String
    word(...values) {
      return values.map((value) => {
        return this._dump(value);
      }).join('');
    }

  };

  module.exports = StringPrims;

}).call(this);

},{"util/regex":"util/regex"}],"engine/prim/tasks":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var all, exceptions, length, map, pipeline, rangeUntil;

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({all, length, map} = require('brazierjs/array'));

  ({pipeline} = require('brazierjs/function'));

  ({rangeUntil} = require('brazierjs/number'));

  module.exports = {
    // [Result] @ (Product => Result, Array[Any]) => Result
    apply: function(fn, args) {
      return fn.apply(fn, args);
    },
    // [Result] @ (Product => Result, Array[Any]*) => Array[Result]
    map: function(fn, lists) {
      return this._processLists(fn, lists);
    },
    // [Result] @ (Number, () => Result | (Number) => Result) => Array[Result]
    nValues: function(n, fn) {
      if (fn.minArgCount === 0) {
        return (new Array(n)).fill(0).map(function() {
          return fn();
        });
      } else {
        // if the length is greater than 1, we rely on the task itself to throw the mismatched args error.
        return map(fn)(rangeUntil(0)(n));
      }
    },
    // [Result] @ (Product => Result, Array[Any]*) => Any
    forEach: function(fn, lists) {
      return this._processLists(fn, lists);
    },
    // [Result] @ (Product => Result, Array[Array[Any]], String) => Array[Result]
    _processLists: function(fn, lists, primName) {
      var head, i, j, k, l, len, list, ref, ref1, res, results, x;
      switch (lists.length) {
        case 0:
          if (fn.isReporter) {
            return [];
          } else {

          }
          break;
        case 1:
          list = lists[0];
          if (fn.isReporter) {
            // beware ye terse-nics tempted to enshorten this to `head.map(fn)`
            // for variadic concise prims be lurking
            // what require the `arguments` set in this way
            return list.map(function(v) {
              return fn(v);
            });
          } else {
            for (j = 0, len = list.length; j < len; j++) {
              x = list[j];
              res = fn(x);
              if (res != null) {
                return res;
              }
            }
          }
          break;
        default:
          head = lists[0];
          if (fn.isReporter) {
            results = [];
            for (i = k = 0, ref = head.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
              results.push(fn(...map(function(list) {
                return list[i];
              })(lists)));
            }
            return results;
          } else {
            for (i = l = 0, ref1 = head.length; (0 <= ref1 ? l < ref1 : l > ref1); i = 0 <= ref1 ? ++l : --l) {
              res = fn(...map(function(list) {
                return list[i];
              })(lists));
              if (res != null) {
                return res;
              }
            }
          }
      }
    }
  };

}).call(this);

},{"brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/number":"brazier/number","util/exception":"util/exception"}],"engine/prim/userdialogprims":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var UserDialogConfig, UserDialogPrims, exceptions;

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  module.exports.Config = UserDialogConfig = class UserDialogConfig {
    // ((String) => Unit, (String) => Boolean, (String) => Boolean, (String) => String) => UserDialogConfig
    constructor(notify = (function() {}), confirm = (function() {
        return true;
      }), yesOrNo = (function() {
        return true;
      }), input = (function() {
        return "dummy implementation";
      })) {
      this.notify = notify;
      this.confirm = confirm;
      this.yesOrNo = yesOrNo;
      this.input = input;
    }

  };

  module.exports.Prims = UserDialogPrims = class UserDialogPrims {
    // (UserDialogConfig) => UserDialogPrims
    constructor({
        confirm: _confirm,
        input: _input,
        yesOrNo: _yesOrNo
      }) {
      this._confirm = _confirm;
      this._input = _input;
      this._yesOrNo = _yesOrNo;
    }

    // (String) => Unit
    confirm(msg) {
      if (!this._confirm(msg)) {
        throw exceptions.halt();
      }
    }

    // (String, String | null) => String
    input(msg, defaultValue) {
      var ref;
      return (function() {
        if ((ref = this._input(msg, defaultValue != null ? defaultValue : "")) != null) {
          return ref;
        } else {
          throw exceptions.halt();
        }
      }).call(this);
    }

    // (String) => Boolean
    yesOrNo(msg) {
      var ref;
      return (function() {
        if ((ref = this._yesOrNo(msg)) != null) {
          return ref;
        } else {
          throw exceptions.halt();
        }
      }).call(this);
    }

  };

}).call(this);

},{"util/exception":"util/exception"}],"engine/updater":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Link, Observer, Patch, Turtle, Update, Updater, World, exceptions, ifInterrupt, ignored, perspectiveToNum;

  Link = require('./core/link');

  Patch = require('./core/patch');

  Turtle = require('./core/turtle');

  World = require('./core/world');

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({ifInterrupt} = require('util/interrupts'));

  ({
    Perspective: {perspectiveToNum},
    Observer
  } = require('./core/observer'));

  ignored = [
    "",
    function() {
      return "";
    }
  ];

  // type ID           = String
  // type Key          = String
  // type Getter       = (Any) -> Any
  // type UpdateEntry  = Object[Key, Getter]
  // type UpdateSet    = Object[ID, UpdateEntry]
  // type _US          = UpdateSet
  // type DrawingEvent = Object[String, Any]

    // (_US, _US, _US, _US, _US, Array[DrawingEvent]) => Update
  Update = class Update {
    constructor(turtles = {}, patches = {}, links = {}, observer1 = {}, world1 = {}, drawingEvents = []) {
      this.turtles = turtles;
      this.patches = patches;
      this.links = links;
      this.observer = observer1;
      this.world = world1;
      this.drawingEvents = drawingEvents;
    }

  };

  module.exports = Updater = (function() {
    class Updater {
      
        // ((Any) => String) => Updater
      constructor(_dump) {
        // (Number) => Unit
        this.registerDeadLink = this.registerDeadLink.bind(this);
        // (Number) => Unit
        this.registerDeadTurtle = this.registerDeadTurtle.bind(this);
        // (Number, Number, Number, Number, RGB, Number, String) => Unit
        this.registerPenTrail = this.registerPenTrail.bind(this);
        // (Number, Number, Number, Number, RGB, String, String) => Unit
        this.registerTurtleStamp = this.registerTurtleStamp.bind(this);
        // (Number, Number, Number, Number, Number, Number, Number, RGB, String, Number, Boolean, Number, Boolean, String) => Unit
        this.registerLinkStamp = this.registerLinkStamp.bind(this);
        // (Updatable) => (EngineKey*) => Unit
        this.updated = this.updated.bind(this);
        this._dump = _dump;
        this._flushUpdates();
      }

      // () => Unit
      clearDrawing() {
        this._reportDrawingEvent({
          type: "clear-drawing"
        });
      }

      // (String) => Unit
      importDrawing(imageBase64) {
        this._reportDrawingEvent({
          type: "import-drawing",
          imageBase64
        });
      }

      // () => Array[Update]
      collectUpdates() {
        var temp;
        temp = this._updates;
        this._flushUpdates();
        return temp;
      }

      // () => Boolean
      drawingWasJustCleared() {
        return this._drawingWasJustCleared;
      }

      // () => Boolean
      hasUpdates() {
        return this._hasUpdates;
      }

      registerDeadLink(id) {
        this._update("links", id, {
          WHO: -1
        });
      }

      registerDeadTurtle(id) {
        this._update("turtles", id, {
          WHO: -1
        });
      }

      registerPenTrail(fromX, fromY, toX, toY, rgb, size, penMode) {
        this._reportDrawingEvent({
          type: "line",
          fromX,
          fromY,
          toX,
          toY,
          rgb,
          size,
          penMode
        });
      }

      registerTurtleStamp(x, y, size, heading, color, shapeName, stampMode) {
        this._reportDrawingEvent({
          type: "stamp-image",
          agentType: "turtle",
          stamp: {x, y, size, heading, color, shapeName, stampMode}
        });
      }

      registerLinkStamp(x1, y1, x2, y2, midpointX, midpointY, heading, color, shapeName, thickness, isDirected, size, isHidden, stampMode) {
        this._reportDrawingEvent({
          type: "stamp-image",
          agentType: "link",
          stamp: {
            x1,
            y1,
            x2,
            y2,
            midpointX,
            midpointY,
            heading,
            color,
            shapeName,
            thickness,
            'directed?': isDirected,
            size,
            'hidden?': isHidden,
            stampMode
          }
        });
      }

      // (UpdateEntry, Number) => Unit
      registerWorldState(state, id = 0) {
        this._update("world", id, state);
      }

      // () => Unit
      rescaleDrawing() {
        this._reportDrawingEvent({
          type: "rescale-drawing"
        });
      }

      updated(obj) {
        return (...vars) => {
          var entry, entryUpdate, getter, i, len, mapping, objMap, ref, update, v, varName;
          this._hasUpdates = true;
          update = this._updates[0];
          [entry, objMap] = (function() {
            if (obj instanceof Turtle) {
              return [update.turtles, this._turtleMap()];
            } else if (obj instanceof Patch) {
              return [update.patches, this._patchMap()];
            } else if (obj instanceof Link) {
              return [update.links, this._linkMap()];
            } else if (obj instanceof World) {
              return [update.world, this._worldMap()];
            } else if (obj instanceof Observer) {
              return [update.observer, this._observerMap()];
            } else {
              throw exceptions.internal("Unrecognized update type");
            }
          }).call(this);
          entryUpdate = (ref = entry[obj.id]) != null ? ref : {};
          // Receiving updates for a turtle that's about to die means the turtle was
          // reborn, so we revive it in the update - BH 1/13/2014
          if (entryUpdate['WHO'] < 0) {
            delete entryUpdate['WHO'];
          }
          for (i = 0, len = vars.length; i < len; i++) {
            v = vars[i];
            mapping = objMap[v];
            if (mapping != null) {
              if (mapping !== ignored) {
                [varName, getter] = mapping;
                entryUpdate[varName] = getter(obj);
                entry[obj.id] = entryUpdate;
              }
            } else {
              throw exceptions.internal(`Unknown ${obj.constructor.name} variable for update: ${v}`);
            }
          }
        };
      }

      // (Turtle) => Object[EngineKey, (Key, Getter)]
      _turtleMap() {
        return {
          breed: [
            "BREED",
            function(turtle) {
              return turtle.getBreedName();
            }
          ],
          color: [
            "COLOR",
            function(turtle) {
              return turtle._color;
            }
          ],
          heading: [
            "HEADING",
            function(turtle) {
              return turtle._heading;
            }
          ],
          who: [
            "WHO",
            function(turtle) {
              return turtle.id;
            }
          ],
          'label-color': [
            "LABEL-COLOR",
            function(turtle) {
              return turtle._labelcolor;
            }
          ],
          'hidden?': [
            "HIDDEN?",
            function(turtle) {
              return turtle._hidden;
            }
          ],
          label: [
            "LABEL",
            (turtle) => {
              return this._dump(turtle._label);
            }
          ],
          'pen-size': [
            "PEN-SIZE",
            function(turtle) {
              return turtle.penManager.getSize();
            }
          ],
          'pen-mode': [
            "PEN-MODE",
            function(turtle) {
              return turtle.penManager.getMode().toString();
            }
          ],
          shape: [
            "SHAPE",
            function(turtle) {
              return turtle._getShape();
            }
          ],
          size: [
            "SIZE",
            function(turtle) {
              return turtle._size;
            }
          ],
          xcor: [
            "XCOR",
            function(turtle) {
              return turtle.xcor;
            }
          ],
          ycor: [
            "YCOR",
            function(turtle) {
              return turtle.ycor;
            }
          ]
        };
      }

      // (Patch) => Object[EngineKey, (Key, Getter)]
      _patchMap() {
        return {
          id: [
            "WHO",
            function(patch) {
              return patch.id;
            }
          ],
          pcolor: [
            "PCOLOR",
            function(patch) {
              return patch._pcolor;
            }
          ],
          plabel: [
            "PLABEL",
            (patch) => {
              return this._dump(patch._plabel);
            }
          ],
          'plabel-color': [
            "PLABEL-COLOR",
            function(patch) {
              return patch._plabelcolor;
            }
          ],
          pxcor: [
            "PXCOR",
            function(patch) {
              return patch.pxcor;
            }
          ],
          pycor: [
            "PYCOR",
            function(patch) {
              return patch.pycor;
            }
          ]
        };
      }

      // (Link) => Object[EngineKey, (Key, Getter)]
      _linkMap() {
        return {
          breed: [
            "BREED",
            function(link) {
              return link.getBreedName();
            }
          ],
          color: [
            "COLOR",
            function(link) {
              return link._color;
            }
          ],
          end1: [
            "END1",
            function(link) {
              return link.end1.id;
            }
          ],
          end2: [
            "END2",
            function(link) {
              return link.end2.id;
            }
          ],
          heading: [
            "HEADING",
            function(link) {
              return ifInterrupt(link.getHeading(),
            0);
            }
          ],
          'hidden?': [
            "HIDDEN?",
            function(link) {
              return link._isHidden;
            }
          ],
          id: [
            "ID",
            function(link) {
              return link.id;
            }
          ],
          'directed?': [
            "DIRECTED?",
            function(link) {
              return link.isDirected;
            }
          ],
          label: [
            "LABEL",
            (link) => {
              return this._dump(link._label);
            }
          ],
          'label-color': [
            "LABEL-COLOR",
            function(link) {
              return link._labelcolor;
            }
          ],
          midpointx: [
            "MIDPOINTX",
            function(link) {
              return link.getMidpointX();
            }
          ],
          midpointy: [
            "MIDPOINTY",
            function(link) {
              return link.getMidpointY();
            }
          ],
          shape: [
            "SHAPE",
            function(link) {
              return link._shape;
            }
          ],
          size: [
            "SIZE",
            function(link) {
              return link.getSize();
            }
          ],
          thickness: [
            "THICKNESS",
            function(link) {
              return link._thickness;
            }
          ],
          'tie-mode': [
            "TIE-MODE",
            function(link) {
              return link.tiemode;
            }
          ],
          lcolor: ignored,
          llabel: ignored,
          llabelcolor: ignored,
          lhidden: ignored,
          lbreed: ignored,
          lshape: ignored
        };
      }

      // (World) => Object[EngineKey, (Key, Getter)]
      _worldMap() {
        return {
          height: [
            "worldHeight",
            function(world) {
              return world.topology.height;
            }
          ],
          id: [
            "WHO",
            function(world) {
              return world.id;
            }
          ],
          patchesAllBlack: [
            "patchesAllBlack",
            function(world) {
              return world._patchesAllBlack;
            }
          ],
          patchesWithLabels: [
            "patchesWithLabels",
            function(world) {
              return world._patchesWithLabels;
            }
          ],
          maxPxcor: [
            "MAXPXCOR",
            function(world) {
              return world.topology.maxPxcor;
            }
          ],
          maxPycor: [
            "MAXPYCOR",
            function(world) {
              return world.topology.maxPycor;
            }
          ],
          minPxcor: [
            "MINPXCOR",
            function(world) {
              return world.topology.minPxcor;
            }
          ],
          minPycor: [
            "MINPYCOR",
            function(world) {
              return world.topology.minPycor;
            }
          ],
          patchSize: [
            "patchSize",
            function(world) {
              return world.patchSize;
            }
          ],
          ticks: [
            "ticks",
            function(world) {
              return world.ticker._count;
            }
          ],
          unbreededLinksAreDirected: [
            "unbreededLinksAreDirected",
            function(world) {
              return world.breedManager.links().isDirected();
            }
          ],
          width: [
            "worldWidth",
            function(world) {
              return world.topology.width;
            }
          ],
          wrappingAllowedInX: [
            "wrappingAllowedInX",
            function(world) {
              return world.topology._wrapInX;
            }
          ],
          wrappingAllowedInY: [
            "wrappingAllowedInY",
            function(world) {
              return world.topology._wrapInY;
            }
          ]
        };
      }

      // (Observer) => Object[EngineKey, (Key, Getter)]
      _observerMap() {
        return {
          id: [
            "WHO",
            function(observer) {
              return observer.id;
            }
          ],
          perspective: [
            "perspective",
            function(observer) {
              return perspectiveToNum(observer.getPerspective());
            }
          ],
          targetAgent: [
            "targetAgent",
            function(observer) {
              return observer._getTargetAgentUpdate();
            }
          ]
        };
      }

      // (String, Number, UpdateEntry) => Unit
      _update(agentType, id, newAgent) {
        this._hasUpdates = true;
        this._updates[0][agentType][id] = newAgent;
      }

      // (Object[String, Any]) => Unit
      _reportDrawingEvent(event) {
        this._hasUpdates = true;
        this._drawingWasJustCleared = event.type === "clear-drawing";
        this._updates[0].drawingEvents.push(event);
      }

      // () => Unit
      _flushUpdates() {
        this._hasUpdates = false;
        this._updates = [new Update()];
      }

    };

    // type Updatable   = Turtle|Patch|Link|World|Observer
    // type EngineKey   = String
    Updater.prototype._drawingWasJustCleared = true; // Boolean

    Updater.prototype._hasUpdates = void 0; // Boolean

    Updater.prototype._updates = void 0; // Array[Update]

    return Updater;

  }).call(this);

}).call(this);

},{"./core/link":"engine/core/link","./core/observer":"engine/core/observer","./core/patch":"engine/core/patch","./core/turtle":"engine/core/turtle","./core/world":"engine/core/world","util/exception":"util/exception","util/interrupts":"util/interrupts"}],"engine/workspace":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var BreedManager, Dump, EvalPrims, Hasher, I18nBundle, ImportExportConfig, ImportExportPrims, InspectionConfig, InspectionPrims, LayoutManager, LinkPrims, ListPrims, Meta, MiniWorkspace, MouseConfig, MousePrims, None, OutputConfig, OutputPrims, PlotManager, PrimChecks, Prims, PrintConfig, PrintPrims, ProcedurePrims, RNG, RandomPrims, SelfManager, SelfPrims, StringPrims, Timer, Updater, UserDialogConfig, UserDialogPrims, World, WorldConfig, csvToWorldState, exceptions, fold, id, importPColors, lookup, toObject, values;

  WorldConfig = class WorldConfig {
    // (() => Unit) => WorldConfig
    constructor(resizeWorld = (function() {})) {
      this.resizeWorld = resizeWorld;
    }

  };

  BreedManager = require('./core/breedmanager');

  Dump = require('./dump');

  EvalPrims = require('./prim/evalprims');

  Hasher = require('./hasher');

  I18nBundle = require('i18n/i18n-bundle');

  LayoutManager = require('./prim/layoutmanager');

  LinkPrims = require('./prim/linkprims');

  ListPrims = require('./prim/listprims');

  PlotManager = require('./plot/plotmanager');

  Prims = require('./prim/prims');

  ProcedurePrims = require('./prim/procedureprims');

  RandomPrims = require('./prim/randomprims');

  PrimChecks = require('./prim-checks/checker');

  RNG = require('util/rng');

  SelfManager = require('./core/structure/selfmanager');

  SelfPrims = require('./prim/selfprims');

  StringPrims = require('./prim/stringprims');

  Timer = require('util/timer');

  Updater = require('./updater');

  World = require('./core/world');

  ({
    importPColorsBase64: importPColors
  } = require('./prim/importpcolors'));

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  csvToWorldState = require('serialize/importcsv');

  ({toObject} = require('brazier/array'));

  ({fold, None} = require('brazier/maybe'));

  ({id} = require('brazier/function'));

  ({lookup, values} = require('brazier/object'));

  ({
    Config: InspectionConfig,
    Prims: InspectionPrims
  } = require('./prim/inspectionprims'));

  ({
    Config: ImportExportConfig,
    Prims: ImportExportPrims
  } = require('./prim/importexportprims'));

  ({
    Config: MouseConfig,
    Prims: MousePrims
  } = require('./prim/mouseprims'));

  ({
    Config: OutputConfig,
    Prims: OutputPrims
  } = require('./prim/outputprims'));

  ({
    Config: PrintConfig,
    Prims: PrintPrims
  } = require('./prim/printprims'));

  ({
    Config: UserDialogConfig,
    Prims: UserDialogPrims
  } = require('./prim/userdialogprims'));

  Meta = require('meta');

  MiniWorkspace = class MiniWorkspace {
    // (SelfManager, Updater, BreedManager, RNG, PlotManager) => MiniWorkspace
    constructor(selfManager1, updater1, breedManager1, rng1, plotManager1) {
      this.selfManager = selfManager1;
      this.updater = updater1;
      this.breedManager = breedManager1;
      this.rng = rng1;
      this.plotManager = plotManager1;
    }

  };

  module.exports = function(modelConfig) {
    return function(breedObjs) {
      return function(turtlesOwns, linksOwns) {
        return function(code) {
          return function(widgets) {
            return function(resources) {
              return function(extensionPorters) {
                return function() { // World args; see constructor for `World` --JAB (4/17/14)
                  var asyncDialogConfig, base64ToImageData, breedManager, dialogConfig, dump, evalPrims, i18nBundle, importExportConfig, importExportPrims, importPatchColors, importWorldFromCSV, inspectionConfig, inspectionPrims, ioConfig, layoutManager, linkPrims, listPrims, mouseConfig, mousePrims, outputConfig, outputPrims, outputStore, plotManager, plots, primChecks, prims, printConfig, printPrims, procedurePrims, randomPrims, ref, ref1, ref10, ref11, ref12, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, reportErrors, rng, selfManager, selfPrims, stringPrims, timer, updater, userDialogPrims, workspace, world, worldArgs, worldConfig;
                  worldArgs = arguments; // If you want `Workspace` to take more parameters--parameters not related to `World`--just keep returning new functions
                  asyncDialogConfig = (ref = modelConfig != null ? modelConfig.asyncDialog : void 0) != null ? ref : {
                    getChoice: (function() {
                      return function() {
                        return None;
                      };
                    }),
                    getText: (function() {
                      return function() {
                        return None;
                      };
                    }),
                    getYesOrNo: (function() {
                      return function() {
                        return None;
                      };
                    }),
                    showMessage: (function() {
                      return function() {
                        return None;
                      };
                    })
                  };
                  base64ToImageData = (ref1 = modelConfig != null ? modelConfig.base64ToImageData : void 0) != null ? ref1 : (function() {
                    throw exceptions.internal("Sorry, no image data converter was provided.");
                  });
                  dialogConfig = (ref2 = modelConfig != null ? modelConfig.dialog : void 0) != null ? ref2 : new UserDialogConfig();
                  importExportConfig = (ref3 = modelConfig != null ? modelConfig.importExport : void 0) != null ? ref3 : new ImportExportConfig();
                  inspectionConfig = (ref4 = modelConfig != null ? modelConfig.inspection : void 0) != null ? ref4 : new InspectionConfig();
                  ioConfig = (ref5 = modelConfig != null ? modelConfig.io : void 0) != null ? ref5 : {
                    importFile: (function() {
                      return function() {};
                    }),
                    slurpFileDialogAsync: (function() {}),
                    slurpURL: (function() {}),
                    slurpURLAsync: (function() {
                      return function() {};
                    })
                  };
                  mouseConfig = (ref6 = modelConfig != null ? modelConfig.mouse : void 0) != null ? ref6 : new MouseConfig();
                  outputConfig = (ref7 = modelConfig != null ? modelConfig.output : void 0) != null ? ref7 : new OutputConfig();
                  plots = (ref8 = modelConfig != null ? modelConfig.plots : void 0) != null ? ref8 : [];
                  printConfig = (ref9 = modelConfig != null ? modelConfig.print : void 0) != null ? ref9 : new PrintConfig();
                  worldConfig = (ref10 = modelConfig != null ? modelConfig.world : void 0) != null ? ref10 : new WorldConfig();
                  reportErrors = (ref11 = modelConfig != null ? modelConfig.reportErrors : void 0) != null ? ref11 : function(messages) {
                    return console.log(messages);
                  };
                  Meta.version = (ref12 = modelConfig != null ? modelConfig.version : void 0) != null ? ref12 : Meta.version;
                  dump = Dump(extensionPorters);
                  rng = new RNG();
                  outputStore = "";
                  selfManager = new SelfManager();
                  breedManager = new BreedManager(breedObjs, turtlesOwns, linksOwns);
                  plotManager = new PlotManager(plots);
                  timer = new Timer();
                  updater = new Updater(dump);
                  workspace = new MiniWorkspace(selfManager, updater, breedManager, rng, plotManager);
                  world = new World(workspace, worldConfig, (function() {
                    return importExportConfig.getViewBase64();
                  }), (function() {
                    outputConfig.clear();
                    return outputStore = "";
                  }), (function() {
                    return outputStore;
                  }), (function(text) {
                    return outputStore = text;
                  }), extensionPorters, ...worldArgs);
                  layoutManager = new LayoutManager(world, rng.nextDouble);
                  inspectionPrims = new InspectionPrims(inspectionConfig);
                  mousePrims = new MousePrims(mouseConfig);
                  outputPrims = new OutputPrims(outputConfig, (function(x) {
                    return outputStore += x;
                  }), (function() {
                    return outputStore = "";
                  }), dump);
                  printPrims = new PrintPrims(printConfig, dump);
                  userDialogPrims = new UserDialogPrims(dialogConfig);
                  evalPrims = new EvalPrims(code, widgets);
                  procedurePrims = new ProcedurePrims(evalPrims, plotManager, rng);
                  prims = new Prims(dump, Hasher, rng, world, printPrims);
                  randomPrims = new RandomPrims(rng);
                  selfPrims = new SelfPrims(selfManager.self);
                  linkPrims = new LinkPrims(world);
                  listPrims = new ListPrims(dump, Hasher, prims.equality.bind(prims), rng.nextInt);
                  stringPrims = new StringPrims(dump);
                  exceptions.setProcecurePrims(procedurePrims);
                  i18nBundle = new I18nBundle();
                  primChecks = new PrimChecks(i18nBundle, dump, prims, listPrims, randomPrims, stringPrims, procedurePrims, selfPrims, world);
                  importWorldFromCSV = function(csvText) {
                    var breedNamePairs, functionify, pluralToSingular, ptsObject, singularToPlural, stpObject, worldState;
                    functionify = function(obj) {
                      return function(x) {
                        var msg;
                        msg = `Cannot find corresponding breed name for ${x}!`;
                        return fold(function() {
                          throw exceptions.internal(msg);
                        })(id)(lookup(x)(obj));
                      };
                    };
                    breedNamePairs = values(breedManager.breeds()).map(function({name, singular}) {
                      return [name, singular];
                    });
                    ptsObject = toObject(breedNamePairs);
                    stpObject = toObject(breedNamePairs.map(function([p, s]) {
                      return [s, p];
                    }));
                    pluralToSingular = functionify(ptsObject);
                    singularToPlural = functionify(stpObject);
                    worldState = csvToWorldState(singularToPlural, pluralToSingular, extensionPorters)(csvText);
                    return world.importState(worldState);
                  };
                  importPatchColors = importPColors((function() {
                    return world.topology;
                  }), (function() {
                    return world.patchSize;
                  }), (function(x, y) {
                    return world.getPatchAt(x, y);
                  }), base64ToImageData);
                  importExportPrims = new ImportExportPrims(importExportConfig, (function() {
                    return world.exportCSV();
                  }), (function() {
                    return world.exportAllPlotsCSV();
                  }), (function(plot) {
                    return world.exportPlotCSV(plot);
                  }), (function(plot) {
                    return world.exportRawPlotCSV(plot);
                  }), (function(path) {
                    return world.importDrawing(path);
                  }), importPatchColors, importWorldFromCSV);
                  return {selfManager, breedManager, dump, reportErrors, importExportPrims, inspectionPrims, asyncDialogConfig, ioConfig, layoutManager, linkPrims, listPrims, mousePrims, outputPrims, plotManager, evalPrims, prims, procedurePrims, randomPrims, primChecks, printPrims, rng, resources, selfPrims, stringPrims, timer, updater, userDialogPrims, world, i18nBundle};
                };
              };
            };
          };
        };
      };
    };
  };

}).call(this);

},{"./core/breedmanager":"engine/core/breedmanager","./core/structure/selfmanager":"engine/core/structure/selfmanager","./core/world":"engine/core/world","./dump":"engine/dump","./hasher":"engine/hasher","./plot/plotmanager":"engine/plot/plotmanager","./prim-checks/checker":"engine/prim-checks/checker","./prim/evalprims":"engine/prim/evalprims","./prim/importexportprims":"engine/prim/importexportprims","./prim/importpcolors":"engine/prim/importpcolors","./prim/inspectionprims":"engine/prim/inspectionprims","./prim/layoutmanager":"engine/prim/layoutmanager","./prim/linkprims":"engine/prim/linkprims","./prim/listprims":"engine/prim/listprims","./prim/mouseprims":"engine/prim/mouseprims","./prim/outputprims":"engine/prim/outputprims","./prim/prims":"engine/prim/prims","./prim/printprims":"engine/prim/printprims","./prim/procedureprims":"engine/prim/procedureprims","./prim/randomprims":"engine/prim/randomprims","./prim/selfprims":"engine/prim/selfprims","./prim/stringprims":"engine/prim/stringprims","./prim/userdialogprims":"engine/prim/userdialogprims","./updater":"engine/updater","brazier/array":"brazier/array","brazier/function":"brazier/function","brazier/maybe":"brazier/maybe","brazier/object":"brazier/object","i18n/i18n-bundle":"i18n/i18n-bundle","meta":"meta","serialize/importcsv":"serialize/importcsv","util/exception":"util/exception","util/rng":"util/rng","util/timer":"util/timer"}],"extensions/all":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var extensionPaths;

  extensionPaths = ['array', 'bitmap', 'codap', 'csv', 'encode', 'dialog', 'export-the', 'fetch', 'fp', 'http-req', 'import-a', 'logging', 'matrix', 'mini-csv', 'nlmap', 'nt', 'palette', 'resource', 'send-to', 'sound', 'store', 'string', 'table'];

  module.exports = {
    initialize: function(workspace, ...importedExtensions) {
      var extensions, upperNames;
      upperNames = importedExtensions.map(function(name) {
        return name.toUpperCase();
      });
      extensions = {};
      extensionPaths.forEach(function(path) {
        var extension, extensionModule, upperName;
        extensionModule = require(`extensions/${path}`);
        extension = extensionModule.init(workspace);
        upperName = extension.name.toUpperCase();
        if (upperNames.includes(upperName)) {
          return extensions[upperName] = extension;
        }
      });
      return extensions;
    },
    porters: function(...importedExtensions) {
      var porters, upperNames;
      upperNames = importedExtensions.map(function(name) {
        return name.toUpperCase();
      });
      porters = [];
      extensionPaths.forEach(function(path) {
        var extensionModule, upperName;
        extensionModule = require(`extensions/${path}`);
        if (extensionModule.porter != null) {
          upperName = extensionModule.porter.extensionName.toUpperCase();
          if (upperNames.includes(upperName)) {
            return porters.push(extensionModule.porter);
          }
        }
      });
      return porters;
    }
  };

}).call(this);

},{}],"extensions/array":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var SingleObjectExtensionPorter, dumpArray, exceptions, exportArray, extensionName, formatArray, importArray, isArray, readArray;

  SingleObjectExtensionPorter = require('../engine/core/world/singleobjectextensionporter');

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  // (Any) => Boolean
  isArray = function(x) {
    return x.type === "ext_array";
  };

  dumpArray = function(extObj, dumpValue) {
    return extObj.items.map(function(item) {
      return dumpValue(item, true);
    }).join(' ');
  };

  exportArray = function(extObj, exportValue) {
    return extObj.items.map(function(item) {
      return exportValue(item);
    });
  };

  formatArray = function(exportedObj, formatAny) {
    return exportedObj.data.map(function(item) {
      return formatAny(item);
    }).join(' ');
  };

  readArray = function(text, parseAny) {
    return parseAny(`[${text}]`);
  };

  importArray = function(exportedObj, reify) {
    return {
      items: exportedObj.data.map(function(i) {
        return reify(i);
      }),
      type: "ext_array"
    };
  };

  extensionName = "array";

  module.exports = {
    porter: new SingleObjectExtensionPorter(extensionName, isArray, dumpArray, exportArray, formatArray, readArray, importArray),
    init: function(workspace) {
      var extArray, fromList, invalidIndexException, item, length, notArrayException, set, toList;
      // type ExtArray = { type: "ext_array", items: Array[Any] }
      extArray = function(array) {
        this.items = array;
        this.type = "ext_array";
      };
      // List[Any] => ExtArray
      fromList = function(list) {
        return new extArray(list.slice(0));
      };
      // (ExtArray) => Number|List[Any]
      toList = function(extArray) {
        if (!isArray(extArray)) {
          throw exceptions.extension(notArrayException(extArray));
        }
        return extArray.items.slice(0);
      };
      // (ExtArray) => Number
      length = function(extArray) {
        if (!isArray(extArray)) {
          throw exceptions.extension(notArrayException(extArray));
        }
        return extArray.items.length;
      };
      // (ExtArray, Number) => Any
      item = function(extArray, index) {
        var ref;
        if (!isArray(extArray)) {
          throw exceptions.extension(notArrayException(extArray));
        }
        return (function() {
          if ((ref = extArray.items[index]) != null) {
            return ref;
          } else {
            throw exceptions.extension(invalidIndexException(extArray, index));
          }
        })();
      };
      // (ExtArray, Number, Any) => Unit
      set = function(extArray, index, value) {
        if (!isArray(extArray)) {
          throw exceptions.extension(notArrayException(extArray));
        }
        if (extArray.items[index] != null) {
          extArray.items[index] = value;
        } else {
          throw exceptions.extension(invalidIndexException(extArray, index));
        }
      };
      notArrayException = function(x) {
        return `not an array: ${workspace.dump(x, true)}`;
      };
      invalidIndexException = function(extArray, index) {
        return `${index} is not a valid index into an array of length ${length(extArray)}`;
      };
      return {
        name: extensionName,
        prims: {
          "FROM-LIST": fromList,
          "TO-LIST": toList,
          "IS-ARRAY?": isArray,
          "LENGTH": length,
          "ITEM": item,
          "SET": set
        }
      };
    }
  };

}).call(this);

},{"../engine/core/world/singleobjectextensionporter":"engine/core/world/singleobjectextensionporter","util/exception":"util/exception"}],"extensions/bitmap":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ImageData, SingleObjectExtensionPorter, arrAdd, arrMult, averageColor, bilinearScale, bitmapExtension, boxScale, channel, checkIsImage, copyToDrawing, copyToPColors, differenceRgb, exceptions, exportError, exportImageData, extensionName, fromBase64, fromView, getPixel, height, importError, importImageData, importPColorsImage, isImageData, scaled, setPixel, toBase64, toGrayscale, width;

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({importPColorsImage} = require('engine/prim/importpcolors'));

  SingleObjectExtensionPorter = require('engine/core/world/singleobjectextensionporter');

  // This is a "polyfill" when running headlessly for testing without the Web API present. In that case, this should be
  // enough for testing purposes.  If we ever need this to run "for real" headlessly, we'll probably need something more
  // robust, like a library that provides a proper implementation.  -Jeremy B November 2022
  if (typeof ImageData === "undefined" || ImageData === null) {
    ImageData = ImageData = class ImageData {
      constructor(data1, width1, height1) {
        this.data = data1;
        this.width = width1;
        this.height = height1;
      }

    };
  }

  isImageData = function(image) {
    return image instanceof ImageData;
  };

  checkIsImage = function(image) {
    if (!isImageData(image)) {
      throw exceptions.extension(`The given argument is not an image: ${image}`);
    }
  };

  // (ImageData) => Array[RGB]
  averageColor = function(image) {
    var averages, pixels, sums;
    checkIsImage(image);
    sums = image.data.reduce(function(sumsSoFar, color, index) {
      sumsSoFar[index % 4] = sumsSoFar[index % 4] + color;
      return sumsSoFar;
    }, [0, 0, 0, 0]);
    pixels = image.width * image.height;
    averages = sums.slice(0, 3).map(function(sum) {
      return sum / pixels;
    });
    return averages;
  };

  // (ImageData, 0 | 1 | 2 | 3) => ImageData
  channel = function(image, channel) {
    var index, j, newData, ref, rgbaIndex, value;
    checkIsImage(image);
    channel = Math.floor(channel);
    if (channel < 0 || channel > 3) {
      throw exceptions.extension("Channel must be one of [0 1 2 3].");
    }
    rgbaIndex = channel === 0 ? 3 : channel - 1;
    newData = new Uint8ClampedArray(image.data.length);
    for (index = j = 0, ref = image.data.length; j < ref; index = j += 4) {
      value = image.data[index + rgbaIndex];
      newData[index] = value;
      newData[index + 1] = value;
      newData[index + 2] = value;
      newData[index + 3] = 255;
    }
    return new ImageData(newData, image.width, image.height);
  };

  // (World) => (ImageData, Int, Int) => Unit
  copyToDrawing = function(image, x, y) {
    checkIsImage(image);
    // I don't love converting this back to base64 to import it, but this is the simplest way I see at the moment without
    // adding a whole new drawing event (of uncertain data type) here and in desktop.  -Jeremy B November 2022
    modelConfig.importImage(toBase64(image), Math.floor(x), Math.floor(y));
  };

  // (World) => (ImageData, Boolean) => Unit
  copyToPColors = function(world) {
    return function(image, useNetLogoColors) {
      var getPatchAt, getPatchSize, getTopology;
      checkIsImage(image);
      getTopology = function() {
        return world.topology;
      };
      getPatchSize = function() {
        return world.patchSize;
      };
      getPatchAt = function(x, y) {
        return world.getPatchAt(x, y);
      };
      importPColorsImage(getTopology, getPatchSize, getPatchAt, useNetLogoColors, image);
    };
  };

  // (ImageData, ImageData) => ImageData
  differenceRgb = function(image1, image2) {
    var diff, newData;
    checkIsImage(image1);
    checkIsImage(image2);
    if (image1.width !== image2.width || image1.height !== image2.height) {
      throw exceptions.extension("Images must be the same size to take the difference.");
    }
    newData = new Uint8ClampedArray(image1.data.length);
    diff = function(arr1, arr2, index) {
      return Math.abs(arr1[index] - arr2[index]);
    };
    image1.data.forEach(function(c1, index) {
      var c2;
      return newData[index] = (index % 4 === 3) ? 255 : (c2 = image2.data[index], Math.abs(c1 - c2));
    });
    return new ImageData(newData, image1.width, image1.height);
  };

  // (String) => ImageData
  fromBase64 = function(base64) {
    var data, height, width;
    // Probably we shouldn't be going to the global for the function, but meh.
    ({data, width, height} = modelConfig.base64ToImageData(base64));
    return new ImageData(data, width, height);
  };

  // (ImageData) => String
  toBase64 = function(image) {
    checkIsImage(image);
    return modelConfig.imageDataToBase64(image);
  };

  // () => ImageData
  fromView = function() {
    var base64;
    // As with `copy-to-drawing` I don't like the extra conversion here, as we can get the `ImageData` from the backing
    // canvas, but this should be good enough for now.  -Jeremy B November 2022
    base64 = workspace.importExportPrims.exportViewRaw();
    return fromBase64(base64);
  };

  // This implementation does not match the desktop version, which uses a Java algorithm I didn't want to track down and
  // re-implement.  This is very simple and looks fine.  I have no idea what else the Java algorithm could be doing to
  // fancy it up.  -Jeremy B November 2022
  // (ImageData) => ImageData
  toGrayscale = function(image) {
    var index, j, newData, ref, value;
    checkIsImage(image);
    newData = new Uint8ClampedArray(image.data.length);
    for (index = j = 0, ref = image.data.length; j < ref; index = j += 4) {
      value = Math.floor(image.data[index] / 3) + Math.floor(image.data[index + 1] / 3) + Math.floor(image.data[index + 2] / 3);
      newData[index] = value;
      newData[index + 1] = value;
      newData[index + 2] = value;
      newData[index + 3] = 255;
    }
    return new ImageData(newData, image.width, image.height);
  };

  // (ImageData) => Int
  height = function(image) {
    checkIsImage(image);
    return image.height;
  };

  // (ImageData, Int, Int) => ImageData
  boxScale = function(image, width, height) {
    var boxHeight, boxIndex, boxPixelCount, boxWidth, boxX, boxXEnd, boxXStart, boxY, boxYEnd, boxYStart, j, k, l, m, newData, newIndex, ref, ref1, ref2, ref3, ref4, ref5, rgbSums, x, xScale, y, yScale;
    xScale = width / image.width;
    yScale = height / image.height;
    newData = new Uint8ClampedArray(width * height * 4);
    boxWidth = Math.ceil(1 / xScale);
    boxHeight = Math.ceil(1 / yScale);
    for (y = j = 0, ref = height; (0 <= ref ? j < ref : j > ref); y = 0 <= ref ? ++j : --j) {
      for (x = k = 0, ref1 = width; (0 <= ref1 ? k < ref1 : k > ref1); x = 0 <= ref1 ? ++k : --k) {
        newIndex = 4 * ((y * width) + x);
        boxXStart = Math.floor(x / xScale);
        boxYStart = Math.floor(y / yScale);
        boxXEnd = Math.min(boxXStart + boxWidth, image.width - 1);
        boxYEnd = Math.min(boxYStart + boxHeight, image.height - 1);
        rgbSums = [0, 0, 0];
        for (boxX = l = ref2 = boxXStart, ref3 = boxXEnd; (ref2 <= ref3 ? l <= ref3 : l >= ref3); boxX = ref2 <= ref3 ? ++l : --l) {
          for (boxY = m = ref4 = boxYStart, ref5 = boxYEnd; (ref4 <= ref5 ? m <= ref5 : m >= ref5); boxY = ref4 <= ref5 ? ++m : --m) {
            boxIndex = 4 * ((boxY * image.width) + boxX);
            rgbSums[0] += image.data[boxIndex];
            rgbSums[1] += image.data[boxIndex + 1];
            rgbSums[2] += image.data[boxIndex + 2];
          }
        }
        boxPixelCount = (boxXEnd - boxXStart) * (boxYEnd - boxYStart);
        newData[newIndex] = Math.floor(rgbSums[0] / boxPixelCount);
        newData[newIndex + 1] = Math.floor(rgbSums[1] / boxPixelCount);
        newData[newIndex + 2] = Math.floor(rgbSums[2] / boxPixelCount);
        newData[newIndex + 3] = 255;
      }
    }
    return new ImageData(newData, width, height);
  };

  // (Array[Int], Int, Int, Int) => Array[RGB]
  getPixel = function(data, width, x, y) {
    var index;
    index = 4 * ((y * width) + x);
    return [0, 1, 2].map(function(i) {
      return data[index + i];
    });
  };

  // (Array[Int], Int, Int, Int, Array[RGB]) => Unit
  setPixel = function(data, width, x, y, rgb) {
    var i, index, j;
    index = 4 * ((y * width) + x);
    for (i = j = 0; j <= 2; i = ++j) {
      data[index + i] = rgb[i];
    }
    data[index + 3] = 255;
  };

  arrMult = function(arr, scalar) {
    return arr.map(function(v, i) {
      return v * scalar;
    });
  };

  arrAdd = function(arr1, arr2) {
    return arr1.map(function(v1, i) {
      return v1 + arr2[i];
    });
  };

  // (ImageData, Int, Int) => ImageData
  bilinearScale = function(image, width, height) {
    var j, k, newData, oldXRaw, oldYRaw, p, p1, p2, q11, q12, q21, q22, ref, ref1, x, x1, x1Mod, x2, x2Mod, xScale, y, y1, y2, yScale;
    xScale = width / image.width;
    yScale = height / image.height;
    newData = new Uint8ClampedArray(width * height * 4);
    for (y = j = 0, ref = height; (0 <= ref ? j < ref : j > ref); y = 0 <= ref ? ++j : --j) {
      for (x = k = 0, ref1 = width; (0 <= ref1 ? k < ref1 : k > ref1); x = 0 <= ref1 ? ++k : --k) {
        oldXRaw = x / xScale;
        oldYRaw = y / yScale;
        x1 = Math.min(Math.floor(oldXRaw), image.width - 1);
        y1 = Math.min(Math.floor(oldYRaw), image.height - 1);
        x2 = Math.min(Math.ceil(oldXRaw), image.width - 1);
        y2 = Math.min(Math.ceil(oldYRaw), image.height - 1);
        q11 = getPixel(image.data, image.width, x1, y1);
        q12 = getPixel(image.data, image.width, x1, y2);
        q21 = getPixel(image.data, image.width, x2, y1);
        q22 = getPixel(image.data, image.width, x2, y2);
        [p1, p2] = x1 === x2 ? [q11, q22] : (x1Mod = x2 - oldXRaw, x2Mod = oldXRaw - x1, p1 = arrAdd(arrMult(q11, x1Mod), arrMult(q21, x2Mod)), p2 = arrAdd(arrMult(q12, x1Mod), arrMult(q22, x2Mod)), [p1, p2]);
        p = y1 === y2 ? q11 : arrAdd(arrMult(p1, y2 - oldYRaw), arrMult(p2, oldYRaw - y1));
        setPixel(newData, width, x, y, p.map(function(v) {
          return Math.floor(v);
        }));
      }
    }
    return new ImageData(newData, width, height);
  };

  // This implementation does not exactly match desktop's version, which uses a Java function to do the scaling.  I did not
  // care to track it down and re-implement it exactly here, since this looks and works fine.  If exactness between them is
  // required in the future, we can either switch desktop to use this version, switch them both to a common library that
  // works on web and the JVM, or track down the Java algorithm.  -Jeremy B November 2022
  // (ImageData, Int, Int) => ImageData
  scaled = function(image, width, height) {
    checkIsImage(image);
    if (image.width > width && image.height > height) {
      return boxScale(image, width, height);
    } else {
      return bilinearScale(image, width, height);
    }
  };

  // (ImageData) => Int
  width = function(image) {
    checkIsImage(image);
    return image.width;
  };

  exportError = function(_) {
    throw exceptions.extension("Writing directly from a file is not supported in NetLogo Web.  Instead you can use the SaveTo extension to synchronously write an image file.");
  };

  importError = function(_) {
    throw exceptions.extension("Reading directly from a file is not supported in NetLogo Web.  Instead you can use the Fetch extension to synchronously read in an image file.");
  };

  extensionName = "bitmap";

  exportImageData = function(image) {
    return image;
  };

  importImageData = function(exportedObj) {
    return exportedObj.data;
  };

  bitmapExtension = {
    porter: new SingleObjectExtensionPorter(extensionName, isImageData, toBase64, exportImageData, toBase64, fromBase64, importImageData),
    init: function(workspace) {
      return {
        name: extensionName,
        prims: {
          "AVERAGE-COLOR": averageColor,
          "CHANNEL": channel,
          "COPY-TO-DRAWING": copyToDrawing,
          "COPY-TO-PCOLORS": copyToPColors(workspace.world),
          "DIFFERENCE-RGB": differenceRgb,
          "EXPORT": exportError,
          "FROM-BASE64": fromBase64,
          "TO-BASE64": toBase64,
          "FROM-VIEW": fromView,
          "TO-GRAYSCALE": toGrayscale,
          "HEIGHT": height,
          "IMPORT": importError,
          "SCALED": scaled,
          "WIDTH": width
        }
      };
    }
  };

  module.exports = bitmapExtension;

}).call(this);

},{"engine/core/world/singleobjectextensionporter":"engine/core/world/singleobjectextensionporter","engine/prim/importpcolors":"engine/prim/importpcolors","util/exception":"util/exception"}],"extensions/codap":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var IFramePhone;

  IFramePhone = require('iframe-phone');

  module.exports = {
    porter: void 0,
    init: function(workspace) {
      var phone;
      phone = void 0;
      return {
        name: "codap",
        prims: {
          INIT: function(handler) {
            var ref;
            phone = ((typeof window !== "undefined" && window !== null ? window.parent : void 0) != null) && window.parent !== window ? new IFramePhone.IframePhoneRpcEndpoint(handler, "data-interactive", window.parent) : (((ref = typeof console !== "undefined" && console !== null ? console.log : void 0) != null ? ref : print)("CODAP Extension: Not in a frame; calls will have no effect."), {
              call: function(x) {
                var ref1;
                return ((ref1 = typeof console !== "undefined" && console !== null ? console.log : void 0) != null ? ref1 : print)("CODAP Extension: Not in a frame; doing nothing; received:", x);
              }
            });
            phone.call({
              action: "update",
              resource: "interactiveFrame",
              values: {
                preventDataContextReorg: false,
                title: "NetLogo Web"
              }
            });
          },
          CALL: function(argObj) {
            phone.call(argObj);
          }
        }
      };
    }
  };

}).call(this);

},{"iframe-phone":27}],"extensions/csv":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var boolNames, cast, checks, exceptions, parse, tryParseBool, tryParseFloat;

  ({checks} = require('../engine/core/typechecker'));

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  parse = require('csv-parse/lib/sync');

  boolNames = ["false", "true"];

  // (String) => Float | Null
  tryParseFloat = function(value) {
    var maybeFloat1, maybeFloat2;
    // NetLogo does not consider ',' a valid float character and I don't want
    // to pull the whole NetLogo `NumberParser` in from Scala, so...
    // Jeremy B -August 2020
    if (value.includes(",")) {
      return null;
    }
    // So.  JavaScript's number parsers.  `Number()` will parse things like hex values, which we don't want.
    // `Number.parseFloat()` doesn't do the extended number notation, but is lenient with trailing non-number chars, like
    // `"100abcdef"` is `100` for some reason, which we do not want.  So.  We check both and use the `parseFloat()` value if
    // they both agree the value is the same, actual number.  -Jeremy B November 2023
    maybeFloat1 = Number(value);
    maybeFloat2 = Number.parseFloat(value);
    if (!(Number.isNaN(maybeFloat1) || Number.isNaN(maybeFloat2)) && maybeFloat1 === maybeFloat2) {
      return maybeFloat2;
    }
    return null;
  };

  // (String) => Bool | Null
  tryParseBool = function(value) {
    var lower;
    if (value === null || value.length < 4 || value.length > 5) {
      return null;
    }
    lower = value.toLowerCase();
    if ("false" === lower) {
      return false;
    }
    if ("true" === lower) {
      return true;
    }
    return null;
  };

  // It's silly we have to do this, but csv-parse doesn't cast boolean values, and if you
  // add a cast function, it completely disables the built-in auto-cast.  Bwuh?
  // -Jeremy B August 2020

  // (String, CsvParseContext) => Bool | Float | String
  cast = function(value, context) {
    var maybeBool, maybeFloat;
    if (context.quoting) {
      return value;
    }
    maybeFloat = tryParseFloat(value);
    if (maybeFloat !== null) {
      return maybeFloat;
    }
    maybeBool = tryParseBool(value);
    if (maybeBool !== null) {
      return maybeBool;
    }
    return value;
  };

  module.exports = {
    porter: void 0,
    init: function(workspace) {
      var dumpAndWrap, fromFileNotSupported, fromRow, fromString, guardedToRow, toFileNotSupported, toRow, toString;
      // (String, String) => List[List[Any]]
      fromString = function(csvText, delimiter = ",") {
        return parse(csvText, {
          comment: '#',
          cast: cast,
          max_record_size: 1e12,
          skip_empty_lines: true,
          relax_column_count: true,
          delimiter: delimiter
        });
      };
      // (String, String) => List[Any]
      fromRow = function(csvText, delimiter = ",") {
        var list;
        // Match the desktop extension's behavior with empty rows
        // -Jeremy B August 2020
        if (csvText.trim() === "") {
          return [csvText];
        }
        list = fromString(csvText, delimiter);
        if (list.length === 0) {
          return list;
        } else {
          return list[0];
        }
      };
      // (List[List[Any]], String) => String
      toString = function(list, delimiter = ",") {
        return list.map(function(maybeRow) {
          return guardedToRow(maybeRow, delimiter);
        }).join("\n");
      };
      // (Any | List[Any], String) => String
      guardedToRow = function(maybeRow, delimiter) {
        if (!checks.isList(maybeRow)) {
          throw exceptions.extension(`Expected a list of lists, but ${workspace.dump(maybeRow)} was one of the elements.`);
        }
        return toRow(maybeRow, delimiter);
      };
      // (List[Any], String) => String
      toRow = function(row, delimiter = ",") {
        return row.map(function(cell) {
          return dumpAndWrap(cell, delimiter);
        }).join(delimiter);
      };
      // (Any, String) => String
      dumpAndWrap = function(cell, delimiter) {
        var cellString;
        cellString = workspace.dump(cell);
        if (cellString.startsWith("\"") && cellString.endsWith("\"")) {
          return `\"\"${cellString}\"\"`;
        } else if (cellString.includes(delimiter) || cellString.includes("\n")) {
          return `\"${cellString}\"`;
        } else {
          return cellString;
        }
      };
      // () => Unit
      fromFileNotSupported = function() {
        throw exceptions.extension("Reading directly from a file is not supported in NetLogo Web.  Instead you can use the Fetch extension to asynchronously read in a text file.\n\nfetch:user-file-async [ file-contents -> show csv:from-string file-contents ]");
      };
      // () => Unit
      toFileNotSupported = function() {
        throw exceptions.extension("Writing directly to a file is not supported in NetLogo Web.  Instead you can use the SendTo extension to download a text file of the user's choice.\n\nsend-to:file \"output.csv\" csv:to-string [[0 1 true \"hello\"][1 10 false \"goodbye\"][2 5 true \"...\"]]");
      };
      return {
        name: "csv",
        prims: {
          "FROM-STRING": fromString,
          "FROM-ROW": fromRow,
          "FROM-FILE": fromFileNotSupported,
          "TO-STRING": toString,
          "TO-ROW": toRow,
          "TO-FILE": toFileNotSupported
        }
      };
    }
  };

}).call(this);

},{"../engine/core/typechecker":"engine/core/typechecker","csv-parse/lib/sync":11,"util/exception":"util/exception"}],"extensions/dialog":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var exceptions, flip, fold, halt, id, item, pipeline;

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({item} = require('brazierjs/array'));

  ({flip, id, pipeline} = require('brazierjs/function'));

  ({fold} = require('brazierjs/maybe'));

  halt = function() {
    throw exceptions.halt();
  };

  module.exports = {
    init: function(workspace) {
      var _noDialogIsOpen, prim, userInput, userMessage, userOneOf, userYesOrNo;
      // (String, (String) => Unit) => Unit
      userInput = function(message, ...args) {
        var callback, defaultValue;
        [defaultValue, callback] = args.length === 2 ? args : ["", args[args.length - 1]];
        prim(function(config) {
          return config.getText(message, defaultValue);
        })(callback);
      };
      // (String, () => Unit) => Unit
      userMessage = function(message, callback) {
        prim(function(config) {
          return config.showMessage(message);
        })(callback);
      };
      // (String, Array[Any], () => Unit) => Unit
      userOneOf = function(message, choices, callback) {
        var fullCallback;
        fullCallback = pipeline(flip(item)(choices), fold(function() {
          throw exceptions.internal("Bad choice index");
        })(id), callback);
        if (choices.length !== 0) {
          prim(function(config) {
            return config.getChoice(message, choices.map(function(x) {
              return workspace.dump(x);
            }));
          })(fullCallback);
        } else {
          throw exceptions.extension("List is empty.");
        }
      };
      // (String, (Boolean) => Unit) => Unit
      userYesOrNo = function(message, callback) {
        prim(function(config) {
          return config.getYesOrNo(message);
        })(callback);
      };
      _noDialogIsOpen = true;
      // [T] @ (DialogConfig => (Maybe[T] => Unit) => Unit) => (T => Unit) => Unit
      prim = function(withConfig) {
        return function(callback) {
          if (_noDialogIsOpen) {
            _noDialogIsOpen = false;
            withConfig(workspace.asyncDialogConfig)(function(resultMaybe) {
              _noDialogIsOpen = true;
              return fold(halt)(callback)(resultMaybe);
            });
          }
        };
      };
      return {
        name: "dialog",
        prims: {
          "USER-INPUT": userInput,
          "USER-MESSAGE": userMessage,
          "USER-ONE-OF": userOneOf,
          "USER-YES-OR-NO?": userYesOrNo
        }
      };
    }
  };

}).call(this);

},{"brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/maybe":"brazier/maybe","util/exception":"util/exception"}],"extensions/encode":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var all, checks, decoder, encoder, exceptions, map, pipeline, rangeUntil;

  ({checks} = require('../engine/core/typechecker'));

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({all, map} = require('brazier/array'));

  ({pipeline} = require('brazier/function'));

  ({rangeUntil} = require('brazier/number'));

  decoder = new TextDecoder();

  encoder = new TextEncoder();

  module.exports = {
    init: function(workspace) {
      var _reportFromBytes, base64ToBytes, bytesToBase64, bytesToString, stringToBytes;
      // [T] @ (Array[Number], String) => ((Array[Number]) => T) => T
      _reportFromBytes = function(bytes, primName) {
        return function(f) {
          var isLegit;
          isLegit = function(x) {
            return checks.isNumber(x) && (x >= 0) && (x <= 255);
          };
          if (all(isLegit)(bytes)) {
            return f(bytes);
          } else {
            throw exceptions.extension(`All elements of the list argument to 'encode:${primName}' must be numbers between 0 and 255`);
          }
        };
      };
      // (String) => Array[Number]
      base64ToBytes = function(base64) {
        var str;
        str = atob(base64);
        return pipeline(rangeUntil(0), map(function(n) {
          return str.codePointAt(n);
        }))(str.length);
      };
      // Array[Number] => String
      bytesToBase64 = function(bytes) {
        return _reportFromBytes(bytes, "bytes-to-base64")(function(bytes) {
          var array, binary;
          array = new Uint8Array(bytes);
          binary = array.reduce((function(acc, x) {
            return acc + String.fromCharCode(x);
          }), "");
          return btoa(binary);
        });
      };
      // Array[Number] => String
      bytesToString = function(bytes) {
        return _reportFromBytes(bytes, "bytes-to-string")(function(bytes) {
          return decoder.decode(new Uint8Array(bytes));
        });
      };
      // (String) => Array[Number]
      stringToBytes = function(str) {
        return Array.from(encoder.encode(str));
      };
      return {
        name: "encode",
        prims: {
          "BASE64-TO-BYTES": base64ToBytes,
          "BYTES-TO-BASE64": bytesToBase64,
          "BYTES-TO-STRING": bytesToString,
          "STRING-TO-BYTES": stringToBytes
        }
      };
    }
  };

}).call(this);

},{"../engine/core/typechecker":"engine/core/typechecker","brazier/array":"brazier/array","brazier/function":"brazier/function","brazier/number":"brazier/number","util/exception":"util/exception"}],"extensions/export-the":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  module.exports = {
    init: function(workspace) {
      var exportModel, exportOutput, exportPlot, exportView, exportWorld;
      // () => String
      exportModel = function() {
        return workspace.importExportPrims.exportNlogoRaw();
      };
      // () => String
      exportOutput = function() {
        return workspace.importExportPrims.exportOutputRaw();
      };
      // (String) => String
      exportPlot = function(plotName) {
        return workspace.importExportPrims.exportPlotNoHeadersRaw(plotName);
      };
      // () => String
      exportView = function() {
        return workspace.importExportPrims.exportViewRaw();
      };
      // () => String
      exportWorld = function() {
        return workspace.importExportPrims.exportWorldRaw();
      };
      return {
        name: "export-the",
        prims: {
          "MODEL": exportModel,
          "OUTPUT": exportOutput,
          "PLOT": exportPlot,
          "VIEW": exportView,
          "WORLD": exportWorld
        }
      };
    }
  };

}).call(this);

},{}],"extensions/fetch":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var exceptions;

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  module.exports = {
    init: function(workspace) {
      var fromFileDialog, fromFileDialogSynchronously, fromFilepath, fromFilepathSynchronously, fromURL, fromURLSynchronously;
      // (String, (String) => Unit) => Unit
      fromFilepath = function(filepath, callback) {
        // `TestModels` needs this, and I don't see any sensible way around it --JAB (3/13/19)
        if (typeof Polyglot !== "undefined" && Polyglot !== null) {
          workspace.ioConfig.importFile(filepath)(callback);
        } else {
          throw exceptions.extension("'fetch:file-async' is not supported in NetLogo Web.  Use 'fetch:user-file-async' instead.");
        }
      };
      // (String) => String
      fromFilepathSynchronously = function(filepath, callback) {
        throw exceptions.extension("'fetch:file' is not supported in NetLogo Web.  Use 'fetch:user-file-async' instead.");
      };
      // (String, (String) => Unit) => Unit
      fromURL = function(url, callback) {
        workspace.ioConfig.slurpURLAsync(url)(callback, workspace.reportErrors);
      };
      // (String) => String
      fromURLSynchronously = function(url) {
        return workspace.ioConfig.slurpURL(url);
      };
      // ((Boolean|String) => Unit) => String
      fromFileDialog = function(callback) {
        workspace.ioConfig.slurpFileDialogAsync(callback);
      };
      // () => String
      fromFileDialogSynchronously = function() {
        throw exceptions.extension("'fetch:user-file' is not supported in NetLogo Web.  Use 'fetch:user-file-async' instead.");
      };
      return {
        name: "fetch",
        prims: {
          "FILE": fromFilepathSynchronously,
          "FILE-ASYNC": fromFilepath,
          "URL": fromURLSynchronously,
          "URL-ASYNC": fromURL,
          "USER-FILE": fromFileDialogSynchronously,
          "USER-FILE-ASYNC": fromFileDialog
        }
      };
    }
  };

}).call(this);

},{"util/exception":"util/exception"}],"extensions/fp":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var apply, checks, compose, curry, drop, exceptions, find, findIndices, flatten, iterateForLast, iterateToList, pipe, reduceReporters, scan, take, unzip, zip;

  ({checks} = require('../engine/core/typechecker'));

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  // (Int, Array) => Array
  take = function(n, l) {
    if (n < 0) {
      throw exceptions.extension('First argument must be a positive number.');
    }
    return l.slice(0, n);
  };

  // (Int, Array) => Array
  drop = function(n, l) {
    if (n < 0) {
      throw exceptions.extension('First argument must be a positive number.');
    }
    return l.slice(n);
  };

  // ((Any, Any) => Any, Array) => Array
  scan = function(r, l) {
    return l.reduce(function(results, value, index) {
      var result;
      result = index === 0 ? value : r(results[index - 1], value);
      results.push(result);
      return results;
    }, []);
  };

  // (Array[Reporter]) => Reporter
  reduceReporters = function(rs) {
    var reduced;
    reduced = function() {
      var firstResult;
      firstResult = rs[0](...arguments);
      return rs.slice(1).reduce(function(resultSoFar, reporter) {
        return reporter(resultSoFar);
      }, firstResult);
    };
    reduced.isReporter = true;
    reduced.minArgCount = rs[0].minArgCount;
    return reduced;
  };

  // (Array[Reporter]) => Reporter
  compose = function(...rs) {
    rs.reverse();
    return reduceReporters(rs);
  };

  // (Array[Reporter]) => Reporter
  pipe = function(...rs) {
    return reduceReporters(rs);
  };

  // (Reporter, Array[Any]) => Reporter
  curry = function(r, ...leftArgs) {
    var curried;
    curried = function(...rightArgs) {
      var args;
      args = leftArgs.concat(rightArgs);
      return r(...args);
    };
    curried.isReporter = true;
    curried.minArgCount = r.minArgCount - leftArgs.length;
    return curried;
  };

  // ((Any) => Boolean, Array[Any]) => Array[Int]
  findIndices = function(r, l) {
    var indices;
    indices = l.map(function(v, i) {
      var check;
      check = r(v);
      if (!checks.isBoolean(check)) {
        throw exceptions.extension('The reporter does not return a boolean value.');
      }
      if (check) {
        return i;
      } else {
        return -1;
      }
    });
    return indices.filter(function(i) {
      return i !== -1;
    });
  };

  // ((Any) => Boolean, Array[Any]) => Any
  find = function(r, l) {
    return l.find(function(v) {
      var check;
      check = r(v);
      if (!checks.isBoolean(check)) {
        throw exceptions.extension('The reporter does not return a boolean value.');
      }
      return check;
    });
  };

  // (Array[Array[Any]]) => Array[Array[Any]]
  zip = function(...ls) {
    var length, results;
    length = Math.min(...ls.map(function(l) {
      return l.length;
    }));
    results = (new Array(length)).fill(0);
    return results.map(function(_, i) {
      var result;
      result = (new Array(ls.length)).fill(0);
      return result.map(function(_, j) {
        return ls[j][i];
      });
    });
  };

  // (Array[Array[Any]]) => Array[Array[Any]]
  unzip = function(ls) {
    var length, results;
    ls.forEach(function(l) {
      if (!checks.isList(l)) {
        throw exceptions.extension('Input must be a list of lists.');
      }
    });
    length = Math.max(...ls.map(function(l) {
      return l.length;
    }));
    results = (new Array(length)).fill(0);
    return results.map(function(_, i) {
      return ls.reduce(function(result, l) {
        if (i < l.length) {
          result.push(l[i]);
        }
        return result;
      }, []);
    });
  };

  // (Array[Any]) => Array[Any]
  flatten = function(l) {
    var flattenRec;
    flattenRec = function(v) {
      if (checks.isList(v)) {
        return v.flatMap(flattenRec);
      } else {
        return v;
      }
    };
    return flattenRec(l);
  };

  iterateToList = function(f, initialValue, repetitions) {
    var initialResult, list, result;
    initialResult = f(initialValue);
    result = initialResult;
    repetitions = repetitions - 1;
    list = (function() {
      var results1;
      results1 = [];
      while (repetitions > 0) {
        repetitions = repetitions - 1;
        result = f(result);
        results1.push(result);
      }
      return results1;
    })();
    list.splice(0, 0, initialValue, initialResult);
    return list;
  };

  iterateForLast = function(f, initialValue, repetitions) {
    var result;
    result = f(initialValue);
    repetitions = repetitions - 1;
    while (repetitions > 0) {
      repetitions = repetitions - 1;
      result = f(result);
    }
    return result;
  };

  apply = function(f, values) {
    return f(...values);
  };

  module.exports = {
    porter: void 0,
    init: function(workspace) {
      var prims;
      prims = {
        take,
        drop,
        scan,
        compose,
        pipe,
        curry,
        "find-indices": findIndices,
        find,
        zip,
        unzip,
        flatten,
        "iterate": iterateToList,
        "iterate-last": iterateForLast,
        apply
      };
      Object.keys(prims).forEach((p) => {
        return prims[p.toUpperCase()] = prims[p];
      });
      return {
        name: "fp",
        prims
      };
    }
  };

}).call(this);

},{"../engine/core/typechecker":"engine/core/typechecker","util/exception":"util/exception"}],"extensions/http-req":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  module.exports = {
    porter: void 0,
    init: function(workspace) {
      var get, post, requestor;
      // (String) => [String, String, String]
      get = function(url) {
        var ref, req;
        req = requestor("GET", url);
        return [req.status, req.statusText, (ref = req.responseText) != null ? ref : ''];
      };
      // (String, String, String) => [String, String, String]
      post = function(url, message, contentType) {
        var req;
        req = requestor("POST", url, message, contentType != null ? contentType : "text/plain");
        return [req.status, req.statusText, req.responseText];
      };
      // (String, String, String, String) => XMLHttpRequest
      requestor = function(reqType, url, message, contentType) {
        var ct, req;
        req = new XMLHttpRequest();
        // Setting the async option to `false` is deprecated and "bad" as far as HTML/JS is
        // concerned.  But this is NetLogo and NetLogo model code doesn't have a concept of
        // async execution, so this is the best we can do.  As long as it isn't used on a
        // per-tick basis or in a loop, it should be okay.  -JMB August 2017
        req.open(reqType, url, false);
        if (contentType != null) {
          ct = (function() {
            switch (contentType) {
              case 'json':
                return 'application/json';
              case 'urlencoded':
                return 'application/x-www-form-urlencoded';
              default:
                return contentType;
            }
          })();
          req.setRequestHeader("Content-type", ct);
        }
        req.send(message != null ? message : "");
        return req;
      };
      return {
        name: "http-req",
        prims: {
          "GET": get,
          "POST": post
        }
      };
    }
  };

}).call(this);

},{}],"extensions/import-a":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  module.exports = {
    init: function(workspace) {
      var importDrawing, importPColors, importPColorsRGB, importWorld;
      // (String) => Unit
      importDrawing = function(base64) {
        workspace.importExportPrims.importDrawingRaw(base64);
      };
      // (String) => Unit
      importPColors = function(base64) {
        workspace.importExportPrims.importPColorsRaw(true)(base64);
      };
      // (String) => Unit
      importPColorsRGB = function(base64) {
        workspace.importExportPrims.importPColorsRaw(false)(base64);
      };
      // (String) => Unit
      importWorld = function(text) {
        workspace.importExportPrims.importWorldRaw(text);
      };
      return {
        name: "import-a",
        prims: {
          "DRAWING": importDrawing,
          "PCOLORS": importPColors,
          "PCOLORS-RGB": importPColorsRGB,
          "WORLD": importWorld
        }
      };
    }
  };

}).call(this);

},{}],"extensions/logging":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var contains, filter, flip, foldl, id, isEmpty, map, pipeline, tail, tee;

  ({contains, filter, foldl, isEmpty, map, tail} = require('brazierjs/array'));

  ({flip, id, pipeline, tee} = require('brazierjs/function'));

  module.exports = {
    porter: void 0,
    init: function(workspace) {
      var allLogs, clearLogs, logBuffer, logGlobals, logMessage;
      logBuffer = []; // Array[String]
      
      // (String) => Unit
      logMessage = function(str) {
        logBuffer.push(str);
      };
      // (String*) => Unit
      logGlobals = function(...names) {
        var getGlobal, globalNames, join, nameToLog, observer, toLogMessage, trueNames;
        observer = workspace.world.observer;
        globalNames = observer.varNames();
        getGlobal = observer.getGlobal.bind(observer);
        trueNames = isEmpty(names) ? globalNames : filter(flip(contains(globalNames)))(names);
        toLogMessage = function([name, value]) {
          return `${name}: ${value}`;
        };
        nameToLog = pipeline(tee(id)(pipeline(getGlobal, function(x) {
          return workspace.dump(x, true);
        })), toLogMessage);
        join = pipeline(foldl(function(acc, s) {
          return acc + "\n" + s;
        })(""), tail); // Use `tail` to drop initial newline
        pipeline(map(nameToLog), join, logMessage)(trueNames);
      };
      // () => Array[String]
      allLogs = function() {
        return logBuffer.slice(0);
      };
      // () => Unit
      clearLogs = function() {
        logBuffer = [];
      };
      return {
        name: "logging",
        prims: {
          "ALL-LOGS": allLogs,
          "CLEAR-LOGS": clearLogs,
          "LOG-GLOBALS": logGlobals,
          "LOG-MESSAGE": logMessage
        }
      };
    }
  };

}).call(this);

},{"brazierjs/array":"brazier/array","brazierjs/function":"brazier/function"}],"extensions/matrix":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var SingleObjectExtensionPorter, StrictMath, arrayEquals, checkNestedList, checks, dumpMatrix, exceptions, exportMatrix, extensionName, find, floor, fold, formatExpMatrix, formatMatrix, importMatrix, isMatrix, map, notImplementedException, pipeline, rangeUntil, readMatrix, vec;

  ({find, map} = require('brazierjs/array'));

  ({arrayEquals} = require('brazierjs/equals'));

  ({pipeline} = require('brazierjs/function'));

  ({fold} = require('brazierjs/maybe'));

  ({rangeUntil} = require('brazierjs/number'));

  ({floor} = require('util/nlmath'));

  ({checks} = require('../engine/core/typechecker'));

  StrictMath = require('shim/strictmath');

  vec = require('vectorious');

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  SingleObjectExtensionPorter = require('../engine/core/world/singleobjectextensionporter');

  notImplementedException = function(prim) {
    throw exceptions.extension(`${prim} has not been implemented.`);
  };

  // Check nestedList input for possible problems, used by fromRowList & fromColumnList
  // If input nestedList includes items, not numbers, replace them by zeros.
  // -- XZ(Summer, 2020)
  // List[Any] => List[List[Number]]
  checkNestedList = function(list) {
    var column, k, l, len1, len2, len3, n, numCols, numRows, ref, ref1, row, rowList;
    numRows = list.length;
    if (numRows === 0) {
      throw exceptions.extension("input list was empty");
    }
    numCols = -1;
    for (k = 0, len1 = list.length; k < len1; k++) {
      rowList = list[k];
      if (rowList instanceof Array) {
        if (numCols === -1) {
          numCols = rowList.length;
        } else if (numCols !== rowList.length) {
          throw exceptions.extension("To convert a nested list into a matrix, all nested lists must be the same length" + " -- e.g. [[1 2 3 4] [1 2 3]] is invalid, because row 1 has one more entry.");
        }
      } else {
        throw exceptions.extension("To convert a nested list into a matrix, there must be exactly two levels of nesting" + " -- e.g. [[1 2 3] [4 5 6]] creates a good 2x3 matrix.");
      }
    }
    if (numCols === 0) {
      throw exceptions.extension("input list contained only empty lists");
    }
    ref = rangeUntil(0)(numRows);
    // Assign zeros if the element is not a number
    for (l = 0, len2 = ref.length; l < len2; l++) {
      row = ref[l];
      ref1 = rangeUntil(0)(numCols);
      for (n = 0, len3 = ref1.length; n < len3; n++) {
        column = ref1[n];
        if (typeof list[row][column] !== 'number') {
          list[row][column] = 0;
        }
      }
    }
    return list;
  };

  // Any => Boolean
  isMatrix = function(x) {
    return x instanceof vec;
  };

  dumpMatrix = function(matrix) {
    return ` ${formatMatrix(matrix)}`;
  };

  exportMatrix = function(matrix) {
    return matrix;
  };

  // Matrix => String
  formatExpMatrix = function(exportedObj) {
    return formatMatrix(exportedObj.data);
  };

  formatMatrix = function(matrix) {
    var inner;
    inner = matrix.toArray().map(function(row) {
      return `[ ${row.join(" ")} ]`;
    }).join("");
    return `[ ${inner} ]`;
  };

  readMatrix = function(x, parseAny) {
    var list, parseable;
    parseable = x.replaceAll("\[ ", "[").replaceAll(" \]", "]").replaceAll("][", "] [");
    list = parseAny(parseable);
    return vec.array(list);
  };

  importMatrix = function(exportedObj) {
    return exportedObj.data;
  };

  extensionName = "matrix";

  module.exports = {
    porter: new SingleObjectExtensionPorter(extensionName, isMatrix, dumpMatrix, exportMatrix, formatExpMatrix, readMatrix, importMatrix),
    init: function(workspace) {
      var copy, det, dimensions, eigenvectors, forecastCompoundGrowth, forecastContinuousGrowth, forecastGrowthHelper, forecastLinearGrowth, fromColumnList, fromRowList, get, getColumn, getRow, imaginaryEigenvalues, inverse, makeConstant, makeIdentity, matrixMap, minus, opReducer, plus, prettyPrint, rank, realEigenvalues, regress, set, setAndReport, setColumn, setRow, solve, submatrix, swapColumns, swapRows, times, timesElementWise, toColumnList, toRowList, trace, transpose, validate;
      // Check input values: matrix is valid; rows & cols are not out of boundary; newVals is a valid list.
      // Return [Integer(rows), Integer(cols)].
      // e.g. matrix:get glob1 1.1 2.2 == matrix:get glob1 1 2
      // -- XZ(Summer, 2020)
      // (Any, Number*, Number*, List[Number]*) => [Number|Null, Number|Null]
      validate = function(matrix, rows, cols, newVals) {
        var len, numCols, numRows;
        if (!isMatrix(matrix)) {
          throw exceptions.extension(`not a matrix: ${workspace.dump(matrix, true)}`);
        }
        [numRows, numCols] = matrix.shape;
        if ((rows != null) && (cols != null)) {
          if (!((0 <= rows && rows < numRows)) || !((0 <= cols && cols < numCols))) {
            throw exceptions.extension(`[${rows} ${cols}] are not valid indices for a matrix with dimensions ${numRows}x${numCols}`);
          } else {
            return [floor(rows), floor(cols)];
          }
        } else if (rows != null) {
          if (!((0 <= rows && rows < numRows))) {
            throw exceptions.extension(`${rows} is not a valid index for a matrix with dimensions ${numRows}x${numCols}`);
          }
          if (newVals && (len = newVals.length) !== numCols) {
            throw exceptions.extension(`The length of the given list (${len}) is different from the length of the matrix row (${numRows})`);
          } else {
            return [floor(rows), null];
          }
        } else if (cols != null) {
          if (!((0 <= cols && cols < numCols))) {
            throw exceptions.extension(`${cols} is not a valid index for a matrix with dimensions ${numRows}x${numCols}`);
          }
          if (newVals && (len = newVals.length) !== numRows) {
            throw exceptions.extension(`The length of the given list (${len}) is different from the length of the matrix column (${numCols})`);
          } else {
            return [null, floor(cols)];
          }
        }
      };
      // (Number, Number, Number) => Matrix
      makeConstant = function(rows, cols, initialValue) {
        return vec.matrix(rows, cols).fill(initialValue);
      };
      // Number => Matrix
      makeIdentity = function(size) {
        return vec.eye(size);
      };
      // List[List[Number]] => Matrix
      fromRowList = function(nestedList) {
        nestedList = checkNestedList(nestedList);
        return vec.array(nestedList);
      };
      // List[List[Number]] => Matrix
      fromColumnList = function(nestedList) {
        nestedList = checkNestedList(nestedList);
        return vec.array(nestedList).T;
      };
      // Matrix => List[List[Number]]
      toRowList = function(matrix) {
        validate(matrix);
        return matrix.toArray();
      };
      // Matrix => List[List[Number]]
      toColumnList = function(matrix) {
        validate(matrix);
        return matrix.T.toArray();
      };
      // Matrix => Matrix
      copy = function(matrix) {
        validate(matrix);
        return matrix.copy();
      };
      // Matrix => String
      prettyPrint = function(matrix) {
        var alignRow, aligned;
        validate(matrix);
        alignRow = function(row) {
          return `[ ${row.join('  ')} ]`;
        };
        aligned = matrix.toArray().map(function(row) {
          return alignRow(row);
        }).join('\n ');
        return `[${aligned}]`;
      };
      // (Matrix, Number, Number) => Number
      get = function(matrix, i, j) {
        [i, j] = validate(matrix, i, j);
        return matrix.get(i, j);
      };
      // (Matrix, Number) => List[Number]
      getRow = function(matrix, i) {
        var _, cols;
        [i, _] = validate(matrix, i);
        [_, cols] = matrix.shape;
        return rangeUntil(0)(cols).map(function(j) {
          return matrix.get(i, j);
        });
      };
      // (Matrix, Number) => List[Number]
      getColumn = function(matrix, j) {
        var _, rows;
        [_, j] = validate(matrix, _, j);
        [rows, _] = matrix.shape;
        return rangeUntil(0)(rows).map(function(i) {
          return matrix.get(i, j);
        });
      };
      // (Matrix, Number, Number, Number) => Unit
      set = function(matrix, i, j, newVal) {
        [i, j] = validate(matrix, i, j);
        matrix.set(i, j, newVal);
      };
      // (Matrix, Number, List[Number]) => Unit
      setRow = function(matrix, i, newVals) {
        var _, cols;
        [i, _] = validate(matrix, i, _, newVals);
        [_, cols] = matrix.shape;
        rangeUntil(0)(cols).forEach(function(j) {
          return matrix.set(i, j, newVals[j]);
        });
      };
      // (Matrix, Number, List[Number]) => Unit
      setColumn = function(matrix, j, newVals) {
        var _, rows;
        [_, j] = validate(matrix, _, j, newVals);
        [rows, _] = matrix.shape;
        rangeUntil(0)(rows).forEach(function(i) {
          return matrix.set(i, j, newVals[i]);
        });
      };
      // (Matrix, Number, Number) => Unit
      swapRows = function(matrix, r1, r2) {
        validate(matrix, r1);
        validate(matrix, r2);
        matrix.swap(r1, r2);
      };
      // (Matrix, Number, Number) => Unit
      swapColumns = function(matrix, c1, c2) {
        var _, i, k, len1, oldC1, ref, rows;
        [_, c1] = validate(matrix, _, c1);
        [_, c2] = validate(matrix, _, c2);
        [rows, _] = matrix.shape;
        ref = rangeUntil(0)(rows);
        for (k = 0, len1 = ref.length; k < len1; k++) {
          i = ref[k];
          oldC1 = matrix.get(i, c1);
          matrix.set(i, c1, matrix.get(i, c2));
          matrix.set(i, c2, oldC1);
        }
      };
      // (Matrix, Number, Number, Number) => Matrix
      setAndReport = function(matrix, i, j, newVal) {
        var dupe;
        validate(matrix, i, j);
        dupe = matrix.copy();
        set(dupe, i, j, newVal);
        return dupe;
      };
      // (Matrix) => (Number, Number)
      dimensions = function(matrix) {
        validate(matrix);
        return matrix.shape;
      };
      // (Matrix, Number, Number, Number, Number) => Matrix
      submatrix = function(matrix, r1, c1, r2, c2) {
        var arr, i, j, k, l, len1, len2, ref, ref1, subArr, subCols, subRows;
        (function() { // Error-checking blurb
          var checkArg, numCols, numRows;
          [numRows, numCols] = matrix.shape;
          checkArg = function({arg, lower, upper, isStart, isRow}) {
            var complaint, dimName, polarity, remedy;
            if (!((lower <= arg && arg <= upper))) {
              polarity = isStart ? "Start" : "End";
              dimName = isRow ? "row" : "column";
              complaint = `${polarity} ${dimName} index (${arg}) is invalid.`;
              remedy = `Should be between ${lower} and ${upper} inclusive.`;
              throw exceptions.extension(`${complaint}  ${remedy}`);
            }
          };
          return [
            {
              arg: r1,
              lower: 0,
              upper: numRows - 1,
              isStart: true,
              isRow: true
            },
            {
              arg: c1,
              lower: 0,
              upper: numCols - 1,
              isStart: true,
              isRow: false
            },
            {
              arg: r2,
              lower: 1,
              upper: numRows,
              isStart: false,
              isRow: true
            },
            {
              arg: c2,
              lower: 1,
              upper: numCols,
              isStart: false,
              isRow: false
            }
          ].forEach(checkArg);
        })();
        arr = matrix.toArray();
        subRows = r2 - r1;
        subCols = c2 - c1;
        subArr = pipeline(rangeUntil(0), map(function() {
          return [];
        }))(subRows);
        ref = rangeUntil(0)(subRows);
        for (k = 0, len1 = ref.length; k < len1; k++) {
          i = ref[k];
          ref1 = rangeUntil(0)(subCols);
          for (l = 0, len2 = ref1.length; l < len2; l++) {
            j = ref1[l];
            subArr[i][j] = arr[r1 + i][c1 + j];
          }
        }
        return vec.array(subArr);
      };
      // ((Number* => Number), Matrix, Matrix*) => Matrix
      matrixMap = function(reporter, matrix, ...rest) {
        var badShape, firstShape, k, len1, m, shapeToStr;
        if (reporter.minArgCount > rest.length + 1) {
          throw exceptions.extension(`Task expected ${reporter.minArgCount} matrix inputs but only got ${rest.length + 1}.`);
        }
        for (k = 0, len1 = rest.length; k < len1; k++) {
          m = rest[k];
          if (!arrayEquals(matrix.shape)(m.shape)) {
            shapeToStr = function([x, y]) {
              return `${x}x${y}`;
            };
            firstShape = shapeToStr(matrix.shape);
            badShape = shapeToStr(m.shape);
            throw exceptions.extension(`All matrices must have the same dimensions: the first was ${firstShape} and another was ${badShape}.`);
          }
        }
        return matrix.map(function(item, i) {
          var restItems;
          restItems = rest.map(function(m) {
            return m.get(floor(i / m.shape[1]), i % m.shape[1]);
          });
          return reporter(item, ...restItems);
        });
      };
      // ((Number, Number) => Number, (Matrix, Matrix) => Matrix, (Matrix, Number) => Matrix) =>
      //   (Matrix|Number, Matrix|Number, (Matrix|Number)*) =>
      //     Matrix|Number
      opReducer = function(scalarOp, matrixOp, mixedOp) {
        return function(m1, m2, ...rest) {
          return [m1, m2, ...rest].reduce(function(left, right) {
            if (checks.isNumber(left)) {
              if (checks.isNumber(right)) {
                return scalarOp(left, right);
              } else {
                return mixedOp(right, left);
              }
            } else {
              if (checks.isNumber(right)) {
                return mixedOp(left, right);
              } else {
                return matrixOp(left, right);
              }
            }
          });
        };
      };
      // (Matrix|Number, Matrix|Number, (Matrix|Number)*) => Matrix|Number
      times = function(m1, m2, ...rest) {
        return opReducer(((s1, s2) => {
          return s1 * s2;
        }), vec.multiply, vec.scale)(m1, m2, ...rest);
      };
      // (Matrix, Matrix, Matrix*) => Matrix
      timesElementWise = function(m1, m2, ...rest) {
        return opReducer(((s1, s2) => {
          return s1 * s2;
        }), vec.product, vec.scale)(m1, m2, ...rest);
      };
      // (Matrix|Number, Matrix|Number, (Matrix|Number)*) => Matrix|Number
      plus = function(m1, m2, ...rest) {
        return opReducer(((s1, s2) => {
          return s1 + s2;
        }), vec.add, (function(m, s) {
          return m.map(function(x) {
            return x + s;
          });
        }))(m1, m2, ...rest);
      };
      // (Matrix|Number, Matrix|Number, (Matrix|Number)*) => Matrix|Number
      minus = function(m1, m2, ...rest) {
        var broadcastIfNumber, cols, operands, rows;
        operands = [m1, m2, ...rest];
        [rows, cols] = pipeline(find(isMatrix), fold(function() {
          throw exceptions.extension("One or more (-) operands must be a matrix...");
        })(function(x) {
          return x.shape;
        }))(operands);
        broadcastIfNumber = function(x) {
          if (checks.isNumber(x)) {
            return makeConstant(rows, cols, x);
          } else {
            return x;
          }
        };
        return operands.reduce(function(left, right) {
          return vec.subtract(broadcastIfNumber(left), broadcastIfNumber(right));
        });
      };
      // Matrix => Matrix
      inverse = function(matrix) {
        validate(matrix);
        return matrix.inv();
      };
      // Matrix => Matrix
      transpose = function(matrix) {
        validate(matrix);
        return matrix.T;
      };
      // Apparently this is inefficient for large matrices. --SL (Spring, 2017)
      // Matrix => Number
      det = function(matrix) {
        validate(matrix);
        return matrix.det();
      };
      // Matrix => Number
      rank = function(matrix) {
        validate(matrix);
        return matrix.rank();
      };
      // Matrix => Number
      trace = function(matrix) {
        validate(matrix);
        return matrix.trace();
      };
      // (Matrix, Matrix) => Matrix
      solve = function(m1, m2) {
        validate(m1);
        validate(m2);
        return m1.solve(m2);
      };
      // Following three eigen-related APIs are dummy implementations.
      // We throw an error to explain we have not implemented them yet. -- XZ (Summer, 2020)
      // (Matrix) => List
      realEigenvalues = function(matrix) {
        return notImplementedException("matrix:real-eigenvalues");
      };
      // (Matrix) => List
      imaginaryEigenvalues = function(matrix) {
        return notImplementedException("matrix:imaginary-eigenvalues");
      };
      // (Matrix) => Matrix
      eigenvectors = function(matrix) {
        return notImplementedException("matrix:eigenvectors");
      };
      // List[Number] => (Number, Number, Number, Number)
      forecastGrowthHelper = function(data) {
        var constant, dataMatrix, indepVar, r2, slope;
        indepVar = rangeUntil(0)(data.length);
        dataMatrix = fromColumnList([data, indepVar]);
        [[constant, slope], [r2]] = regress(dataMatrix);
        return [constant, slope, r2];
      };
      // List[Number] => (Number, Number, Number, Number)
      forecastLinearGrowth = function(data) {
        var constant, forecast, r2, slope;
        [constant, slope, r2] = forecastGrowthHelper(data);
        forecast = slope * data.length + constant;
        return [forecast, constant, slope, r2];
      };
      // List[Number] => (Number, Number, Number, Number)
      forecastCompoundGrowth = function(data) {
        var c, constant, forecast, lnData, p, proportion, r2;
        lnData = data.map(function(x) {
          return StrictMath.log(x);
        });
        [c, p, r2] = forecastGrowthHelper(lnData);
        constant = StrictMath.exp(c);
        proportion = StrictMath.exp(p);
        forecast = constant * proportion ** data.length;
        return [forecast, constant, proportion, r2];
      };
      // List[Number] => (Number, Number, Number, Number)
      forecastContinuousGrowth = function(data) {
        var c, constant, forecast, lnData, r2, rate;
        lnData = data.map(function(x) {
          return StrictMath.log(x);
        });
        [c, rate, r2] = forecastGrowthHelper(lnData);
        constant = StrictMath.exp(c);
        forecast = constant * StrictMath.exp(rate * data.length);
        return [forecast, constant, rate, r2];
      };
      // Matrix => (List[Number], (Number, Number, Number))
      regress = function(data) {
        var coefficients, indepVars, matrix, nObservations, nVars, ones, rSquared, resid, residSumSq, stats, totalSumSq, y, yBar, yDiff, ySum;
        y = fromColumnList([getColumn(data, 0)]);
        // To construct the matrix (known as "matrix" in the code, and as "X" in the comments),
        // we replace the first column (the dependent variable) of the input matrix with all 1's --SL (Spring, 2017)
        [nObservations, nVars] = data.shape;
        indepVars = submatrix(data, 0, 1, nObservations, nVars);
        ones = y.map(function() {
          return 1;
        });
        matrix = vec.augment(ones, indepVars);
        // Solve the system Xb = y for b, the row vector of coefficients for each independent variable.
        // The following form ensures X does not need to be square: y.T * X * (X.T * X)^-1 --SL (Spring, 2017)
        coefficients = times(y.T, matrix, inverse(times(matrix.copy().T, matrix)));
        ySum = y.reduce(function(a, b) {
          return a + b;
        });
        yBar = ySum / nObservations;
        yDiff = minus(y, makeConstant(nObservations, 1, yBar));
        totalSumSq = times(yDiff.copy().T, yDiff).get(0, 0);
        resid = minus(times(matrix, coefficients.copy().T), y);
        residSumSq = times(resid.copy().T, resid).get(0, 0);
        rSquared = 1 - (residSumSq / totalSumSq);
        stats = [rSquared, totalSumSq, residSumSq];
        return [getRow(coefficients, 0), stats];
      };
      return {
        name: extensionName,
        prims: {
          "MAKE-CONSTANT": makeConstant,
          "MAKE-IDENTITY": makeIdentity,
          "FROM-ROW-LIST": fromRowList,
          "FROM-COLUMN-LIST": fromColumnList,
          "TO-ROW-LIST": toRowList,
          "TO-COLUMN-LIST": toColumnList,
          "COPY": copy,
          "PRETTY-PRINT-TEXT": prettyPrint,
          "SOLVE": solve,
          "GET": get,
          "GET-ROW": getRow,
          "GET-COLUMN": getColumn,
          "SET": set,
          "SET-ROW": setRow,
          "SET-COLUMN": setColumn,
          "SWAP-ROWS": swapRows,
          "SWAP-COLUMNS": swapColumns,
          "SET-AND-REPORT": setAndReport,
          "DIMENSIONS": dimensions,
          "SUBMATRIX": submatrix,
          "MAP": matrixMap,
          "TIMES-SCALAR": times,
          "TIMES": times,
          "*": times,
          "TIMES-ELEMENT-WISE": timesElementWise,
          "PLUS-SCALAR": plus,
          "PLUS": plus,
          "+": plus,
          "MINUS": minus,
          "-": minus,
          "INVERSE": inverse,
          "TRANSPOSE": transpose,
          "DET": det,
          "RANK": rank,
          "TRACE": trace,
          "FORECAST-LINEAR-GROWTH": forecastLinearGrowth,
          "FORECAST-COMPOUND-GROWTH": forecastCompoundGrowth,
          "FORECAST-CONTINUOUS-GROWTH": forecastContinuousGrowth,
          "REGRESS": regress,
          "IS-MATRIX?": isMatrix,
          "REAL-EIGENVALUES": realEigenvalues,
          "IMAGINARY-EIGENVALUES": imaginaryEigenvalues,
          "EIGENVECTORS": eigenvectors
        }
      };
    }
  };

}).call(this);

},{"../engine/core/typechecker":"engine/core/typechecker","../engine/core/world/singleobjectextensionporter":"engine/core/world/singleobjectextensionporter","brazierjs/array":"brazier/array","brazierjs/equals":"brazier/equals","brazierjs/function":"brazier/function","brazierjs/maybe":"brazier/maybe","brazierjs/number":"brazier/number","shim/strictmath":"shim/strictmath","util/exception":"util/exception","util/nlmath":"util/nlmath","vectorious":144}],"extensions/mini-csv":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var csv, instance, parseString;

  csv = require("extensions/csv");

  ({parseString} = require('../serialize/readexportedvalue'));

  instance = null;

  module.exports = {
    porter: {
      extensionName: "mini-csv",
      canHandle: function() {
        return false;
      },
      export: function() {
        return {
          extensionName: "mini-csv",
          value: instance.value.report()
        };
      },
      format: function(state) {
        var str;
        str = JSON.stringify(state);
        return '"""' + str.replace(/"/g, '\\""') + '"""';
      },
      read: function(str) {
        var json;
        json = parseString(str[0]);
        return JSON.parse(json);
      },
      import: function(state) {
        return instance.value.set(state.value);
      }
    },
    init: function(workspace) {
      var core, deprecatePrim, val, value;
      core = csv.init(workspace);
      val = 100;
      value = {
        set: function(v) {
          return val = v;
        },
        decrement: function() {
          val = val - 1;
        },
        report: function() {
          return val;
        },
        increment: function() {
          val = val + 1;
        }
      };
      // (String, String, U => T) => U => T
      deprecatePrim = function(oldName, newName, f) {
        return function() {
          workspace.printPrims.print(`${oldName} is deprecated and will be removed in a future NetLogo Web release.  Please switch to using ${newName} instead.`);
          return f.apply(null, arguments);
        };
      };
      instance = {
        name: "mini-csv",
        clearAll: value.decrement,
        value: value,
        prims: {
          "FROM-STRING": deprecatePrim("mini-csv:from-string", "csv:from-string", core.prims["FROM-STRING"]),
          "FROM-ROW": deprecatePrim("mini-csv:from-row", "csv:from-row", core.prims["FROM-ROW"]),
          "TO-STRING": deprecatePrim("mini-csv:to-string", "csv:to-string", core.prims["TO-STRING"]),
          "TO-ROW": deprecatePrim("mini-csv:to-row", "csv:to-row", core.prims["TO-ROW"]),
          // These are non-functional prims just to test our extension format parsing/loading.
          // At the moment there is no easy way to add a "test only" extension, so they get
          // put here.  -Jeremy B July 2021
          "__T-CONTEXT-REPORTER": value.report,
          "__O-CONTEXT-COMMAND": value.increment
        }
      };
      return instance;
    }
  };

}).call(this);

},{"../serialize/readexportedvalue":"serialize/readexportedvalue","extensions/csv":"extensions/csv"}],"extensions/nlmap":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var SingleObjectExtensionPorter, dumpMap, exceptions, exportMap, extensionName, formatMap, importMap, isMap, keyBlacklist, keyBlacklistError, newMap, readMap, toMap,
    indexOf = [].indexOf,
    hasProp = {}.hasOwnProperty;

  SingleObjectExtensionPorter = require('../engine/core/world/singleobjectextensionporter');

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  // (Any) => Boolean
  isMap = function(x) {
    return x._type === "nl_map";
  };

  // type NLMap = Object[Any]

  // ((NLMap) => String) => NLMap
  newMap = function() {
    var out;
    out = {};
    return toMap(out);
  };

  // (POJO, (NLMap) => String) => NLMap
  toMap = function(obj) {
    Object.defineProperty(obj, "_type", {
      enumerable: false,
      value: "nl_map",
      writable: false
    });
    return obj;
  };

  extensionName = "nlmap";

  dumpMap = function(x, dumpValue) {
    var values;
    values = Object.keys(x).map((key) => {
      return `[\"${key}\" ${dumpValue(x[key], true)}]`;
    }).join(' ');
    return ` ${values}`;
  };

  exportMap = function(x, exportValue) {
    var out;
    out = {};
    Object.keys(x).map(function(k) {
      return out[k] = exportValue(x[k]);
    });
    return toMap(out);
  };

  formatMap = function(exportedObj, formatAny) {
    return Object.keys(exportedObj.data).map((key) => {
      return `[\"${key}\" ${formatAny(x[key])}]`;
    }).join(' ');
  };

  readMap = function(x, parseAny) {
    var i, k, len, list, out, v;
    out = {};
    list = parseAny(`[${x}]`);
    for (i = 0, len = list.length; i < len; i++) {
      [k, v] = list[i];
      out[k] = v;
    }
    return out;
  };

  importMap = function(exportedObj, reify) {
    var out;
    out = {};
    Object.keys(exportedObj.data).map(function(k) {
      return out[k] = reify(exportedObj.data[k]);
    });
    return toMap(out);
  };

  // Array[String]
  keyBlacklist = ["__defineGetter__", "__defineSetter__", "__lookupGetter__", "__lookupSetter__", "__proto__", "constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];

  // (String) => String
  keyBlacklistError = function(key) {
    var str;
    str = `\"${key}\" is a protected key and cannot be accessed.  Try using a different key.`;
    return exceptions.extension(str);
  };

  module.exports = {
    porter: new SingleObjectExtensionPorter(extensionName, isMap, dumpMap, exportMap, formatMap, readMap, importMap),
    init: function(workspace) {
      var add, fromList, get, jsonToMap, mapToJson, mapToUrlEncoded, remove, toList;
      // List[(String, Any)] => NLMap
      fromList = function(list) {
        var i, k, len, out, v;
        out = newMap();
        for (i = 0, len = list.length; i < len; i++) {
          [k, v] = list[i];
          if (indexOf.call(keyBlacklist, k) >= 0) {
            throw keyBlacklistError(k);
          } else {
            out[k] = v;
          }
        }
        return out;
      };
      // (NLMap) => List[(String, Any)]
      toList = function(nlMap) {
        var k, results;
        results = [];
        for (k in nlMap) {
          results.push([k, nlMap[k]]);
        }
        return results;
      };
      // (NLMap, String, Any) -> NLMap
      add = function(nlMap, key, value) {
        var k, out;
        if (indexOf.call(keyBlacklist, key) >= 0) {
          throw keyBlacklistError(key);
        } else {
          out = newMap();
          for (k in nlMap) {
            out[k] = nlMap[k];
          }
          out[key] = value;
          return out;
        }
      };
      // (NLMap, String) => Any
      get = function(nlMap, key) {
        if (indexOf.call(keyBlacklist, key) >= 0) {
          throw keyBlacklistError(key);
        } else if (nlMap[key] == null) {
          throw exceptions.extension(`${key} does not exist in this map`);
        } else {
          return nlMap[key];
        }
      };
      // (NLMap, String) => NLMap
      remove = function(nlMap, key) {
        var k, out;
        if (indexOf.call(keyBlacklist, key) >= 0) {
          throw keyBlacklistError(key);
        } else {
          out = newMap();
          for (k in nlMap) {
            if (k !== key) {
              out[k] = nlMap[k];
            }
          }
          return out;
        }
      };
      // NLMap => String
      mapToJson = function(nlMap) {
        if (nlMap._type !== "nl_map") {
          throw exceptions.extension("Only nlmap type values can be converted to JSON format.");
        }
        return JSON.stringify(nlMap);
      };
      // NLMap => String
      mapToUrlEncoded = function(nlMap) {
        var key, kvps, value;
        if (nlMap._type !== "nl_map") {
          throw exceptions.extension("Only nlmap type values can be converted to URL format.");
        } else {
          kvps = [];
          for (key in nlMap) {
            if (!hasProp.call(nlMap, key)) continue;
            value = nlMap[key];
            if (typeof value !== 'object') {
              kvps.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
            }
          }
          return kvps.join('&');
        }
      };
      // String => NLMap
      jsonToMap = function(json) {
        return JSON.parse(json, function(key, value) {
          if (indexOf.call(keyBlacklist, key) >= 0) {
            throw keyBlacklistError(key);
          } else if (typeof value === 'object') {
            return toMap(value);
          } else {
            return value;
          }
        });
      };
      return {
        name: extensionName,
        prims: {
          "FROM-LIST": fromList,
          "TO-LIST": toList,
          "IS-MAP?": isMap,
          "ADD": add,
          "GET": get,
          "REMOVE": remove,
          "TO-JSON": mapToJson,
          "TO-URLENC": mapToUrlEncoded,
          "FROM-JSON": jsonToMap
        }
      };
    }
  };

}).call(this);

},{"../engine/core/world/singleobjectextensionporter":"engine/core/world/singleobjectextensionporter","util/exception":"util/exception"}],"extensions/nt":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  module.exports = {
    init: function(workspace) {
      var get, ntStore, set;
      ntStore = {};
      get = function(key) {
        if (ntStore.hasOwnProperty(key)) {
          return ntStore[key];
        } else {
          return "";
        }
      };
      set = function(key, value) {
        ntStore[key] = value;
      };
      return {
        name: "nt",
        prims: {
          "GET": get,
          "SET": set
        }
      };
    }
  };

}).call(this);

},{}],"extensions/palette-color-schemes":[function(require,module,exports){
(function() {
  var ColorSchemes, Divergent, Qualitative, Sequential, exceptions;

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ColorSchemes = class ColorSchemes {
    static getRGBArray(schemeName, legendName, legendSize) {
      var colorLegend, colorScheme, e, fields, i, j, ref, selectedClass;
      if (arguments.length === 1) {
        colorScheme = [[[[]]]];
        if (schemeName === "Sequential") {
          selectedClass = Sequential.class;
        } else if (schemeName === "Divergent") {
          selectedClass = Divergent.class;
        } else if (schemeName === "Qualitative") {
          selectedClass = Qualitative.class;
        } else {
          throw exceptions.extension("1 Your Scheme Type name was " + schemeName + " your argument can only be : Sequential, Divergent or Qualitative");
        }
        try {
          fields = selectedClass.getDeclaredFields();
          for (i = j = 0, ref = fields.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
            colorScheme[i] = fields[i].get(null);
          }
        } catch (error) {
          e = error;
          throw exceptions.extension("the currently executing method does not have access to the definition of the specified field");
        }
        return colorScheme;
      } else if (arguments.length === 2) {
        colorScheme = [[[], []], [[], []]];
        if (schemeName === "Sequential") {
          try {
            colorScheme = Sequential.getScheme(legendName);
          } catch (error) {
            e = error;
            throw exceptions.extension(e);
          }
        } else if (schemeName === "Divergent") {
          try {
            colorScheme = Divergent.getScheme(legendName);
          } catch (error) {
            e = error;
            throw exceptions.extension(e);
          }
        } else if (schemeName === "Qualitative") {
          try {
            colorScheme = Qualitative.getScheme(legendName);
          } catch (error) {
            e = error;
            throw exceptions.extension(e);
          }
        } else {
          extension.exception("1 Your Scheme Type name was " + schemeName + " your argument can only be: Sequential, Divergent or Qualitative.");
        }
        return colorScheme;
      } else if (arguments.length === 3) {
        colorScheme = [[[], []], [[], []]];
        colorLegend = [[], []];
        if (legendSize < 3) {
          throw exceptions.extension("The minimum size of a color class is 3, but your third argument is " + legendSize);
        }
        colorScheme = ColorSchemes.getRGBArray(schemeName, legendName);
        i = 0;
        while (i < colorScheme.length && (colorScheme[i].length !== legendSize)) {
          i++;
        }
        if (i === colorScheme.length) {
          throw exceptions.extension(legendName + " has a maximum of " + i + " colors, but you have requested " + legendSize);
        }
        if (i < colorScheme.length) {
          colorLegend = [[], []];
          return colorLegend = colorScheme[i];
        } else {
          return colorLegend = null;
        }
      }
    }

    static getColorArray(schemeTypeName, colorSchemeName, colorSchemeSize) {
      var chosenColorLegend, colorArray, i, j, ref;
      chosenColorLegend = [];
      colorArray = [[], []];
      colorArray = getRGBArray(schemeTypeName, colorSchemeName, colorSchemeSize);
      if (colorSchemeSize < 3) {
        throw exceptions.extension("The minimum size of a color class is 3, but your third argument is " + colorSchemeSize);
      }
      for (i = j = 0, ref = colorArray.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        chosenColorLegend[i] = [colorArray[i][0], colorArray[i][1], colorArray[i][2]];
      }
      return chosenColorLegend;
    }

    static getIntArray(schemeTypeName, colorSchemeName, colorSchemeSize) {
      var colorArray, colorInt, i, j, ref;
      if (colorSchemeSize < 3) {
        throw exceptions.extension("The minimum size of a color class is 3, but your third argument is " + colorSchemeSize);
      }
      colorInt = [];
      colorArray = getRGBArray(schemeTypeName, colorSchemeName, colorSchemeSize);
      for (i = j = 0, ref = colorArray.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        colorInt[i] = (colorArray[i][0] << 16) | (colorArray[i][1] << 8) | colorArray[i][2];
      }
      return colorInt;
    }

    static getMaximumLegendSize(schemeType) {
      var colorschemes, i, j, max, ref;
      colorschemes = getRGBArray(schemeType);
      max = 0;
      for (i = j = 0, ref = colorschemes.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        max = Math.max(colorschemes[i].length, max);
      }
      return max + 2;
    }

  };

  Divergent = (function() {
    var BrBG, PRGn, PiYG, PuOr, RdBu, RdGy, RdYlBu, RdYlGn, Spectral;

    class Divergent extends ColorSchemes {
      static getScheme(legendName) {
        if (legendName === "PuOr") {
          return PuOr;
        } else if (legendName === "Spectral") {
          return Spectral;
        } else if (legendName === "RdYlBu") {
          return RdYlBu;
        } else if (legendName === "RdBu") {
          return RdBu;
        } else if (legendName === "RdGy") {
          return RdGy;
        } else if (legendName === "RdYlGn") {
          return RdYlGn;
        } else if (legendName === "PRGn") {
          return PRGn;
        } else if (legendName === "PiYG") {
          return PiYG;
        } else if (legendName === "BrBG") {
          return BrBG;
        }
      }

    };

    PuOr = [[[241, 163, 64], [247, 247, 247], [153, 142, 195]], [[230, 97, 1], [253, 184, 99], [178, 171, 210], [94, 60, 153]], [[230, 97, 1], [253, 184, 99], [247, 247, 247], [178, 171, 210], [94, 60, 153]], [[179, 88, 6], [241, 163, 64], [254, 224, 182], [216, 218, 235], [153, 142, 195], [84, 39, 136]], [[179, 88, 6], [241, 163, 64], [254, 224, 182], [247, 247, 247], [216, 218, 235], [153, 142, 195], [84, 39, 136]], [[179, 88, 6], [224, 130, 20], [253, 184, 99], [254, 224, 182], [216, 218, 235], [178, 171, 210], [128, 115, 172], [84, 39, 136]], [[179, 88, 6], [224, 130, 20], [253, 184, 99], [254, 224, 182], [247, 247, 247], [216, 218, 235], [178, 171, 210], [128, 115, 172], [84, 39, 136]], [[127, 59, 8], [179, 88, 6], [224, 130, 20], [253, 184, 99], [254, 224, 182], [216, 218, 235], [178, 171, 210], [128, 115, 172], [84, 39, 136], [45, 0, 75]], [[127, 59, 8], [179, 88, 6], [224, 130, 20], [253, 184, 99], [254, 224, 182], [247, 247, 247], [216, 218, 235], [178, 171, 210], [128, 115, 172], [84, 39, 136], [45, 0, 75]]];

    Spectral = [[[252, 141, 89], [255, 255, 191], [153, 213, 148]], [[215, 25, 28], [253, 174, 97], [171, 221, 164], [43, 131, 186]], [[215, 25, 28], [253, 174, 97], [255, 255, 191], [171, 221, 164], [43, 131, 186]], [[213, 62, 79], [252, 141, 89], [254, 224, 139], [230, 245, 152], [153, 213, 148], [50, 136, 189]], [[213, 62, 79], [252, 141, 89], [254, 224, 139], [255, 255, 191], [230, 245, 152], [153, 213, 148], [50, 136, 189]], [[213, 62, 79], [244, 109, 67], [253, 174, 97], [254, 224, 139], [230, 245, 152], [171, 221, 164], [102, 194, 165], [50, 136, 189]], [[213, 62, 79], [244, 109, 67], [253, 174, 97], [254, 224, 139], [255, 255, 191], [230, 245, 152], [171, 221, 164], [102, 194, 165], [50, 136, 189]], [[158, 1, 66], [213, 62, 79], [244, 109, 67], [253, 174, 97], [254, 224, 139], [230, 245, 152], [171, 221, 164], [102, 194, 165], [50, 136, 189], [94, 79, 162]], [[158, 1, 66], [213, 62, 79], [244, 109, 67], [253, 174, 97], [254, 224, 139], [255, 255, 191], [230, 245, 152], [171, 221, 164], [102, 194, 165], [50, 136, 189], [94, 79, 162]]];

    RdYlBu = [[[252, 141, 89], [255, 255, 191], [145, 191, 219]], [[215, 25, 28], [253, 174, 97], [171, 217, 233], [44, 123, 182]], [[215, 25, 28], [253, 174, 97], [255, 255, 191], [171, 217, 233], [44, 123, 182]], [[215, 48, 39], [252, 141, 89], [254, 224, 144], [224, 243, 248], [145, 191, 219], [69, 117, 180]], [[215, 48, 39], [252, 141, 89], [254, 224, 144], [255, 255, 191], [224, 243, 248], [145, 191, 219], [69, 117, 180]], [[215, 48, 39], [244, 109, 67], [253, 174, 97], [254, 224, 144], [224, 243, 248], [171, 217, 233], [116, 173, 209], [69, 117, 180]], [[215, 48, 39], [244, 109, 67], [253, 174, 97], [254, 224, 144], [255, 255, 191], [224, 243, 248], [171, 217, 233], [116, 173, 209], [69, 117, 180]], [[165, 0, 38], [215, 48, 39], [244, 109, 67], [253, 174, 97], [254, 224, 144], [224, 243, 248], [171, 217, 233], [116, 173, 209], [69, 117, 180], [49, 54, 149]], [[165, 0, 38], [215, 48, 39], [244, 109, 67], [253, 174, 97], [254, 224, 144], [255, 255, 191], [224, 243, 248], [171, 217, 233], [116, 173, 209], [69, 117, 180], [49, 54, 149]]];

    RdBu = [[[239, 138, 98], [247, 247, 247], [103, 169, 207]], [[202, 0, 32], [244, 165, 130], [146, 197, 222], [5, 113, 176]], [[202, 0, 32], [244, 165, 130], [247, 247, 247], [146, 197, 222], [5, 113, 176]], [[178, 24, 43], [239, 138, 98], [253, 219, 199], [209, 229, 240], [103, 169, 207], [33, 102, 172]], [[178, 24, 43], [239, 138, 98], [253, 219, 199], [247, 247, 247], [209, 229, 240], [103, 169, 207], [33, 102, 172]], [[178, 24, 43], [214, 96, 77], [244, 165, 130], [253, 219, 199], [209, 229, 240], [146, 197, 222], [67, 147, 195], [33, 102, 172]], [[178, 24, 43], [214, 96, 77], [244, 165, 130], [253, 219, 199], [247, 247, 247], [209, 229, 240], [146, 197, 222], [67, 147, 195], [33, 102, 172]], [[103, 0, 31], [178, 24, 43], [214, 96, 77], [244, 165, 130], [253, 219, 199], [209, 229, 240], [146, 197, 222], [67, 147, 195], [33, 102, 172], [5, 48, 97]], [[103, 0, 31], [178, 24, 43], [214, 96, 77], [244, 165, 130], [253, 219, 199], [247, 247, 247], [209, 229, 240], [146, 197, 222], [67, 147, 195], [33, 102, 172], [5, 48, 97]]];

    RdGy = [[[239, 138, 98], [255, 255, 255], [153, 153, 153]], [[202, 0, 32], [244, 165, 130], [186, 186, 186], [64, 64, 64]], [[202, 0, 32], [244, 165, 130], [255, 255, 255], [186, 186, 186], [64, 64, 64]], [[178, 24, 43], [239, 138, 98], [253, 219, 199], [224, 224, 224], [153, 153, 153], [77, 77, 77]], [[178, 24, 43], [239, 138, 98], [253, 219, 199], [255, 255, 255], [224, 224, 224], [153, 153, 153], [77, 77, 77]], [[178, 24, 43], [214, 96, 77], [244, 165, 130], [253, 219, 199], [224, 224, 224], [186, 186, 186], [135, 135, 135], [77, 77, 77]], [[178, 24, 43], [214, 96, 77], [244, 165, 130], [253, 219, 199], [255, 255, 255], [224, 224, 224], [186, 186, 186], [135, 135, 135], [77, 77, 77]], [[103, 0, 31], [178, 24, 43], [214, 96, 77], [244, 165, 130], [253, 219, 199], [224, 224, 224], [186, 186, 186], [135, 135, 135], [77, 77, 77], [26, 26, 26]], [[103, 0, 31], [178, 24, 43], [214, 96, 77], [244, 165, 130], [253, 219, 199], [255, 255, 255], [224, 224, 224], [186, 186, 186], [135, 135, 135], [77, 77, 77], [26, 26, 26]]];

    RdYlGn = [[[252, 141, 89], [255, 255, 191], [145, 207, 96]], [[215, 25, 28], [253, 174, 97], [166, 217, 106], [26, 150, 65]], [[215, 25, 28], [253, 174, 97], [255, 255, 191], [166, 217, 106], [26, 150, 65]], [[215, 48, 39], [252, 141, 89], [254, 224, 139], [217, 239, 139], [145, 207, 96], [26, 152, 80]], [[215, 48, 39], [252, 141, 89], [254, 224, 139], [255, 255, 191], [217, 239, 139], [145, 207, 96], [26, 152, 80]], [[215, 48, 39], [244, 109, 67], [253, 174, 97], [254, 224, 139], [217, 239, 139], [166, 217, 106], [102, 189, 99], [26, 152, 80]], [[215, 48, 39], [244, 109, 67], [253, 174, 97], [254, 224, 139], [255, 255, 191], [217, 239, 139], [166, 217, 106], [102, 189, 99], [26, 152, 80]], [[165, 0, 38], [215, 48, 39], [244, 109, 67], [253, 174, 97], [254, 224, 139], [217, 239, 139], [166, 217, 106], [102, 189, 99], [26, 152, 80], [0, 104, 55]], [[165, 0, 38], [215, 48, 39], [244, 109, 67], [253, 174, 97], [254, 224, 139], [255, 255, 191], [217, 239, 139], [166, 217, 106], [102, 189, 99], [26, 152, 80], [0, 104, 55]]];

    PRGn = [[[175, 141, 195], [247, 247, 247], [127, 191, 123]], [[123, 50, 148], [194, 165, 207], [166, 219, 160], [0, 136, 55]], [[123, 50, 148], [194, 165, 207], [247, 247, 247], [166, 219, 160], [0, 136, 55]], [[118, 42, 131], [175, 141, 195], [231, 212, 232], [217, 240, 211], [127, 191, 123], [27, 120, 55]], [[118, 42, 131], [175, 141, 195], [231, 212, 232], [247, 247, 247], [217, 240, 211], [127, 191, 123], [27, 120, 55]], [[118, 42, 131], [153, 112, 171], [194, 165, 207], [231, 212, 232], [217, 240, 211], [166, 219, 160], [90, 174, 97], [27, 120, 55]], [[118, 42, 131], [153, 112, 171], [194, 165, 207], [231, 212, 232], [247, 247, 247], [217, 240, 211], [166, 219, 160], [90, 174, 97], [27, 120, 55]], [[64, 0, 75], [118, 42, 131], [153, 112, 171], [194, 165, 207], [231, 212, 232], [217, 240, 211], [166, 219, 160], [90, 174, 97], [27, 120, 55], [0, 68, 27]], [[64, 0, 75], [118, 42, 131], [153, 112, 171], [194, 165, 207], [231, 212, 232], [247, 247, 247], [217, 240, 211], [166, 219, 160], [90, 174, 97], [27, 120, 55], [0, 68, 27]]];

    PiYG = [[[233, 163, 201], [247, 247, 247], [161, 215, 106]], [[208, 28, 139], [241, 182, 218], [184, 225, 134], [77, 172, 38]], [[208, 28, 139], [241, 182, 218], [247, 247, 247], [184, 225, 134], [77, 172, 38]], [[197, 27, 125], [233, 163, 201], [253, 224, 239], [230, 245, 208], [161, 215, 106], [77, 146, 33]], [[197, 27, 125], [233, 163, 201], [253, 224, 239], [247, 247, 247], [230, 245, 208], [161, 215, 106], [77, 146, 33]], [[197, 27, 125], [222, 119, 174], [241, 182, 218], [253, 224, 239], [230, 245, 208], [184, 225, 134], [127, 188, 65], [77, 146, 33]], [[197, 27, 125], [222, 119, 174], [241, 182, 218], [253, 224, 239], [247, 247, 247], [230, 245, 208], [184, 225, 134], [127, 188, 65], [77, 146, 33]], [[142, 1, 82], [197, 27, 125], [222, 119, 174], [241, 182, 218], [253, 224, 239], [230, 245, 208], [184, 225, 134], [127, 188, 65], [77, 146, 33], [39, 100, 25]], [[142, 1, 82], [197, 27, 125], [222, 119, 174], [241, 182, 218], [253, 224, 239], [247, 247, 247], [230, 245, 208], [184, 225, 134], [127, 188, 65], [77, 146, 33], [39, 100, 25]]];

    BrBG = [[[216, 179, 101], [245, 245, 245], [90, 180, 172]], [[166, 97, 26], [223, 194, 125], [128, 205, 193], [1, 133, 113]], [[166, 97, 26], [223, 194, 125], [245, 245, 245], [128, 205, 193], [1, 133, 113]], [[140, 81, 10], [216, 179, 101], [246, 232, 195], [199, 234, 229], [90, 180, 172], [1, 102, 94]], [[140, 81, 10], [216, 179, 101], [246, 232, 195], [245, 245, 245], [199, 234, 229], [90, 180, 172], [1, 102, 94]], [[140, 81, 10], [191, 129, 45], [223, 194, 125], [246, 232, 195], [199, 234, 229], [128, 205, 193], [53, 151, 143], [1, 102, 94]], [[140, 81, 10], [191, 129, 45], [223, 194, 125], [246, 232, 195], [245, 245, 245], [199, 234, 229], [128, 205, 193], [53, 151, 143], [1, 102, 94]], [[84, 48, 5], [140, 81, 10], [191, 129, 45], [223, 194, 125], [246, 232, 195], [199, 234, 229], [128, 205, 193], [53, 151, 143], [1, 102, 94], [0, 60, 48]], [[84, 48, 5], [140, 81, 10], [191, 129, 45], [223, 194, 125], [246, 232, 195], [245, 245, 245], [199, 234, 229], [128, 205, 193], [53, 151, 143], [1, 102, 94], [0, 60, 48]]];

    return Divergent;

  }).call(this);

  Qualitative = (function() {
    var Accent, Dark2, Paired, Pastel1, Pastel2, Set1, Set2, Set3;

    class Qualitative extends ColorSchemes {
      static getScheme(legendName) {
        if (legendName === "Accent") {
          return Accent;
        } else if (legendName === "Dark2") {
          return Dark2;
        } else if (legendName === "Paired") {
          return Paired;
        } else if (legendName === "Pastel1") {
          return Pastel1;
        } else if (legendName === "Pastel2") {
          return Pastel2;
        } else if (legendName === "Set1") {
          return Set1;
        } else if (legendName === "Set2") {
          return Set2;
        } else if (legendName === "Set3") {
          return Set3;
        }
      }

    };

    Accent = [[[127, 201, 127], [190, 174, 212], [253, 192, 134]], [[127, 201, 127], [190, 174, 212], [253, 192, 134], [255, 255, 153]], [[127, 201, 127], [190, 174, 212], [253, 192, 134], [255, 255, 153], [56, 108, 176]], [[127, 201, 127], [190, 174, 212], [253, 192, 134], [255, 255, 153], [56, 108, 176], [240, 2, 127]], [[127, 201, 127], [190, 174, 212], [253, 192, 134], [255, 255, 153], [56, 108, 176], [240, 2, 127], [191, 91, 23]], [[127, 201, 127], [190, 174, 212], [253, 192, 134], [255, 255, 153], [56, 108, 176], [240, 2, 127], [191, 91, 23], [102, 102, 102]]];

    Dark2 = [[[27, 158, 119], [217, 95, 2], [117, 112, 179]], [[27, 158, 119], [217, 95, 2], [117, 112, 179], [231, 41, 138]], [[27, 158, 119], [217, 95, 2], [117, 112, 179], [231, 41, 138], [102, 166, 30]], [[27, 158, 119], [217, 95, 2], [117, 112, 179], [231, 41, 138], [102, 166, 30], [230, 171, 2]], [[27, 158, 119], [217, 95, 2], [117, 112, 179], [231, 41, 138], [102, 166, 30], [230, 171, 2], [166, 118, 29]], [[27, 158, 119], [217, 95, 2], [117, 112, 179], [231, 41, 138], [102, 166, 30], [230, 171, 2], [166, 118, 29], [102, 102, 102]]];

    Paired = [[[166, 206, 227], [31, 120, 180], [178, 223, 138]], [[166, 206, 227], [31, 120, 180], [178, 223, 138], [51, 160, 44]], [[166, 206, 227], [31, 120, 180], [178, 223, 138], [51, 160, 44], [251, 154, 153]], [[166, 206, 227], [31, 120, 180], [178, 223, 138], [51, 160, 44], [251, 154, 153], [227, 26, 28]], [[166, 206, 227], [31, 120, 180], [178, 223, 138], [51, 160, 44], [251, 154, 153], [227, 26, 28], [253, 191, 111]], [[166, 206, 227], [31, 120, 180], [178, 223, 138], [51, 160, 44], [251, 154, 153], [227, 26, 28], [253, 191, 111], [255, 127, 0]], [[166, 206, 227], [31, 120, 180], [178, 223, 138], [51, 160, 44], [251, 154, 153], [227, 26, 28], [253, 191, 111], [255, 127, 0], [202, 178, 214]], [[166, 206, 227], [31, 120, 180], [178, 223, 138], [51, 160, 44], [251, 154, 153], [227, 26, 28], [253, 191, 111], [255, 127, 0], [202, 178, 214], [106, 61, 154]], [[166, 206, 227], [31, 120, 180], [178, 223, 138], [51, 160, 44], [251, 154, 153], [227, 26, 28], [253, 191, 111], [255, 127, 0], [202, 178, 214], [106, 61, 154], [255, 255, 153]], [[166, 206, 227], [31, 120, 180], [178, 223, 138], [51, 160, 44], [251, 154, 153], [227, 26, 28], [253, 191, 111], [255, 127, 0], [202, 178, 214], [106, 61, 154], [255, 255, 153], [177, 89, 40]]];

    Pastel1 = [[[251, 180, 174], [179, 205, 227], [204, 235, 197]], [[251, 180, 174], [179, 205, 227], [204, 235, 197], [222, 203, 228]], [[251, 180, 174], [179, 205, 227], [204, 235, 197], [222, 203, 228], [254, 217, 166]], [[251, 180, 174], [179, 205, 227], [204, 235, 197], [222, 203, 228], [254, 217, 166], [255, 255, 204]], [[251, 180, 174], [179, 205, 227], [204, 235, 197], [222, 203, 228], [254, 217, 166], [255, 255, 204], [229, 216, 189]], [[251, 180, 174], [179, 205, 227], [204, 235, 197], [222, 203, 228], [254, 217, 166], [255, 255, 204], [229, 216, 189], [253, 218, 236]], [[251, 180, 174], [179, 205, 227], [204, 235, 197], [222, 203, 228], [254, 217, 166], [255, 255, 204], [229, 216, 189], [253, 218, 236], [242, 242, 242]]];

    Pastel2 = [[[179, 226, 205], [253, 205, 172], [203, 213, 232]], [[179, 226, 205], [253, 205, 172], [203, 213, 232], [244, 202, 228]], [[179, 226, 205], [253, 205, 172], [203, 213, 232], [244, 202, 228], [230, 245, 201]], [[179, 226, 205], [253, 205, 172], [203, 213, 232], [244, 202, 228], [230, 245, 201], [255, 242, 174]], [[179, 226, 205], [253, 205, 172], [203, 213, 232], [244, 202, 228], [230, 245, 201], [255, 242, 174], [241, 226, 204]], [[179, 226, 205], [253, 205, 172], [203, 213, 232], [244, 202, 228], [230, 245, 201], [255, 242, 174], [241, 226, 204], [204, 204, 204]]];

    Set1 = [[[228, 26, 28], [55, 126, 184], [77, 175, 74]], [[228, 26, 28], [55, 126, 184], [77, 175, 74], [152, 78, 163]], [[228, 26, 28], [55, 126, 184], [77, 175, 74], [152, 78, 163], [255, 127, 0]], [[228, 26, 28], [55, 126, 184], [77, 175, 74], [152, 78, 163], [255, 127, 0], [255, 255, 51]], [[228, 26, 28], [55, 126, 184], [77, 175, 74], [152, 78, 163], [255, 127, 0], [255, 255, 51], [166, 86, 40]], [[228, 26, 28], [55, 126, 184], [77, 175, 74], [152, 78, 163], [255, 127, 0], [255, 255, 51], [166, 86, 40], [247, 129, 191]], [[228, 26, 28], [55, 126, 184], [77, 175, 74], [152, 78, 163], [255, 127, 0], [255, 255, 51], [166, 86, 40], [247, 129, 191], [153, 153, 153]]];

    Set2 = [[[102, 194, 165], [252, 141, 98], [141, 160, 203]], [[102, 194, 165], [252, 141, 98], [141, 160, 203], [231, 138, 195]], [[102, 194, 165], [252, 141, 98], [141, 160, 203], [231, 138, 195], [166, 216, 84]], [[102, 194, 165], [252, 141, 98], [141, 160, 203], [231, 138, 195], [166, 216, 84], [255, 217, 47]], [[102, 194, 165], [252, 141, 98], [141, 160, 203], [231, 138, 195], [166, 216, 84], [255, 217, 47], [229, 196, 148]], [[102, 194, 165], [252, 141, 98], [141, 160, 203], [231, 138, 195], [166, 216, 84], [255, 217, 47], [229, 196, 148], [179, 179, 179]]];

    Set3 = [[[141, 211, 199], [255, 255, 179], [190, 186, 218]], [[141, 211, 199], [255, 255, 179], [190, 186, 218], [251, 128, 114]], [[141, 211, 199], [255, 255, 179], [190, 186, 218], [251, 128, 114], [128, 177, 211]], [[141, 211, 199], [255, 255, 179], [190, 186, 218], [251, 128, 114], [128, 177, 211], [253, 180, 98]], [[141, 211, 199], [255, 255, 179], [190, 186, 218], [251, 128, 114], [128, 177, 211], [253, 180, 98], [179, 222, 105]], [[141, 211, 199], [255, 255, 179], [190, 186, 218], [251, 128, 114], [128, 177, 211], [253, 180, 98], [179, 222, 105], [252, 205, 229]], [[141, 211, 199], [255, 255, 179], [190, 186, 218], [251, 128, 114], [128, 177, 211], [253, 180, 98], [179, 222, 105], [252, 205, 229], [217, 217, 217]], [[141, 211, 199], [255, 255, 179], [190, 186, 218], [251, 128, 114], [128, 177, 211], [253, 180, 98], [179, 222, 105], [252, 205, 229], [217, 217, 217], [188, 128, 189]], [[141, 211, 199], [255, 255, 179], [190, 186, 218], [251, 128, 114], [128, 177, 211], [253, 180, 98], [179, 222, 105], [252, 205, 229], [217, 217, 217], [188, 128, 189], [204, 235, 197]], [[141, 211, 199], [255, 255, 179], [190, 186, 218], [251, 128, 114], [128, 177, 211], [253, 180, 98], [179, 222, 105], [252, 205, 229], [217, 217, 217], [188, 128, 189], [204, 235, 197], [255, 237, 111]]];

    return Qualitative;

  }).call(this);

  Sequential = (function() {
    var Blues, BuGn, BuPu, GnBu, Greens, Greys, OrRd, Oranges, PuBu, PuBuGn, PuRd, Purples, RdPu, Reds, YlGn, YlGnBu, YlOrBr, YlOrRd;

    class Sequential extends ColorSchemes {
      static getScheme(legendName) {
        if (legendName === "YlOrBr") {
          return YlOrBr;
        } else if (legendName === "Oranges") {
          return Oranges;
        } else if (legendName === "Reds") {
          return Reds;
        } else if (legendName === "YlOrRd") {
          return YlOrRd;
        } else if (legendName === "OrRd") {
          return OrRd;
        } else if (legendName === "PuRd") {
          return PuRd;
        } else if (legendName === "RdPu") {
          return RdPu;
        } else if (legendName === "BuPu") {
          return BuPu;
        } else if (legendName === "Purples") {
          return Purples;
        } else if (legendName === "PuBu") {
          return PuBu;
        } else if (legendName === "Blues") {
          return Blues;
        } else if (legendName === "GnBu") {
          return GnBu;
        } else if (legendName === "YlGnBu") {
          return YlGnBu;
        } else if (legendName === "PuBuGn") {
          return PuGuGn;
        } else if (legendName === "Greens") {
          return Greens;
        } else if (legendName === "Greys") {
          return Greys;
        } else if (legendName === "YlGn") {
          return YlGn;
        }
      }

    };

    YlOrBr = [[[255, 247, 188], [254, 196, 79], [217, 95, 14]], [[255, 255, 212], [254, 217, 142], [254, 153, 41], [204, 76, 2]], [[255, 255, 212], [254, 217, 142], [254, 153, 41], [217, 95, 14], [153, 52, 4]], [[255, 255, 212], [254, 227, 145], [254, 196, 79], [254, 153, 41], [217, 95, 14], [153, 52, 4]], [[255, 255, 212], [254, 227, 145], [254, 196, 79], [254, 153, 41], [236, 112, 20], [204, 76, 2], [140, 45, 4]], [[255, 255, 229], [255, 247, 188], [254, 227, 145], [254, 196, 79], [254, 153, 41], [236, 112, 20], [204, 76, 2], [140, 45, 4]], [[255, 255, 229], [255, 247, 188], [254, 227, 145], [254, 196, 79], [254, 153, 41], [236, 112, 20], [204, 76, 2], [153, 52, 4], [102, 37, 6]]];

    Oranges = [[[254, 230, 206], [253, 174, 107], [230, 85, 13]], [[254, 237, 222], [253, 190, 133], [253, 141, 60], [217, 71, 1]], [[254, 237, 222], [253, 190, 133], [253, 141, 60], [230, 85, 13], [166, 54, 3]], [[254, 237, 222], [253, 208, 162], [253, 174, 107], [253, 141, 60], [230, 85, 13], [166, 54, 3]], [[254, 237, 222], [253, 208, 162], [253, 174, 107], [253, 141, 60], [241, 105, 19], [217, 72, 1], [140, 45, 4]], [[255, 245, 235], [254, 230, 206], [253, 208, 162], [253, 174, 107], [253, 141, 60], [241, 105, 19], [217, 72, 1], [140, 45, 4]], [[255, 245, 235], [254, 230, 206], [253, 208, 162], [253, 174, 107], [253, 141, 60], [241, 105, 19], [217, 72, 1], [166, 54, 3], [127, 39, 4]]];

    Reds = [[[254, 224, 210], [252, 146, 114], [222, 45, 38]], [[254, 229, 217], [252, 174, 145], [251, 106, 74], [203, 24, 29]], [[254, 229, 217], [252, 174, 145], [251, 106, 74], [222, 45, 38], [165, 15, 21]], [[254, 229, 217], [252, 187, 161], [252, 146, 114], [251, 106, 74], [222, 45, 38], [165, 15, 21]], [[254, 229, 217], [252, 187, 161], [252, 146, 114], [251, 106, 74], [239, 59, 44], [203, 24, 29], [153, 0, 13]], [[255, 245, 240], [254, 224, 210], [252, 187, 161], [252, 146, 114], [251, 106, 74], [239, 59, 44], [203, 24, 29], [153, 0, 13]], [[255, 245, 240], [254, 224, 210], [252, 187, 161], [252, 146, 114], [251, 106, 74], [239, 59, 44], [203, 24, 29], [165, 15, 21], [103, 0, 13]]];

    YlOrRd = [[[255, 237, 160], [254, 178, 76], [240, 59, 32]], [[255, 255, 178], [254, 204, 92], [253, 141, 60], [227, 26, 28]], [[255, 255, 178], [254, 204, 92], [253, 141, 60], [240, 59, 32], [189, 0, 38]], [[255, 255, 178], [254, 217, 118], [254, 178, 76], [253, 141, 60], [240, 59, 32], [189, 0, 38]], [[255, 255, 178], [254, 217, 118], [254, 178, 76], [253, 141, 60], [252, 78, 42], [227, 26, 28], [177, 0, 38]], [[255, 255, 204], [255, 237, 160], [254, 217, 118], [254, 178, 76], [253, 141, 60], [252, 78, 42], [227, 26, 28], [177, 0, 38]], [[255, 255, 204], [255, 237, 160], [254, 217, 118], [254, 178, 76], [253, 141, 60], [252, 78, 42], [227, 26, 28], [189, 0, 38], [128, 0, 38]]];

    OrRd = [[[254, 232, 200], [253, 187, 132], [227, 74, 51]], [[254, 240, 217], [253, 204, 138], [252, 141, 89], [215, 48, 31]], [[254, 240, 217], [253, 204, 138], [252, 141, 89], [227, 74, 51], [179, 0, 0]], [[254, 240, 217], [253, 212, 158], [253, 187, 132], [252, 141, 89], [227, 74, 51], [179, 0, 0]], [[254, 240, 217], [253, 212, 158], [253, 187, 132], [252, 141, 89], [239, 101, 72], [215, 48, 31], [153, 0, 0]], [[255, 247, 236], [254, 232, 200], [253, 212, 158], [253, 187, 132], [252, 141, 89], [239, 101, 72], [215, 48, 31], [153, 0, 0]], [[255, 247, 236], [254, 232, 200], [253, 212, 158], [253, 187, 132], [252, 141, 89], [239, 101, 72], [215, 48, 31], [179, 0, 0], [127, 0, 0]]];

    PuRd = [[[231, 225, 239], [201, 148, 199], [221, 28, 119]], [[241, 238, 246], [215, 181, 216], [223, 101, 176], [206, 18, 86]], [[241, 238, 246], [215, 181, 216], [223, 101, 176], [221, 28, 119], [152, 0, 67]], [[241, 238, 246], [212, 185, 218], [201, 148, 199], [223, 101, 176], [221, 28, 119], [152, 0, 67]], [[241, 238, 246], [212, 185, 218], [201, 148, 199], [223, 101, 176], [231, 41, 138], [206, 18, 86], [145, 0, 63]], [[247, 244, 249], [231, 225, 239], [212, 185, 218], [201, 148, 199], [223, 101, 176], [231, 41, 138], [206, 18, 86], [145, 0, 63]], [[247, 244, 249], [231, 225, 239], [212, 185, 218], [201, 148, 199], [223, 101, 176], [231, 41, 138], [206, 18, 86], [152, 0, 67], [103, 0, 31]]];

    RdPu = [[[253, 224, 221], [250, 159, 181], [197, 27, 138]], [[254, 235, 226], [251, 180, 185], [247, 104, 161], [174, 1, 126]], [[254, 235, 226], [251, 180, 185], [247, 104, 161], [197, 27, 138], [122, 1, 119]], [[254, 235, 226], [252, 197, 192], [250, 159, 181], [247, 104, 161], [197, 27, 138], [122, 1, 119]], [[254, 235, 226], [252, 197, 192], [250, 159, 181], [247, 104, 161], [221, 52, 151], [174, 1, 126], [122, 1, 119]], [[255, 247, 243], [253, 224, 221], [252, 197, 192], [250, 159, 181], [247, 104, 161], [221, 52, 151], [174, 1, 126], [122, 1, 119]], [[255, 247, 243], [253, 224, 221], [252, 197, 192], [250, 159, 181], [247, 104, 161], [221, 52, 151], [174, 1, 126], [122, 1, 119], [73, 0, 106]]];

    BuPu = [[[224, 236, 244], [158, 188, 218], [136, 86, 167]], [[237, 248, 251], [179, 205, 227], [140, 150, 198], [136, 65, 157]], [[237, 248, 251], [179, 205, 227], [140, 150, 198], [136, 86, 167], [129, 15, 124]], [[237, 248, 251], [191, 211, 230], [158, 188, 218], [140, 150, 198], [136, 86, 167], [129, 15, 124]], [[237, 248, 251], [191, 211, 230], [158, 188, 218], [140, 150, 198], [140, 107, 177], [136, 65, 157], [110, 1, 107]], [[247, 252, 253], [224, 236, 244], [191, 211, 230], [158, 188, 218], [140, 150, 198], [140, 107, 177], [136, 65, 157], [110, 1, 107]], [[247, 252, 253], [224, 236, 244], [191, 211, 230], [158, 188, 218], [140, 150, 198], [140, 107, 177], [136, 65, 157], [129, 15, 124], [77, 0, 75]]];

    Purples = [[[239, 237, 245], [188, 189, 220], [117, 107, 177]], [[242, 240, 247], [203, 201, 226], [158, 154, 200], [106, 81, 163]], [[242, 240, 247], [203, 201, 226], [158, 154, 200], [117, 107, 177], [84, 39, 143]], [[242, 240, 247], [218, 218, 235], [188, 189, 220], [158, 154, 200], [117, 107, 177], [84, 39, 143]], [[242, 240, 247], [218, 218, 235], [188, 189, 220], [158, 154, 200], [128, 125, 186], [106, 81, 163], [74, 20, 134]], [[252, 251, 253], [239, 237, 245], [218, 218, 235], [188, 189, 220], [158, 154, 200], [128, 125, 186], [106, 81, 163], [74, 20, 134]], [[252, 251, 253], [239, 237, 245], [218, 218, 235], [188, 189, 220], [158, 154, 200], [128, 125, 186], [106, 81, 163], [84, 39, 143], [63, 0, 125]]];

    PuBu = [[[236, 231, 242], [166, 189, 219], [43, 140, 190]], [[241, 238, 246], [189, 201, 225], [116, 169, 207], [5, 112, 176]], [[241, 238, 246], [189, 201, 225], [116, 169, 207], [43, 140, 190], [4, 90, 141]], [[241, 238, 246], [208, 209, 230], [166, 189, 219], [116, 169, 207], [43, 140, 190], [4, 90, 141]], [[241, 238, 246], [208, 209, 230], [166, 189, 219], [116, 169, 207], [54, 144, 192], [5, 112, 176], [3, 78, 123]], [[255, 247, 251], [236, 231, 242], [208, 209, 230], [166, 189, 219], [116, 169, 207], [54, 144, 192], [5, 112, 176], [3, 78, 123]], [[255, 247, 251], [236, 231, 242], [208, 209, 230], [166, 189, 219], [116, 169, 207], [54, 144, 192], [5, 112, 176], [4, 90, 141], [2, 56, 88]]];

    Blues = [[[222, 235, 247], [158, 202, 225], [49, 130, 189]], [[239, 243, 255], [189, 215, 231], [107, 174, 214], [33, 113, 181]], [[239, 243, 255], [189, 215, 231], [107, 174, 214], [49, 130, 189], [8, 81, 156]], [[239, 243, 255], [198, 219, 239], [158, 202, 225], [107, 174, 214], [49, 130, 189], [8, 81, 156]], [[239, 243, 255], [198, 219, 239], [158, 202, 225], [107, 174, 214], [66, 146, 198], [33, 113, 181], [8, 69, 148]], [[247, 251, 255], [222, 235, 247], [198, 219, 239], [158, 202, 225], [107, 174, 214], [66, 146, 198], [33, 113, 181], [8, 69, 148]], [[247, 251, 255], [222, 235, 247], [198, 219, 239], [158, 202, 225], [107, 174, 214], [66, 146, 198], [33, 113, 181], [8, 81, 156], [8, 48, 107]]];

    GnBu = [[[224, 243, 219], [168, 221, 181], [67, 162, 202]], [[240, 249, 232], [186, 228, 188], [123, 204, 196], [43, 140, 190]], [[240, 249, 232], [186, 228, 188], [123, 204, 196], [67, 162, 202], [8, 104, 172]], [[240, 249, 232], [204, 235, 197], [168, 221, 181], [123, 204, 196], [67, 162, 202], [8, 104, 172]], [[240, 249, 232], [204, 235, 197], [168, 221, 181], [123, 204, 196], [78, 179, 211], [43, 140, 190], [8, 88, 158]], [[247, 252, 240], [224, 243, 219], [204, 235, 197], [168, 221, 181], [123, 204, 196], [78, 179, 211], [43, 140, 190], [8, 88, 158]], [[247, 252, 240], [224, 243, 219], [204, 235, 197], [168, 221, 181], [123, 204, 196], [78, 179, 211], [43, 140, 190], [8, 104, 172], [8, 64, 129]]];

    YlGnBu = [[[237, 248, 177], [127, 205, 187], [44, 127, 184]], [[255, 255, 204], [161, 218, 180], [65, 182, 196], [34, 94, 168]], [[255, 255, 204], [161, 218, 180], [65, 182, 196], [44, 127, 184], [37, 52, 148]], [[255, 255, 204], [199, 233, 180], [127, 205, 187], [65, 182, 196], [44, 127, 184], [37, 52, 148]], [[255, 255, 204], [199, 233, 180], [127, 205, 187], [65, 182, 196], [29, 145, 192], [34, 94, 168], [12, 44, 132]], [[255, 255, 217], [237, 248, 177], [199, 233, 180], [127, 205, 187], [65, 182, 196], [29, 145, 192], [34, 94, 168], [12, 44, 132]], [[255, 255, 217], [237, 248, 177], [199, 233, 180], [127, 205, 187], [65, 182, 196], [29, 145, 192], [34, 94, 168], [37, 52, 148], [8, 29, 88]]];

    PuBuGn = [[[236, 226, 240], [166, 189, 219], [28, 144, 153]], [[246, 239, 247], [189, 201, 225], [103, 169, 207], [2, 129, 138]], [[246, 239, 247], [189, 201, 225], [103, 169, 207], [28, 144, 153], [1, 108, 89]], [[246, 239, 247], [208, 209, 230], [166, 189, 219], [103, 169, 207], [28, 144, 153], [1, 108, 89]], [[246, 239, 247], [208, 209, 230], [166, 189, 219], [103, 169, 207], [54, 144, 192], [2, 129, 138], [1, 100, 80]], [[255, 247, 251], [236, 226, 240], [208, 209, 230], [166, 189, 219], [103, 169, 207], [54, 144, 192], [2, 129, 138], [1, 100, 80]], [[255, 247, 251], [236, 226, 240], [208, 209, 230], [166, 189, 219], [103, 169, 207], [54, 144, 192], [2, 129, 138], [1, 108, 89], [1, 70, 54]]];

    BuGn = [[[229, 245, 249], [153, 216, 201], [44, 162, 95]], [[237, 248, 251], [178, 226, 226], [102, 194, 164], [35, 139, 69]], [[237, 248, 251], [178, 226, 226], [102, 194, 164], [44, 162, 95], [0, 109, 44]], [[237, 248, 251], [204, 236, 230], [153, 216, 201], [102, 194, 164], [44, 162, 95], [0, 109, 44]], [[237, 248, 251], [204, 236, 230], [153, 216, 201], [102, 194, 164], [65, 174, 118], [35, 139, 69], [0, 88, 36]], [[247, 252, 253], [229, 245, 249], [204, 236, 230], [153, 216, 201], [102, 194, 164], [65, 174, 118], [35, 139, 69], [0, 88, 36]], [[247, 252, 253], [229, 245, 249], [204, 236, 230], [153, 216, 201], [102, 194, 164], [65, 174, 118], [35, 139, 69], [0, 109, 44], [0, 68, 27]]];

    Greens = [[[229, 245, 224], [161, 217, 155], [49, 163, 84]], [[237, 248, 233], [186, 228, 179], [116, 196, 118], [35, 139, 69]], [[237, 248, 233], [186, 228, 179], [116, 196, 118], [49, 163, 84], [0, 109, 44]], [[237, 248, 233], [199, 233, 192], [161, 217, 155], [116, 196, 118], [49, 163, 84], [0, 109, 44]], [[237, 248, 233], [199, 233, 192], [161, 217, 155], [116, 196, 118], [65, 171, 93], [35, 139, 69], [0, 90, 50]], [[247, 252, 245], [229, 245, 224], [199, 233, 192], [161, 217, 155], [116, 196, 118], [65, 171, 93], [35, 139, 69], [0, 90, 50]], [[247, 252, 245], [229, 245, 224], [199, 233, 192], [161, 217, 155], [116, 196, 118], [65, 171, 93], [35, 139, 69], [0, 109, 44], [0, 68, 27]]];

    Greys = [[[240, 240, 240], [189, 189, 189], [99, 99, 99]], [[247, 247, 247], [204, 204, 204], [150, 150, 150], [82, 82, 82]], [[247, 247, 247], [204, 204, 204], [150, 150, 150], [99, 99, 99], [37, 37, 37]], [[247, 247, 247], [217, 217, 217], [189, 189, 189], [150, 150, 150], [99, 99, 99], [37, 37, 37]], [[247, 247, 247], [217, 217, 217], [189, 189, 189], [150, 150, 150], [115, 115, 115], [82, 82, 82], [37, 37, 37]], [[255, 255, 255], [240, 240, 240], [217, 217, 217], [189, 189, 189], [150, 150, 150], [115, 115, 115], [82, 82, 82], [37, 37, 37]], [[255, 255, 255], [240, 240, 240], [217, 217, 217], [189, 189, 189], [150, 150, 150], [115, 115, 115], [82, 82, 82], [37, 37, 37], [0, 0, 0]]];

    YlGn = [[[247, 252, 185], [173, 221, 142], [49, 163, 84]], [[255, 255, 204], [194, 230, 153], [120, 198, 121], [35, 132, 67]], [[255, 255, 204], [194, 230, 153], [120, 198, 121], [49, 163, 84], [0, 104, 55]], [[255, 255, 204], [217, 240, 163], [173, 221, 142], [120, 198, 121], [49, 163, 84], [0, 104, 55]], [[255, 255, 204], [217, 240, 163], [173, 221, 142], [120, 198, 121], [65, 171, 93], [35, 132, 67], [0, 90, 50]], [[255, 255, 229], [247, 252, 185], [217, 240, 163], [173, 221, 142], [120, 198, 121], [65, 171, 93], [35, 132, 67], [0, 90, 50]], [[255, 255, 229], [247, 252, 185], [217, 240, 163], [173, 221, 142], [120, 198, 121], [65, 171, 93], [35, 132, 67], [0, 104, 55], [0, 69, 41]]];

    return Sequential;

  }).call(this);

  module.exports = ColorSchemes;

  //Apache-Style Software License for ColorBrewer software and ColorBrewer Color Schemes
//Version 1.1

//Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The Pennsylvania State University. All rights reserved.
//Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
//1. Redistributions as source code must retain the above copyright notice, this list of conditions and the following disclaimer.
//2. The end-user documentation included with the redistribution, if any, must include the following acknowledgment:
//This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).
//Alternately, this acknowledgment may appear in the software itself, if and wherever such third-party acknowledgments normally appear.
//4. The name "ColorBrewer" must not be used to endorse or promote products derived from this software without prior written permission. For written permission, please
//contact Cynthia Brewer at cbrewer@psu.edu.
//5. Products derived from this software may not be called "ColorBrewer", nor may "ColorBrewer" appear in their name, without prior written permission of Cynthia Brewer.

//THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL CYNTHIA BREWER, MARK HARROWER, OR THE
//PENNSYLVANIA STATE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
//BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
//WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

}).call(this);

},{"util/exception":"util/exception"}],"extensions/palette":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Color, ColorSchemes, Patch, colorHSBArray, colorRGBArray, exceptions, extractHSB, extractRGB, getIndexGradient, getIndexScheme, hsbUpdated, isValidHSBList, isValidRGBList, modDouble, rgbUpdated, toColorList, validateHSB, validateRGB;

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  Color = require('../engine/core/colormodel');

  Patch = require('../engine/core/patch');

  ColorSchemes = require('./palette-color-schemes');

  // MAIN FUNCTIONS #

  //RGBList
  validateRGB = function(color) {
    if (!isValidRGBList(color)) {
      throw exceptions.extension("Color must have a valid RGB List.");
    }
  };

  isValidRGBList = function(color) {
    var valid;
    valid = true;
    color = toColorList(color);
    if (color.length < 3 || color.length > 4) {
      return false;
    }
    valid = color.every(function(component) {
      return typeof component === "number" && component >= 0 && component <= 255;
    });
    return valid;
  };

  extractRGB = function(color, index) {
    var newList;
    newList = toColorList(color);
    validateRGB(newList);
    return newList[index];
  };

  rgbUpdated = function(color, value, index) {
    var newList;
    color = toColorList(color);
    validateRGB(color);
    newList = color.slice();
    newList[index] = value;
    return newList;
  };

  //HSB
  validateHSB = function(color) {
    if (!isValidHSBList(color)) {
      throw exceptions.extension("Color must be a valid HSB list.");
    }
  };

  isValidHSBList = function(color) { // must be a list upon import
    var k, valid, x;
    valid = true;
    if (typeof color === "number") {
      throw exceptions.extension("Input must be an HSB list for scale-gradient-hsb.");
    }
    if (color.length === !3) {
      return false;
    }
    valid = color.every(function(component) {
      return typeof component === "number";
    });
    if (color[0] > 360 || color[0] < 0) {
      return false;
    }
    for (x = k = 1; k <= 2; x = ++k) {
      if (color[x] > 100 || color[x] < 0) {
        return false;
      }
    }
    return valid;
  };

  extractHSB = function(color, index) {
    var newList;
    newList = toColorList(color);
    validateRGB(newList);
    newList = Color.rgbToHSB(newList[0], newList[1], newList[2]);
    return newList[index];
  };

  hsbUpdated = function(color, value, index) {
    var alpha, newList, re_add, readd;
    newList = toColorList(color);
    validateRGB(newList);
    alpha = 255;
    re_add = false;
    if (newList.length === 4) {
      alpha = newList[3];
      readd = true;
    }
    newList = Color.rgbToHSB(newList[0], newList[1], newList[2]);
    newList[index] = value;
    newList = Color.hsbToRGB(newList[0], newList[1], newList[2]);
    if (readd === true) {
      newList[3] = alpha;
    }
    return newList;
  };

  //GRADIENTS AND COLOR SCHEMES
  //interestingly, the index calculation varies for scale gradient and scale schemes
  getIndexGradient = function(number, min, max, colorListLength, SIZE) {
    var index, perc;
    perc = 0;
    if (min > max) {
      if (number < max) {
        perc = 1;
      } else if (number > min) {
        perc = 0;
      } else {
        perc = (min - number) / (min - max);
      }
    } else {
      if (number > max) {
        perc = 1;
      } else if (number < min) {
        perc = 0;
      } else {
        if (max === min) {
          perc = 0;
        } else {
          perc = (number - min) / (max - min);
        }
      }
    }
    index = 0;
    if (colorListLength < 3) {
      return index = Math.floor(perc * (SIZE - 1));
    } else {
      return index = Math.floor(perc * ((SIZE - 1) + SIZE * (colorListLength - 2)));
    }
  };

  getIndexScheme = function(number, min, max, SIZE) {
    var index, perc;
    perc = 0;
    if (min > max) {
      if (number < max) {
        perc = SIZE - 1;
      } else if (number > min) {
        perc = 0;
      } else {
        perc = Math.floor((min - number) / ((min - max) / SIZE));
      }
    } else {
      if (number > max) {
        perc = SIZE - 1;
      } else if (number < min) {
        perc = 0;
      } else {
        if (max === min) {
          perc = 0;
        } else {
          perc = Math.floor((number - min) / ((max - min) / SIZE));
        }
      }
    }
    return index = Math.min(perc, SIZE - 1);
  };

  colorHSBArray = function(startColor, endColor, width) { // input colors in HSB form
    var gradientHSBarray, i, inc, j, k, l, ref;
    width--;
    inc = startColor.slice();
    if (endColor[0] > startColor[0]) {
      if (startColor[0] + 360.0 - endColor[0] < endColor[0] - startColor[0]) {
        inc[0] = (endColor[0] - (startColor[0] + 360.0)) / width;
      } else {
        inc[0] = (endColor[0] - startColor[0]) / width;
      }
    } else {
      if (endColor[0] + 360.0 - startColor[0] < startColor[0] - endColor[0]) {
        inc[0] = (endColor[0] + 360.0 - startColor[0]) / width;
      } else {
        inc[0] = (endColor[0] - startColor[0]) / width;
      }
    }
    inc[1] = (endColor[1] - startColor[1]) / width;
    inc[2] = (endColor[2] - startColor[2]) / width;
    width++;
    gradientHSBarray = [[], []];
    gradientHSBarray[0] = startColor.slice();
    i = 1;
    for (i = k = 1, ref = width; (1 <= ref ? k < ref : k > ref); i = 1 <= ref ? ++k : --k) {
      gradientHSBarray[i] = startColor.slice(); // just to avoid errors  all values will be over written
      for (j = l = 0; l <= 2; j = ++l) {
        gradientHSBarray[i][j] = gradientHSBarray[i - 1][j] + inc[j];
        if (j > 0) {
          gradientHSBarray[i][j] = Math.min(100, Math.max(0, gradientHSBarray[i][j]));
        } else {
          if (gradientHSBarray[i][j] >= 360) {
            gradientHSBarray[i][j] -= 360;
          }
          if (gradientHSBarray[i][j] < 0) {
            gradientHSBarray[i][j] += 360;
          }
        }
      }
    }
    return gradientHSBarray;
  };

  colorRGBArray = function(startColor, endColor, width) {
    var endColorList, gradientRGBArray, i, inc, j, k, l, m, n, ref, ref1, startColorList;
    startColorList = toColorList(startColor);
    endColorList = toColorList(endColor);
    inc = startColorList.slice();
    inc[0] = (endColorList[0] - startColorList[0]) / width;
    inc[1] = (endColorList[1] - startColorList[1]) / width;
    inc[2] = (endColorList[2] - startColorList[2]) / width;
    gradientRGBArray = [[], []];
    gradientRGBArray[0] = startColorList.slice();
    for (i = k = 1, ref = width; (1 <= ref ? k < ref : k > ref); i = 1 <= ref ? ++k : --k) {
      gradientRGBArray[i] = startColorList.slice(); // just to avoid errors  all values will be over written
      for (j = l = 0; l <= 2; j = ++l) {
        gradientRGBArray[i][j] = gradientRGBArray[i - 1][j] + inc[j];
        gradientRGBArray[i][j] = Math.min(255, Math.max(0, gradientRGBArray[i][j]));
      }
    }
    for (i = m = 1, ref1 = width; (1 <= ref1 ? m < ref1 : m > ref1); i = 1 <= ref1 ? ++m : --m) {
      for (j = n = 0; n <= 2; j = ++n) {
        gradientRGBArray[i][j] = Math.floor(gradientRGBArray[i][j]);
      }
    }
    return gradientRGBArray;
  };

  //MISC
  modDouble = function(number, limit) {
    while (number > limit) {
      number -= limit;
    }
    while (number < 0) {
      number += limit;
    }
    return number;
  };

  toColorList = function(color) {
    if (typeof color === "number") {
      color = Color.colorToRGB(color);
      if (color.length === 4) { // sometimes gives an alpha of 0
        color.pop();
      }
    }
    return color;
  };

  module.exports = {
    init: function(workspace) {
      var HSBOf, alphaOf, getAlpha, getHSB, getMyColor, getRGB, getTransparency, rgbOf, scaleGradient, scaleGradientHSB, scaleScheme, schemeColors, setAlpha, setHSB, setMyColor, setRGB, setTransparency, transparencyOf, withAlpha, withHSB, withRGB, withTransparency;
      getMyColor = function() {
        var mycolor, self;
        self = workspace.selfManager.self();
        mycolor = [];
        if (self instanceof Patch) {
          mycolor = self.getVariable("pcolor");
        } else {
          mycolor = self.getVariable("color");
        }
        return toColorList(mycolor);
      };
      setMyColor = function(mycolor) {
        var self;
        self = workspace.selfManager.self();
        if (self instanceof Patch) {
          self.setVariable("pcolor", mycolor);
        } else {
          self.setVariable("color", mycolor);
        }
      };
      // PRIMS #

      //alpha/trapnsparency
      alphaOf = function(color) {
        if (typeof color === "number") {
          return 255;
        }
        validateRGB(color);
        if (color.length === 4) {
          return color[3];
        }
        return 255;
      };
      transparencyOf = function(color) {
        return (1 - alphaOf(color) / 255.0) * 100.0;
      };
      withAlpha = function(color, newVal) {
        if (newVal < 0 || newVal > 255) {
          throw exceptions.extension("Alpha must be in the range from 0 to 255.");
        }
        if (typeof color === "number") {
          color = Color.colorToRGB(color);
        }
        validateRGB(color);
        color[3] = newVal;
        return color;
      };
      withTransparency = function(color, newVal) {
        if (newVal < 0 || newVal > 100) {
          throw exceptions.extension("Transparency must be in the range from 0 to 100.");
        }
        newVal = (1.0 - newVal / 100.0) * 255.0;
        return withAlpha(color, newVal);
      };
      getAlpha = function() {
        var mycolor, self;
        self = workspace.selfManager.self();
        mycolor = self.getVariable("color");
        if (self instanceof Patch) {
          return 255;
        }
        return alphaOf(mycolor);
      };
      getTransparency = function() {
        return (1 - getAlpha() / 255.0) * 100.0;
      };
      setAlpha = function(newVal) {
        var mycolor, self;
        self = workspace.selfManager.self();
        mycolor = self.getVariable("color");
        if (self instanceof Patch) {
          throw exceptions.extension("Alpha for 2D patches cannot be changed.");
        }
        setMyColor(withAlpha(mycolor, newVal));
      };
      setTransparency = function(newVal) {
        var mycolor, self;
        self = workspace.selfManager.self();
        mycolor = self.getVariable("color");
        if (self instanceof Patch) {
          throw exceptions.extension("Transparency for 2D patches cannot be changed.");
        }
        return setMyColor(withTransparency(mycolor, newVal));
      };
      //HSB
      HSBOf = function(index) {
        return function(color) {
          return extractHSB(color, index);
        };
      };
      withHSB = function(index) {
        return function(color, newVal) {
          if (index === 0) {
            newVal = modDouble(newVal, 360);
          } else {
            newVal = Math.max(Math.min(newVal, 100), 0);
          }
          return hsbUpdated(color, newVal, index);
        };
      };
      getHSB = function(index) {
        return function() {
          return HSBOf(index)(getMyColor());
        };
      };
      setHSB = function(index) {
        return function(number) {
          var range, type;
          type = ["Hue", "Saturation", "Brightness"];
          range = 100;
          if (index === 0) {
            range = 360;
          }
          if (number < 0 || number > 360) {
            throw exceptions.extension(type[index] + " must be in the range from 0 to " + range + ".");
          }
          setMyColor(withHSB(index)(getMyColor(), number));
        };
      };
      //RGB
      rgbOf = function(index) {
        return function(color) {
          return extractRGB(color, index);
        };
      };
      withRGB = function(index) {
        return function(color, newVal) {
          if (newVal < 0 || newVal > 255) { // withRGB is a primitive that takes input from the user, so it needs this check
            throw exceptions.extension("Value must be in the range from 0 to 255.");
          }
          return rgbUpdated(color, newVal, index);
        };
      };
      getRGB = function(index) {
        return function() {
          var mycolor;
          mycolor = getMyColor();
          return mycolor[index];
        };
      };
      setRGB = function(index) {
        return function(number) {
          var mycolor;
          mycolor = getMyColor();
          setMyColor(withRGB(index)(mycolor, number));
        };
      };
      //Gradients and schemes
      scaleGradientHSB = function(colorList, number, min, max) { // takes HSB colors as input
        var SIZE, color, color1, color2, gradient, gradientArray, index, j, k, l, len, m, ref, ref1, x;
        SIZE = 256;
        for (k = 0, len = colorList.length; k < len; k++) {
          color = colorList[k];
          validateHSB(color);
        }
        index = getIndexGradient(number, min, max, colorList.length, SIZE);
        gradientArray = [[], []];
        for (x = l = 0, ref = colorList.length - 1; (0 <= ref ? l < ref : l > ref); x = 0 <= ref ? ++l : --l) {
          color1 = colorList[x];
          color2 = colorList[x + 1];
          gradient = colorHSBArray(color1, color2, SIZE);
          for (j = m = 0, ref1 = SIZE; (0 <= ref1 ? m < ref1 : m > ref1); j = 0 <= ref1 ? ++m : --m) {
            gradientArray[j + SIZE * x] = Color.hsbToRGB(gradient[j][0], gradient[j][1], gradient[j][2]);
          }
        }
        return gradientArray[index];
      };
      scaleGradient = function(colorList, number, min, max) {
        var SIZE, color, color1, color2, gradient, gradientArray, index, j, k, l, len, m, ref, ref1, x;
        SIZE = 256;
        for (k = 0, len = colorList.length; k < len; k++) {
          color = colorList[k];
          validateRGB(color);
        }
        index = getIndexGradient(number, min, max, colorList.length, SIZE);
        gradientArray = [[], []];
        for (x = l = 0, ref = colorList.length - 1; (0 <= ref ? l < ref : l > ref); x = 0 <= ref ? ++l : --l) {
          color1 = colorList[x];
          color2 = colorList[x + 1];
          gradient = colorRGBArray(color1, color2, SIZE);
          for (j = m = 0, ref1 = SIZE; (0 <= ref1 ? m < ref1 : m > ref1); j = 0 <= ref1 ? ++m : --m) {
            gradientArray[j + SIZE * x] = gradient[j];
          }
        }
        return gradientArray[index];
      };
      scaleScheme = function(schemename, legendname, size, number, min, max) {
        var index, legend;
        index = getIndexScheme(number, min, max, size);
        legend = ColorSchemes.getRGBArray(schemename, legendname, size);
        return legend[index];
      };
      schemeColors = function(schemename, legendname, size) {
        return ColorSchemes.getRGBArray(schemename, legendname, size);
      };
      return {
        name: "palette",
        prims: {
          "ALPHA-OF": alphaOf,
          "TRANSPARENCY-OF": transparencyOf,
          "ALPHA": getAlpha,
          "SET-ALPHA": setAlpha,
          "TRANSPARENCY": getTransparency,
          "SET-TRANSPARENCY": setTransparency,
          "WITH-ALPHA": withAlpha,
          "WITH-TRANSPARENCY": withTransparency,
          "HUE-OF": HSBOf(0),
          "SATURATION-OF": HSBOf(1),
          "BRIGHTNESS-OF": HSBOf(2),
          "WITH-HUE": withHSB(0),
          "WITH-SATURATION": withHSB(1),
          "WITH-BRIGHTNESS": withHSB(2),
          "HUE": getHSB(0),
          "SATURATION": getHSB(1),
          "BRIGHTNESS": getHSB(2),
          "SET-HUE": setHSB(0),
          "SET-SATURATION": setHSB(1),
          "SET-BRIGHTNESS": setHSB(2),
          "R-OF": rgbOf(0),
          "G-OF": rgbOf(1),
          "B-OF": rgbOf(2),
          "WITH-R": withRGB(0),
          "WITH-G": withRGB(1),
          "WITH-B": withRGB(2),
          "R": getRGB(0),
          "G": getRGB(1),
          "B": getRGB(2),
          "SET-R": setRGB(0),
          "SET-G": setRGB(1),
          "SET-B": setRGB(2),
          "SCALE-GRADIENT-HSB": scaleGradientHSB,
          "SCALE-GRADIENT": scaleGradient,
          "SCALE-SCHEME": scaleScheme,
          "SCHEME-COLORS": schemeColors
        }
      };
    }
  };

}).call(this);

},{"../engine/core/colormodel":"engine/core/colormodel","../engine/core/patch":"engine/core/patch","./palette-color-schemes":"extensions/palette-color-schemes","util/exception":"util/exception"}],"extensions/resource":[function(require,module,exports){
(function() {
  var exceptions;

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  module.exports = {
    porter: void 0,
    init: function(workspace) {
      var getResource, listResourceKeys;
      getResource = function(key) {
        if (!workspace.resources.hasOwnProperty(key)) {
          exceptions.extension(`Resource \"${key}\" does not exist.`);
        }
        return workspace.resources[key].data;
      };
      listResourceKeys = function() {
        return Object.keys(workspace.resources);
      };
      return {
        name: "resource",
        prims: {
          "GET": getResource,
          "LIST": listResourceKeys
        }
      };
    }
  };

}).call(this);

},{"util/exception":"util/exception"}],"extensions/send-to":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  module.exports = {
    init: function(workspace) {
      var file;
      // (String, String) => Unit
      file = function(fileName, content) {
        workspace.importExportPrims.exportFile(content)(fileName);
      };
      return {
        name: "send-to",
        prims: {
          "FILE": file
        }
      };
    }
  };

}).call(this);

},{}],"extensions/sound":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var exceptions;

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  module.exports = {
    init: function(workspace) {
      var playTone, setup, synth;
      synth = null;
      setup = function() {
        var tone;
        tone = require('tone');
        return synth = new tone.PolySynth(tone.Synth).toDestination();
      };
      playTone = function(note, duration, velocity) {
        var regex;
        if (synth === null) {
          setup();
        }
        regex = /(A|B|C|D|E|F|G)(#|b)?\d/;
        if (regex.test(note)) {
          return synth.triggerAttackRelease(note, duration, void 0, velocity);
        } else {
          throw exceptions.extension(`${note} is not a valid note!`);
        }
      };
      return {
        name: "sound",
        prims: {
          "PLAY-TONE": playTone
        }
      };
    }
  };

}).call(this);

},{"tone":52,"util/exception":"util/exception"}],"extensions/store":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ForageStorage, ObjectStorage, exceptions;

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ObjectStorage = class ObjectStorage {
    constructor() {
      // ((String[]) => Unit) => Unit
      this.listStores = this.listStores.bind(this);
      // (String) => Unit
      this.switchStore = this.switchStore.bind(this);
      // (String) => Unit
      this.deleteStore = this.deleteStore.bind(this);
      // (String, (String) => Unit) => Unit
      this.getItem = this.getItem.bind(this);
      // (String, String, () => Unit) => Unit
      this.setItem = this.setItem.bind(this);
      // (String, () => Unit) => Unit
      this.removeItem = this.removeItem.bind(this);
      // (String, (Boolean) => Unit) => Unit
      this.hasKey = this.hasKey.bind(this);
      // ((String[]) => Unit) => Unit
      this.getKeys = this.getKeys.bind(this);
      // (() => Unit) => Unit
      this.clear = this.clear.bind(this);
      this.store = {
        name: "",
        data: {}
      };
      this.stores = [];
      this.stores.push(this.store);
    }

    listStores(callback) {
      callback(this.stores.filter(function(store) {
        return store.name !== "";
      }).map(function(store) {
        return store.name;
      }));
    }

    switchStore(name) {
      var matchingStore, store;
      name = name !== "Default Store" ? name : "";
      matchingStore = this.stores.find(function(store) {
        return store.name === name;
      });
      this.store = (matchingStore != null) ? matchingStore : (store = {
        name: name,
        data: {}
      }, this.stores.push(store), store);
    }

    deleteStore(name) {
      if (name === "" || name === "Default Store") {
        throw exceptions.extension("Cannot delete the default store, but you can clear it if you want.");
      }
      if (this.store.name === name) {
        throw exceptions.extension("Cannot delete the current store, switch to another store first.");
      }
      this.stores = this.stores.filter(function(store) {
        return store.name !== name;
      });
    }

    getItem(key, callback) {
      this.hasKey(key, (isValidKey) => {
        if (!isValidKey) {
          throw exceptions.extension(`Could not find a value for key: '${key}'.`);
        }
        return callback(this.store.data[key]);
      });
    }

    setItem(key, value, callback = (function() {})) {
      this.store.data[key] = value;
      callback();
    }

    removeItem(key, callback = (function() {})) {
      this.hasKey(key, (isValidKey) => {
        if (isValidKey) {
          return delete this.store.data[key];
        }
      });
      callback();
    }

    hasKey(key, callback) {
      callback(this.store.data.hasOwnProperty(key));
    }

    getKeys(callback) {
      callback(Object.getOwnPropertyNames(this.store.data));
    }

    clear(callback = (function() {})) {
      this.store.data = {};
      callback();
    }

  };

  ForageStorage = class ForageStorage {
    constructor(localforage, reportErrors) {
      // (String, Int | String) => Unit
      this._setCurrentStorage = this._setCurrentStorage.bind(this);
      // ((String[]) => Unit) => Unit
      this.listStores = this.listStores.bind(this);
      // (String) => Unit
      this.switchStore = this.switchStore.bind(this);
      // (String) => Unit
      this.deleteStore = this.deleteStore.bind(this);
      // (String, (String) => Unit) => Unit
      this.getItem = this.getItem.bind(this);
      // ((String[]) => Unit) => Unit
      this.getKeys = this.getKeys.bind(this);
      // (String, (Boolean) => Unit) => Unit
      this.hasKey = this.hasKey.bind(this);
      // (String, String, () => Unit) => Unit
      this.setItem = this.setItem.bind(this);
      // (String, () => Unit) => Unit
      this.removeItem = this.removeItem.bind(this);
      // (() => Unit) => Unit
      this.clear = this.clear.bind(this);
      this.localforage = localforage;
      this.reportError = function(error) {
        return reportErrors(["Unable to process your store request.", "", error.message]);
      };
      this._setCurrentStorage("Default Store", "default");
      this.storesInstance = this.localforage.createInstance({
        name: "Store Extension for NLW",
        storeName: "nlw_store_extension_stores"
      });
      this.stores = [];
      this.lastStoreNumber = 0;
      this.storesInstance.iterate((storeNumber, name) => {
        var storeName;
        storeName = this._storeName(storeNumber);
        this.stores.push({name, storeName, storeNumber});
        if (storeNumber > this.lastStoreNumber) {
          return this.lastStoreNumber = storeNumber;
        }
      });
      return;
    }

    _storeName(storeNumber) {
      return `nlw_store_extension_${storeNumber}`;
    }

    _setCurrentStorage(name, storeNumber) {
      var store;
      store = {
        name: name,
        storeName: this._storeName(storeNumber),
        storeNumber: storeNumber
      };
      this.currentStorage = this.localforage.createInstance(store);
      return store;
    }

    listStores(callback) {
      callback(this.stores.filter(function(store) {
        return store.name !== "";
      }).map(function(store) {
        return store.name;
      }));
    }

    switchStore(name) {
      var matchingStore;
      if (name === "" || name === "Default Store") {
        this._setCurrentStorage("Default Store", "default");
        return;
      }
      matchingStore = this.stores.find(function(store) {
        return store.name === name;
      });
      if ((matchingStore != null)) {
        this._setCurrentStorage(matchingStore.name, matchingStore.storeNumber);
      } else {
        this.lastStoreNumber = this.lastStoreNumber + 1;
        this.storesInstance.setItem(name, this.lastStoreNumber);
        this.stores.push(this._setCurrentStorage(name, this.lastStoreNumber));
      }
    }

    deleteStore(name) {
      var deleteStore, store;
      if (name === "" || name === "Default Store") {
        throw exceptions.extension("Cannot delete the default store, but you can clear it if you want.");
      }
      if (this.currentStorage._config.name === name) {
        throw exceptions.extension("Cannot delete the current store, switch to another store first.");
      }
      this.storesInstance.removeItem(name);
      store = this.stores.find(function(store) {
        return store.name === name;
      });
      if (store == null) {
        return;
      }
      deleteStore = this.localforage.createInstance({
        name: name,
        storeName: store.storeName
      });
      deleteStore.dropInstance();
      this.stores = this.stores.filter(function(store) {
        return store.name !== name;
      });
    }

    getItem(key, callback) {
      this.hasKey(key, (isValidKey) => {
        if (!isValidKey) {
          throw exceptions.extension(`Could not find a value for key: '${key}'.`);
        }
        return this.currentStorage.getItem(key).then(callback).catch(this.reportError);
      });
    }

    getKeys(callback) {
      this.currentStorage.keys().then(callback).catch(this.reportError);
    }

    hasKey(key, callback) {
      this.getKeys(function(keys) {
        return callback(keys.includes(key));
      });
    }

    setItem(key, value, callback = (function() {})) {
      this.currentStorage.setItem(key, value).then(callback).catch(this.reportError);
    }

    removeItem(key, callback = (function() {})) {
      this.currentStorage.removeItem(key).then(callback).catch(this.reportError);
    }

    clear(callback = (function() {})) {
      this.currentStorage.clear().then(callback).catch(this.reportError);
    }

  };

  module.exports = {
    init: function(workspace) {
      var storage;
      storage = ((typeof window !== "undefined" && window !== null ? window.localforage : void 0) != null) ? new ForageStorage(window.localforage, workspace.reportErrors) : new ObjectStorage();
      return {
        name: "store",
        prims: {
          "LIST-STORES": storage.listStores,
          "SWITCH-STORE": storage.switchStore,
          "DELETE-STORE": storage.deleteStore,
          "CLEAR": storage.clear,
          "GET": storage.getItem,
          "GET-KEYS": storage.getKeys,
          "HAS-KEY": storage.hasKey,
          "PUT": storage.setItem,
          "REMOVE": storage.removeItem
        }
      };
    }
  };

}).call(this);

},{"util/exception":"util/exception"}],"extensions/string":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var cryptoMd5, endsWith, escapeRegEx, exceptions, explode, fromFile, fromList, hashCode, lowerCase, md5, rexMatch, rexReplaceAll, rexReplaceFirst, rexSplit, splitOn, startsWith, trim, upperCase;

  cryptoMd5 = require("crypto-js/md5");

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({escapeRegEx} = require('util/regex'));

  explode = function(s) {
    return [...s];
  };

  fromFile = function(f) {
    throw exceptions.extension("There are no local files to access in a web application.  To get the contents of a text file as a string on NetLogo Web try the Fetch extension instead.");
  };

  fromList = function(workspace) {
    return function(l) {
      return l.map(function(i) {
        return workspace.dump(i, false);
      }).join("");
    };
  };

  hashCode = function(s) {
    var chars, hash;
    if (s.length === 0) {
      return 0;
    }
    chars = explode(s).map(function(_1, i) {
      return s.charCodeAt(i);
    });
    hash = chars.reduce(function(hashSoFar, c) {
      hash = ((hashSoFar << 5) - hashSoFar) + c;
      return hash |= 0;
    }, 0);
    return hash;
  };

  md5 = function(s) {
    return cryptoMd5(s).toString();
  };

  rexMatch = function(rex, s) {
    var matches;
    matches = s.match(`^${rex}$`);
    return (matches != null) && matches.length !== 0;
  };

  rexReplaceFirst = function(rex, s, sub) {
    var re;
    re = new RegExp(rex);
    return s.replace(re, sub);
  };

  rexReplaceAll = function(rex, s, sub) {
    var re;
    re = new RegExp(rex, "g");
    return s.replaceAll(re, sub);
  };

  rexSplit = function(s, rex) {
    var re;
    re = new RegExp(rex);
    return s.split(re);
  };

  startsWith = function(s, sub) {
    return s.startsWith(sub);
  };

  endsWith = function(s, sub) {
    return s.endsWith(sub);
  };

  trim = function(s) {
    return s.trim();
  };

  upperCase = function(s) {
    return s.toLocaleUpperCase();
  };

  lowerCase = function(s) {
    return s.toLocaleLowerCase();
  };

  splitOn = function(sub, s) {
    var escaped, re;
    escaped = escapeRegEx(sub);
    // This check is to match Java's behavior for compatibility with desktop
    if (escaped === s) {
      return [''];
    }
    re = new RegExp(escaped);
    return s.split(re);
  };

  module.exports = {
    init: function(workspace) {
      return {
        name: "string",
        prims: {
          "EXPLODE": explode,
          "FROM-FILE": fromFile,
          "FROM-LIST": fromList(workspace),
          "HASH-CODE": hashCode,
          "MD5": md5,
          "MESSAGE-DIGEST-5": md5,
          "REX-MATCH?": rexMatch,
          "REX-REPLACE-FIRST": rexReplaceFirst,
          "REX-REPLACE-ALL": rexReplaceAll,
          "REX-SPLIT": rexSplit,
          "STARTS-WITH?": startsWith,
          "ENDS-WITH?": endsWith,
          "TRIM": trim,
          "UPPER-CASE": upperCase,
          "LOWER-CASE": lowerCase,
          "SPLIT-ON": splitOn
        }
      };
    }
  };

}).call(this);

},{"crypto-js/md5":8,"util/exception":"util/exception","util/regex":"util/regex"}],"extensions/table":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var SingleObjectExtensionPorter, checkInput, checkIsValidList, checks, dumpTable, equals, exceptions, exportTable, extensionName, formatTable, getOriginKey, importTable, isTable, isValidKey, jsonObjectToTable, readTable, tableToJsonObject;

  ({checks} = require('../engine/core/typechecker'));

  SingleObjectExtensionPorter = require('../engine/core/world/singleobjectextensionporter');

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  // (Any) => Boolean
  isTable = function(x) {
    return x instanceof Map;
  };

  // This method is to get the same-value key in a table.
  // e.g (table:get glob1 [1 2]) where passing `key` param is an array; array is a reference type in JavaScript.
  // So we need to find whether there's a same-value key in the table.
  // -- XZ (July, 2020)
  // (Table, Any) => Any | Undefined
  getOriginKey = function(table, key) {
    return Array.from(table.keys()).find(function(k) {
      return equals(k, key);
    });
  };

  // Compare two Array by their values instead of references.
  // (Any, Any) => Boolean
  equals = function(a, b) {
    if (a instanceof Array && b instanceof Array) {
      return a.length === b.length && a.every(function(val, index) {
        return equals(val, b[index]);
      });
    } else {
      return a === b;
    }
  };

  // (Any) => Boolean
  isValidKey = function(x) {
    if (!checks.isList(x)) {
      return checks.isString(x) || checks.isNumber(x) || checks.isBoolean(x);
    } else {
      return x.every(function(item) {
        return isValidKey(item);
      });
    }
  };

  // (List) => Boolean
  checkIsValidList = function(list) {
    var i, len, pair;
    for (i = 0, len = list.length; i < len; i++) {
      pair = list[i];
      if (!(pair instanceof Array && pair.length >= 2)) {
        throw exceptions.extension(`expected a two-element list: ${workspace.dump(pair, true)}`);
      }
    }
  };

  // (Any, String|Boolean|Number|List) ->
  checkInput = function({table, key}) {
    if (!isTable(table)) {
      throw exceptions.extension(`${workspace.dump(table, true)} is not a table`);
    }
    if ((key != null) && !isValidKey(key)) {
      throw exceptions.extension("" + `${workspace.dump(key, true)} is not a valid table key ` + "(a table key may only be a number, a string, true or false, or a list whose items are valid keys)");
    }
  };

  extensionName = "table";

  dumpTable = function(x, dumpValue) {
    return `[${Array.from(x).map((item) => {
      return dumpValue(item, true);
    }).join(' ')}]`;
  };

  exportTable = function(x, exportValue) {
    var map;
    map = new Map();
    Array.from(x.keys()).forEach(function(key) {
      var value;
      value = x.get(key);
      map.set(key, exportValue(value));
    });
    return map;
  };

  formatTable = function(exportedObj, formatAny) {
    var values;
    values = Array.from(exportedObj.data.keys()).map(function(key) {
      return `[\"\"${key}\"\" ${formatAny(exportedObj.data.get(key))}]`;
    });
    return `[${values.join(' ')}]`;
  };

  readTable = function(x, parseAny) {
    var list;
    list = parseAny(x);
    return new Map(list);
  };

  // (ExportedExtensionObject, (Any) => Any)) => Table
  importTable = function(exportedObj, reify) {
    var map;
    map = new Map();
    Array.from(exportedObj.data.keys()).forEach(function(key) {
      var value;
      value = exportedObj.data.get(key);
      map.set(key, reify(value));
    });
    return map;
  };

  jsonObjectToTable = function(jsonObj) {
    var map;
    if (Array.isArray(jsonObj)) {
      return jsonObj.map(function(item) {
        return jsonObjectToTable(item);
      });
    } else if (typeof jsonObj === "object") {
      map = new Map();
      Object.keys(jsonObj).forEach(function(key) {
        var value;
        value = jsonObjectToTable(jsonObj[key]);
        map.set(key, value);
      });
      return map;
    } else {
      return jsonObj;
    }
  };

  tableToJsonObject = function(target) {
    var result;
    if (Array.isArray(target)) {
      return target.map(function(item) {
        return tableToJsonObject(item);
      });
    } else if (typeof target === "object") {
      result = Object.fromEntries(target);
      Object.keys(result).forEach(function(key) {
        var value;
        value = result[key];
        return result[key] = tableToJsonObject(value);
      });
      return result;
    } else {
      return target;
    }
  };

  module.exports = {
    porter: new SingleObjectExtensionPorter(extensionName, isTable, dumpTable, exportTable, formatTable, readTable, importTable),
    init: function(workspace) {
      var clear, counts, fromJson, fromList, get, getOrDefault, groupAgents, groupItems, hasKey, keys, length, make, put, remove, toJson, toList, values;
      // () => Table
      make = function() {
        return new Map();
      };
      // (List) => Map
      fromList = function(list) {
        checkIsValidList(list);
        return new Map(list.slice(0));
      };
      // (Table) => List
      toList = function(table) {
        checkInput({
          table: table
        });
        return Array.from(table).slice(0);
      };
      // (String) => Table
      fromJson = function(source) {
        var ex, json, table;
        json = (function() {
          try {
            return JSON.parse(source);
          } catch (error) {
            ex = error;
            throw exceptions.extension(`The string given to FROM-JSON was not valid.  ${ex.message}`);
          }
        })();
        table = jsonObjectToTable(json);
        checkInput({
          table: table
        });
        return table;
      };
      // (Table) => String
      toJson = function(table) {
        checkInput({
          table: table
        });
        return JSON.stringify(tableToJsonObject(table));
      };
      // (Table) => Unit
      clear = function(table) {
        checkInput({
          table: table
        });
        table.clear();
      };
      // (Table, Any) => Any
      get = function(table, key) {
        var originKey, value;
        checkInput({
          table: table
        });
        value = !(key instanceof Array) ? table.get(key) : (originKey = getOriginKey(table, key), originKey != null ? table.get(originKey) : void 0);
        if (value == null) {
          throw exceptions.extension(`No value for ${key} in table.`);
        }
        return value;
      };
      // (Table, Any) => Boolean
      hasKey = function(table, key) {
        checkInput({
          table: table
        });
        if (!(key instanceof Array)) {
          return table.has(key);
        }
        return Array.from(table.keys()).some(function(k) {
          return equals(k, key);
        });
      };
      // (Table) => List
      keys = function(table) {
        checkInput({
          table: table
        });
        return Array.from(table.keys()).slice(0);
      };
      // (Table) => List
      values = function(table) {
        checkInput({
          table: table
        });
        return Array.from(table.values()).slice(0);
      };
      // (Table) => Number
      length = function(table) {
        checkInput({
          table: table
        });
        return table.size;
      };
      // (Table, Any, Any) => Unit
      put = function(table, key, value) {
        var ref;
        checkInput({
          table: table,
          key: key
        });
        if (!(key instanceof Array)) {
          table.set(key, value);
          return;
        }
        key = (ref = getOriginKey(table, key)) != null ? ref : key;
        table.set(key, value);
      };
      // (Table, Any) => Unit
      remove = function(table, key) {
        var originKey;
        checkInput({
          table: table
        });
        if (!(key instanceof Array)) {
          table.delete(key);
          return;
        }
        originKey = getOriginKey(table, key);
        if (originKey != null) {
          table.delete(originKey);
        }
      };
      // (List) => Table
      counts = function(list) {
        var count, i, item, len;
        counts = new Map();
        for (i = 0, len = list.length; i < len; i++) {
          item = list[i];
          count = hasKey(counts, item) ? get(counts, item) + 1 : 1;
          put(counts, item, count);
        }
        return counts;
      };
      // (Table, Any, Any) => Any
      getOrDefault = function(table, key, defaultValue) {
        checkInput({
          table: table
        });
        if (hasKey(table, key)) {
          return get(table, key);
        } else {
          return defaultValue;
        }
      };
      // (Agentset, Reporter) => Table
      groupAgents = function(agentset, reporter) {
        var group;
        group = new Map();
        agentset.shufflerator().forEach(function(agent) {
          var key, ref, value;
          key = workspace.world.selfManager.askAgent(reporter)(agent);
          value = (ref = group.get(key)) != null ? ref : [];
          value.push(agent);
          return group.set(key, value);
        });
        group.forEach(function(value, key) {
          var newAgentset;
          newAgentset = (function() {
            switch (agentset._agentTypeName) {
              case "turtles":
                return new TurtleSet(value, workspace.world);
              case "patches":
                return new PatchSet(value, workspace.world);
              case "links":
                return new LinkSet(value, workspace.world);
              default:
                throw exceptions.internal("Unknown agentset type");
            }
          })();
          return group.set(key, newAgentset);
        });
        return group;
      };
      // (List, (Number => Number)) => Table
      groupItems = function(list, reporter) {
        var group, i, item, key, len, ref, ref1, value;
        group = new Map();
        for (i = 0, len = list.length; i < len; i++) {
          item = list[i];
          key = (ref = getOriginKey(group, reporter(item))) != null ? ref : reporter(item);
          value = (ref1 = group.get(key)) != null ? ref1 : [];
          value.push(item);
          group.set(key, value);
        }
        return group;
      };
      return {
        name: extensionName,
        prims: {
          "CLEAR": clear,
          "COUNTS": counts,
          "GROUP-AGENTS": groupAgents,
          "GROUP-ITEMS": groupItems,
          "FROM-LIST": fromList,
          "GET": get,
          "GET-OR-DEFAULT": getOrDefault,
          "HAS-KEY?": hasKey,
          "KEYS": keys,
          "LENGTH": length,
          "MAKE": make,
          "PUT": put,
          "REMOVE": remove,
          "TO-LIST": toList,
          "TO-JSON": toJson,
          "FROM-JSON": fromJson,
          "VALUES": values,
          "IS-TABLE?": isTable
        }
      };
    }
  };

}).call(this);

},{"../engine/core/typechecker":"engine/core/typechecker","../engine/core/world/singleobjectextensionporter":"engine/core/world/singleobjectextensionporter","util/exception":"util/exception"}],"i18n/en_us":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var bundle;

  bundle = {
    identifier: 'en_us',
    // Math Prims
    'atan is undefined when both inputs are zero.': function() {
      return "atan is undefined when both inputs are zero.";
    },
    '_ isn_t a valid base for a logarithm.': function(b) {
      return `${b} isn't a valid base for a logarithm.`;
    },
    'The square root of _ is an imaginary number.': function(n) {
      return `The square root of ${n} is an imaginary number.`;
    },
    'math operation produced a non-number': function() {
      return "math operation produced a non-number";
    },
    'math operation produced a number too large for NetLogo': function() {
      return "math operation produced a number too large for NetLogo";
    },
    'Division by zero.': function() {
      return "Division by zero.";
    },
    'Can_t take logarithm of _.': function(n) {
      return `Can't take logarithm of ${n}.`;
    },
    // Color Prims
    'Color must be a number or a valid RGB/A color list with 3 - 4 numbers that have values between 0 and 255.': function() {
      return 'Color must be a number or a valid RGB/A color list with 3 - 4 numbers that have values between 0 and 255.';
    },
    // Other Prims
    'random-normal_s second input can_t be negative.': function() {
      return "random-normal's second input can't be negative.";
    },
    'Both Inputs to RANDOM-GAMMA must be positive.': function() {
      return "Both Inputs to RANDOM-GAMMA must be positive.";
    },
    '_ is not in the allowable range for random seeds (-2147483648 to 2147483647)': function(n) {
      return `${n} is not in the allowable range for random seeds (-2147483648 to 2147483647)`;
    },
    '_ is too large to be represented exactly as an integer in NetLogo': function(n) {
      return `${n} is too large to be represented exactly as an integer in NetLogo`;
    },
    'List is empty.': function() {
      return "List is empty.";
    },
    'Can_t find element _ of the _ _, which is only of length _.': function(n, type, list, length) {
      return `Can't find element ${n} of the ${type} ${list}, which is only of length ${length}.`;
    },
    'The list argument to reduce must not be empty.': function() {
      return "The list argument to reduce must not be empty.";
    },
    '_ is greater than the length of the input list (_).': function(endIndex, listLength) {
      return `${endIndex} is greater than the length of the input list (${listLength}).`;
    },
    '_ is less than zero.': function(index) {
      return `${index} is less than zero.`;
    },
    '_ is less than _.': function(endIndex, startIndex) {
      return `${endIndex} is less than ${startIndex}.`;
    },
    '_ got an empty _ as input.': function(prim, type) {
      return `${prim} got an empty ${type} as input.`;
    },
    '_ isn_t greater than or equal to zero.': function(index) {
      return `${index} isn't greater than or equal to zero.`;
    },
    'Can_t find the _ of a list with no numbers: __': function(aspect, list, punc) {
      return `Can't find the ${aspect} of a list with no numbers: ${list}${punc}`;
    },
    'Requested _ random items from a list of length _.': function(count, length) {
      return `Requested ${count} random items from a list of length ${length}.`;
    },
    'Requested _ random agents from a set of only _ agents.': function(count, size) {
      return `Requested ${count} random agents from a set of only ${size} agents.`;
    },
    'Can_t find the _ of a list without at least two numbers: __': function(aspect, list, punc) {
      return `Can't find the ${aspect} of a list without at least two numbers: ${list}${punc}`;
    },
    'Invalid list of points: _': function(points) {
      return `Invalid list of points: ${points}`;
    },
    'First input to _ can_t be negative.': function(prim) {
      return `First input to ${prim} can't be negative.`;
    },
    '_ expected a true/false value from _, but got _ instead.': function(prim, item, value) {
      return `${prim} expected a true/false value from ${item}, but got ${value} instead.`;
    },
    '_ expected input to be a _ agentset or _ but got _ instead.': function(prim, agentType, value) {
      return `${prim} expected input to be a ${agentType} agentset or ${agentType} but got ${value} instead.`;
    },
    '_ expected input to be _ but got _ instead.': function(prim, expectedType, actualType) {
      return `${prim} expected input to be ${expectedType} but got ${actualType} instead.`;
    },
    'List inputs to _ must only contain _, _ agentset, or list elements.  The list _ contained _ which is NOT a _ or _ agentset.': function(prim, agentType, list, value) {
      return `List inputs to ${prim} must only contain ${agentType}, ${agentType} agentset, or list elements.  The list ${list} contained ${value} which is NOT a ${agentType} or ${agentType} agentset.`;
    },
    'List inputs to _ must only contain _, _ agentset, or list elements.  The list _ contained a different type agentset: _.': function(prim, agentType, list, value) {
      return `List inputs to ${prim} must only contain ${agentType}, ${agentType} agentset, or list elements.  The list ${list} contained a different type agentset: ${value}.`;
    },
    'SORT-ON works on numbers, strings, or agents of the same type, but not on _ and _': function(type1, type2) {
      return `SORT-ON works on numbers, strings, or agents of the same type, but not on ${type1} and ${type2}`;
    },
    'anonymous procedure expected _ input_, but only got _': function(needed, given) {
      return `anonymous procedure expected ${needed} input${needed !== 1 ? "s" : ""}, but only got ${given}`;
    },
    'REPORT can only be used inside TO-REPORT.': function() {
      return "REPORT can only be used inside TO-REPORT.";
    },
    'STOP is not allowed inside TO-REPORT.': function() {
      return "STOP is not allowed inside TO-REPORT.";
    },
    'Reached end of reporter procedure without REPORT being called.': function() {
      return "Reached end of reporter procedure without REPORT being called.";
    },
    '_ doesn_t accept further inputs if the first is a string': function(primName) {
      return `${primName} doesn't accept further inputs if the first is a string`;
    },
    'Unfortunately, no perfect equivalent to `_` can be implemented in NetLogo Web.  However, the \'import-a\' and \'fetch\' extensions offer primitives that can accomplish this in both NetLogo and NetLogo Web.': function(primName) {
      return `Unfortunately, no perfect equivalent to \`${primName}\` can be implemented in NetLogo Web.  However, the \'import-a\' and \'fetch\' extensions offer primitives that can accomplish this in both NetLogo and NetLogo Web.`;
    },
    'The point [ _ , _ ] is outside of the boundaries of the world and wrapping is not permitted in one or both directions.': function(x, y) {
      return `The point [ ${x} , ${y} ] is outside of the boundaries of the world and wrapping is not permitted in one or both directions.`;
    },
    'Cannot move turtle beyond the world_s edge.': function() {
      return "Cannot move turtle beyond the world's edge.";
    },
    'there is no heading of a link whose endpoints are in the same position': function() {
      return "there is no heading of a link whose endpoints are in the same position";
    },
    'No heading is defined from a point (_,_) to that same point.': function(x, y) {
      return `No heading is defined from a point (${x},${y}) to that same point.`;
    },
    '_ is not an integer': function(x) {
      return `${x} is not an integer`;
    },
    '_ is not a _': function(breed1, breed2) {
      return `${breed1} is not a ${breed2}`;
    },
    'An rgb list must contain 3 numbers 0-255': function() {
      return 'An rgb list must contain 3 numbers 0-255';
    },
    'An rgb list must contain 3 or 4 numbers 0-255': function() {
      return 'An rgb list must contain 3 or 4 numbers 0-255';
    },
    'RGB values must be 0-255': function() {
      return 'RGB values must be 0-255';
    },
    "can't set _ variable _ to non-number _": function(e) {
      return `can't set ${e.myType} variable ${e.varName.toUpperCase()} to non-number ${e.target}`;
    },
    '_ breed does not own variable _': function(breedName, varName) {
      return `${breedName} breed does not own variable ${varName}`;
    },
    'All the list arguments to _ must be the same length.': function(primName) {
      return `All the list arguments to ${primName} must be the same length.`;
    },
    'The step-size for range must be non-zero.': function() {
      return "The step-size for range must be non-zero.";
    },
    'range expects at most three arguments': function() {
      return "range expects at most three arguments";
    },
    '_ cannot take a negative number.': function(primName) {
      return `${primName} cannot take a negative number.`;
    },
    'The list of values for _ must be at least as long as the list of names.  We need _ value(s) but only got _ from the list _.': function(primName, varCount, argsLength, argsList) {
      return `The list of values for ${primName} must be at least as long as the list of names.  We need ${varCount} value(s) but only got ${argsLength} from the list ${argsList}.`;
    },
    // Dynamic Calls (TU)
    'Cannot find the procedure _.': function(procedureName) {
      return `Cannot find the procedure ${procedureName}.`;
    },
    'Patch size must be greater than zero.': function() {
      return "Patch size must be greater than zero.";
    }
  };

  module.exports = bundle;

}).call(this);

},{}],"i18n/es_es":[function(require,module,exports){
(function() {
  var bundle;

  bundle = {
    identifier: 'es_es',
    'atan is undefined when both inputs are zero.': function() {
      return "atan no puede tomar dos ceros por input.";
    },
    '_ isn_t a valid base for a logarithm.': function(b) {
      return `${b} no esta un base valido para el logarithm.`;
    },
    'The square root of _ is an imaginary number.': function(n) {
      return `El square root de ${n} esta un numero imaginario.`;
    },
    'Division by zero.': function() {
      return "No se puede dividir con 0.";
    },
    'Can_t take logarithm of _.': function(n) {
      return `No puede tomar un logarithm de ${n}.`;
    },
    'random-normal_s second input can_t be negative.': function() {
      return "El segundo input de random-normal no puede ser negativo.";
    },
    '_ is too large to be represented exactly as an integer in NetLogo': function(n) {
      return `${n} es demasiado grande para estar representado como un Integer en NetLogo.`;
    },
    'List is empty.': function() {
      return "No hay nada en el listo.";
    },
    'Can_t find element _ of the _ _, which is only of length _.': function(n, type, list, length) {
      return `No puede esconder elemento ${n} del listo ${type} que solamente tiene ${list} miembros.`;
    },
    'The list argument to reduce must not be empty.': function() {
      return "El listo para hacer 'reducto' no debe ser vacio.";
    },
    '_ is greater than the length of the input list (_).': function(endIndex, listLength) {
      return `${endIndex} es mas que el longitud del listo de input (${listLength}).`;
    },
    '_ is less than zero.': function(index) {
      return `${index} es menos que cero.`;
    },
    '_ got an empty _ as input.': function(prim, type) {
      return `${prim} recibio un listo sin miembros.`;
    },
    '_ isn_t greater than or equal to zero.': function(index) {
      return `${index} no esta mas que o iqual a cero.`;
    },
    'Can_t find the _ of a list with no numbers: __': function(aspect, list, punc) {
      return `No puede esconder el promedio de un listo sin numeros: ${aspect}.`;
    },
    'Requested _ random items from a list of length _.': function(count, length) {
      return `Escondiendo ${count} miembros al azar del listo de longitud ${length}.`;
    },
    'Requested _ random agents from a set of only _ agents.': function(count, size) {
      return `Pidi a ${count} agentes azar de un conjunto de slo ${size} agentes.`;
    },
    'Can_t find the _ of a list without at least two numbers: __': function(aspect, list, punc) {
      return `No puede esconder el variance de un listo que tiene por lo menos dos numeros: ${aspect}.`;
    },
    'Invalid list of points: _': function(points) {
      return `Esta lista de puntos no es valido: ${points}`;
    },
    'First input to _ can_t be negative.': function(prim) {
      return `El primero input a ${prim} no puede ser negativo.`;
    },
    '_ expected a true/false value from _, but got _ instead.': function(prim, item, value) {
      return `${prim} expectabla un verdad/falso valor de ${item}, pero encuentro ${value} en vez.`;
    },
    'List inputs to _ must only contain _, _ agentset, or list elements.  The list _ contained _ which is NOT a _ or _ agentset.': function(prim, agentType, list, value) {
      return `Los inputs del listo ${prim} solamente puede contener un ${agentType}, ${agentType} agentset, o elementos de un listo. `;
    },
    'List inputs to _ must only contain _, _ agentset, or list elements.  The list _ contained a different type agentset: _.': function(prim, agentType, list, value) {
      return `Los inputs de ${prim} olamente puede contener un link, link agentset, o elementos de un listo.  El listo ${agentType} contiene un otro tipo de agentset: ${list}.`;
    },
    'REPORT can only be used inside TO-REPORT.': function() {
      return "solamente se puede usar REPORT en TO-REPORT.";
    },
    'STOP is not allowed inside TO-REPORT.': function() {
      return "STOP no esta permitido entre TO-REPORT.";
    },
    'Reached end of reporter procedure without REPORT being called.': function() {
      return "Llego al terminacion del procedimiento de reporter sin llamando REPORT.";
    },
    'The point [ _ , _ ] is outside of the boundaries of the world and wrapping is not permitted in one or both directions.': function(x, y) {
      return `El punto [ ${x} , ${y} ] es fuera de los limites de ese mundo y  wrapping no esta permitido en uno o mas de los direcions.`;
    },
    'Cannot move turtle beyond the world_s edge.': function() {
      return "No se puede mover la tortuga ms all del borde del mundo.";
    },
    'there is no heading of a link whose endpoints are in the same position': function() {
      return "No hay un heading de un link que tiene endpoints en el mismo lugar.";
    },
    'No heading is defined from a point (_,_) to that same point.': function(x, y) {
      return `No hay un heading definido desde punto (${x},${y}) a si mismo.`;
    },
    'An rgb list must contain 3 numbers 0-255': function() {
      return "rgb una lista deber contener tres nmeros de 0 a 255";
    },
    'An rgb list must contain 3 or 4 numbers 0-255': function() {
      return "Una lista rgb debe contener 3 o 4 nmeros de 0 a 255";
    },
    'RGB values must be 0-255': function() {
      return "valores RGB debe 0-255";
    },
    '_ breed does not own variable _': function(breedName, varName) {
      return `${breedName} breed no tiene variable ${varName}`;
    },
    'All the list arguments to _ must be the same length.': function(primName) {
      return `Todos los argumentos lista para ${primName} debe tener la misma longitud.`;
    },
    '_ cannot take a negative number.': function(primName) {
      return `${primName} no puede tomar un numero negativo.`;
    }
  };

  module.exports = bundle;

}).call(this);

},{}],"i18n/i18n-bundle":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var BUNDLES, EN_US, ES_ES, I18nBundle, JA_JP, PT_PT, ZH_CN, exceptions;

  EN_US = require('./en_us');

  // Manually importing these is kind-of a pain, but it's easy enough to keep updated and I don't feel like wrestling with
  // getting the dyanmic `require()` working with Tortoise's packaging.  *TODO*: Once we've switched over to ES modules
  // would be a good time to revisit this.  -Jeremy B March 2023
  ZH_CN = require('./zh_cn');

  ES_ES = require('./es_es');

  JA_JP = require('./ja_jp');

  PT_PT = require('./pt_pt');

  BUNDLES = {
    'en_us': EN_US,
    'zh_cn': ZH_CN,
    'es_es': ES_ES,
    'ja_jp': JA_JP,
    'pt_pt': PT_PT
  };

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  I18nBundle = (function() {
    var _current, _warnings;

    // At the moment this doesn't do much but it'd be a good place to add
    // the ability to swap the current locale as needed.
    // -Jeremy B November 2020
    class I18nBundle {
      constructor() {
        this._current = EN_US;
      }

      get(key, ...args) {
        var bundle, message;
        bundle = (function() {
          if (this._current.hasOwnProperty(key)) {
            return this._current;
          } else if (this._current !== EN_US && EN_US.hasOwnProperty(key)) {
            return EN_US;
          } else {
            throw exceptions.internal(`Could not find a message for this key: ${key}`);
          }
        }).call(this);
        message = bundle[key];
        return message(...args);
      }

      supports(locale) {
        return BUNDLES.hasOwnProperty(locale);
      }

      switch(locale) {
        if (this.supports(locale)) {
          return this._current = BUNDLES[locale];
        } else {
          if (!this._warnings.has(locale)) {
            this._warning.add(locale);
            console.warn(`Unsupported locale '${locale}', reverting to 'en_us'.`);
          }
          return this._current = EN_US;
        }
      }

    };

    _current = null;

    _warnings = new Set();

    return I18nBundle;

  }).call(this);

  module.exports = I18nBundle;

}).call(this);

},{"./en_us":"i18n/en_us","./es_es":"i18n/es_es","./ja_jp":"i18n/ja_jp","./pt_pt":"i18n/pt_pt","./zh_cn":"i18n/zh_cn","util/exception":"util/exception"}],"i18n/ja_jp":[function(require,module,exports){
(function() {
  var bundle;

  bundle = {
    identifier: 'ja_jp',
    'atan is undefined when both inputs are zero.': function() {
      return "atan  0 ";
    },
    '_ isn_t a valid base for a logarithm.': function(b) {
      return `${b} `;
    },
    'The square root of _ is an imaginary number.': function(n) {
      return `${n} `;
    },
    'Division by zero.': function() {
      return "0";
    },
    'Can_t take logarithm of _.': function(n) {
      return `${n} `;
    },
    'random-normal_s second input can_t be negative.': function() {
      return "random-normal 2";
    },
    '_ is too large to be represented exactly as an integer in NetLogo': function(n) {
      return `${n} NetLogo`;
    },
    'List is empty.': function() {
      return "";
    },
    'Can_t find element _ of the _ _, which is only of length _.': function(n, type, list, length) {
      return ` ${type}  ${list}  ${n} `;
    },
    'The list argument to reduce must not be empty.': function() {
      return " reduce ";
    },
    '_ is greater than the length of the input list (_).': function(endIndex, listLength) {
      return `${endIndex} ${listLength} `;
    },
    '_ is less than zero.': function(index) {
      return `${index} 0`;
    },
    '_ got an empty _ as input.': function(prim, type) {
      return `${prim} `;
    },
    '_ isn_t greater than or equal to zero.': function(index) {
      return `${index} 0`;
    },
    'Can_t find the _ of a list with no numbers: __': function(aspect, list, punc) {
      return ` ${aspect} `;
    },
    'Requested _ random items from a list of length _.': function(count, length) {
      return ` ${length}  ${count} `;
    },
    'Requested _ random agents from a set of only _ agents.': function(count, size) {
      return ` ${size}  ${count} `;
    },
    'Can_t find the _ of a list without at least two numbers: __': function(aspect, list, punc) {
      return ` ${aspect} 2`;
    },
    'Invalid list of points: _': function(points) {
      return ` ${points} `;
    },
    'First input to _ can_t be negative.': function(prim) {
      return `${prim} 1`;
    },
    '_ expected a true/false value from _, but got _ instead.': function(prim, item, value) {
      return `${prim}  ${item} ${value} `;
    },
    'List inputs to _ must only contain _, _ agentset, or list elements.  The list _ contained _ which is NOT a _ or _ agentset.': function(prim, agentType, list, value) {
      return `${prim}  ${agentType}  ${list} `;
    },
    'List inputs to _ must only contain _, _ agentset, or list elements.  The list _ contained a different type agentset: _.': function(prim, agentType, list, value) {
      return `${prim}  ${agentType}  ${list} `;
    },
    'REPORT can only be used inside TO-REPORT.': function() {
      return "REPORT  TO-REPORT ";
    },
    'STOP is not allowed inside TO-REPORT.': function() {
      return "STOP  TO-REPORT ";
    },
    'Reached end of reporter procedure without REPORT being called.': function() {
      return " REPORT ";
    },
    'The point [ _ , _ ] is outside of the boundaries of the world and wrapping is not permitted in one or both directions.': function(x, y) {
      return ` [ ${x} , ${y} ] xy`;
    },
    'Cannot move turtle beyond the world_s edge.': function() {
      return "";
    },
    'there is no heading of a link whose endpoints are in the same position': function() {
      return " heading ";
    },
    'No heading is defined from a point (_,_) to that same point.': function(x, y) {
      return ` (${x},${y}) `;
    },
    'An rgb list must contain 3 numbers 0-255': function() {
      return "RGB02553";
    },
    'An rgb list must contain 3 or 4 numbers 0-255': function() {
      return "RGB025534";
    },
    'RGB values must be 0-255': function() {
      return "RGB0255";
    },
    '_ breed does not own variable _': function(breedName, varName) {
      return ` ${breedName}  ${varName} `;
    },
    'All the list arguments to _ must be the same length.': function(primName) {
      return `${primName} `;
    },
    '_ cannot take a negative number.': function(primName) {
      return `${primName} `;
    }
  };

  module.exports = bundle;

}).call(this);

},{}],"i18n/pt_pt":[function(require,module,exports){
(function() {
  var bundle;

  bundle = {
    identifier: 'pt_pt',
    'atan is undefined when both inputs are zero.': function() {
      return "atan  indefinido quando ambas as entradas so zero.";
    },
    '_ isn_t a valid base for a logarithm.': function(b) {
      return `${b} no  uma base vlida para um logaritmo.`;
    },
    'The square root of _ is an imaginary number.': function(n) {
      return `A raiz quadrada de ${n}  um nmero imaginrio.`;
    },
    'Division by zero.': function() {
      return "Diviso por zero.";
    },
    'Can_t take logarithm of _.': function(n) {
      return `No  possvel encontrar o logaritmo de ${n}.`;
    },
    'random-normal_s second input can_t be negative.': function() {
      return "a segunda entrada de random-normal no pode ser negativa.";
    },
    '_ is too large to be represented exactly as an integer in NetLogo': function(n) {
      return `${n}  muito largo para ser representado exatamente como um inteiro no NetLogo.`;
    },
    'List is empty.': function() {
      return "A lista est vazia.";
    },
    'Can_t find element _ of the _ _, which is only of length _.': function(n, type, list, length) {
      return `No foi possvel encontrar o elemento ${n} da lista ${type}, que tem comprimento de apenas ${list}.`;
    },
    'The list argument to reduce must not be empty.': function() {
      return "O argumento de lista para 'reduce' no pode ser vazio.";
    },
    '_ is greater than the length of the input list (_).': function(endIndex, listLength) {
      return `${endIndex}  maior que o comprimento da lista de entrada (${listLength}).`;
    },
    '_ is less than zero.': function(index) {
      return `${index}  menor que zero.`;
    },
    '_ got an empty _ as input.': function(prim, type) {
      return `${prim} recebeu uma lista vazia como entrada.`;
    },
    '_ isn_t greater than or equal to zero.': function(index) {
      return `${index} no  maior ou igual a zero.`;
    },
    'Requested _ random items from a list of length _.': function(count, length) {
      return `Foram pedidos ${count} itens aleatrios de uma lista de comprimento ${length}.`;
    },
    'Requested _ random agents from a set of only _ agents.': function(count, size) {
      return `Foram pedidos ${count} agentes aleatrios de um conjunto com apenas ${size} agentes.`;
    },
    'Can_t find the _ of a list without at least two numbers: __': function(aspect, list, punc) {
      return `No  possvel encontrar a varincia de uma lista sem pelo menos dois nmeros: ${aspect}.`;
    },
    'Invalid list of points: _': function(points) {
      return `Lista de pontos invlida: ${points}`;
    },
    'First input to _ can_t be negative.': function(prim) {
      return `A primeira entrada para ${prim} no pode ser negativa.`;
    },
    '_ expected a true/false value from _, but got _ instead.': function(prim, item, value) {
      return `${prim} esperava um valor de verdadeiro/falso (true/false) de ${item}, mas no lugar disso recebeu ${value}.`;
    },
    'List inputs to _ must only contain _, _ agentset, or list elements.  The list _ contained _ which is NOT a _ or _ agentset.': function(prim, agentType, list, value) {
      return `Entradas de lista para ${prim} devem somente conter ${agentType}, ${agentType} agentset, ou elementos de lista.  A lista ${list} continha ${value} que NO  um ${agentType} ou ${agentType} agentset.`;
    },
    'List inputs to _ must only contain _, _ agentset, or list elements.  The list _ contained a different type agentset: _.': function(prim, agentType, list, value) {
      return `Entradas de lista para ${prim} devem somente conter ${agentType}, ${agentType} agentset, ou elementos de lista.  A lista ${list} continha um tipo diferente de agentset: ${value}.`;
    },
    'anonymous procedure expected _ inputs, but only got _': function(needed, given) {
      return "o procedimento annimo esperava 1 entrada, mas obteve apenas 0";
    },
    'REPORT can only be used inside TO-REPORT.': function() {
      return "REPORT s pode ser usado dentro de TO-REPORT.";
    },
    'STOP is not allowed inside TO-REPORT.': function() {
      return "STOP no  permitido dentro de TO-REPORT.";
    },
    'Reached end of reporter procedure without REPORT being called.': function() {
      return "Chegou-se ao fim de um procedimento reporter sem que REPORT tenha sido chamado.";
    },
    'The point [ _ , _ ] is outside of the boundaries of the world and wrapping is not permitted in one or both directions.': function(x, y) {
      return `O ponto [ ${x} , ${y} ] est fora dos limites do mundo e dar a volta no mundo no  permitido em uma ou mais direes.`;
    },
    'Cannot move turtle beyond the world_s edge.': function() {
      return "No se pode mover a turtle para alm da fronteira do mundo.";
    },
    'there is no heading of a link whose endpoints are in the same position': function() {
      return "No h um heading de um link no qual as pontas estejam na mesma posio.";
    },
    'No heading is defined from a point (_,_) to that same point.': function(x, y) {
      return `No  possvel determinar um heading do ponto (${x},${y}) para esse mesmo ponto.`;
    },
    'An rgb list must contain 3 numbers 0-255': function() {
      return "Uma lista RGB deve conter 3 nmeros 0-255";
    },
    'An rgb list must contain 3 or 4 numbers 0-255': function() {
      return "Uma lista RGB deve conter 3 ou 4 nmeros 0-255";
    },
    'RGB values must be 0-255': function() {
      return "Valores RGB devem ser 0-255";
    },
    '_ breed does not own variable _': function(breedName, varName) {
      return `${breedName} breed no possui a varivel ${varName}`;
    },
    'All the list arguments to _ must be the same length.': function(primName) {
      return `Todos os argumentos de lista para ${primName} devem ter o mesmo comprimento.`;
    },
    'The step-size for range must be non-zero.': function() {
      return "O tamanho de degrau para range deve ser diferente de zero.";
    },
    '_ cannot take a negative number.': function(primName) {
      return `${primName} no pode ter nmero negativo.`;
    }
  };

  module.exports = bundle;

}).call(this);

},{}],"i18n/zh_cn":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var bundle;

  bundle = {
    identifier: 'zh_cn',
    // Math Prims
    'atan is undefined when both inputs are zero.': function() {
      return " 0 atan ";
    },
    '_ isn_t a valid base for a logarithm.': function(b) {
      return `${b} `;
    },
    'The square root of _ is an imaginary number.': function(n) {
      return ` ${n} `;
    },
    'math operation produced a non-number': function() {
      return "";
    },
    'math operation produced a number too large for NetLogo': function() {
      return " NetLogo ";
    },
    'Division by zero.': function() {
      return "";
    },
    'Can_t take logarithm of _.': function(n) {
      return ` ${n} `;
    },
    // Color Prims
    'Color must be a number or a valid RGB/A color list with 3 - 4 numbers that have values between 0 and 255.': function() {
      return ' RGB  3-4  0-255 ';
    },
    // Other Prims
    'random-normal_s second input can_t be negative.': function() {
      return "random-normal ";
    },
    'Both Inputs to RANDOM-GAMMA must be positive.': function() {
      return "RANDOM-GAMMA ";
    },
    '_ is not in the allowable range for random seeds (-2147483648 to 2147483647)': function(n) {
      return `${n}  (-2147483648 ~ 2147483647)`;
    },
    '_ is too large to be represented exactly as an integer in NetLogo': function(n) {
      return `${n}  NetLogo `;
    },
    'List is empty.': function() {
      return "";
    },
    'Can_t find element _ of the _ _, which is only of length _.': function(n, type, list, length) {
      return ` ${type} ${list}  ${n}  ${length}`;
    },
    'The list argument to reduce must not be empty.': function() {
      return " reduce ";
    },
    '_ is greater than the length of the input list (_).': function(endIndex, listLength) {
      return `${endIndex}  (${listLength})`;
    },
    '_ is less than zero.': function(index) {
      return `${index}  0`;
    },
    '_ is less than _.': function(endIndex, startIndex) {
      return `${endIndex}  ${startIndex}`;
    },
    '_ got an empty _ as input.': function(prim, type) {
      return `${prim}  ${type} `;
    },
    '_ isn_t greater than or equal to zero.': function(index) {
      return `${index}  0`;
    },
    'Can_t find the _ of a list with no numbers: __': function(aspect, list, punc) {
      return ` ${list}${punc}  ${aspect}`;
    },
    'Requested _ random items from a list of length _.': function(count, length) {
      return ` ${length}  ${count} `;
    },
    'Requested _ random agents from a set of only _ agents.': function(count, size) {
      return ` ${size}  ${count} `;
    },
    'Can_t find the _ of a list without at least two numbers: __': function(aspect, list, punc) {
      return `${list}${punc}  ${aspect}`;
    },
    'Invalid list of points: _': function(points) {
      return ` ${points} `;
    },
    'First input to _ can_t be negative.': function(prim) {
      return `${prim} `;
    },
    '_ expected a true/false value from _, but got _ instead.': function(prim, item, value) {
      return `${prim}  ${item}  true/false  ${value}`;
    },
    '_ expected input to be a _ agentset or _ but got _ instead.': function(prim, agentType, value) {
      return `${prim}  ${agentType}  ${value}`;
    },
    '_ expected input to be _ but got _ instead.': function(prim, expectedType, actualType) {
      return `${prim}  ${expectedType} ${actualType}`;
    },
    'List inputs to _ must only contain _, _ agentset, or list elements.  The list _ contained _ which is NOT a _ or _ agentset.': function(prim, agentType, list, value) {
      return `${prim} ${agentType} ${agentType}  ${list}  ${value} `;
    },
    'List inputs to _ must only contain _, _ agentset, or list elements.  The list _ contained a different type agentset: _.': function(prim, agentType, list, value) {
      return `${prim} ${agentType} ${agentType}  ${list} : ${value}`;
    },
    'SORT-ON works on numbers, strings, or agents of the same type, but not on _ and _': function(type1, type2) {
      return `SORT-ON  ${type1}  ${type2}`;
    },
    'anonymous procedure expected _ input_, but only got _': function(needed, given) {
      return ` ${needed}  ${given} `;
    },
    'REPORT can only be used inside TO-REPORT.': function() {
      return "REPORT  TO-REPORT ";
    },
    'STOP is not allowed inside TO-REPORT.': function() {
      return " TO-REPORT  STOP";
    },
    'Reached end of reporter procedure without REPORT being called.': function() {
      return " `REPORT` ";
    },
    '_ doesn_t accept further inputs if the first is a string': function(primName) {
      return `${primName} `;
    },
    'Unfortunately, no perfect equivalent to `_` can be implemented in NetLogo Web.  However, the \'import-a\' and \'fetch\' extensions offer primitives that can accomplish this in both NetLogo and NetLogo Web.': function(primName) {
      return ` \`${primName}\` \`import-a\`  \`fetch\` `;
    },
    'The point [ _ , _ ] is outside of the boundaries of the world and wrapping is not permitted in one or both directions.': function(x, y) {
      return ` [ ${x} , ${y} ] `;
    },
    'Cannot move turtle beyond the world_s edge.': function() {
      return "";
    },
    'there is no heading of a link whose endpoints are in the same position': function() {
      return "";
    },
    'No heading is defined from a point (_,_) to that same point.': function(x, y) {
      return ` (${x},${y}) `;
    },
    '_ is not an integer': function(x) {
      return `${x} `;
    },
    '_ is not a _': function(breed1, breed2) {
      return `${breed1}  ${breed2}`;
    },
    'An rgb list must contain 3 numbers 0-255': function() {
      return ' RGB  3  0-255 ';
    },
    'An rgb list must contain 3 or 4 numbers 0-255': function() {
      return ' RGB  3-4  0-255 ';
    },
    'RGB values must be 0-255': function() {
      return 'RGB  0-255 ';
    },
    "can't set _ variable _ to non-number _": function(e) {
      return ` ${e.myType}  ${e.varName.toUpperCase()}  ${e.target}`;
    },
    '_ breed does not own variable _': function(breedName, varName) {
      return ` ${breedName}  ${varName}`;
    },
    'All the list arguments to _ must be the same length.': function(primName) {
      return `${primName} `;
    },
    'The step-size for range must be non-zero.': function() {
      return "";
    },
    'range expects at most three arguments': function() {
      return "";
    },
    '_ cannot take a negative number.': function(primName) {
      return `${primName} `;
    },
    // Dynamic Calls (TU)
    'Cannot find the procedure _.': function(procedureName) {
      return ` ${procedureName}.`;
    }
  };

  module.exports = bundle;

}).call(this);

},{}],"meta":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  module.exports = {
    isApplet: false,
    isWeb: true,
    behaviorSpaceName: "",
    behaviorSpaceRun: 0,
    // for any explorer who finds this and is wanting to update the `netlogo-version`, know that this is just a placeholder
    // and should be overwritten by a version provided to the workspace via `modelConfig`.  -JMB March 2018
    version: "1.0"
  };

}).call(this);

},{}],"mori":[function(require,module,exports){
(function(definition){if(typeof exports==="object"){module.exports=definition();}else if(typeof define==="function"&&define.amd){define(definition);}else{mori=definition();}})(function(){return function(){
if(typeof Math.imul == "undefined" || (Math.imul(0xffffffff,5) == 0)) {
    Math.imul = function (a, b) {
        var ah  = (a >>> 16) & 0xffff;
        var al = a & 0xffff;
        var bh  = (b >>> 16) & 0xffff;
        var bl = b & 0xffff;
        // the shift by 0 fixes the sign on the high part
        // the final |0 converts the unsigned value into a signed value
        return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0)|0);
    }
}

var k,aa=this;
function n(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";else if("function"==
b&&"undefined"==typeof a.call)return"object";return b}var ba="closure_uid_"+(1E9*Math.random()>>>0),ca=0;function r(a,b){var c=a.split("."),d=aa;c[0]in d||!d.execScript||d.execScript("var "+c[0]);for(var e;c.length&&(e=c.shift());)c.length||void 0===b?d=d[e]?d[e]:d[e]={}:d[e]=b};function da(a){return Array.prototype.join.call(arguments,"")};function ea(a,b){for(var c in a)b.call(void 0,a[c],c,a)};function fa(a,b){null!=a&&this.append.apply(this,arguments)}fa.prototype.Za="";fa.prototype.append=function(a,b,c){this.Za+=a;if(null!=b)for(var d=1;d<arguments.length;d++)this.Za+=arguments[d];return this};fa.prototype.clear=function(){this.Za=""};fa.prototype.toString=function(){return this.Za};function ga(a,b){a.sort(b||ha)}function ia(a,b){for(var c=0;c<a.length;c++)a[c]={index:c,value:a[c]};var d=b||ha;ga(a,function(a,b){return d(a.value,b.value)||a.index-b.index});for(c=0;c<a.length;c++)a[c]=a[c].value}function ha(a,b){return a>b?1:a<b?-1:0};var ja;if("undefined"===typeof ka)var ka=function(){throw Error("No *print-fn* fn set for evaluation environment");};var la=null,ma=null;if("undefined"===typeof na)var na=null;function oa(){return new pa(null,5,[sa,!0,ua,!0,wa,!1,ya,!1,za,la],null)}function t(a){return null!=a&&!1!==a}function Aa(a){return t(a)?!1:!0}function w(a,b){return a[n(null==b?null:b)]?!0:a._?!0:!1}function Ba(a){return null==a?null:a.constructor}
function x(a,b){var c=Ba(b),c=t(t(c)?c.Yb:c)?c.Xb:n(b);return Error(["No protocol method ",a," defined for type ",c,": ",b].join(""))}function Da(a){var b=a.Xb;return t(b)?b:""+z(a)}var Ea="undefined"!==typeof Symbol&&"function"===n(Symbol)?Symbol.Cc:"@@iterator";function Fa(a){for(var b=a.length,c=Array(b),d=0;;)if(d<b)c[d]=a[d],d+=1;else break;return c}function Ha(a){for(var b=Array(arguments.length),c=0;;)if(c<b.length)b[c]=arguments[c],c+=1;else return b}
var Ia=function(){function a(a,b){function c(a,b){a.push(b);return a}var g=[];return A.c?A.c(c,g,b):A.call(null,c,g,b)}function b(a){return c.a(null,a)}var c=null,c=function(d,c){switch(arguments.length){case 1:return b.call(this,d);case 2:return a.call(this,0,c)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),Ja={},La={};function Ma(a){if(a?a.L:a)return a.L(a);var b;b=Ma[n(null==a?null:a)];if(!b&&(b=Ma._,!b))throw x("ICounted.-count",a);return b.call(null,a)}
function Na(a){if(a?a.J:a)return a.J(a);var b;b=Na[n(null==a?null:a)];if(!b&&(b=Na._,!b))throw x("IEmptyableCollection.-empty",a);return b.call(null,a)}var Qa={};function Ra(a,b){if(a?a.G:a)return a.G(a,b);var c;c=Ra[n(null==a?null:a)];if(!c&&(c=Ra._,!c))throw x("ICollection.-conj",a);return c.call(null,a,b)}
var Ta={},C=function(){function a(a,b,c){if(a?a.$:a)return a.$(a,b,c);var g;g=C[n(null==a?null:a)];if(!g&&(g=C._,!g))throw x("IIndexed.-nth",a);return g.call(null,a,b,c)}function b(a,b){if(a?a.Q:a)return a.Q(a,b);var c;c=C[n(null==a?null:a)];if(!c&&(c=C._,!c))throw x("IIndexed.-nth",a);return c.call(null,a,b)}var c=null,c=function(d,c,f){switch(arguments.length){case 2:return b.call(this,d,c);case 3:return a.call(this,d,c,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}(),
Ua={};function Va(a){if(a?a.N:a)return a.N(a);var b;b=Va[n(null==a?null:a)];if(!b&&(b=Va._,!b))throw x("ISeq.-first",a);return b.call(null,a)}function Wa(a){if(a?a.S:a)return a.S(a);var b;b=Wa[n(null==a?null:a)];if(!b&&(b=Wa._,!b))throw x("ISeq.-rest",a);return b.call(null,a)}
var Xa={},Za={},$a=function(){function a(a,b,c){if(a?a.s:a)return a.s(a,b,c);var g;g=$a[n(null==a?null:a)];if(!g&&(g=$a._,!g))throw x("ILookup.-lookup",a);return g.call(null,a,b,c)}function b(a,b){if(a?a.t:a)return a.t(a,b);var c;c=$a[n(null==a?null:a)];if(!c&&(c=$a._,!c))throw x("ILookup.-lookup",a);return c.call(null,a,b)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=
a;return c}(),ab={};function bb(a,b){if(a?a.rb:a)return a.rb(a,b);var c;c=bb[n(null==a?null:a)];if(!c&&(c=bb._,!c))throw x("IAssociative.-contains-key?",a);return c.call(null,a,b)}function cb(a,b,c){if(a?a.Ka:a)return a.Ka(a,b,c);var d;d=cb[n(null==a?null:a)];if(!d&&(d=cb._,!d))throw x("IAssociative.-assoc",a);return d.call(null,a,b,c)}var db={};function eb(a,b){if(a?a.wb:a)return a.wb(a,b);var c;c=eb[n(null==a?null:a)];if(!c&&(c=eb._,!c))throw x("IMap.-dissoc",a);return c.call(null,a,b)}var fb={};
function hb(a){if(a?a.hb:a)return a.hb(a);var b;b=hb[n(null==a?null:a)];if(!b&&(b=hb._,!b))throw x("IMapEntry.-key",a);return b.call(null,a)}function ib(a){if(a?a.ib:a)return a.ib(a);var b;b=ib[n(null==a?null:a)];if(!b&&(b=ib._,!b))throw x("IMapEntry.-val",a);return b.call(null,a)}var jb={};function kb(a,b){if(a?a.Eb:a)return a.Eb(a,b);var c;c=kb[n(null==a?null:a)];if(!c&&(c=kb._,!c))throw x("ISet.-disjoin",a);return c.call(null,a,b)}
function lb(a){if(a?a.La:a)return a.La(a);var b;b=lb[n(null==a?null:a)];if(!b&&(b=lb._,!b))throw x("IStack.-peek",a);return b.call(null,a)}function mb(a){if(a?a.Ma:a)return a.Ma(a);var b;b=mb[n(null==a?null:a)];if(!b&&(b=mb._,!b))throw x("IStack.-pop",a);return b.call(null,a)}var nb={};function pb(a,b,c){if(a?a.Ua:a)return a.Ua(a,b,c);var d;d=pb[n(null==a?null:a)];if(!d&&(d=pb._,!d))throw x("IVector.-assoc-n",a);return d.call(null,a,b,c)}
function qb(a){if(a?a.Ra:a)return a.Ra(a);var b;b=qb[n(null==a?null:a)];if(!b&&(b=qb._,!b))throw x("IDeref.-deref",a);return b.call(null,a)}var rb={};function sb(a){if(a?a.H:a)return a.H(a);var b;b=sb[n(null==a?null:a)];if(!b&&(b=sb._,!b))throw x("IMeta.-meta",a);return b.call(null,a)}var tb={};function ub(a,b){if(a?a.F:a)return a.F(a,b);var c;c=ub[n(null==a?null:a)];if(!c&&(c=ub._,!c))throw x("IWithMeta.-with-meta",a);return c.call(null,a,b)}
var vb={},wb=function(){function a(a,b,c){if(a?a.O:a)return a.O(a,b,c);var g;g=wb[n(null==a?null:a)];if(!g&&(g=wb._,!g))throw x("IReduce.-reduce",a);return g.call(null,a,b,c)}function b(a,b){if(a?a.R:a)return a.R(a,b);var c;c=wb[n(null==a?null:a)];if(!c&&(c=wb._,!c))throw x("IReduce.-reduce",a);return c.call(null,a,b)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}();
function xb(a,b,c){if(a?a.gb:a)return a.gb(a,b,c);var d;d=xb[n(null==a?null:a)];if(!d&&(d=xb._,!d))throw x("IKVReduce.-kv-reduce",a);return d.call(null,a,b,c)}function yb(a,b){if(a?a.A:a)return a.A(a,b);var c;c=yb[n(null==a?null:a)];if(!c&&(c=yb._,!c))throw x("IEquiv.-equiv",a);return c.call(null,a,b)}function zb(a){if(a?a.B:a)return a.B(a);var b;b=zb[n(null==a?null:a)];if(!b&&(b=zb._,!b))throw x("IHash.-hash",a);return b.call(null,a)}var Bb={};
function Cb(a){if(a?a.D:a)return a.D(a);var b;b=Cb[n(null==a?null:a)];if(!b&&(b=Cb._,!b))throw x("ISeqable.-seq",a);return b.call(null,a)}var Db={},Eb={},Fb={};function Gb(a){if(a?a.ab:a)return a.ab(a);var b;b=Gb[n(null==a?null:a)];if(!b&&(b=Gb._,!b))throw x("IReversible.-rseq",a);return b.call(null,a)}function Hb(a,b){if(a?a.Hb:a)return a.Hb(a,b);var c;c=Hb[n(null==a?null:a)];if(!c&&(c=Hb._,!c))throw x("ISorted.-sorted-seq",a);return c.call(null,a,b)}
function Ib(a,b,c){if(a?a.Ib:a)return a.Ib(a,b,c);var d;d=Ib[n(null==a?null:a)];if(!d&&(d=Ib._,!d))throw x("ISorted.-sorted-seq-from",a);return d.call(null,a,b,c)}function Jb(a,b){if(a?a.Gb:a)return a.Gb(a,b);var c;c=Jb[n(null==a?null:a)];if(!c&&(c=Jb._,!c))throw x("ISorted.-entry-key",a);return c.call(null,a,b)}function Kb(a){if(a?a.Fb:a)return a.Fb(a);var b;b=Kb[n(null==a?null:a)];if(!b&&(b=Kb._,!b))throw x("ISorted.-comparator",a);return b.call(null,a)}
function Lb(a,b){if(a?a.Wb:a)return a.Wb(0,b);var c;c=Lb[n(null==a?null:a)];if(!c&&(c=Lb._,!c))throw x("IWriter.-write",a);return c.call(null,a,b)}var Mb={};function Nb(a,b,c){if(a?a.v:a)return a.v(a,b,c);var d;d=Nb[n(null==a?null:a)];if(!d&&(d=Nb._,!d))throw x("IPrintWithWriter.-pr-writer",a);return d.call(null,a,b,c)}function Ob(a){if(a?a.$a:a)return a.$a(a);var b;b=Ob[n(null==a?null:a)];if(!b&&(b=Ob._,!b))throw x("IEditableCollection.-as-transient",a);return b.call(null,a)}
function Pb(a,b){if(a?a.Sa:a)return a.Sa(a,b);var c;c=Pb[n(null==a?null:a)];if(!c&&(c=Pb._,!c))throw x("ITransientCollection.-conj!",a);return c.call(null,a,b)}function Qb(a){if(a?a.Ta:a)return a.Ta(a);var b;b=Qb[n(null==a?null:a)];if(!b&&(b=Qb._,!b))throw x("ITransientCollection.-persistent!",a);return b.call(null,a)}function Rb(a,b,c){if(a?a.kb:a)return a.kb(a,b,c);var d;d=Rb[n(null==a?null:a)];if(!d&&(d=Rb._,!d))throw x("ITransientAssociative.-assoc!",a);return d.call(null,a,b,c)}
function Sb(a,b){if(a?a.Jb:a)return a.Jb(a,b);var c;c=Sb[n(null==a?null:a)];if(!c&&(c=Sb._,!c))throw x("ITransientMap.-dissoc!",a);return c.call(null,a,b)}function Tb(a,b,c){if(a?a.Ub:a)return a.Ub(0,b,c);var d;d=Tb[n(null==a?null:a)];if(!d&&(d=Tb._,!d))throw x("ITransientVector.-assoc-n!",a);return d.call(null,a,b,c)}function Ub(a){if(a?a.Vb:a)return a.Vb();var b;b=Ub[n(null==a?null:a)];if(!b&&(b=Ub._,!b))throw x("ITransientVector.-pop!",a);return b.call(null,a)}
function Vb(a,b){if(a?a.Tb:a)return a.Tb(0,b);var c;c=Vb[n(null==a?null:a)];if(!c&&(c=Vb._,!c))throw x("ITransientSet.-disjoin!",a);return c.call(null,a,b)}function Xb(a){if(a?a.Pb:a)return a.Pb();var b;b=Xb[n(null==a?null:a)];if(!b&&(b=Xb._,!b))throw x("IChunk.-drop-first",a);return b.call(null,a)}function Yb(a){if(a?a.Cb:a)return a.Cb(a);var b;b=Yb[n(null==a?null:a)];if(!b&&(b=Yb._,!b))throw x("IChunkedSeq.-chunked-first",a);return b.call(null,a)}
function Zb(a){if(a?a.Db:a)return a.Db(a);var b;b=Zb[n(null==a?null:a)];if(!b&&(b=Zb._,!b))throw x("IChunkedSeq.-chunked-rest",a);return b.call(null,a)}function $b(a){if(a?a.Bb:a)return a.Bb(a);var b;b=$b[n(null==a?null:a)];if(!b&&(b=$b._,!b))throw x("IChunkedNext.-chunked-next",a);return b.call(null,a)}function ac(a,b){if(a?a.bb:a)return a.bb(0,b);var c;c=ac[n(null==a?null:a)];if(!c&&(c=ac._,!c))throw x("IVolatile.-vreset!",a);return c.call(null,a,b)}var bc={};
function cc(a){if(a?a.fb:a)return a.fb(a);var b;b=cc[n(null==a?null:a)];if(!b&&(b=cc._,!b))throw x("IIterable.-iterator",a);return b.call(null,a)}function dc(a){this.qc=a;this.q=0;this.j=1073741824}dc.prototype.Wb=function(a,b){return this.qc.append(b)};function ec(a){var b=new fa;a.v(null,new dc(b),oa());return""+z(b)}
var fc="undefined"!==typeof Math.imul&&0!==(Math.imul.a?Math.imul.a(4294967295,5):Math.imul.call(null,4294967295,5))?function(a,b){return Math.imul.a?Math.imul.a(a,b):Math.imul.call(null,a,b)}:function(a,b){var c=a&65535,d=b&65535;return c*d+((a>>>16&65535)*d+c*(b>>>16&65535)<<16>>>0)|0};function gc(a){a=fc(a,3432918353);return fc(a<<15|a>>>-15,461845907)}function hc(a,b){var c=a^b;return fc(c<<13|c>>>-13,5)+3864292196}
function ic(a,b){var c=a^b,c=fc(c^c>>>16,2246822507),c=fc(c^c>>>13,3266489909);return c^c>>>16}var kc={},lc=0;function mc(a){255<lc&&(kc={},lc=0);var b=kc[a];if("number"!==typeof b){a:if(null!=a)if(b=a.length,0<b){for(var c=0,d=0;;)if(c<b)var e=c+1,d=fc(31,d)+a.charCodeAt(c),c=e;else{b=d;break a}b=void 0}else b=0;else b=0;kc[a]=b;lc+=1}return a=b}
function nc(a){a&&(a.j&4194304||a.vc)?a=a.B(null):"number"===typeof a?a=(Math.floor.b?Math.floor.b(a):Math.floor.call(null,a))%2147483647:!0===a?a=1:!1===a?a=0:"string"===typeof a?(a=mc(a),0!==a&&(a=gc(a),a=hc(0,a),a=ic(a,4))):a=a instanceof Date?a.valueOf():null==a?0:zb(a);return a}
function oc(a){var b;b=a.name;var c;a:{c=1;for(var d=0;;)if(c<b.length){var e=c+2,d=hc(d,gc(b.charCodeAt(c-1)|b.charCodeAt(c)<<16));c=e}else{c=d;break a}c=void 0}c=1===(b.length&1)?c^gc(b.charCodeAt(b.length-1)):c;b=ic(c,fc(2,b.length));a=mc(a.ba);return b^a+2654435769+(b<<6)+(b>>2)}function pc(a,b){if(a.ta===b.ta)return 0;var c=Aa(a.ba);if(t(c?b.ba:c))return-1;if(t(a.ba)){if(Aa(b.ba))return 1;c=ha(a.ba,b.ba);return 0===c?ha(a.name,b.name):c}return ha(a.name,b.name)}
function qc(a,b,c,d,e){this.ba=a;this.name=b;this.ta=c;this.Ya=d;this.Z=e;this.j=2154168321;this.q=4096}k=qc.prototype;k.v=function(a,b){return Lb(b,this.ta)};k.B=function(){var a=this.Ya;return null!=a?a:this.Ya=a=oc(this)};k.F=function(a,b){return new qc(this.ba,this.name,this.ta,this.Ya,b)};k.H=function(){return this.Z};
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return $a.c(c,this,null);case 3:return $a.c(c,this,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return $a.c(c,this,null)};a.c=function(a,c,d){return $a.c(c,this,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return $a.c(a,this,null)};k.a=function(a,b){return $a.c(a,this,b)};k.A=function(a,b){return b instanceof qc?this.ta===b.ta:!1};
k.toString=function(){return this.ta};var rc=function(){function a(a,b){var c=null!=a?[z(a),z("/"),z(b)].join(""):b;return new qc(a,b,c,null,null)}function b(a){return a instanceof qc?a:c.a(null,a)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}();
function D(a){if(null==a)return null;if(a&&(a.j&8388608||a.mc))return a.D(null);if(a instanceof Array||"string"===typeof a)return 0===a.length?null:new F(a,0);if(w(Bb,a))return Cb(a);throw Error([z(a),z(" is not ISeqable")].join(""));}function G(a){if(null==a)return null;if(a&&(a.j&64||a.jb))return a.N(null);a=D(a);return null==a?null:Va(a)}function H(a){return null!=a?a&&(a.j&64||a.jb)?a.S(null):(a=D(a))?Wa(a):J:J}function K(a){return null==a?null:a&&(a.j&128||a.xb)?a.T(null):D(H(a))}
var sc=function(){function a(a,b){return null==a?null==b:a===b||yb(a,b)}var b=null,c=function(){function a(b,d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return c.call(this,b,d,l)}function c(a,d,e){for(;;)if(b.a(a,d))if(K(e))a=d,d=G(e),e=K(e);else return b.a(d,G(e));else return!1}a.i=2;a.f=function(a){var b=G(a);a=K(a);var d=G(a);a=H(a);return c(b,d,a)};a.d=c;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return!0;
case 2:return a.call(this,b,e);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.b=function(){return!0};b.a=a;b.d=c.d;return b}();function tc(a){this.C=a}tc.prototype.next=function(){if(null!=this.C){var a=G(this.C);this.C=K(this.C);return{done:!1,value:a}}return{done:!0,value:null}};function uc(a){return new tc(D(a))}
function vc(a,b){var c=gc(a),c=hc(0,c);return ic(c,b)}function wc(a){var b=0,c=1;for(a=D(a);;)if(null!=a)b+=1,c=fc(31,c)+nc(G(a))|0,a=K(a);else return vc(c,b)}function xc(a){var b=0,c=0;for(a=D(a);;)if(null!=a)b+=1,c=c+nc(G(a))|0,a=K(a);else return vc(c,b)}La["null"]=!0;Ma["null"]=function(){return 0};Date.prototype.A=function(a,b){return b instanceof Date&&this.toString()===b.toString()};yb.number=function(a,b){return a===b};rb["function"]=!0;sb["function"]=function(){return null};
Ja["function"]=!0;zb._=function(a){return a[ba]||(a[ba]=++ca)};function yc(a){this.o=a;this.q=0;this.j=32768}yc.prototype.Ra=function(){return this.o};function Ac(a){return a instanceof yc}function Bc(a){return Ac(a)?L.b?L.b(a):L.call(null,a):a}function L(a){return qb(a)}
var Cc=function(){function a(a,b,c,d){for(var l=Ma(a);;)if(d<l){var m=C.a(a,d);c=b.a?b.a(c,m):b.call(null,c,m);if(Ac(c))return qb(c);d+=1}else return c}function b(a,b,c){var d=Ma(a),l=c;for(c=0;;)if(c<d){var m=C.a(a,c),l=b.a?b.a(l,m):b.call(null,l,m);if(Ac(l))return qb(l);c+=1}else return l}function c(a,b){var c=Ma(a);if(0===c)return b.l?b.l():b.call(null);for(var d=C.a(a,0),l=1;;)if(l<c){var m=C.a(a,l),d=b.a?b.a(d,m):b.call(null,d,m);if(Ac(d))return qb(d);l+=1}else return d}var d=null,d=function(d,
f,g,h){switch(arguments.length){case 2:return c.call(this,d,f);case 3:return b.call(this,d,f,g);case 4:return a.call(this,d,f,g,h)}throw Error("Invalid arity: "+arguments.length);};d.a=c;d.c=b;d.n=a;return d}(),Dc=function(){function a(a,b,c,d){for(var l=a.length;;)if(d<l){var m=a[d];c=b.a?b.a(c,m):b.call(null,c,m);if(Ac(c))return qb(c);d+=1}else return c}function b(a,b,c){var d=a.length,l=c;for(c=0;;)if(c<d){var m=a[c],l=b.a?b.a(l,m):b.call(null,l,m);if(Ac(l))return qb(l);c+=1}else return l}function c(a,
b){var c=a.length;if(0===a.length)return b.l?b.l():b.call(null);for(var d=a[0],l=1;;)if(l<c){var m=a[l],d=b.a?b.a(d,m):b.call(null,d,m);if(Ac(d))return qb(d);l+=1}else return d}var d=null,d=function(d,f,g,h){switch(arguments.length){case 2:return c.call(this,d,f);case 3:return b.call(this,d,f,g);case 4:return a.call(this,d,f,g,h)}throw Error("Invalid arity: "+arguments.length);};d.a=c;d.c=b;d.n=a;return d}();function Ec(a){return a?a.j&2||a.cc?!0:a.j?!1:w(La,a):w(La,a)}
function Fc(a){return a?a.j&16||a.Qb?!0:a.j?!1:w(Ta,a):w(Ta,a)}function Gc(a,b){this.e=a;this.m=b}Gc.prototype.ga=function(){return this.m<this.e.length};Gc.prototype.next=function(){var a=this.e[this.m];this.m+=1;return a};function F(a,b){this.e=a;this.m=b;this.j=166199550;this.q=8192}k=F.prototype;k.toString=function(){return ec(this)};k.Q=function(a,b){var c=b+this.m;return c<this.e.length?this.e[c]:null};k.$=function(a,b,c){a=b+this.m;return a<this.e.length?this.e[a]:c};k.vb=!0;
k.fb=function(){return new Gc(this.e,this.m)};k.T=function(){return this.m+1<this.e.length?new F(this.e,this.m+1):null};k.L=function(){return this.e.length-this.m};k.ab=function(){var a=Ma(this);return 0<a?new Hc(this,a-1,null):null};k.B=function(){return wc(this)};k.A=function(a,b){return Ic.a?Ic.a(this,b):Ic.call(null,this,b)};k.J=function(){return J};k.R=function(a,b){return Dc.n(this.e,b,this.e[this.m],this.m+1)};k.O=function(a,b,c){return Dc.n(this.e,b,c,this.m)};k.N=function(){return this.e[this.m]};
k.S=function(){return this.m+1<this.e.length?new F(this.e,this.m+1):J};k.D=function(){return this};k.G=function(a,b){return M.a?M.a(b,this):M.call(null,b,this)};F.prototype[Ea]=function(){return uc(this)};
var Jc=function(){function a(a,b){return b<a.length?new F(a,b):null}function b(a){return c.a(a,0)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),Kc=function(){function a(a,b){return Jc.a(a,b)}function b(a){return Jc.a(a,0)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+
arguments.length);};c.b=b;c.a=a;return c}();function Hc(a,b,c){this.qb=a;this.m=b;this.k=c;this.j=32374990;this.q=8192}k=Hc.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.k};k.T=function(){return 0<this.m?new Hc(this.qb,this.m-1,null):null};k.L=function(){return this.m+1};k.B=function(){return wc(this)};k.A=function(a,b){return Ic.a?Ic.a(this,b):Ic.call(null,this,b)};k.J=function(){var a=this.k;return O.a?O.a(J,a):O.call(null,J,a)};
k.R=function(a,b){return P.a?P.a(b,this):P.call(null,b,this)};k.O=function(a,b,c){return P.c?P.c(b,c,this):P.call(null,b,c,this)};k.N=function(){return C.a(this.qb,this.m)};k.S=function(){return 0<this.m?new Hc(this.qb,this.m-1,null):J};k.D=function(){return this};k.F=function(a,b){return new Hc(this.qb,this.m,b)};k.G=function(a,b){return M.a?M.a(b,this):M.call(null,b,this)};Hc.prototype[Ea]=function(){return uc(this)};function Lc(a){return G(K(a))}yb._=function(a,b){return a===b};
var Nc=function(){function a(a,b){return null!=a?Ra(a,b):Ra(J,b)}var b=null,c=function(){function a(b,d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return c.call(this,b,d,l)}function c(a,d,e){for(;;)if(t(e))a=b.a(a,d),d=G(e),e=K(e);else return b.a(a,d)}a.i=2;a.f=function(a){var b=G(a);a=K(a);var d=G(a);a=H(a);return c(b,d,a)};a.d=c;return a}(),b=function(b,e,f){switch(arguments.length){case 0:return Mc;case 1:return b;
case 2:return a.call(this,b,e);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.l=function(){return Mc};b.b=function(a){return a};b.a=a;b.d=c.d;return b}();function Oc(a){return null==a?null:Na(a)}
function Q(a){if(null!=a)if(a&&(a.j&2||a.cc))a=a.L(null);else if(a instanceof Array)a=a.length;else if("string"===typeof a)a=a.length;else if(w(La,a))a=Ma(a);else a:{a=D(a);for(var b=0;;){if(Ec(a)){a=b+Ma(a);break a}a=K(a);b+=1}a=void 0}else a=0;return a}
var Pc=function(){function a(a,b,c){for(;;){if(null==a)return c;if(0===b)return D(a)?G(a):c;if(Fc(a))return C.c(a,b,c);if(D(a))a=K(a),b-=1;else return c}}function b(a,b){for(;;){if(null==a)throw Error("Index out of bounds");if(0===b){if(D(a))return G(a);throw Error("Index out of bounds");}if(Fc(a))return C.a(a,b);if(D(a)){var c=K(a),g=b-1;a=c;b=g}else throw Error("Index out of bounds");}}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,
c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}(),R=function(){function a(a,b,c){if("number"!==typeof b)throw Error("index argument to nth must be a number.");if(null==a)return c;if(a&&(a.j&16||a.Qb))return a.$(null,b,c);if(a instanceof Array||"string"===typeof a)return b<a.length?a[b]:c;if(w(Ta,a))return C.a(a,b);if(a?a.j&64||a.jb||(a.j?0:w(Ua,a)):w(Ua,a))return Pc.c(a,b,c);throw Error([z("nth not supported on this type "),z(Da(Ba(a)))].join(""));}function b(a,b){if("number"!==
typeof b)throw Error("index argument to nth must be a number");if(null==a)return a;if(a&&(a.j&16||a.Qb))return a.Q(null,b);if(a instanceof Array||"string"===typeof a)return b<a.length?a[b]:null;if(w(Ta,a))return C.a(a,b);if(a?a.j&64||a.jb||(a.j?0:w(Ua,a)):w(Ua,a))return Pc.a(a,b);throw Error([z("nth not supported on this type "),z(Da(Ba(a)))].join(""));}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+
arguments.length);};c.a=b;c.c=a;return c}(),S=function(){function a(a,b,c){return null!=a?a&&(a.j&256||a.Rb)?a.s(null,b,c):a instanceof Array?b<a.length?a[b]:c:"string"===typeof a?b<a.length?a[b]:c:w(Za,a)?$a.c(a,b,c):c:c}function b(a,b){return null==a?null:a&&(a.j&256||a.Rb)?a.t(null,b):a instanceof Array?b<a.length?a[b]:null:"string"===typeof a?b<a.length?a[b]:null:w(Za,a)?$a.a(a,b):null}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,
c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}(),Rc=function(){function a(a,b,c){if(null!=a)a=cb(a,b,c);else a:{a=[b];c=[c];b=a.length;for(var g=0,h=Ob(Qc);;)if(g<b)var l=g+1,h=h.kb(null,a[g],c[g]),g=l;else{a=Qb(h);break a}a=void 0}return a}var b=null,c=function(){function a(b,d,h,l){var m=null;if(3<arguments.length){for(var m=0,p=Array(arguments.length-3);m<p.length;)p[m]=arguments[m+3],++m;m=new F(p,0)}return c.call(this,b,d,h,m)}function c(a,d,e,l){for(;;)if(a=b.c(a,
d,e),t(l))d=G(l),e=Lc(l),l=K(K(l));else return a}a.i=3;a.f=function(a){var b=G(a);a=K(a);var d=G(a);a=K(a);var l=G(a);a=H(a);return c(b,d,l,a)};a.d=c;return a}(),b=function(b,e,f,g){switch(arguments.length){case 3:return a.call(this,b,e,f);default:var h=null;if(3<arguments.length){for(var h=0,l=Array(arguments.length-3);h<l.length;)l[h]=arguments[h+3],++h;h=new F(l,0)}return c.d(b,e,f,h)}throw Error("Invalid arity: "+arguments.length);};b.i=3;b.f=c.f;b.c=a;b.d=c.d;return b}(),Sc=function(){function a(a,
b){return null==a?null:eb(a,b)}var b=null,c=function(){function a(b,d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return c.call(this,b,d,l)}function c(a,d,e){for(;;){if(null==a)return null;a=b.a(a,d);if(t(e))d=G(e),e=K(e);else return a}}a.i=2;a.f=function(a){var b=G(a);a=K(a);var d=G(a);a=H(a);return c(b,d,a)};a.d=c;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return b;case 2:return a.call(this,b,e);
default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.b=function(a){return a};b.a=a;b.d=c.d;return b}();function Tc(a){var b="function"==n(a);return t(b)?b:a?t(t(null)?null:a.bc)?!0:a.yb?!1:w(Ja,a):w(Ja,a)}function Uc(a,b){this.h=a;this.k=b;this.q=0;this.j=393217}k=Uc.prototype;
k.call=function(){function a(a,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N,Y,ra,I){a=this.h;return T.ub?T.ub(a,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N,Y,ra,I):T.call(null,a,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N,Y,ra,I)}function b(a,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N,Y,ra){a=this;return a.h.Fa?a.h.Fa(b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N,Y,ra):a.h.call(null,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N,Y,ra)}function c(a,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N,Y){a=this;return a.h.Ea?a.h.Ea(b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N,
Y):a.h.call(null,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N,Y)}function d(a,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N){a=this;return a.h.Da?a.h.Da(b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N):a.h.call(null,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E,N)}function e(a,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E){a=this;return a.h.Ca?a.h.Ca(b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E):a.h.call(null,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B,E)}function f(a,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B){a=this;return a.h.Ba?a.h.Ba(b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B):a.h.call(null,
b,c,d,e,f,g,h,l,m,p,q,u,s,v,y,B)}function g(a,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y){a=this;return a.h.Aa?a.h.Aa(b,c,d,e,f,g,h,l,m,p,q,u,s,v,y):a.h.call(null,b,c,d,e,f,g,h,l,m,p,q,u,s,v,y)}function h(a,b,c,d,e,f,g,h,l,m,p,q,u,s,v){a=this;return a.h.za?a.h.za(b,c,d,e,f,g,h,l,m,p,q,u,s,v):a.h.call(null,b,c,d,e,f,g,h,l,m,p,q,u,s,v)}function l(a,b,c,d,e,f,g,h,l,m,p,q,u,s){a=this;return a.h.ya?a.h.ya(b,c,d,e,f,g,h,l,m,p,q,u,s):a.h.call(null,b,c,d,e,f,g,h,l,m,p,q,u,s)}function m(a,b,c,d,e,f,g,h,l,m,p,q,u){a=this;
return a.h.xa?a.h.xa(b,c,d,e,f,g,h,l,m,p,q,u):a.h.call(null,b,c,d,e,f,g,h,l,m,p,q,u)}function p(a,b,c,d,e,f,g,h,l,m,p,q){a=this;return a.h.wa?a.h.wa(b,c,d,e,f,g,h,l,m,p,q):a.h.call(null,b,c,d,e,f,g,h,l,m,p,q)}function q(a,b,c,d,e,f,g,h,l,m,p){a=this;return a.h.va?a.h.va(b,c,d,e,f,g,h,l,m,p):a.h.call(null,b,c,d,e,f,g,h,l,m,p)}function s(a,b,c,d,e,f,g,h,l,m){a=this;return a.h.Ha?a.h.Ha(b,c,d,e,f,g,h,l,m):a.h.call(null,b,c,d,e,f,g,h,l,m)}function u(a,b,c,d,e,f,g,h,l){a=this;return a.h.Ga?a.h.Ga(b,c,
d,e,f,g,h,l):a.h.call(null,b,c,d,e,f,g,h,l)}function v(a,b,c,d,e,f,g,h){a=this;return a.h.ia?a.h.ia(b,c,d,e,f,g,h):a.h.call(null,b,c,d,e,f,g,h)}function y(a,b,c,d,e,f,g){a=this;return a.h.P?a.h.P(b,c,d,e,f,g):a.h.call(null,b,c,d,e,f,g)}function B(a,b,c,d,e,f){a=this;return a.h.r?a.h.r(b,c,d,e,f):a.h.call(null,b,c,d,e,f)}function E(a,b,c,d,e){a=this;return a.h.n?a.h.n(b,c,d,e):a.h.call(null,b,c,d,e)}function N(a,b,c,d){a=this;return a.h.c?a.h.c(b,c,d):a.h.call(null,b,c,d)}function Y(a,b,c){a=this;
return a.h.a?a.h.a(b,c):a.h.call(null,b,c)}function ra(a,b){a=this;return a.h.b?a.h.b(b):a.h.call(null,b)}function Pa(a){a=this;return a.h.l?a.h.l():a.h.call(null)}var I=null,I=function(I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,ob,Ab,Wb,jc,zc,Zc,Gd,De,Wf,dh){switch(arguments.length){case 1:return Pa.call(this,I);case 2:return ra.call(this,I,qa);case 3:return Y.call(this,I,qa,ta);case 4:return N.call(this,I,qa,ta,va);case 5:return E.call(this,I,qa,ta,va,xa);case 6:return B.call(this,I,qa,ta,va,xa,Ca);case 7:return y.call(this,
I,qa,ta,va,xa,Ca,Ga);case 8:return v.call(this,I,qa,ta,va,xa,Ca,Ga,Ka);case 9:return u.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa);case 10:return s.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa);case 11:return q.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya);case 12:return p.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb);case 13:return m.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,ob);case 14:return l.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,ob,Ab);case 15:return h.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,
ob,Ab,Wb);case 16:return g.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,ob,Ab,Wb,jc);case 17:return f.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,ob,Ab,Wb,jc,zc);case 18:return e.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,ob,Ab,Wb,jc,zc,Zc);case 19:return d.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,ob,Ab,Wb,jc,zc,Zc,Gd);case 20:return c.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,ob,Ab,Wb,jc,zc,Zc,Gd,De);case 21:return b.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,ob,Ab,Wb,jc,zc,Zc,Gd,De,
Wf);case 22:return a.call(this,I,qa,ta,va,xa,Ca,Ga,Ka,Oa,Sa,Ya,gb,ob,Ab,Wb,jc,zc,Zc,Gd,De,Wf,dh)}throw Error("Invalid arity: "+arguments.length);};I.b=Pa;I.a=ra;I.c=Y;I.n=N;I.r=E;I.P=B;I.ia=y;I.Ga=v;I.Ha=u;I.va=s;I.wa=q;I.xa=p;I.ya=m;I.za=l;I.Aa=h;I.Ba=g;I.Ca=f;I.Da=e;I.Ea=d;I.Fa=c;I.hc=b;I.ub=a;return I}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.l=function(){return this.h.l?this.h.l():this.h.call(null)};
k.b=function(a){return this.h.b?this.h.b(a):this.h.call(null,a)};k.a=function(a,b){return this.h.a?this.h.a(a,b):this.h.call(null,a,b)};k.c=function(a,b,c){return this.h.c?this.h.c(a,b,c):this.h.call(null,a,b,c)};k.n=function(a,b,c,d){return this.h.n?this.h.n(a,b,c,d):this.h.call(null,a,b,c,d)};k.r=function(a,b,c,d,e){return this.h.r?this.h.r(a,b,c,d,e):this.h.call(null,a,b,c,d,e)};k.P=function(a,b,c,d,e,f){return this.h.P?this.h.P(a,b,c,d,e,f):this.h.call(null,a,b,c,d,e,f)};
k.ia=function(a,b,c,d,e,f,g){return this.h.ia?this.h.ia(a,b,c,d,e,f,g):this.h.call(null,a,b,c,d,e,f,g)};k.Ga=function(a,b,c,d,e,f,g,h){return this.h.Ga?this.h.Ga(a,b,c,d,e,f,g,h):this.h.call(null,a,b,c,d,e,f,g,h)};k.Ha=function(a,b,c,d,e,f,g,h,l){return this.h.Ha?this.h.Ha(a,b,c,d,e,f,g,h,l):this.h.call(null,a,b,c,d,e,f,g,h,l)};k.va=function(a,b,c,d,e,f,g,h,l,m){return this.h.va?this.h.va(a,b,c,d,e,f,g,h,l,m):this.h.call(null,a,b,c,d,e,f,g,h,l,m)};
k.wa=function(a,b,c,d,e,f,g,h,l,m,p){return this.h.wa?this.h.wa(a,b,c,d,e,f,g,h,l,m,p):this.h.call(null,a,b,c,d,e,f,g,h,l,m,p)};k.xa=function(a,b,c,d,e,f,g,h,l,m,p,q){return this.h.xa?this.h.xa(a,b,c,d,e,f,g,h,l,m,p,q):this.h.call(null,a,b,c,d,e,f,g,h,l,m,p,q)};k.ya=function(a,b,c,d,e,f,g,h,l,m,p,q,s){return this.h.ya?this.h.ya(a,b,c,d,e,f,g,h,l,m,p,q,s):this.h.call(null,a,b,c,d,e,f,g,h,l,m,p,q,s)};
k.za=function(a,b,c,d,e,f,g,h,l,m,p,q,s,u){return this.h.za?this.h.za(a,b,c,d,e,f,g,h,l,m,p,q,s,u):this.h.call(null,a,b,c,d,e,f,g,h,l,m,p,q,s,u)};k.Aa=function(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v){return this.h.Aa?this.h.Aa(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v):this.h.call(null,a,b,c,d,e,f,g,h,l,m,p,q,s,u,v)};k.Ba=function(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y){return this.h.Ba?this.h.Ba(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y):this.h.call(null,a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y)};
k.Ca=function(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B){return this.h.Ca?this.h.Ca(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B):this.h.call(null,a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B)};k.Da=function(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E){return this.h.Da?this.h.Da(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E):this.h.call(null,a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E)};
k.Ea=function(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N){return this.h.Ea?this.h.Ea(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N):this.h.call(null,a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N)};k.Fa=function(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y){return this.h.Fa?this.h.Fa(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y):this.h.call(null,a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y)};
k.hc=function(a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y,ra){var Pa=this.h;return T.ub?T.ub(Pa,a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y,ra):T.call(null,Pa,a,b,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y,ra)};k.bc=!0;k.F=function(a,b){return new Uc(this.h,b)};k.H=function(){return this.k};function O(a,b){return Tc(a)&&!(a?a.j&262144||a.Bc||(a.j?0:w(tb,a)):w(tb,a))?new Uc(a,b):null==a?null:ub(a,b)}function Vc(a){var b=null!=a;return(b?a?a.j&131072||a.kc||(a.j?0:w(rb,a)):w(rb,a):b)?sb(a):null}
function Wc(a){return null==a?null:lb(a)}
var Xc=function(){function a(a,b){return null==a?null:kb(a,b)}var b=null,c=function(){function a(b,d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return c.call(this,b,d,l)}function c(a,d,e){for(;;){if(null==a)return null;a=b.a(a,d);if(t(e))d=G(e),e=K(e);else return a}}a.i=2;a.f=function(a){var b=G(a);a=K(a);var d=G(a);a=H(a);return c(b,d,a)};a.d=c;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return b;case 2:return a.call(this,
b,e);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.b=function(a){return a};b.a=a;b.d=c.d;return b}();function Yc(a){return null==a||Aa(D(a))}function $c(a){return null==a?!1:a?a.j&8||a.tc?!0:a.j?!1:w(Qa,a):w(Qa,a)}function ad(a){return null==a?!1:a?a.j&4096||a.zc?!0:a.j?!1:w(jb,a):w(jb,a)}
function bd(a){return a?a.j&512||a.rc?!0:a.j?!1:w(ab,a):w(ab,a)}function cd(a){return a?a.j&16777216||a.yc?!0:a.j?!1:w(Db,a):w(Db,a)}function dd(a){return null==a?!1:a?a.j&1024||a.ic?!0:a.j?!1:w(db,a):w(db,a)}function ed(a){return a?a.j&16384||a.Ac?!0:a.j?!1:w(nb,a):w(nb,a)}function fd(a){return a?a.q&512||a.sc?!0:!1:!1}function gd(a){var b=[];ea(a,function(a,b){return function(a,c){return b.push(c)}}(a,b));return b}function hd(a,b,c,d,e){for(;0!==e;)c[d]=a[b],d+=1,e-=1,b+=1}
function id(a,b,c,d,e){b+=e-1;for(d+=e-1;0!==e;)c[d]=a[b],d-=1,e-=1,b-=1}var jd={};function kd(a){return null==a?!1:a?a.j&64||a.jb?!0:a.j?!1:w(Ua,a):w(Ua,a)}function ld(a){return a?a.j&8388608||a.mc?!0:a.j?!1:w(Bb,a):w(Bb,a)}function md(a){return t(a)?!0:!1}function nd(a,b){return S.c(a,b,jd)===jd?!1:!0}
function od(a,b){if(a===b)return 0;if(null==a)return-1;if(null==b)return 1;if(Ba(a)===Ba(b))return a&&(a.q&2048||a.sb)?a.tb(null,b):ha(a,b);throw Error("compare on non-nil objects of different types");}
var pd=function(){function a(a,b,c,g){for(;;){var h=od(R.a(a,g),R.a(b,g));if(0===h&&g+1<c)g+=1;else return h}}function b(a,b){var f=Q(a),g=Q(b);return f<g?-1:f>g?1:c.n(a,b,f,0)}var c=null,c=function(c,e,f,g){switch(arguments.length){case 2:return b.call(this,c,e);case 4:return a.call(this,c,e,f,g)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.n=a;return c}();
function qd(a){return sc.a(a,od)?od:function(b,c){var d=a.a?a.a(b,c):a.call(null,b,c);return"number"===typeof d?d:t(d)?-1:t(a.a?a.a(c,b):a.call(null,c,b))?1:0}}
var sd=function(){function a(a,b){if(D(b)){var c=rd.b?rd.b(b):rd.call(null,b),g=qd(a);ia(c,g);return D(c)}return J}function b(a){return c.a(od,a)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),td=function(){function a(a,b,c){return sd.a(function(c,f){return qd(b).call(null,a.b?a.b(c):a.call(null,c),a.b?a.b(f):a.call(null,f))},c)}function b(a,b){return c.c(a,od,
b)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}(),P=function(){function a(a,b,c){for(c=D(c);;)if(c){var g=G(c);b=a.a?a.a(b,g):a.call(null,b,g);if(Ac(b))return qb(b);c=K(c)}else return b}function b(a,b){var c=D(b);if(c){var g=G(c),c=K(c);return A.c?A.c(a,g,c):A.call(null,a,g,c)}return a.l?a.l():a.call(null)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,
c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}(),A=function(){function a(a,b,c){return c&&(c.j&524288||c.Sb)?c.O(null,a,b):c instanceof Array?Dc.c(c,a,b):"string"===typeof c?Dc.c(c,a,b):w(vb,c)?wb.c(c,a,b):P.c(a,b,c)}function b(a,b){return b&&(b.j&524288||b.Sb)?b.R(null,a):b instanceof Array?Dc.a(b,a):"string"===typeof b?Dc.a(b,a):w(vb,b)?wb.a(b,a):P.a(a,b)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,
c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}();function ud(a){return a}
var vd=function(){function a(a,b){return function(){function c(b,e){return a.a?a.a(b,e):a.call(null,b,e)}function g(a){return b.b?b.b(a):b.call(null,a)}function h(){return a.l?a.l():a.call(null)}var l=null,l=function(a,b){switch(arguments.length){case 0:return h.call(this);case 1:return g.call(this,a);case 2:return c.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);};l.l=h;l.b=g;l.a=c;return l}()}function b(a){return c.a(a,ud)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,
c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),wd=function(){function a(a,b,c,g){a=a.b?a.b(b):a.call(null,b);c=A.c(a,c,g);return a.b?a.b(c):a.call(null,c)}function b(a,b,f){return c.n(a,b,b.l?b.l():b.call(null),f)}var c=null,c=function(c,e,f,g){switch(arguments.length){case 3:return b.call(this,c,e,f);case 4:return a.call(this,c,e,f,g)}throw Error("Invalid arity: "+arguments.length);};c.c=b;c.n=a;return c}(),xd=function(){var a=null,b=function(){function b(a,
c,g){var h=null;if(2<arguments.length){for(var h=0,l=Array(arguments.length-2);h<l.length;)l[h]=arguments[h+2],++h;h=new F(l,0)}return d.call(this,a,c,h)}function d(b,c,d){return A.c(a,b+c,d)}b.i=2;b.f=function(a){var b=G(a);a=K(a);var c=G(a);a=H(a);return d(b,c,a)};b.d=d;return b}(),a=function(a,d,e){switch(arguments.length){case 0:return 0;case 1:return a;case 2:return a+d;default:var f=null;if(2<arguments.length){for(var f=0,g=Array(arguments.length-2);f<g.length;)g[f]=arguments[f+2],++f;f=new F(g,
0)}return b.d(a,d,f)}throw Error("Invalid arity: "+arguments.length);};a.i=2;a.f=b.f;a.l=function(){return 0};a.b=function(a){return a};a.a=function(a,b){return a+b};a.d=b.d;return a}(),yd=function(){var a=null,b=function(){function a(c,f,g){var h=null;if(2<arguments.length){for(var h=0,l=Array(arguments.length-2);h<l.length;)l[h]=arguments[h+2],++h;h=new F(l,0)}return b.call(this,c,f,h)}function b(a,c,d){for(;;)if(a<c)if(K(d))a=c,c=G(d),d=K(d);else return c<G(d);else return!1}a.i=2;a.f=function(a){var c=
G(a);a=K(a);var g=G(a);a=H(a);return b(c,g,a)};a.d=b;return a}(),a=function(a,d,e){switch(arguments.length){case 1:return!0;case 2:return a<d;default:var f=null;if(2<arguments.length){for(var f=0,g=Array(arguments.length-2);f<g.length;)g[f]=arguments[f+2],++f;f=new F(g,0)}return b.d(a,d,f)}throw Error("Invalid arity: "+arguments.length);};a.i=2;a.f=b.f;a.b=function(){return!0};a.a=function(a,b){return a<b};a.d=b.d;return a}(),zd=function(){var a=null,b=function(){function a(c,f,g){var h=null;if(2<
arguments.length){for(var h=0,l=Array(arguments.length-2);h<l.length;)l[h]=arguments[h+2],++h;h=new F(l,0)}return b.call(this,c,f,h)}function b(a,c,d){for(;;)if(a<=c)if(K(d))a=c,c=G(d),d=K(d);else return c<=G(d);else return!1}a.i=2;a.f=function(a){var c=G(a);a=K(a);var g=G(a);a=H(a);return b(c,g,a)};a.d=b;return a}(),a=function(a,d,e){switch(arguments.length){case 1:return!0;case 2:return a<=d;default:var f=null;if(2<arguments.length){for(var f=0,g=Array(arguments.length-2);f<g.length;)g[f]=arguments[f+
2],++f;f=new F(g,0)}return b.d(a,d,f)}throw Error("Invalid arity: "+arguments.length);};a.i=2;a.f=b.f;a.b=function(){return!0};a.a=function(a,b){return a<=b};a.d=b.d;return a}(),Ad=function(){var a=null,b=function(){function a(c,f,g){var h=null;if(2<arguments.length){for(var h=0,l=Array(arguments.length-2);h<l.length;)l[h]=arguments[h+2],++h;h=new F(l,0)}return b.call(this,c,f,h)}function b(a,c,d){for(;;)if(a>c)if(K(d))a=c,c=G(d),d=K(d);else return c>G(d);else return!1}a.i=2;a.f=function(a){var c=
G(a);a=K(a);var g=G(a);a=H(a);return b(c,g,a)};a.d=b;return a}(),a=function(a,d,e){switch(arguments.length){case 1:return!0;case 2:return a>d;default:var f=null;if(2<arguments.length){for(var f=0,g=Array(arguments.length-2);f<g.length;)g[f]=arguments[f+2],++f;f=new F(g,0)}return b.d(a,d,f)}throw Error("Invalid arity: "+arguments.length);};a.i=2;a.f=b.f;a.b=function(){return!0};a.a=function(a,b){return a>b};a.d=b.d;return a}(),Bd=function(){var a=null,b=function(){function a(c,f,g){var h=null;if(2<
arguments.length){for(var h=0,l=Array(arguments.length-2);h<l.length;)l[h]=arguments[h+2],++h;h=new F(l,0)}return b.call(this,c,f,h)}function b(a,c,d){for(;;)if(a>=c)if(K(d))a=c,c=G(d),d=K(d);else return c>=G(d);else return!1}a.i=2;a.f=function(a){var c=G(a);a=K(a);var g=G(a);a=H(a);return b(c,g,a)};a.d=b;return a}(),a=function(a,d,e){switch(arguments.length){case 1:return!0;case 2:return a>=d;default:var f=null;if(2<arguments.length){for(var f=0,g=Array(arguments.length-2);f<g.length;)g[f]=arguments[f+
2],++f;f=new F(g,0)}return b.d(a,d,f)}throw Error("Invalid arity: "+arguments.length);};a.i=2;a.f=b.f;a.b=function(){return!0};a.a=function(a,b){return a>=b};a.d=b.d;return a}();function Cd(a,b){var c=(a-a%b)/b;return 0<=c?Math.floor.b?Math.floor.b(c):Math.floor.call(null,c):Math.ceil.b?Math.ceil.b(c):Math.ceil.call(null,c)}function Dd(a){a-=a>>1&1431655765;a=(a&858993459)+(a>>2&858993459);return 16843009*(a+(a>>4)&252645135)>>24}
function Ed(a){var b=1;for(a=D(a);;)if(a&&0<b)b-=1,a=K(a);else return a}
var z=function(){function a(a){return null==a?"":da(a)}var b=null,c=function(){function a(b,d){var h=null;if(1<arguments.length){for(var h=0,l=Array(arguments.length-1);h<l.length;)l[h]=arguments[h+1],++h;h=new F(l,0)}return c.call(this,b,h)}function c(a,d){for(var e=new fa(b.b(a)),l=d;;)if(t(l))e=e.append(b.b(G(l))),l=K(l);else return e.toString()}a.i=1;a.f=function(a){var b=G(a);a=H(a);return c(b,a)};a.d=c;return a}(),b=function(b,e){switch(arguments.length){case 0:return"";case 1:return a.call(this,
b);default:var f=null;if(1<arguments.length){for(var f=0,g=Array(arguments.length-1);f<g.length;)g[f]=arguments[f+1],++f;f=new F(g,0)}return c.d(b,f)}throw Error("Invalid arity: "+arguments.length);};b.i=1;b.f=c.f;b.l=function(){return""};b.b=a;b.d=c.d;return b}();function Ic(a,b){var c;if(cd(b))if(Ec(a)&&Ec(b)&&Q(a)!==Q(b))c=!1;else a:{c=D(a);for(var d=D(b);;){if(null==c){c=null==d;break a}if(null!=d&&sc.a(G(c),G(d)))c=K(c),d=K(d);else{c=!1;break a}}c=void 0}else c=null;return md(c)}
function Fd(a,b,c,d,e){this.k=a;this.first=b;this.M=c;this.count=d;this.p=e;this.j=65937646;this.q=8192}k=Fd.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.k};k.T=function(){return 1===this.count?null:this.M};k.L=function(){return this.count};k.La=function(){return this.first};k.Ma=function(){return Wa(this)};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return ub(J,this.k)};
k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};k.N=function(){return this.first};k.S=function(){return 1===this.count?J:this.M};k.D=function(){return this};k.F=function(a,b){return new Fd(b,this.first,this.M,this.count,this.p)};k.G=function(a,b){return new Fd(this.k,b,this,this.count+1,null)};Fd.prototype[Ea]=function(){return uc(this)};function Hd(a){this.k=a;this.j=65937614;this.q=8192}k=Hd.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.k};
k.T=function(){return null};k.L=function(){return 0};k.La=function(){return null};k.Ma=function(){throw Error("Can't pop empty list");};k.B=function(){return 0};k.A=function(a,b){return Ic(this,b)};k.J=function(){return this};k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};k.N=function(){return null};k.S=function(){return J};k.D=function(){return null};k.F=function(a,b){return new Hd(b)};k.G=function(a,b){return new Fd(this.k,b,null,1,null)};var J=new Hd(null);
Hd.prototype[Ea]=function(){return uc(this)};function Id(a){return a?a.j&134217728||a.xc?!0:a.j?!1:w(Fb,a):w(Fb,a)}function Jd(a){return Id(a)?Gb(a):A.c(Nc,J,a)}
var Kd=function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){var b;if(a instanceof F&&0===a.m)b=a.e;else a:{for(b=[];;)if(null!=a)b.push(a.N(null)),a=a.T(null);else break a;b=void 0}a=b.length;for(var e=J;;)if(0<a){var f=a-1,e=e.G(null,b[a-1]);a=f}else return e}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}();
function Ld(a,b,c,d){this.k=a;this.first=b;this.M=c;this.p=d;this.j=65929452;this.q=8192}k=Ld.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.k};k.T=function(){return null==this.M?null:D(this.M)};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.k)};k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};k.N=function(){return this.first};
k.S=function(){return null==this.M?J:this.M};k.D=function(){return this};k.F=function(a,b){return new Ld(b,this.first,this.M,this.p)};k.G=function(a,b){return new Ld(null,b,this,this.p)};Ld.prototype[Ea]=function(){return uc(this)};function M(a,b){var c=null==b;return(c?c:b&&(b.j&64||b.jb))?new Ld(null,a,b,null):new Ld(null,a,D(b),null)}
function Md(a,b){if(a.pa===b.pa)return 0;var c=Aa(a.ba);if(t(c?b.ba:c))return-1;if(t(a.ba)){if(Aa(b.ba))return 1;c=ha(a.ba,b.ba);return 0===c?ha(a.name,b.name):c}return ha(a.name,b.name)}function U(a,b,c,d){this.ba=a;this.name=b;this.pa=c;this.Ya=d;this.j=2153775105;this.q=4096}k=U.prototype;k.v=function(a,b){return Lb(b,[z(":"),z(this.pa)].join(""))};k.B=function(){var a=this.Ya;return null!=a?a:this.Ya=a=oc(this)+2654435769|0};
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return S.a(c,this);case 3:return S.c(c,this,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return S.a(c,this)};a.c=function(a,c,d){return S.c(c,this,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return S.a(a,this)};k.a=function(a,b){return S.c(a,this,b)};k.A=function(a,b){return b instanceof U?this.pa===b.pa:!1};
k.toString=function(){return[z(":"),z(this.pa)].join("")};function Nd(a,b){return a===b?!0:a instanceof U&&b instanceof U?a.pa===b.pa:!1}
var Pd=function(){function a(a,b){return new U(a,b,[z(t(a)?[z(a),z("/")].join(""):null),z(b)].join(""),null)}function b(a){if(a instanceof U)return a;if(a instanceof qc){var b;if(a&&(a.q&4096||a.lc))b=a.ba;else throw Error([z("Doesn't support namespace: "),z(a)].join(""));return new U(b,Od.b?Od.b(a):Od.call(null,a),a.ta,null)}return"string"===typeof a?(b=a.split("/"),2===b.length?new U(b[0],b[1],a,null):new U(null,b[0],a,null)):null}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,
c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}();function V(a,b,c,d){this.k=a;this.cb=b;this.C=c;this.p=d;this.q=0;this.j=32374988}k=V.prototype;k.toString=function(){return ec(this)};function Qd(a){null!=a.cb&&(a.C=a.cb.l?a.cb.l():a.cb.call(null),a.cb=null);return a.C}k.H=function(){return this.k};k.T=function(){Cb(this);return null==this.C?null:K(this.C)};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};
k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.k)};k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};k.N=function(){Cb(this);return null==this.C?null:G(this.C)};k.S=function(){Cb(this);return null!=this.C?H(this.C):J};k.D=function(){Qd(this);if(null==this.C)return null;for(var a=this.C;;)if(a instanceof V)a=Qd(a);else return this.C=a,D(this.C)};k.F=function(a,b){return new V(b,this.cb,this.C,this.p)};k.G=function(a,b){return M(b,this)};
V.prototype[Ea]=function(){return uc(this)};function Rd(a,b){this.Ab=a;this.end=b;this.q=0;this.j=2}Rd.prototype.L=function(){return this.end};Rd.prototype.add=function(a){this.Ab[this.end]=a;return this.end+=1};Rd.prototype.ca=function(){var a=new Sd(this.Ab,0,this.end);this.Ab=null;return a};function Td(a){return new Rd(Array(a),0)}function Sd(a,b,c){this.e=a;this.V=b;this.end=c;this.q=0;this.j=524306}k=Sd.prototype;k.R=function(a,b){return Dc.n(this.e,b,this.e[this.V],this.V+1)};
k.O=function(a,b,c){return Dc.n(this.e,b,c,this.V)};k.Pb=function(){if(this.V===this.end)throw Error("-drop-first of empty chunk");return new Sd(this.e,this.V+1,this.end)};k.Q=function(a,b){return this.e[this.V+b]};k.$=function(a,b,c){return 0<=b&&b<this.end-this.V?this.e[this.V+b]:c};k.L=function(){return this.end-this.V};
var Ud=function(){function a(a,b,c){return new Sd(a,b,c)}function b(a,b){return new Sd(a,b,a.length)}function c(a){return new Sd(a,0,a.length)}var d=null,d=function(d,f,g){switch(arguments.length){case 1:return c.call(this,d);case 2:return b.call(this,d,f);case 3:return a.call(this,d,f,g)}throw Error("Invalid arity: "+arguments.length);};d.b=c;d.a=b;d.c=a;return d}();function Vd(a,b,c,d){this.ca=a;this.ra=b;this.k=c;this.p=d;this.j=31850732;this.q=1536}k=Vd.prototype;k.toString=function(){return ec(this)};
k.H=function(){return this.k};k.T=function(){if(1<Ma(this.ca))return new Vd(Xb(this.ca),this.ra,this.k,null);var a=Cb(this.ra);return null==a?null:a};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.k)};k.N=function(){return C.a(this.ca,0)};k.S=function(){return 1<Ma(this.ca)?new Vd(Xb(this.ca),this.ra,this.k,null):null==this.ra?J:this.ra};k.D=function(){return this};k.Cb=function(){return this.ca};
k.Db=function(){return null==this.ra?J:this.ra};k.F=function(a,b){return new Vd(this.ca,this.ra,b,this.p)};k.G=function(a,b){return M(b,this)};k.Bb=function(){return null==this.ra?null:this.ra};Vd.prototype[Ea]=function(){return uc(this)};function Wd(a,b){return 0===Ma(a)?b:new Vd(a,b,null,null)}function Xd(a,b){a.add(b)}function rd(a){for(var b=[];;)if(D(a))b.push(G(a)),a=K(a);else return b}function Yd(a,b){if(Ec(a))return Q(a);for(var c=a,d=b,e=0;;)if(0<d&&D(c))c=K(c),d-=1,e+=1;else return e}
var $d=function Zd(b){return null==b?null:null==K(b)?D(G(b)):M(G(b),Zd(K(b)))},ae=function(){function a(a,b){return new V(null,function(){var c=D(a);return c?fd(c)?Wd(Yb(c),d.a(Zb(c),b)):M(G(c),d.a(H(c),b)):b},null,null)}function b(a){return new V(null,function(){return a},null,null)}function c(){return new V(null,function(){return null},null,null)}var d=null,e=function(){function a(c,d,e){var f=null;if(2<arguments.length){for(var f=0,q=Array(arguments.length-2);f<q.length;)q[f]=arguments[f+2],++f;
f=new F(q,0)}return b.call(this,c,d,f)}function b(a,c,e){return function q(a,b){return new V(null,function(){var c=D(a);return c?fd(c)?Wd(Yb(c),q(Zb(c),b)):M(G(c),q(H(c),b)):t(b)?q(G(b),K(b)):null},null,null)}(d.a(a,c),e)}a.i=2;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=H(a);return b(c,d,a)};a.d=b;return a}(),d=function(d,g,h){switch(arguments.length){case 0:return c.call(this);case 1:return b.call(this,d);case 2:return a.call(this,d,g);default:var l=null;if(2<arguments.length){for(var l=0,m=
Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return e.d(d,g,l)}throw Error("Invalid arity: "+arguments.length);};d.i=2;d.f=e.f;d.l=c;d.b=b;d.a=a;d.d=e.d;return d}(),be=function(){function a(a,b,c,d){return M(a,M(b,M(c,d)))}function b(a,b,c){return M(a,M(b,c))}var c=null,d=function(){function a(c,d,e,m,p){var q=null;if(4<arguments.length){for(var q=0,s=Array(arguments.length-4);q<s.length;)s[q]=arguments[q+4],++q;q=new F(s,0)}return b.call(this,c,d,e,m,q)}function b(a,
c,d,e,f){return M(a,M(c,M(d,M(e,$d(f)))))}a.i=4;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=K(a);var e=G(a);a=K(a);var p=G(a);a=H(a);return b(c,d,e,p,a)};a.d=b;return a}(),c=function(c,f,g,h,l){switch(arguments.length){case 1:return D(c);case 2:return M(c,f);case 3:return b.call(this,c,f,g);case 4:return a.call(this,c,f,g,h);default:var m=null;if(4<arguments.length){for(var m=0,p=Array(arguments.length-4);m<p.length;)p[m]=arguments[m+4],++m;m=new F(p,0)}return d.d(c,f,g,h,m)}throw Error("Invalid arity: "+
arguments.length);};c.i=4;c.f=d.f;c.b=function(a){return D(a)};c.a=function(a,b){return M(a,b)};c.c=b;c.n=a;c.d=d.d;return c}();function ce(a){return Qb(a)}
var de=function(){function a(){return Ob(Mc)}var b=null,c=function(){function a(c,d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return b.call(this,c,d,l)}function b(a,c,d){for(;;)if(a=Pb(a,c),t(d))c=G(d),d=K(d);else return a}a.i=2;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=H(a);return b(c,d,a)};a.d=b;return a}(),b=function(b,e,f){switch(arguments.length){case 0:return a.call(this);case 1:return b;case 2:return Pb(b,
e);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.l=a;b.b=function(a){return a};b.a=function(a,b){return Pb(a,b)};b.d=c.d;return b}(),ee=function(){var a=null,b=function(){function a(c,f,g,h){var l=null;if(3<arguments.length){for(var l=0,m=Array(arguments.length-3);l<m.length;)m[l]=arguments[l+3],++l;l=new F(m,0)}return b.call(this,
c,f,g,l)}function b(a,c,d,h){for(;;)if(a=Rb(a,c,d),t(h))c=G(h),d=Lc(h),h=K(K(h));else return a}a.i=3;a.f=function(a){var c=G(a);a=K(a);var g=G(a);a=K(a);var h=G(a);a=H(a);return b(c,g,h,a)};a.d=b;return a}(),a=function(a,d,e,f){switch(arguments.length){case 3:return Rb(a,d,e);default:var g=null;if(3<arguments.length){for(var g=0,h=Array(arguments.length-3);g<h.length;)h[g]=arguments[g+3],++g;g=new F(h,0)}return b.d(a,d,e,g)}throw Error("Invalid arity: "+arguments.length);};a.i=3;a.f=b.f;a.c=function(a,
b,e){return Rb(a,b,e)};a.d=b.d;return a}(),fe=function(){var a=null,b=function(){function a(c,f,g){var h=null;if(2<arguments.length){for(var h=0,l=Array(arguments.length-2);h<l.length;)l[h]=arguments[h+2],++h;h=new F(l,0)}return b.call(this,c,f,h)}function b(a,c,d){for(;;)if(a=Sb(a,c),t(d))c=G(d),d=K(d);else return a}a.i=2;a.f=function(a){var c=G(a);a=K(a);var g=G(a);a=H(a);return b(c,g,a)};a.d=b;return a}(),a=function(a,d,e){switch(arguments.length){case 2:return Sb(a,d);default:var f=null;if(2<
arguments.length){for(var f=0,g=Array(arguments.length-2);f<g.length;)g[f]=arguments[f+2],++f;f=new F(g,0)}return b.d(a,d,f)}throw Error("Invalid arity: "+arguments.length);};a.i=2;a.f=b.f;a.a=function(a,b){return Sb(a,b)};a.d=b.d;return a}(),ge=function(){var a=null,b=function(){function a(c,f,g){var h=null;if(2<arguments.length){for(var h=0,l=Array(arguments.length-2);h<l.length;)l[h]=arguments[h+2],++h;h=new F(l,0)}return b.call(this,c,f,h)}function b(a,c,d){for(;;)if(a=Vb(a,c),t(d))c=G(d),d=K(d);
else return a}a.i=2;a.f=function(a){var c=G(a);a=K(a);var g=G(a);a=H(a);return b(c,g,a)};a.d=b;return a}(),a=function(a,d,e){switch(arguments.length){case 2:return Vb(a,d);default:var f=null;if(2<arguments.length){for(var f=0,g=Array(arguments.length-2);f<g.length;)g[f]=arguments[f+2],++f;f=new F(g,0)}return b.d(a,d,f)}throw Error("Invalid arity: "+arguments.length);};a.i=2;a.f=b.f;a.a=function(a,b){return Vb(a,b)};a.d=b.d;return a}();
function he(a,b,c){var d=D(c);if(0===b)return a.l?a.l():a.call(null);c=Va(d);var e=Wa(d);if(1===b)return a.b?a.b(c):a.b?a.b(c):a.call(null,c);var d=Va(e),f=Wa(e);if(2===b)return a.a?a.a(c,d):a.a?a.a(c,d):a.call(null,c,d);var e=Va(f),g=Wa(f);if(3===b)return a.c?a.c(c,d,e):a.c?a.c(c,d,e):a.call(null,c,d,e);var f=Va(g),h=Wa(g);if(4===b)return a.n?a.n(c,d,e,f):a.n?a.n(c,d,e,f):a.call(null,c,d,e,f);var g=Va(h),l=Wa(h);if(5===b)return a.r?a.r(c,d,e,f,g):a.r?a.r(c,d,e,f,g):a.call(null,c,d,e,f,g);var h=Va(l),
m=Wa(l);if(6===b)return a.P?a.P(c,d,e,f,g,h):a.P?a.P(c,d,e,f,g,h):a.call(null,c,d,e,f,g,h);var l=Va(m),p=Wa(m);if(7===b)return a.ia?a.ia(c,d,e,f,g,h,l):a.ia?a.ia(c,d,e,f,g,h,l):a.call(null,c,d,e,f,g,h,l);var m=Va(p),q=Wa(p);if(8===b)return a.Ga?a.Ga(c,d,e,f,g,h,l,m):a.Ga?a.Ga(c,d,e,f,g,h,l,m):a.call(null,c,d,e,f,g,h,l,m);var p=Va(q),s=Wa(q);if(9===b)return a.Ha?a.Ha(c,d,e,f,g,h,l,m,p):a.Ha?a.Ha(c,d,e,f,g,h,l,m,p):a.call(null,c,d,e,f,g,h,l,m,p);var q=Va(s),u=Wa(s);if(10===b)return a.va?a.va(c,d,e,
f,g,h,l,m,p,q):a.va?a.va(c,d,e,f,g,h,l,m,p,q):a.call(null,c,d,e,f,g,h,l,m,p,q);var s=Va(u),v=Wa(u);if(11===b)return a.wa?a.wa(c,d,e,f,g,h,l,m,p,q,s):a.wa?a.wa(c,d,e,f,g,h,l,m,p,q,s):a.call(null,c,d,e,f,g,h,l,m,p,q,s);var u=Va(v),y=Wa(v);if(12===b)return a.xa?a.xa(c,d,e,f,g,h,l,m,p,q,s,u):a.xa?a.xa(c,d,e,f,g,h,l,m,p,q,s,u):a.call(null,c,d,e,f,g,h,l,m,p,q,s,u);var v=Va(y),B=Wa(y);if(13===b)return a.ya?a.ya(c,d,e,f,g,h,l,m,p,q,s,u,v):a.ya?a.ya(c,d,e,f,g,h,l,m,p,q,s,u,v):a.call(null,c,d,e,f,g,h,l,m,p,
q,s,u,v);var y=Va(B),E=Wa(B);if(14===b)return a.za?a.za(c,d,e,f,g,h,l,m,p,q,s,u,v,y):a.za?a.za(c,d,e,f,g,h,l,m,p,q,s,u,v,y):a.call(null,c,d,e,f,g,h,l,m,p,q,s,u,v,y);var B=Va(E),N=Wa(E);if(15===b)return a.Aa?a.Aa(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B):a.Aa?a.Aa(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B):a.call(null,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B);var E=Va(N),Y=Wa(N);if(16===b)return a.Ba?a.Ba(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E):a.Ba?a.Ba(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E):a.call(null,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E);var N=
Va(Y),ra=Wa(Y);if(17===b)return a.Ca?a.Ca(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N):a.Ca?a.Ca(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N):a.call(null,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N);var Y=Va(ra),Pa=Wa(ra);if(18===b)return a.Da?a.Da(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y):a.Da?a.Da(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y):a.call(null,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y);ra=Va(Pa);Pa=Wa(Pa);if(19===b)return a.Ea?a.Ea(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y,ra):a.Ea?a.Ea(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y,ra):a.call(null,
c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y,ra);var I=Va(Pa);Wa(Pa);if(20===b)return a.Fa?a.Fa(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y,ra,I):a.Fa?a.Fa(c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y,ra,I):a.call(null,c,d,e,f,g,h,l,m,p,q,s,u,v,y,B,E,N,Y,ra,I);throw Error("Only up to 20 arguments supported on functions");}
var T=function(){function a(a,b,c,d,e){b=be.n(b,c,d,e);c=a.i;return a.f?(d=Yd(b,c+1),d<=c?he(a,d,b):a.f(b)):a.apply(a,rd(b))}function b(a,b,c,d){b=be.c(b,c,d);c=a.i;return a.f?(d=Yd(b,c+1),d<=c?he(a,d,b):a.f(b)):a.apply(a,rd(b))}function c(a,b,c){b=be.a(b,c);c=a.i;if(a.f){var d=Yd(b,c+1);return d<=c?he(a,d,b):a.f(b)}return a.apply(a,rd(b))}function d(a,b){var c=a.i;if(a.f){var d=Yd(b,c+1);return d<=c?he(a,d,b):a.f(b)}return a.apply(a,rd(b))}var e=null,f=function(){function a(c,d,e,f,g,u){var v=null;
if(5<arguments.length){for(var v=0,y=Array(arguments.length-5);v<y.length;)y[v]=arguments[v+5],++v;v=new F(y,0)}return b.call(this,c,d,e,f,g,v)}function b(a,c,d,e,f,g){c=M(c,M(d,M(e,M(f,$d(g)))));d=a.i;return a.f?(e=Yd(c,d+1),e<=d?he(a,e,c):a.f(c)):a.apply(a,rd(c))}a.i=5;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=K(a);var e=G(a);a=K(a);var f=G(a);a=K(a);var g=G(a);a=H(a);return b(c,d,e,f,g,a)};a.d=b;return a}(),e=function(e,h,l,m,p,q){switch(arguments.length){case 2:return d.call(this,e,h);case 3:return c.call(this,
e,h,l);case 4:return b.call(this,e,h,l,m);case 5:return a.call(this,e,h,l,m,p);default:var s=null;if(5<arguments.length){for(var s=0,u=Array(arguments.length-5);s<u.length;)u[s]=arguments[s+5],++s;s=new F(u,0)}return f.d(e,h,l,m,p,s)}throw Error("Invalid arity: "+arguments.length);};e.i=5;e.f=f.f;e.a=d;e.c=c;e.n=b;e.r=a;e.d=f.d;return e}(),ie=function(){function a(a,b,c,d,e,f){var g=O,v=Vc(a);b=b.r?b.r(v,c,d,e,f):b.call(null,v,c,d,e,f);return g(a,b)}function b(a,b,c,d,e){var f=O,g=Vc(a);b=b.n?b.n(g,
c,d,e):b.call(null,g,c,d,e);return f(a,b)}function c(a,b,c,d){var e=O,f=Vc(a);b=b.c?b.c(f,c,d):b.call(null,f,c,d);return e(a,b)}function d(a,b,c){var d=O,e=Vc(a);b=b.a?b.a(e,c):b.call(null,e,c);return d(a,b)}function e(a,b){var c=O,d;d=Vc(a);d=b.b?b.b(d):b.call(null,d);return c(a,d)}var f=null,g=function(){function a(c,d,e,f,g,h,y){var B=null;if(6<arguments.length){for(var B=0,E=Array(arguments.length-6);B<E.length;)E[B]=arguments[B+6],++B;B=new F(E,0)}return b.call(this,c,d,e,f,g,h,B)}function b(a,
c,d,e,f,g,h){return O(a,T.d(c,Vc(a),d,e,f,Kc([g,h],0)))}a.i=6;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=K(a);var e=G(a);a=K(a);var f=G(a);a=K(a);var g=G(a);a=K(a);var h=G(a);a=H(a);return b(c,d,e,f,g,h,a)};a.d=b;return a}(),f=function(f,l,m,p,q,s,u){switch(arguments.length){case 2:return e.call(this,f,l);case 3:return d.call(this,f,l,m);case 4:return c.call(this,f,l,m,p);case 5:return b.call(this,f,l,m,p,q);case 6:return a.call(this,f,l,m,p,q,s);default:var v=null;if(6<arguments.length){for(var v=
0,y=Array(arguments.length-6);v<y.length;)y[v]=arguments[v+6],++v;v=new F(y,0)}return g.d(f,l,m,p,q,s,v)}throw Error("Invalid arity: "+arguments.length);};f.i=6;f.f=g.f;f.a=e;f.c=d;f.n=c;f.r=b;f.P=a;f.d=g.d;return f}(),je=function(){function a(a,b){return!sc.a(a,b)}var b=null,c=function(){function a(c,d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return b.call(this,c,d,l)}function b(a,c,d){return Aa(T.n(sc,a,c,d))}a.i=
2;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=H(a);return b(c,d,a)};a.d=b;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return!1;case 2:return a.call(this,b,e);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.b=function(){return!1};b.a=a;b.d=c.d;return b}(),qe=function ke(){"undefined"===typeof ja&&(ja=function(b,c){this.pc=
b;this.oc=c;this.q=0;this.j=393216},ja.prototype.ga=function(){return!1},ja.prototype.next=function(){return Error("No such element")},ja.prototype.H=function(){return this.oc},ja.prototype.F=function(b,c){return new ja(this.pc,c)},ja.Yb=!0,ja.Xb="cljs.core/t12660",ja.nc=function(b){return Lb(b,"cljs.core/t12660")});return new ja(ke,new pa(null,5,[le,54,me,2998,ne,3,oe,2994,pe,"/Users/davidnolen/development/clojure/mori/out-mori-adv/cljs/core.cljs"],null))};function re(a,b){this.C=a;this.m=b}
re.prototype.ga=function(){return this.m<this.C.length};re.prototype.next=function(){var a=this.C.charAt(this.m);this.m+=1;return a};function se(a,b){this.e=a;this.m=b}se.prototype.ga=function(){return this.m<this.e.length};se.prototype.next=function(){var a=this.e[this.m];this.m+=1;return a};var te={},ue={};function ve(a,b){this.eb=a;this.Qa=b}ve.prototype.ga=function(){this.eb===te?(this.eb=ue,this.Qa=D(this.Qa)):this.eb===this.Qa&&(this.Qa=K(this.eb));return null!=this.Qa};
ve.prototype.next=function(){if(Aa(this.ga()))throw Error("No such element");this.eb=this.Qa;return G(this.Qa)};function we(a){if(null==a)return qe();if("string"===typeof a)return new re(a,0);if(a instanceof Array)return new se(a,0);if(a?t(t(null)?null:a.vb)||(a.yb?0:w(bc,a)):w(bc,a))return cc(a);if(ld(a))return new ve(te,a);throw Error([z("Cannot create iterator from "),z(a)].join(""));}function xe(a,b){this.fa=a;this.$b=b}
xe.prototype.step=function(a){for(var b=this;;){if(t(function(){var c=null!=a.X;return c?b.$b.ga():c}()))if(Ac(function(){var c=b.$b.next();return b.fa.a?b.fa.a(a,c):b.fa.call(null,a,c)}()))null!=a.M&&(a.M.X=null);else continue;break}return null==a.X?null:b.fa.b?b.fa.b(a):b.fa.call(null,a)};
function ye(a,b){var c=function(){function a(b,c){b.first=c;b.M=new ze(b.X,null,null,null);b.X=null;return b.M}function b(a){(Ac(a)?qb(a):a).X=null;return a}var c=null,c=function(c,f){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,f)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}();return new xe(a.b?a.b(c):a.call(null,c),b)}function Ae(a,b,c){this.fa=a;this.Kb=b;this.ac=c}
Ae.prototype.ga=function(){for(var a=D(this.Kb);;)if(null!=a){var b=G(a);if(Aa(b.ga()))return!1;a=K(a)}else return!0};Ae.prototype.next=function(){for(var a=this.Kb.length,b=0;;)if(b<a)this.ac[b]=this.Kb[b].next(),b+=1;else break;return Jc.a(this.ac,0)};Ae.prototype.step=function(a){for(;;){var b;b=(b=null!=a.X)?this.ga():b;if(t(b))if(Ac(T.a(this.fa,M(a,this.next()))))null!=a.M&&(a.M.X=null);else continue;break}return null==a.X?null:this.fa.b?this.fa.b(a):this.fa.call(null,a)};
var Be=function(){function a(a,b,c){var g=function(){function a(b,c){b.first=c;b.M=new ze(b.X,null,null,null);b.X=null;return b.M}function b(a){a=Ac(a)?qb(a):a;a.X=null;return a}var c=null,c=function(c,d){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,d)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}();return new Ae(a.b?a.b(g):a.call(null,g),b,c)}function b(a,b){return c.c(a,b,Array(b.length))}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,
c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}();function ze(a,b,c,d){this.X=a;this.first=b;this.M=c;this.k=d;this.q=0;this.j=31719628}k=ze.prototype;k.T=function(){null!=this.X&&Cb(this);return null==this.M?null:Cb(this.M)};k.N=function(){null!=this.X&&Cb(this);return null==this.M?null:this.first};k.S=function(){null!=this.X&&Cb(this);return null==this.M?J:this.M};
k.D=function(){null!=this.X&&this.X.step(this);return null==this.M?null:this};k.B=function(){return wc(this)};k.A=function(a,b){return null!=Cb(this)?Ic(this,b):cd(b)&&null==D(b)};k.J=function(){return J};k.G=function(a,b){return M(b,Cb(this))};k.F=function(a,b){return new ze(this.X,this.first,this.M,b)};ze.prototype[Ea]=function(){return uc(this)};
var Ce=function(){function a(a){return kd(a)?a:(a=D(a))?a:J}var b=null,c=function(){function a(c,d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return b.call(this,c,d,l)}function b(a,c,d){d=rd(M(c,d));c=[];d=D(d);for(var e=null,m=0,p=0;;)if(p<m){var q=e.Q(null,p);c.push(we(q));p+=1}else if(d=D(d))e=d,fd(e)?(d=Yb(e),p=Zb(e),e=d,m=Q(d),d=p):(d=G(e),c.push(we(d)),d=K(e),e=null,m=0),p=0;else break;return new ze(Be.c(a,c,
Array(c.length)),null,null,null)}a.i=2;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=H(a);return b(c,d,a)};a.d=b;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return a.call(this,b);case 2:return new ze(ye(b,we(e)),null,null,null);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.b=a;b.a=function(a,b){return new ze(ye(a,
we(b)),null,null,null)};b.d=c.d;return b}();function Ee(a,b){for(;;){if(null==D(b))return!0;var c;c=G(b);c=a.b?a.b(c):a.call(null,c);if(t(c)){c=a;var d=K(b);a=c;b=d}else return!1}}function Fe(a,b){for(;;)if(D(b)){var c;c=G(b);c=a.b?a.b(c):a.call(null,c);if(t(c))return c;c=a;var d=K(b);a=c;b=d}else return null}function Ge(a){if("number"===typeof a&&Aa(isNaN(a))&&Infinity!==a&&parseFloat(a)===parseInt(a,10))return 0===(a&1);throw Error([z("Argument must be an integer: "),z(a)].join(""));}
function He(a){return function(){function b(b,c){return Aa(a.a?a.a(b,c):a.call(null,b,c))}function c(b){return Aa(a.b?a.b(b):a.call(null,b))}function d(){return Aa(a.l?a.l():a.call(null))}var e=null,f=function(){function b(a,d,e){var f=null;if(2<arguments.length){for(var f=0,g=Array(arguments.length-2);f<g.length;)g[f]=arguments[f+2],++f;f=new F(g,0)}return c.call(this,a,d,f)}function c(b,d,e){return Aa(T.n(a,b,d,e))}b.i=2;b.f=function(a){var b=G(a);a=K(a);var d=G(a);a=H(a);return c(b,d,a)};b.d=c;
return b}(),e=function(a,e,l){switch(arguments.length){case 0:return d.call(this);case 1:return c.call(this,a);case 2:return b.call(this,a,e);default:var m=null;if(2<arguments.length){for(var m=0,p=Array(arguments.length-2);m<p.length;)p[m]=arguments[m+2],++m;m=new F(p,0)}return f.d(a,e,m)}throw Error("Invalid arity: "+arguments.length);};e.i=2;e.f=f.f;e.l=d;e.b=c;e.a=b;e.d=f.d;return e}()}
var Ie=function(){function a(a,b,c){return function(){function d(h,l,m){h=c.c?c.c(h,l,m):c.call(null,h,l,m);h=b.b?b.b(h):b.call(null,h);return a.b?a.b(h):a.call(null,h)}function l(d,h){var l;l=c.a?c.a(d,h):c.call(null,d,h);l=b.b?b.b(l):b.call(null,l);return a.b?a.b(l):a.call(null,l)}function m(d){d=c.b?c.b(d):c.call(null,d);d=b.b?b.b(d):b.call(null,d);return a.b?a.b(d):a.call(null,d)}function p(){var d;d=c.l?c.l():c.call(null);d=b.b?b.b(d):b.call(null,d);return a.b?a.b(d):a.call(null,d)}var q=null,
s=function(){function d(a,b,c,e){var f=null;if(3<arguments.length){for(var f=0,g=Array(arguments.length-3);f<g.length;)g[f]=arguments[f+3],++f;f=new F(g,0)}return h.call(this,a,b,c,f)}function h(d,l,m,p){d=T.r(c,d,l,m,p);d=b.b?b.b(d):b.call(null,d);return a.b?a.b(d):a.call(null,d)}d.i=3;d.f=function(a){var b=G(a);a=K(a);var c=G(a);a=K(a);var d=G(a);a=H(a);return h(b,c,d,a)};d.d=h;return d}(),q=function(a,b,c,e){switch(arguments.length){case 0:return p.call(this);case 1:return m.call(this,a);case 2:return l.call(this,
a,b);case 3:return d.call(this,a,b,c);default:var f=null;if(3<arguments.length){for(var f=0,g=Array(arguments.length-3);f<g.length;)g[f]=arguments[f+3],++f;f=new F(g,0)}return s.d(a,b,c,f)}throw Error("Invalid arity: "+arguments.length);};q.i=3;q.f=s.f;q.l=p;q.b=m;q.a=l;q.c=d;q.d=s.d;return q}()}function b(a,b){return function(){function c(d,g,h){d=b.c?b.c(d,g,h):b.call(null,d,g,h);return a.b?a.b(d):a.call(null,d)}function d(c,g){var h=b.a?b.a(c,g):b.call(null,c,g);return a.b?a.b(h):a.call(null,h)}
function l(c){c=b.b?b.b(c):b.call(null,c);return a.b?a.b(c):a.call(null,c)}function m(){var c=b.l?b.l():b.call(null);return a.b?a.b(c):a.call(null,c)}var p=null,q=function(){function c(a,b,e,f){var g=null;if(3<arguments.length){for(var g=0,h=Array(arguments.length-3);g<h.length;)h[g]=arguments[g+3],++g;g=new F(h,0)}return d.call(this,a,b,e,g)}function d(c,g,h,l){c=T.r(b,c,g,h,l);return a.b?a.b(c):a.call(null,c)}c.i=3;c.f=function(a){var b=G(a);a=K(a);var c=G(a);a=K(a);var e=G(a);a=H(a);return d(b,
c,e,a)};c.d=d;return c}(),p=function(a,b,e,f){switch(arguments.length){case 0:return m.call(this);case 1:return l.call(this,a);case 2:return d.call(this,a,b);case 3:return c.call(this,a,b,e);default:var p=null;if(3<arguments.length){for(var p=0,E=Array(arguments.length-3);p<E.length;)E[p]=arguments[p+3],++p;p=new F(E,0)}return q.d(a,b,e,p)}throw Error("Invalid arity: "+arguments.length);};p.i=3;p.f=q.f;p.l=m;p.b=l;p.a=d;p.c=c;p.d=q.d;return p}()}var c=null,d=function(){function a(c,d,e,m){var p=null;
if(3<arguments.length){for(var p=0,q=Array(arguments.length-3);p<q.length;)q[p]=arguments[p+3],++p;p=new F(q,0)}return b.call(this,c,d,e,p)}function b(a,c,d,e){return function(a){return function(){function b(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return c.call(this,d)}function c(b){b=T.a(G(a),b);for(var d=K(a);;)if(d)b=G(d).call(null,b),d=K(d);else return b}b.i=0;b.f=function(a){a=D(a);return c(a)};b.d=c;return b}()}(Jd(be.n(a,
c,d,e)))}a.i=3;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=K(a);var e=G(a);a=H(a);return b(c,d,e,a)};a.d=b;return a}(),c=function(c,f,g,h){switch(arguments.length){case 0:return ud;case 1:return c;case 2:return b.call(this,c,f);case 3:return a.call(this,c,f,g);default:var l=null;if(3<arguments.length){for(var l=0,m=Array(arguments.length-3);l<m.length;)m[l]=arguments[l+3],++l;l=new F(m,0)}return d.d(c,f,g,l)}throw Error("Invalid arity: "+arguments.length);};c.i=3;c.f=d.f;c.l=function(){return ud};
c.b=function(a){return a};c.a=b;c.c=a;c.d=d.d;return c}(),Je=function(){function a(a,b,c,d){return function(){function e(m,p,q){return a.P?a.P(b,c,d,m,p,q):a.call(null,b,c,d,m,p,q)}function p(e,m){return a.r?a.r(b,c,d,e,m):a.call(null,b,c,d,e,m)}function q(e){return a.n?a.n(b,c,d,e):a.call(null,b,c,d,e)}function s(){return a.c?a.c(b,c,d):a.call(null,b,c,d)}var u=null,v=function(){function e(a,b,c,d){var f=null;if(3<arguments.length){for(var f=0,g=Array(arguments.length-3);f<g.length;)g[f]=arguments[f+
3],++f;f=new F(g,0)}return m.call(this,a,b,c,f)}function m(e,p,q,s){return T.d(a,b,c,d,e,Kc([p,q,s],0))}e.i=3;e.f=function(a){var b=G(a);a=K(a);var c=G(a);a=K(a);var d=G(a);a=H(a);return m(b,c,d,a)};e.d=m;return e}(),u=function(a,b,c,d){switch(arguments.length){case 0:return s.call(this);case 1:return q.call(this,a);case 2:return p.call(this,a,b);case 3:return e.call(this,a,b,c);default:var f=null;if(3<arguments.length){for(var f=0,g=Array(arguments.length-3);f<g.length;)g[f]=arguments[f+3],++f;f=
new F(g,0)}return v.d(a,b,c,f)}throw Error("Invalid arity: "+arguments.length);};u.i=3;u.f=v.f;u.l=s;u.b=q;u.a=p;u.c=e;u.d=v.d;return u}()}function b(a,b,c){return function(){function d(e,l,m){return a.r?a.r(b,c,e,l,m):a.call(null,b,c,e,l,m)}function e(d,l){return a.n?a.n(b,c,d,l):a.call(null,b,c,d,l)}function p(d){return a.c?a.c(b,c,d):a.call(null,b,c,d)}function q(){return a.a?a.a(b,c):a.call(null,b,c)}var s=null,u=function(){function d(a,b,c,f){var g=null;if(3<arguments.length){for(var g=0,h=Array(arguments.length-
3);g<h.length;)h[g]=arguments[g+3],++g;g=new F(h,0)}return e.call(this,a,b,c,g)}function e(d,l,m,p){return T.d(a,b,c,d,l,Kc([m,p],0))}d.i=3;d.f=function(a){var b=G(a);a=K(a);var c=G(a);a=K(a);var d=G(a);a=H(a);return e(b,c,d,a)};d.d=e;return d}(),s=function(a,b,c,f){switch(arguments.length){case 0:return q.call(this);case 1:return p.call(this,a);case 2:return e.call(this,a,b);case 3:return d.call(this,a,b,c);default:var g=null;if(3<arguments.length){for(var g=0,h=Array(arguments.length-3);g<h.length;)h[g]=
arguments[g+3],++g;g=new F(h,0)}return u.d(a,b,c,g)}throw Error("Invalid arity: "+arguments.length);};s.i=3;s.f=u.f;s.l=q;s.b=p;s.a=e;s.c=d;s.d=u.d;return s}()}function c(a,b){return function(){function c(d,e,h){return a.n?a.n(b,d,e,h):a.call(null,b,d,e,h)}function d(c,e){return a.c?a.c(b,c,e):a.call(null,b,c,e)}function e(c){return a.a?a.a(b,c):a.call(null,b,c)}function p(){return a.b?a.b(b):a.call(null,b)}var q=null,s=function(){function c(a,b,e,f){var g=null;if(3<arguments.length){for(var g=0,
h=Array(arguments.length-3);g<h.length;)h[g]=arguments[g+3],++g;g=new F(h,0)}return d.call(this,a,b,e,g)}function d(c,e,h,l){return T.d(a,b,c,e,h,Kc([l],0))}c.i=3;c.f=function(a){var b=G(a);a=K(a);var c=G(a);a=K(a);var e=G(a);a=H(a);return d(b,c,e,a)};c.d=d;return c}(),q=function(a,b,f,g){switch(arguments.length){case 0:return p.call(this);case 1:return e.call(this,a);case 2:return d.call(this,a,b);case 3:return c.call(this,a,b,f);default:var q=null;if(3<arguments.length){for(var q=0,N=Array(arguments.length-
3);q<N.length;)N[q]=arguments[q+3],++q;q=new F(N,0)}return s.d(a,b,f,q)}throw Error("Invalid arity: "+arguments.length);};q.i=3;q.f=s.f;q.l=p;q.b=e;q.a=d;q.c=c;q.d=s.d;return q}()}var d=null,e=function(){function a(c,d,e,f,q){var s=null;if(4<arguments.length){for(var s=0,u=Array(arguments.length-4);s<u.length;)u[s]=arguments[s+4],++s;s=new F(u,0)}return b.call(this,c,d,e,f,s)}function b(a,c,d,e,f){return function(){function b(a){var c=null;if(0<arguments.length){for(var c=0,d=Array(arguments.length-
0);c<d.length;)d[c]=arguments[c+0],++c;c=new F(d,0)}return g.call(this,c)}function g(b){return T.r(a,c,d,e,ae.a(f,b))}b.i=0;b.f=function(a){a=D(a);return g(a)};b.d=g;return b}()}a.i=4;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=K(a);var e=G(a);a=K(a);var f=G(a);a=H(a);return b(c,d,e,f,a)};a.d=b;return a}(),d=function(d,g,h,l,m){switch(arguments.length){case 1:return d;case 2:return c.call(this,d,g);case 3:return b.call(this,d,g,h);case 4:return a.call(this,d,g,h,l);default:var p=null;if(4<arguments.length){for(var p=
0,q=Array(arguments.length-4);p<q.length;)q[p]=arguments[p+4],++p;p=new F(q,0)}return e.d(d,g,h,l,p)}throw Error("Invalid arity: "+arguments.length);};d.i=4;d.f=e.f;d.b=function(a){return a};d.a=c;d.c=b;d.n=a;d.d=e.d;return d}(),Ke=function(){function a(a,b,c,d){return function(){function l(l,m,p){l=null==l?b:l;m=null==m?c:m;p=null==p?d:p;return a.c?a.c(l,m,p):a.call(null,l,m,p)}function m(d,h){var l=null==d?b:d,m=null==h?c:h;return a.a?a.a(l,m):a.call(null,l,m)}var p=null,q=function(){function l(a,
b,c,d){var e=null;if(3<arguments.length){for(var e=0,f=Array(arguments.length-3);e<f.length;)f[e]=arguments[e+3],++e;e=new F(f,0)}return m.call(this,a,b,c,e)}function m(l,p,q,s){return T.r(a,null==l?b:l,null==p?c:p,null==q?d:q,s)}l.i=3;l.f=function(a){var b=G(a);a=K(a);var c=G(a);a=K(a);var d=G(a);a=H(a);return m(b,c,d,a)};l.d=m;return l}(),p=function(a,b,c,d){switch(arguments.length){case 2:return m.call(this,a,b);case 3:return l.call(this,a,b,c);default:var e=null;if(3<arguments.length){for(var e=
0,f=Array(arguments.length-3);e<f.length;)f[e]=arguments[e+3],++e;e=new F(f,0)}return q.d(a,b,c,e)}throw Error("Invalid arity: "+arguments.length);};p.i=3;p.f=q.f;p.a=m;p.c=l;p.d=q.d;return p}()}function b(a,b,c){return function(){function d(h,l,m){h=null==h?b:h;l=null==l?c:l;return a.c?a.c(h,l,m):a.call(null,h,l,m)}function l(d,h){var l=null==d?b:d,m=null==h?c:h;return a.a?a.a(l,m):a.call(null,l,m)}var m=null,p=function(){function d(a,b,c,e){var f=null;if(3<arguments.length){for(var f=0,g=Array(arguments.length-
3);f<g.length;)g[f]=arguments[f+3],++f;f=new F(g,0)}return h.call(this,a,b,c,f)}function h(d,l,m,p){return T.r(a,null==d?b:d,null==l?c:l,m,p)}d.i=3;d.f=function(a){var b=G(a);a=K(a);var c=G(a);a=K(a);var d=G(a);a=H(a);return h(b,c,d,a)};d.d=h;return d}(),m=function(a,b,c,e){switch(arguments.length){case 2:return l.call(this,a,b);case 3:return d.call(this,a,b,c);default:var f=null;if(3<arguments.length){for(var f=0,g=Array(arguments.length-3);f<g.length;)g[f]=arguments[f+3],++f;f=new F(g,0)}return p.d(a,
b,c,f)}throw Error("Invalid arity: "+arguments.length);};m.i=3;m.f=p.f;m.a=l;m.c=d;m.d=p.d;return m}()}function c(a,b){return function(){function c(d,g,h){d=null==d?b:d;return a.c?a.c(d,g,h):a.call(null,d,g,h)}function d(c,g){var h=null==c?b:c;return a.a?a.a(h,g):a.call(null,h,g)}function l(c){c=null==c?b:c;return a.b?a.b(c):a.call(null,c)}var m=null,p=function(){function c(a,b,e,f){var g=null;if(3<arguments.length){for(var g=0,h=Array(arguments.length-3);g<h.length;)h[g]=arguments[g+3],++g;g=new F(h,
0)}return d.call(this,a,b,e,g)}function d(c,g,h,l){return T.r(a,null==c?b:c,g,h,l)}c.i=3;c.f=function(a){var b=G(a);a=K(a);var c=G(a);a=K(a);var e=G(a);a=H(a);return d(b,c,e,a)};c.d=d;return c}(),m=function(a,b,e,f){switch(arguments.length){case 1:return l.call(this,a);case 2:return d.call(this,a,b);case 3:return c.call(this,a,b,e);default:var m=null;if(3<arguments.length){for(var m=0,B=Array(arguments.length-3);m<B.length;)B[m]=arguments[m+3],++m;m=new F(B,0)}return p.d(a,b,e,m)}throw Error("Invalid arity: "+
arguments.length);};m.i=3;m.f=p.f;m.b=l;m.a=d;m.c=c;m.d=p.d;return m}()}var d=null,d=function(d,f,g,h){switch(arguments.length){case 2:return c.call(this,d,f);case 3:return b.call(this,d,f,g);case 4:return a.call(this,d,f,g,h)}throw Error("Invalid arity: "+arguments.length);};d.a=c;d.c=b;d.n=a;return d}(),Le=function(){function a(a,b){return new V(null,function(){var f=D(b);if(f){if(fd(f)){for(var g=Yb(f),h=Q(g),l=Td(h),m=0;;)if(m<h){var p=function(){var b=C.a(g,m);return a.b?a.b(b):a.call(null,b)}();
null!=p&&l.add(p);m+=1}else break;return Wd(l.ca(),c.a(a,Zb(f)))}h=function(){var b=G(f);return a.b?a.b(b):a.call(null,b)}();return null==h?c.a(a,H(f)):M(h,c.a(a,H(f)))}return null},null,null)}function b(a){return function(b){return function(){function c(f,g){var h=a.b?a.b(g):a.call(null,g);return null==h?f:b.a?b.a(f,h):b.call(null,f,h)}function g(a){return b.b?b.b(a):b.call(null,a)}function h(){return b.l?b.l():b.call(null)}var l=null,l=function(a,b){switch(arguments.length){case 0:return h.call(this);
case 1:return g.call(this,a);case 2:return c.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);};l.l=h;l.b=g;l.a=c;return l}()}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}();function Me(a){this.state=a;this.q=0;this.j=32768}Me.prototype.Ra=function(){return this.state};Me.prototype.bb=function(a,b){return this.state=b};
var Ne=function(){function a(a,b){return function g(b,c){return new V(null,function(){var e=D(c);if(e){if(fd(e)){for(var p=Yb(e),q=Q(p),s=Td(q),u=0;;)if(u<q){var v=function(){var c=b+u,e=C.a(p,u);return a.a?a.a(c,e):a.call(null,c,e)}();null!=v&&s.add(v);u+=1}else break;return Wd(s.ca(),g(b+q,Zb(e)))}q=function(){var c=G(e);return a.a?a.a(b,c):a.call(null,b,c)}();return null==q?g(b+1,H(e)):M(q,g(b+1,H(e)))}return null},null,null)}(0,b)}function b(a){return function(b){return function(c){return function(){function g(g,
h){var l=c.bb(0,c.Ra(null)+1),l=a.a?a.a(l,h):a.call(null,l,h);return null==l?g:b.a?b.a(g,l):b.call(null,g,l)}function h(a){return b.b?b.b(a):b.call(null,a)}function l(){return b.l?b.l():b.call(null)}var m=null,m=function(a,b){switch(arguments.length){case 0:return l.call(this);case 1:return h.call(this,a);case 2:return g.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);};m.l=l;m.b=h;m.a=g;return m}()}(new Me(-1))}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,
c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),Oe=function(){function a(a,b,c,d){return new V(null,function(){var f=D(b),q=D(c),s=D(d);if(f&&q&&s){var u=M,v;v=G(f);var y=G(q),B=G(s);v=a.c?a.c(v,y,B):a.call(null,v,y,B);f=u(v,e.n(a,H(f),H(q),H(s)))}else f=null;return f},null,null)}function b(a,b,c){return new V(null,function(){var d=D(b),f=D(c);if(d&&f){var q=M,s;s=G(d);var u=G(f);s=a.a?a.a(s,u):a.call(null,s,u);d=q(s,e.c(a,H(d),H(f)))}else d=
null;return d},null,null)}function c(a,b){return new V(null,function(){var c=D(b);if(c){if(fd(c)){for(var d=Yb(c),f=Q(d),q=Td(f),s=0;;)if(s<f)Xd(q,function(){var b=C.a(d,s);return a.b?a.b(b):a.call(null,b)}()),s+=1;else break;return Wd(q.ca(),e.a(a,Zb(c)))}return M(function(){var b=G(c);return a.b?a.b(b):a.call(null,b)}(),e.a(a,H(c)))}return null},null,null)}function d(a){return function(b){return function(){function c(d,e){var f=a.b?a.b(e):a.call(null,e);return b.a?b.a(d,f):b.call(null,d,f)}function d(a){return b.b?
b.b(a):b.call(null,a)}function e(){return b.l?b.l():b.call(null)}var f=null,s=function(){function c(a,b,e){var f=null;if(2<arguments.length){for(var f=0,g=Array(arguments.length-2);f<g.length;)g[f]=arguments[f+2],++f;f=new F(g,0)}return d.call(this,a,b,f)}function d(c,e,f){e=T.c(a,e,f);return b.a?b.a(c,e):b.call(null,c,e)}c.i=2;c.f=function(a){var b=G(a);a=K(a);var c=G(a);a=H(a);return d(b,c,a)};c.d=d;return c}(),f=function(a,b,f){switch(arguments.length){case 0:return e.call(this);case 1:return d.call(this,
a);case 2:return c.call(this,a,b);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return s.d(a,b,g)}throw Error("Invalid arity: "+arguments.length);};f.i=2;f.f=s.f;f.l=e;f.b=d;f.a=c;f.d=s.d;return f}()}}var e=null,f=function(){function a(c,d,e,f,g){var u=null;if(4<arguments.length){for(var u=0,v=Array(arguments.length-4);u<v.length;)v[u]=arguments[u+4],++u;u=new F(v,0)}return b.call(this,c,d,e,f,u)}function b(a,c,d,
f,g){var h=function y(a){return new V(null,function(){var b=e.a(D,a);return Ee(ud,b)?M(e.a(G,b),y(e.a(H,b))):null},null,null)};return e.a(function(){return function(b){return T.a(a,b)}}(h),h(Nc.d(g,f,Kc([d,c],0))))}a.i=4;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=K(a);var e=G(a);a=K(a);var f=G(a);a=H(a);return b(c,d,e,f,a)};a.d=b;return a}(),e=function(e,h,l,m,p){switch(arguments.length){case 1:return d.call(this,e);case 2:return c.call(this,e,h);case 3:return b.call(this,e,h,l);case 4:return a.call(this,
e,h,l,m);default:var q=null;if(4<arguments.length){for(var q=0,s=Array(arguments.length-4);q<s.length;)s[q]=arguments[q+4],++q;q=new F(s,0)}return f.d(e,h,l,m,q)}throw Error("Invalid arity: "+arguments.length);};e.i=4;e.f=f.f;e.b=d;e.a=c;e.c=b;e.n=a;e.d=f.d;return e}(),Pe=function(){function a(a,b){return new V(null,function(){if(0<a){var f=D(b);return f?M(G(f),c.a(a-1,H(f))):null}return null},null,null)}function b(a){return function(b){return function(a){return function(){function c(d,g){var h=qb(a),
l=a.bb(0,a.Ra(null)-1),h=0<h?b.a?b.a(d,g):b.call(null,d,g):d;return 0<l?h:Ac(h)?h:new yc(h)}function d(a){return b.b?b.b(a):b.call(null,a)}function l(){return b.l?b.l():b.call(null)}var m=null,m=function(a,b){switch(arguments.length){case 0:return l.call(this);case 1:return d.call(this,a);case 2:return c.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);};m.l=l;m.b=d;m.a=c;return m}()}(new Me(a))}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,
c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),Qe=function(){function a(a,b){return new V(null,function(c){return function(){return c(a,b)}}(function(a,b){for(;;){var c=D(b);if(0<a&&c){var d=a-1,c=H(c);a=d;b=c}else return c}}),null,null)}function b(a){return function(b){return function(a){return function(){function c(d,g){var h=qb(a);a.bb(0,a.Ra(null)-1);return 0<h?d:b.a?b.a(d,g):b.call(null,d,g)}function d(a){return b.b?b.b(a):b.call(null,a)}function l(){return b.l?
b.l():b.call(null)}var m=null,m=function(a,b){switch(arguments.length){case 0:return l.call(this);case 1:return d.call(this,a);case 2:return c.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);};m.l=l;m.b=d;m.a=c;return m}()}(new Me(a))}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),Re=function(){function a(a,b){return new V(null,function(c){return function(){return c(a,
b)}}(function(a,b){for(;;){var c=D(b),d;if(d=c)d=G(c),d=a.b?a.b(d):a.call(null,d);if(t(d))d=a,c=H(c),a=d,b=c;else return c}}),null,null)}function b(a){return function(b){return function(c){return function(){function g(g,h){var l=qb(c);if(t(t(l)?a.b?a.b(h):a.call(null,h):l))return g;ac(c,null);return b.a?b.a(g,h):b.call(null,g,h)}function h(a){return b.b?b.b(a):b.call(null,a)}function l(){return b.l?b.l():b.call(null)}var m=null,m=function(a,b){switch(arguments.length){case 0:return l.call(this);case 1:return h.call(this,
a);case 2:return g.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);};m.l=l;m.b=h;m.a=g;return m}()}(new Me(!0))}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),Se=function(){function a(a,b){return Pe.a(a,c.b(b))}function b(a){return new V(null,function(){return M(a,c.b(a))},null,null)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,
c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),Te=function(){function a(a,b){return Pe.a(a,c.b(b))}function b(a){return new V(null,function(){return M(a.l?a.l():a.call(null),c.b(a))},null,null)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),Ue=function(){function a(a,c){return new V(null,function(){var f=
D(a),g=D(c);return f&&g?M(G(f),M(G(g),b.a(H(f),H(g)))):null},null,null)}var b=null,c=function(){function a(b,d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return c.call(this,b,d,l)}function c(a,d,e){return new V(null,function(){var c=Oe.a(D,Nc.d(e,d,Kc([a],0)));return Ee(ud,c)?ae.a(Oe.a(G,c),T.a(b,Oe.a(H,c))):null},null,null)}a.i=2;a.f=function(a){var b=G(a);a=K(a);var d=G(a);a=H(a);return c(b,d,a)};a.d=c;return a}(),
b=function(b,e,f){switch(arguments.length){case 2:return a.call(this,b,e);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.a=a;b.d=c.d;return b}(),We=function(){function a(a){return Ie.a(Oe.b(a),Ve)}var b=null,c=function(){function a(c,d){var h=null;if(1<arguments.length){for(var h=0,l=Array(arguments.length-1);h<l.length;)l[h]=arguments[h+
1],++h;h=new F(l,0)}return b.call(this,c,h)}function b(a,c){return T.a(ae,T.c(Oe,a,c))}a.i=1;a.f=function(a){var c=G(a);a=H(a);return b(c,a)};a.d=b;return a}(),b=function(b,e){switch(arguments.length){case 1:return a.call(this,b);default:var f=null;if(1<arguments.length){for(var f=0,g=Array(arguments.length-1);f<g.length;)g[f]=arguments[f+1],++f;f=new F(g,0)}return c.d(b,f)}throw Error("Invalid arity: "+arguments.length);};b.i=1;b.f=c.f;b.b=a;b.d=c.d;return b}(),Xe=function(){function a(a,b){return new V(null,
function(){var f=D(b);if(f){if(fd(f)){for(var g=Yb(f),h=Q(g),l=Td(h),m=0;;)if(m<h){var p;p=C.a(g,m);p=a.b?a.b(p):a.call(null,p);t(p)&&(p=C.a(g,m),l.add(p));m+=1}else break;return Wd(l.ca(),c.a(a,Zb(f)))}g=G(f);f=H(f);return t(a.b?a.b(g):a.call(null,g))?M(g,c.a(a,f)):c.a(a,f)}return null},null,null)}function b(a){return function(b){return function(){function c(f,g){return t(a.b?a.b(g):a.call(null,g))?b.a?b.a(f,g):b.call(null,f,g):f}function g(a){return b.b?b.b(a):b.call(null,a)}function h(){return b.l?
b.l():b.call(null)}var l=null,l=function(a,b){switch(arguments.length){case 0:return h.call(this);case 1:return g.call(this,a);case 2:return c.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);};l.l=h;l.b=g;l.a=c;return l}()}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),Ye=function(){function a(a,b){return Xe.a(He(a),b)}function b(a){return Xe.b(He(a))}
var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}();function Ze(a){var b=$e;return function d(a){return new V(null,function(){return M(a,t(b.b?b.b(a):b.call(null,a))?We.d(d,Kc([D.b?D.b(a):D.call(null,a)],0)):null)},null,null)}(a)}
var af=function(){function a(a,b,c){return a&&(a.q&4||a.dc)?O(ce(wd.n(b,de,Ob(a),c)),Vc(a)):wd.n(b,Nc,a,c)}function b(a,b){return null!=a?a&&(a.q&4||a.dc)?O(ce(A.c(Pb,Ob(a),b)),Vc(a)):A.c(Ra,a,b):A.c(Nc,J,b)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}(),bf=function(){function a(a,b,c,h){return new V(null,function(){var l=D(h);if(l){var m=Pe.a(a,l);return a===
Q(m)?M(m,d.n(a,b,c,Qe.a(b,l))):Ra(J,Pe.a(a,ae.a(m,c)))}return null},null,null)}function b(a,b,c){return new V(null,function(){var h=D(c);if(h){var l=Pe.a(a,h);return a===Q(l)?M(l,d.c(a,b,Qe.a(b,h))):null}return null},null,null)}function c(a,b){return d.c(a,a,b)}var d=null,d=function(d,f,g,h){switch(arguments.length){case 2:return c.call(this,d,f);case 3:return b.call(this,d,f,g);case 4:return a.call(this,d,f,g,h)}throw Error("Invalid arity: "+arguments.length);};d.a=c;d.c=b;d.n=a;return d}(),cf=function(){function a(a,
b,c){var g=jd;for(b=D(b);;)if(b){var h=a;if(h?h.j&256||h.Rb||(h.j?0:w(Za,h)):w(Za,h)){a=S.c(a,G(b),g);if(g===a)return c;b=K(b)}else return c}else return a}function b(a,b){return c.c(a,b,null)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}(),df=function(){function a(a,b,c,d,f,q){var s=R.c(b,0,null);return(b=Ed(b))?Rc.c(a,s,e.P(S.a(a,s),b,c,d,f,q)):Rc.c(a,s,
function(){var b=S.a(a,s);return c.n?c.n(b,d,f,q):c.call(null,b,d,f,q)}())}function b(a,b,c,d,f){var q=R.c(b,0,null);return(b=Ed(b))?Rc.c(a,q,e.r(S.a(a,q),b,c,d,f)):Rc.c(a,q,function(){var b=S.a(a,q);return c.c?c.c(b,d,f):c.call(null,b,d,f)}())}function c(a,b,c,d){var f=R.c(b,0,null);return(b=Ed(b))?Rc.c(a,f,e.n(S.a(a,f),b,c,d)):Rc.c(a,f,function(){var b=S.a(a,f);return c.a?c.a(b,d):c.call(null,b,d)}())}function d(a,b,c){var d=R.c(b,0,null);return(b=Ed(b))?Rc.c(a,d,e.c(S.a(a,d),b,c)):Rc.c(a,d,function(){var b=
S.a(a,d);return c.b?c.b(b):c.call(null,b)}())}var e=null,f=function(){function a(c,d,e,f,g,u,v){var y=null;if(6<arguments.length){for(var y=0,B=Array(arguments.length-6);y<B.length;)B[y]=arguments[y+6],++y;y=new F(B,0)}return b.call(this,c,d,e,f,g,u,y)}function b(a,c,d,f,g,h,v){var y=R.c(c,0,null);return(c=Ed(c))?Rc.c(a,y,T.d(e,S.a(a,y),c,d,f,Kc([g,h,v],0))):Rc.c(a,y,T.d(d,S.a(a,y),f,g,h,Kc([v],0)))}a.i=6;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=K(a);var e=G(a);a=K(a);var f=G(a);a=K(a);var g=
G(a);a=K(a);var v=G(a);a=H(a);return b(c,d,e,f,g,v,a)};a.d=b;return a}(),e=function(e,h,l,m,p,q,s){switch(arguments.length){case 3:return d.call(this,e,h,l);case 4:return c.call(this,e,h,l,m);case 5:return b.call(this,e,h,l,m,p);case 6:return a.call(this,e,h,l,m,p,q);default:var u=null;if(6<arguments.length){for(var u=0,v=Array(arguments.length-6);u<v.length;)v[u]=arguments[u+6],++u;u=new F(v,0)}return f.d(e,h,l,m,p,q,u)}throw Error("Invalid arity: "+arguments.length);};e.i=6;e.f=f.f;e.c=d;e.n=c;
e.r=b;e.P=a;e.d=f.d;return e}();function ef(a,b){this.u=a;this.e=b}function ff(a){return new ef(a,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null])}function gf(a){return new ef(a.u,Fa(a.e))}function hf(a){a=a.g;return 32>a?0:a-1>>>5<<5}function jf(a,b,c){for(;;){if(0===b)return c;var d=ff(a);d.e[0]=c;c=d;b-=5}}
var lf=function kf(b,c,d,e){var f=gf(d),g=b.g-1>>>c&31;5===c?f.e[g]=e:(d=d.e[g],b=null!=d?kf(b,c-5,d,e):jf(null,c-5,e),f.e[g]=b);return f};function mf(a,b){throw Error([z("No item "),z(a),z(" in vector of length "),z(b)].join(""));}function nf(a,b){if(b>=hf(a))return a.W;for(var c=a.root,d=a.shift;;)if(0<d)var e=d-5,c=c.e[b>>>d&31],d=e;else return c.e}function of(a,b){return 0<=b&&b<a.g?nf(a,b):mf(b,a.g)}
var qf=function pf(b,c,d,e,f){var g=gf(d);if(0===c)g.e[e&31]=f;else{var h=e>>>c&31;b=pf(b,c-5,d.e[h],e,f);g.e[h]=b}return g},sf=function rf(b,c,d){var e=b.g-2>>>c&31;if(5<c){b=rf(b,c-5,d.e[e]);if(null==b&&0===e)return null;d=gf(d);d.e[e]=b;return d}if(0===e)return null;d=gf(d);d.e[e]=null;return d};function tf(a,b,c,d,e,f){this.m=a;this.zb=b;this.e=c;this.oa=d;this.start=e;this.end=f}tf.prototype.ga=function(){return this.m<this.end};
tf.prototype.next=function(){32===this.m-this.zb&&(this.e=nf(this.oa,this.m),this.zb+=32);var a=this.e[this.m&31];this.m+=1;return a};function W(a,b,c,d,e,f){this.k=a;this.g=b;this.shift=c;this.root=d;this.W=e;this.p=f;this.j=167668511;this.q=8196}k=W.prototype;k.toString=function(){return ec(this)};k.t=function(a,b){return $a.c(this,b,null)};k.s=function(a,b,c){return"number"===typeof b?C.c(this,b,c):c};
k.gb=function(a,b,c){a=0;for(var d=c;;)if(a<this.g){var e=nf(this,a);c=e.length;a:{for(var f=0;;)if(f<c){var g=f+a,h=e[f],d=b.c?b.c(d,g,h):b.call(null,d,g,h);if(Ac(d)){e=d;break a}f+=1}else{e=d;break a}e=void 0}if(Ac(e))return b=e,L.b?L.b(b):L.call(null,b);a+=c;d=e}else return d};k.Q=function(a,b){return of(this,b)[b&31]};k.$=function(a,b,c){return 0<=b&&b<this.g?nf(this,b)[b&31]:c};
k.Ua=function(a,b,c){if(0<=b&&b<this.g)return hf(this)<=b?(a=Fa(this.W),a[b&31]=c,new W(this.k,this.g,this.shift,this.root,a,null)):new W(this.k,this.g,this.shift,qf(this,this.shift,this.root,b,c),this.W,null);if(b===this.g)return Ra(this,c);throw Error([z("Index "),z(b),z(" out of bounds  [0,"),z(this.g),z("]")].join(""));};k.vb=!0;k.fb=function(){var a=this.g;return new tf(0,0,0<Q(this)?nf(this,0):null,this,0,a)};k.H=function(){return this.k};k.L=function(){return this.g};
k.hb=function(){return C.a(this,0)};k.ib=function(){return C.a(this,1)};k.La=function(){return 0<this.g?C.a(this,this.g-1):null};
k.Ma=function(){if(0===this.g)throw Error("Can't pop empty vector");if(1===this.g)return ub(Mc,this.k);if(1<this.g-hf(this))return new W(this.k,this.g-1,this.shift,this.root,this.W.slice(0,-1),null);var a=nf(this,this.g-2),b=sf(this,this.shift,this.root),b=null==b?uf:b,c=this.g-1;return 5<this.shift&&null==b.e[1]?new W(this.k,c,this.shift-5,b.e[0],a,null):new W(this.k,c,this.shift,b,a,null)};k.ab=function(){return 0<this.g?new Hc(this,this.g-1,null):null};
k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){if(b instanceof W)if(this.g===Q(b))for(var c=cc(this),d=cc(b);;)if(t(c.ga())){var e=c.next(),f=d.next();if(!sc.a(e,f))return!1}else return!0;else return!1;else return Ic(this,b)};k.$a=function(){var a=this;return new vf(a.g,a.shift,function(){var b=a.root;return wf.b?wf.b(b):wf.call(null,b)}(),function(){var b=a.W;return xf.b?xf.b(b):xf.call(null,b)}())};k.J=function(){return O(Mc,this.k)};
k.R=function(a,b){return Cc.a(this,b)};k.O=function(a,b,c){a=0;for(var d=c;;)if(a<this.g){var e=nf(this,a);c=e.length;a:{for(var f=0;;)if(f<c){var g=e[f],d=b.a?b.a(d,g):b.call(null,d,g);if(Ac(d)){e=d;break a}f+=1}else{e=d;break a}e=void 0}if(Ac(e))return b=e,L.b?L.b(b):L.call(null,b);a+=c;d=e}else return d};k.Ka=function(a,b,c){if("number"===typeof b)return pb(this,b,c);throw Error("Vector's key for assoc must be a number.");};
k.D=function(){if(0===this.g)return null;if(32>=this.g)return new F(this.W,0);var a;a:{a=this.root;for(var b=this.shift;;)if(0<b)b-=5,a=a.e[0];else{a=a.e;break a}a=void 0}return yf.n?yf.n(this,a,0,0):yf.call(null,this,a,0,0)};k.F=function(a,b){return new W(b,this.g,this.shift,this.root,this.W,this.p)};
k.G=function(a,b){if(32>this.g-hf(this)){for(var c=this.W.length,d=Array(c+1),e=0;;)if(e<c)d[e]=this.W[e],e+=1;else break;d[c]=b;return new W(this.k,this.g+1,this.shift,this.root,d,null)}c=(d=this.g>>>5>1<<this.shift)?this.shift+5:this.shift;d?(d=ff(null),d.e[0]=this.root,e=jf(null,this.shift,new ef(null,this.W)),d.e[1]=e):d=lf(this,this.shift,this.root,new ef(null,this.W));return new W(this.k,this.g+1,c,d,[b],null)};
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return this.Q(null,c);case 3:return this.$(null,c,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return this.Q(null,c)};a.c=function(a,c,d){return this.$(null,c,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return this.Q(null,a)};k.a=function(a,b){return this.$(null,a,b)};
var uf=new ef(null,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]),Mc=new W(null,0,5,uf,[],0);W.prototype[Ea]=function(){return uc(this)};function zf(a){return Qb(A.c(Pb,Ob(Mc),a))}
var Af=function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){if(a instanceof F&&0===a.m)a:{a=a.e;var b=a.length;if(32>b)a=new W(null,b,5,uf,a,null);else{for(var e=32,f=(new W(null,32,5,uf,a.slice(0,32),null)).$a(null);;)if(e<b)var g=e+1,f=de.a(f,a[e]),e=g;else{a=Qb(f);break a}a=void 0}}else a=zf(a);return a}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}();
function Bf(a,b,c,d,e,f){this.ha=a;this.Ja=b;this.m=c;this.V=d;this.k=e;this.p=f;this.j=32375020;this.q=1536}k=Bf.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.k};k.T=function(){if(this.V+1<this.Ja.length){var a;a=this.ha;var b=this.Ja,c=this.m,d=this.V+1;a=yf.n?yf.n(a,b,c,d):yf.call(null,a,b,c,d);return null==a?null:a}return $b(this)};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(Mc,this.k)};
k.R=function(a,b){var c=this;return Cc.a(function(){var a=c.ha,b=c.m+c.V,f=Q(c.ha);return Cf.c?Cf.c(a,b,f):Cf.call(null,a,b,f)}(),b)};k.O=function(a,b,c){var d=this;return Cc.c(function(){var a=d.ha,b=d.m+d.V,c=Q(d.ha);return Cf.c?Cf.c(a,b,c):Cf.call(null,a,b,c)}(),b,c)};k.N=function(){return this.Ja[this.V]};k.S=function(){if(this.V+1<this.Ja.length){var a;a=this.ha;var b=this.Ja,c=this.m,d=this.V+1;a=yf.n?yf.n(a,b,c,d):yf.call(null,a,b,c,d);return null==a?J:a}return Zb(this)};k.D=function(){return this};
k.Cb=function(){return Ud.a(this.Ja,this.V)};k.Db=function(){var a=this.m+this.Ja.length;if(a<Ma(this.ha)){var b=this.ha,c=nf(this.ha,a);return yf.n?yf.n(b,c,a,0):yf.call(null,b,c,a,0)}return J};k.F=function(a,b){var c=this.ha,d=this.Ja,e=this.m,f=this.V;return yf.r?yf.r(c,d,e,f,b):yf.call(null,c,d,e,f,b)};k.G=function(a,b){return M(b,this)};k.Bb=function(){var a=this.m+this.Ja.length;if(a<Ma(this.ha)){var b=this.ha,c=nf(this.ha,a);return yf.n?yf.n(b,c,a,0):yf.call(null,b,c,a,0)}return null};
Bf.prototype[Ea]=function(){return uc(this)};var yf=function(){function a(a,b,c,d,l){return new Bf(a,b,c,d,l,null)}function b(a,b,c,d){return new Bf(a,b,c,d,null,null)}function c(a,b,c){return new Bf(a,of(a,b),b,c,null,null)}var d=null,d=function(d,f,g,h,l){switch(arguments.length){case 3:return c.call(this,d,f,g);case 4:return b.call(this,d,f,g,h);case 5:return a.call(this,d,f,g,h,l)}throw Error("Invalid arity: "+arguments.length);};d.c=c;d.n=b;d.r=a;return d}();
function Df(a,b,c,d,e){this.k=a;this.oa=b;this.start=c;this.end=d;this.p=e;this.j=166617887;this.q=8192}k=Df.prototype;k.toString=function(){return ec(this)};k.t=function(a,b){return $a.c(this,b,null)};k.s=function(a,b,c){return"number"===typeof b?C.c(this,b,c):c};k.Q=function(a,b){return 0>b||this.end<=this.start+b?mf(b,this.end-this.start):C.a(this.oa,this.start+b)};k.$=function(a,b,c){return 0>b||this.end<=this.start+b?c:C.c(this.oa,this.start+b,c)};
k.Ua=function(a,b,c){var d=this.start+b;a=this.k;c=Rc.c(this.oa,d,c);b=this.start;var e=this.end,d=d+1,d=e>d?e:d;return Ef.r?Ef.r(a,c,b,d,null):Ef.call(null,a,c,b,d,null)};k.H=function(){return this.k};k.L=function(){return this.end-this.start};k.La=function(){return C.a(this.oa,this.end-1)};k.Ma=function(){if(this.start===this.end)throw Error("Can't pop empty vector");var a=this.k,b=this.oa,c=this.start,d=this.end-1;return Ef.r?Ef.r(a,b,c,d,null):Ef.call(null,a,b,c,d,null)};
k.ab=function(){return this.start!==this.end?new Hc(this,this.end-this.start-1,null):null};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(Mc,this.k)};k.R=function(a,b){return Cc.a(this,b)};k.O=function(a,b,c){return Cc.c(this,b,c)};k.Ka=function(a,b,c){if("number"===typeof b)return pb(this,b,c);throw Error("Subvec's key for assoc must be a number.");};
k.D=function(){var a=this;return function(b){return function d(e){return e===a.end?null:M(C.a(a.oa,e),new V(null,function(){return function(){return d(e+1)}}(b),null,null))}}(this)(a.start)};k.F=function(a,b){var c=this.oa,d=this.start,e=this.end,f=this.p;return Ef.r?Ef.r(b,c,d,e,f):Ef.call(null,b,c,d,e,f)};k.G=function(a,b){var c=this.k,d=pb(this.oa,this.end,b),e=this.start,f=this.end+1;return Ef.r?Ef.r(c,d,e,f,null):Ef.call(null,c,d,e,f,null)};
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return this.Q(null,c);case 3:return this.$(null,c,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return this.Q(null,c)};a.c=function(a,c,d){return this.$(null,c,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return this.Q(null,a)};k.a=function(a,b){return this.$(null,a,b)};Df.prototype[Ea]=function(){return uc(this)};
function Ef(a,b,c,d,e){for(;;)if(b instanceof Df)c=b.start+c,d=b.start+d,b=b.oa;else{var f=Q(b);if(0>c||0>d||c>f||d>f)throw Error("Index out of bounds");return new Df(a,b,c,d,e)}}var Cf=function(){function a(a,b,c){return Ef(null,a,b,c,null)}function b(a,b){return c.c(a,b,Q(a))}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}();
function Ff(a,b){return a===b.u?b:new ef(a,Fa(b.e))}function wf(a){return new ef({},Fa(a.e))}function xf(a){var b=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];hd(a,0,b,0,a.length);return b}
var Hf=function Gf(b,c,d,e){d=Ff(b.root.u,d);var f=b.g-1>>>c&31;if(5===c)b=e;else{var g=d.e[f];b=null!=g?Gf(b,c-5,g,e):jf(b.root.u,c-5,e)}d.e[f]=b;return d},Jf=function If(b,c,d){d=Ff(b.root.u,d);var e=b.g-2>>>c&31;if(5<c){b=If(b,c-5,d.e[e]);if(null==b&&0===e)return null;d.e[e]=b;return d}if(0===e)return null;d.e[e]=null;return d};function vf(a,b,c,d){this.g=a;this.shift=b;this.root=c;this.W=d;this.j=275;this.q=88}k=vf.prototype;
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return this.t(null,c);case 3:return this.s(null,c,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return this.t(null,c)};a.c=function(a,c,d){return this.s(null,c,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return this.t(null,a)};k.a=function(a,b){return this.s(null,a,b)};k.t=function(a,b){return $a.c(this,b,null)};
k.s=function(a,b,c){return"number"===typeof b?C.c(this,b,c):c};k.Q=function(a,b){if(this.root.u)return of(this,b)[b&31];throw Error("nth after persistent!");};k.$=function(a,b,c){return 0<=b&&b<this.g?C.a(this,b):c};k.L=function(){if(this.root.u)return this.g;throw Error("count after persistent!");};
k.Ub=function(a,b,c){var d=this;if(d.root.u){if(0<=b&&b<d.g)return hf(this)<=b?d.W[b&31]=c:(a=function(){return function f(a,h){var l=Ff(d.root.u,h);if(0===a)l.e[b&31]=c;else{var m=b>>>a&31,p=f(a-5,l.e[m]);l.e[m]=p}return l}}(this).call(null,d.shift,d.root),d.root=a),this;if(b===d.g)return Pb(this,c);throw Error([z("Index "),z(b),z(" out of bounds for TransientVector of length"),z(d.g)].join(""));}throw Error("assoc! after persistent!");};
k.Vb=function(){if(this.root.u){if(0===this.g)throw Error("Can't pop empty vector");if(1===this.g)this.g=0;else if(0<(this.g-1&31))this.g-=1;else{var a;a:if(a=this.g-2,a>=hf(this))a=this.W;else{for(var b=this.root,c=b,d=this.shift;;)if(0<d)c=Ff(b.u,c.e[a>>>d&31]),d-=5;else{a=c.e;break a}a=void 0}b=Jf(this,this.shift,this.root);b=null!=b?b:new ef(this.root.u,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
null,null,null,null]);5<this.shift&&null==b.e[1]?(this.root=Ff(this.root.u,b.e[0]),this.shift-=5):this.root=b;this.g-=1;this.W=a}return this}throw Error("pop! after persistent!");};k.kb=function(a,b,c){if("number"===typeof b)return Tb(this,b,c);throw Error("TransientVector's key for assoc! must be a number.");};
k.Sa=function(a,b){if(this.root.u){if(32>this.g-hf(this))this.W[this.g&31]=b;else{var c=new ef(this.root.u,this.W),d=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];d[0]=b;this.W=d;if(this.g>>>5>1<<this.shift){var d=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],e=this.shift+
5;d[0]=this.root;d[1]=jf(this.root.u,this.shift,c);this.root=new ef(this.root.u,d);this.shift=e}else this.root=Hf(this,this.shift,this.root,c)}this.g+=1;return this}throw Error("conj! after persistent!");};k.Ta=function(){if(this.root.u){this.root.u=null;var a=this.g-hf(this),b=Array(a);hd(this.W,0,b,0,a);return new W(null,this.g,this.shift,this.root,b,null)}throw Error("persistent! called twice");};function Kf(a,b,c,d){this.k=a;this.ea=b;this.sa=c;this.p=d;this.q=0;this.j=31850572}k=Kf.prototype;
k.toString=function(){return ec(this)};k.H=function(){return this.k};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.k)};k.N=function(){return G(this.ea)};k.S=function(){var a=K(this.ea);return a?new Kf(this.k,a,this.sa,null):null==this.sa?Na(this):new Kf(this.k,this.sa,null,null)};k.D=function(){return this};k.F=function(a,b){return new Kf(b,this.ea,this.sa,this.p)};k.G=function(a,b){return M(b,this)};
Kf.prototype[Ea]=function(){return uc(this)};function Lf(a,b,c,d,e){this.k=a;this.count=b;this.ea=c;this.sa=d;this.p=e;this.j=31858766;this.q=8192}k=Lf.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.k};k.L=function(){return this.count};k.La=function(){return G(this.ea)};k.Ma=function(){if(t(this.ea)){var a=K(this.ea);return a?new Lf(this.k,this.count-1,a,this.sa,null):new Lf(this.k,this.count-1,D(this.sa),Mc,null)}return this};
k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(Mf,this.k)};k.N=function(){return G(this.ea)};k.S=function(){return H(D(this))};k.D=function(){var a=D(this.sa),b=this.ea;return t(t(b)?b:a)?new Kf(null,this.ea,D(a),null):null};k.F=function(a,b){return new Lf(b,this.count,this.ea,this.sa,this.p)};
k.G=function(a,b){var c;t(this.ea)?(c=this.sa,c=new Lf(this.k,this.count+1,this.ea,Nc.a(t(c)?c:Mc,b),null)):c=new Lf(this.k,this.count+1,Nc.a(this.ea,b),Mc,null);return c};var Mf=new Lf(null,0,null,Mc,0);Lf.prototype[Ea]=function(){return uc(this)};function Nf(){this.q=0;this.j=2097152}Nf.prototype.A=function(){return!1};var Of=new Nf;function Pf(a,b){return md(dd(b)?Q(a)===Q(b)?Ee(ud,Oe.a(function(a){return sc.a(S.c(b,G(a),Of),Lc(a))},a)):null:null)}
function Qf(a,b){var c=a.e;if(b instanceof U)a:{for(var d=c.length,e=b.pa,f=0;;){if(d<=f){c=-1;break a}var g=c[f];if(g instanceof U&&e===g.pa){c=f;break a}f+=2}c=void 0}else if(d="string"==typeof b,t(t(d)?d:"number"===typeof b))a:{d=c.length;for(e=0;;){if(d<=e){c=-1;break a}if(b===c[e]){c=e;break a}e+=2}c=void 0}else if(b instanceof qc)a:{d=c.length;e=b.ta;for(f=0;;){if(d<=f){c=-1;break a}g=c[f];if(g instanceof qc&&e===g.ta){c=f;break a}f+=2}c=void 0}else if(null==b)a:{d=c.length;for(e=0;;){if(d<=
e){c=-1;break a}if(null==c[e]){c=e;break a}e+=2}c=void 0}else a:{d=c.length;for(e=0;;){if(d<=e){c=-1;break a}if(sc.a(b,c[e])){c=e;break a}e+=2}c=void 0}return c}function Rf(a,b,c){this.e=a;this.m=b;this.Z=c;this.q=0;this.j=32374990}k=Rf.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.Z};k.T=function(){return this.m<this.e.length-2?new Rf(this.e,this.m+2,this.Z):null};k.L=function(){return(this.e.length-this.m)/2};k.B=function(){return wc(this)};
k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.Z)};k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};k.N=function(){return new W(null,2,5,uf,[this.e[this.m],this.e[this.m+1]],null)};k.S=function(){return this.m<this.e.length-2?new Rf(this.e,this.m+2,this.Z):J};k.D=function(){return this};k.F=function(a,b){return new Rf(this.e,this.m,b)};k.G=function(a,b){return M(b,this)};Rf.prototype[Ea]=function(){return uc(this)};
function Sf(a,b,c){this.e=a;this.m=b;this.g=c}Sf.prototype.ga=function(){return this.m<this.g};Sf.prototype.next=function(){var a=new W(null,2,5,uf,[this.e[this.m],this.e[this.m+1]],null);this.m+=2;return a};function pa(a,b,c,d){this.k=a;this.g=b;this.e=c;this.p=d;this.j=16647951;this.q=8196}k=pa.prototype;k.toString=function(){return ec(this)};k.t=function(a,b){return $a.c(this,b,null)};k.s=function(a,b,c){a=Qf(this,b);return-1===a?c:this.e[a+1]};
k.gb=function(a,b,c){a=this.e.length;for(var d=0;;)if(d<a){var e=this.e[d],f=this.e[d+1];c=b.c?b.c(c,e,f):b.call(null,c,e,f);if(Ac(c))return b=c,L.b?L.b(b):L.call(null,b);d+=2}else return c};k.vb=!0;k.fb=function(){return new Sf(this.e,0,2*this.g)};k.H=function(){return this.k};k.L=function(){return this.g};k.B=function(){var a=this.p;return null!=a?a:this.p=a=xc(this)};
k.A=function(a,b){if(b&&(b.j&1024||b.ic)){var c=this.e.length;if(this.g===b.L(null))for(var d=0;;)if(d<c){var e=b.s(null,this.e[d],jd);if(e!==jd)if(sc.a(this.e[d+1],e))d+=2;else return!1;else return!1}else return!0;else return!1}else return Pf(this,b)};k.$a=function(){return new Tf({},this.e.length,Fa(this.e))};k.J=function(){return ub(Uf,this.k)};k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};
k.wb=function(a,b){if(0<=Qf(this,b)){var c=this.e.length,d=c-2;if(0===d)return Na(this);for(var d=Array(d),e=0,f=0;;){if(e>=c)return new pa(this.k,this.g-1,d,null);sc.a(b,this.e[e])||(d[f]=this.e[e],d[f+1]=this.e[e+1],f+=2);e+=2}}else return this};
k.Ka=function(a,b,c){a=Qf(this,b);if(-1===a){if(this.g<Vf){a=this.e;for(var d=a.length,e=Array(d+2),f=0;;)if(f<d)e[f]=a[f],f+=1;else break;e[d]=b;e[d+1]=c;return new pa(this.k,this.g+1,e,null)}return ub(cb(af.a(Qc,this),b,c),this.k)}if(c===this.e[a+1])return this;b=Fa(this.e);b[a+1]=c;return new pa(this.k,this.g,b,null)};k.rb=function(a,b){return-1!==Qf(this,b)};k.D=function(){var a=this.e;return 0<=a.length-2?new Rf(a,0,null):null};k.F=function(a,b){return new pa(b,this.g,this.e,this.p)};
k.G=function(a,b){if(ed(b))return cb(this,C.a(b,0),C.a(b,1));for(var c=this,d=D(b);;){if(null==d)return c;var e=G(d);if(ed(e))c=cb(c,C.a(e,0),C.a(e,1)),d=K(d);else throw Error("conj on a map takes map entries or seqables of map entries");}};
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return this.t(null,c);case 3:return this.s(null,c,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return this.t(null,c)};a.c=function(a,c,d){return this.s(null,c,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return this.t(null,a)};k.a=function(a,b){return this.s(null,a,b)};var Uf=new pa(null,0,[],null),Vf=8;pa.prototype[Ea]=function(){return uc(this)};
function Tf(a,b,c){this.Va=a;this.qa=b;this.e=c;this.q=56;this.j=258}k=Tf.prototype;k.Jb=function(a,b){if(t(this.Va)){var c=Qf(this,b);0<=c&&(this.e[c]=this.e[this.qa-2],this.e[c+1]=this.e[this.qa-1],c=this.e,c.pop(),c.pop(),this.qa-=2);return this}throw Error("dissoc! after persistent!");};
k.kb=function(a,b,c){var d=this;if(t(d.Va)){a=Qf(this,b);if(-1===a)return d.qa+2<=2*Vf?(d.qa+=2,d.e.push(b),d.e.push(c),this):ee.c(function(){var a=d.qa,b=d.e;return Xf.a?Xf.a(a,b):Xf.call(null,a,b)}(),b,c);c!==d.e[a+1]&&(d.e[a+1]=c);return this}throw Error("assoc! after persistent!");};
k.Sa=function(a,b){if(t(this.Va)){if(b?b.j&2048||b.jc||(b.j?0:w(fb,b)):w(fb,b))return Rb(this,Yf.b?Yf.b(b):Yf.call(null,b),Zf.b?Zf.b(b):Zf.call(null,b));for(var c=D(b),d=this;;){var e=G(c);if(t(e))var f=e,c=K(c),d=Rb(d,function(){var a=f;return Yf.b?Yf.b(a):Yf.call(null,a)}(),function(){var a=f;return Zf.b?Zf.b(a):Zf.call(null,a)}());else return d}}else throw Error("conj! after persistent!");};
k.Ta=function(){if(t(this.Va))return this.Va=!1,new pa(null,Cd(this.qa,2),this.e,null);throw Error("persistent! called twice");};k.t=function(a,b){return $a.c(this,b,null)};k.s=function(a,b,c){if(t(this.Va))return a=Qf(this,b),-1===a?c:this.e[a+1];throw Error("lookup after persistent!");};k.L=function(){if(t(this.Va))return Cd(this.qa,2);throw Error("count after persistent!");};function Xf(a,b){for(var c=Ob(Qc),d=0;;)if(d<a)c=ee.c(c,b[d],b[d+1]),d+=2;else return c}function $f(){this.o=!1}
function ag(a,b){return a===b?!0:Nd(a,b)?!0:sc.a(a,b)}var bg=function(){function a(a,b,c,g,h){a=Fa(a);a[b]=c;a[g]=h;return a}function b(a,b,c){a=Fa(a);a[b]=c;return a}var c=null,c=function(c,e,f,g,h){switch(arguments.length){case 3:return b.call(this,c,e,f);case 5:return a.call(this,c,e,f,g,h)}throw Error("Invalid arity: "+arguments.length);};c.c=b;c.r=a;return c}();function cg(a,b){var c=Array(a.length-2);hd(a,0,c,0,2*b);hd(a,2*(b+1),c,2*b,c.length-2*b);return c}
var dg=function(){function a(a,b,c,g,h,l){a=a.Na(b);a.e[c]=g;a.e[h]=l;return a}function b(a,b,c,g){a=a.Na(b);a.e[c]=g;return a}var c=null,c=function(c,e,f,g,h,l){switch(arguments.length){case 4:return b.call(this,c,e,f,g);case 6:return a.call(this,c,e,f,g,h,l)}throw Error("Invalid arity: "+arguments.length);};c.n=b;c.P=a;return c}();
function eg(a,b,c){for(var d=a.length,e=0,f=c;;)if(e<d){c=a[e];if(null!=c){var g=a[e+1];c=b.c?b.c(f,c,g):b.call(null,f,c,g)}else c=a[e+1],c=null!=c?c.Xa(b,f):f;if(Ac(c))return a=c,L.b?L.b(a):L.call(null,a);e+=2;f=c}else return f}function fg(a,b,c){this.u=a;this.w=b;this.e=c}k=fg.prototype;k.Na=function(a){if(a===this.u)return this;var b=Dd(this.w),c=Array(0>b?4:2*(b+1));hd(this.e,0,c,0,2*b);return new fg(a,this.w,c)};
k.nb=function(a,b,c,d,e){var f=1<<(c>>>b&31);if(0===(this.w&f))return this;var g=Dd(this.w&f-1),h=this.e[2*g],l=this.e[2*g+1];return null==h?(b=l.nb(a,b+5,c,d,e),b===l?this:null!=b?dg.n(this,a,2*g+1,b):this.w===f?null:gg(this,a,f,g)):ag(d,h)?(e[0]=!0,gg(this,a,f,g)):this};function gg(a,b,c,d){if(a.w===c)return null;a=a.Na(b);b=a.e;var e=b.length;a.w^=c;hd(b,2*(d+1),b,2*d,e-2*(d+1));b[e-2]=null;b[e-1]=null;return a}k.lb=function(){var a=this.e;return hg.b?hg.b(a):hg.call(null,a)};
k.Xa=function(a,b){return eg(this.e,a,b)};k.Oa=function(a,b,c,d){var e=1<<(b>>>a&31);if(0===(this.w&e))return d;var f=Dd(this.w&e-1),e=this.e[2*f],f=this.e[2*f+1];return null==e?f.Oa(a+5,b,c,d):ag(c,e)?f:d};
k.la=function(a,b,c,d,e,f){var g=1<<(c>>>b&31),h=Dd(this.w&g-1);if(0===(this.w&g)){var l=Dd(this.w);if(2*l<this.e.length){var m=this.Na(a),p=m.e;f.o=!0;id(p,2*h,p,2*(h+1),2*(l-h));p[2*h]=d;p[2*h+1]=e;m.w|=g;return m}if(16<=l){g=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];g[c>>>b&31]=ig.la(a,b+5,c,d,e,f);for(m=h=0;;)if(32>h)0!==(this.w>>>h&1)&&(g[h]=null!=this.e[m]?ig.la(a,b+5,nc(this.e[m]),
this.e[m],this.e[m+1],f):this.e[m+1],m+=2),h+=1;else break;return new jg(a,l+1,g)}p=Array(2*(l+4));hd(this.e,0,p,0,2*h);p[2*h]=d;p[2*h+1]=e;hd(this.e,2*h,p,2*(h+1),2*(l-h));f.o=!0;m=this.Na(a);m.e=p;m.w|=g;return m}var q=this.e[2*h],s=this.e[2*h+1];if(null==q)return l=s.la(a,b+5,c,d,e,f),l===s?this:dg.n(this,a,2*h+1,l);if(ag(d,q))return e===s?this:dg.n(this,a,2*h+1,e);f.o=!0;return dg.P(this,a,2*h,null,2*h+1,function(){var f=b+5;return kg.ia?kg.ia(a,f,q,s,c,d,e):kg.call(null,a,f,q,s,c,d,e)}())};
k.ka=function(a,b,c,d,e){var f=1<<(b>>>a&31),g=Dd(this.w&f-1);if(0===(this.w&f)){var h=Dd(this.w);if(16<=h){f=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];f[b>>>a&31]=ig.ka(a+5,b,c,d,e);for(var l=g=0;;)if(32>g)0!==(this.w>>>g&1)&&(f[g]=null!=this.e[l]?ig.ka(a+5,nc(this.e[l]),this.e[l],this.e[l+1],e):this.e[l+1],l+=2),g+=1;else break;return new jg(null,h+1,f)}l=Array(2*(h+1));hd(this.e,
0,l,0,2*g);l[2*g]=c;l[2*g+1]=d;hd(this.e,2*g,l,2*(g+1),2*(h-g));e.o=!0;return new fg(null,this.w|f,l)}var m=this.e[2*g],p=this.e[2*g+1];if(null==m)return h=p.ka(a+5,b,c,d,e),h===p?this:new fg(null,this.w,bg.c(this.e,2*g+1,h));if(ag(c,m))return d===p?this:new fg(null,this.w,bg.c(this.e,2*g+1,d));e.o=!0;return new fg(null,this.w,bg.r(this.e,2*g,null,2*g+1,function(){var e=a+5;return kg.P?kg.P(e,m,p,b,c,d):kg.call(null,e,m,p,b,c,d)}()))};
k.mb=function(a,b,c){var d=1<<(b>>>a&31);if(0===(this.w&d))return this;var e=Dd(this.w&d-1),f=this.e[2*e],g=this.e[2*e+1];return null==f?(a=g.mb(a+5,b,c),a===g?this:null!=a?new fg(null,this.w,bg.c(this.e,2*e+1,a)):this.w===d?null:new fg(null,this.w^d,cg(this.e,e))):ag(c,f)?new fg(null,this.w^d,cg(this.e,e)):this};var ig=new fg(null,0,[]);
function lg(a,b,c){var d=a.e,e=d.length;a=Array(2*(a.g-1));for(var f=0,g=1,h=0;;)if(f<e)f!==c&&null!=d[f]&&(a[g]=d[f],g+=2,h|=1<<f),f+=1;else return new fg(b,h,a)}function jg(a,b,c){this.u=a;this.g=b;this.e=c}k=jg.prototype;k.Na=function(a){return a===this.u?this:new jg(a,this.g,Fa(this.e))};
k.nb=function(a,b,c,d,e){var f=c>>>b&31,g=this.e[f];if(null==g)return this;b=g.nb(a,b+5,c,d,e);if(b===g)return this;if(null==b){if(8>=this.g)return lg(this,a,f);a=dg.n(this,a,f,b);a.g-=1;return a}return dg.n(this,a,f,b)};k.lb=function(){var a=this.e;return mg.b?mg.b(a):mg.call(null,a)};k.Xa=function(a,b){for(var c=this.e.length,d=0,e=b;;)if(d<c){var f=this.e[d];if(null!=f&&(e=f.Xa(a,e),Ac(e)))return c=e,L.b?L.b(c):L.call(null,c);d+=1}else return e};
k.Oa=function(a,b,c,d){var e=this.e[b>>>a&31];return null!=e?e.Oa(a+5,b,c,d):d};k.la=function(a,b,c,d,e,f){var g=c>>>b&31,h=this.e[g];if(null==h)return a=dg.n(this,a,g,ig.la(a,b+5,c,d,e,f)),a.g+=1,a;b=h.la(a,b+5,c,d,e,f);return b===h?this:dg.n(this,a,g,b)};k.ka=function(a,b,c,d,e){var f=b>>>a&31,g=this.e[f];if(null==g)return new jg(null,this.g+1,bg.c(this.e,f,ig.ka(a+5,b,c,d,e)));a=g.ka(a+5,b,c,d,e);return a===g?this:new jg(null,this.g,bg.c(this.e,f,a))};
k.mb=function(a,b,c){var d=b>>>a&31,e=this.e[d];return null!=e?(a=e.mb(a+5,b,c),a===e?this:null==a?8>=this.g?lg(this,null,d):new jg(null,this.g-1,bg.c(this.e,d,a)):new jg(null,this.g,bg.c(this.e,d,a))):this};function ng(a,b,c){b*=2;for(var d=0;;)if(d<b){if(ag(c,a[d]))return d;d+=2}else return-1}function og(a,b,c,d){this.u=a;this.Ia=b;this.g=c;this.e=d}k=og.prototype;k.Na=function(a){if(a===this.u)return this;var b=Array(2*(this.g+1));hd(this.e,0,b,0,2*this.g);return new og(a,this.Ia,this.g,b)};
k.nb=function(a,b,c,d,e){b=ng(this.e,this.g,d);if(-1===b)return this;e[0]=!0;if(1===this.g)return null;a=this.Na(a);e=a.e;e[b]=e[2*this.g-2];e[b+1]=e[2*this.g-1];e[2*this.g-1]=null;e[2*this.g-2]=null;a.g-=1;return a};k.lb=function(){var a=this.e;return hg.b?hg.b(a):hg.call(null,a)};k.Xa=function(a,b){return eg(this.e,a,b)};k.Oa=function(a,b,c,d){a=ng(this.e,this.g,c);return 0>a?d:ag(c,this.e[a])?this.e[a+1]:d};
k.la=function(a,b,c,d,e,f){if(c===this.Ia){b=ng(this.e,this.g,d);if(-1===b){if(this.e.length>2*this.g)return a=dg.P(this,a,2*this.g,d,2*this.g+1,e),f.o=!0,a.g+=1,a;c=this.e.length;b=Array(c+2);hd(this.e,0,b,0,c);b[c]=d;b[c+1]=e;f.o=!0;f=this.g+1;a===this.u?(this.e=b,this.g=f,a=this):a=new og(this.u,this.Ia,f,b);return a}return this.e[b+1]===e?this:dg.n(this,a,b+1,e)}return(new fg(a,1<<(this.Ia>>>b&31),[null,this,null,null])).la(a,b,c,d,e,f)};
k.ka=function(a,b,c,d,e){return b===this.Ia?(a=ng(this.e,this.g,c),-1===a?(a=2*this.g,b=Array(a+2),hd(this.e,0,b,0,a),b[a]=c,b[a+1]=d,e.o=!0,new og(null,this.Ia,this.g+1,b)):sc.a(this.e[a],d)?this:new og(null,this.Ia,this.g,bg.c(this.e,a+1,d))):(new fg(null,1<<(this.Ia>>>a&31),[null,this])).ka(a,b,c,d,e)};k.mb=function(a,b,c){a=ng(this.e,this.g,c);return-1===a?this:1===this.g?null:new og(null,this.Ia,this.g-1,cg(this.e,Cd(a,2)))};
var kg=function(){function a(a,b,c,g,h,l,m){var p=nc(c);if(p===h)return new og(null,p,2,[c,g,l,m]);var q=new $f;return ig.la(a,b,p,c,g,q).la(a,b,h,l,m,q)}function b(a,b,c,g,h,l){var m=nc(b);if(m===g)return new og(null,m,2,[b,c,h,l]);var p=new $f;return ig.ka(a,m,b,c,p).ka(a,g,h,l,p)}var c=null,c=function(c,e,f,g,h,l,m){switch(arguments.length){case 6:return b.call(this,c,e,f,g,h,l);case 7:return a.call(this,c,e,f,g,h,l,m)}throw Error("Invalid arity: "+arguments.length);};c.P=b;c.ia=a;return c}();
function pg(a,b,c,d,e){this.k=a;this.Pa=b;this.m=c;this.C=d;this.p=e;this.q=0;this.j=32374860}k=pg.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.k};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.k)};k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};k.N=function(){return null==this.C?new W(null,2,5,uf,[this.Pa[this.m],this.Pa[this.m+1]],null):G(this.C)};
k.S=function(){if(null==this.C){var a=this.Pa,b=this.m+2;return hg.c?hg.c(a,b,null):hg.call(null,a,b,null)}var a=this.Pa,b=this.m,c=K(this.C);return hg.c?hg.c(a,b,c):hg.call(null,a,b,c)};k.D=function(){return this};k.F=function(a,b){return new pg(b,this.Pa,this.m,this.C,this.p)};k.G=function(a,b){return M(b,this)};pg.prototype[Ea]=function(){return uc(this)};
var hg=function(){function a(a,b,c){if(null==c)for(c=a.length;;)if(b<c){if(null!=a[b])return new pg(null,a,b,null,null);var g=a[b+1];if(t(g)&&(g=g.lb(),t(g)))return new pg(null,a,b+2,g,null);b+=2}else return null;else return new pg(null,a,b,c,null)}function b(a){return c.c(a,0,null)}var c=null,c=function(c,e,f){switch(arguments.length){case 1:return b.call(this,c);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.c=a;return c}();
function qg(a,b,c,d,e){this.k=a;this.Pa=b;this.m=c;this.C=d;this.p=e;this.q=0;this.j=32374860}k=qg.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.k};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.k)};k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};k.N=function(){return G(this.C)};
k.S=function(){var a=this.Pa,b=this.m,c=K(this.C);return mg.n?mg.n(null,a,b,c):mg.call(null,null,a,b,c)};k.D=function(){return this};k.F=function(a,b){return new qg(b,this.Pa,this.m,this.C,this.p)};k.G=function(a,b){return M(b,this)};qg.prototype[Ea]=function(){return uc(this)};
var mg=function(){function a(a,b,c,g){if(null==g)for(g=b.length;;)if(c<g){var h=b[c];if(t(h)&&(h=h.lb(),t(h)))return new qg(a,b,c+1,h,null);c+=1}else return null;else return new qg(a,b,c,g,null)}function b(a){return c.n(null,a,0,null)}var c=null,c=function(c,e,f,g){switch(arguments.length){case 1:return b.call(this,c);case 4:return a.call(this,c,e,f,g)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.n=a;return c}();
function rg(a,b,c,d,e,f){this.k=a;this.g=b;this.root=c;this.U=d;this.da=e;this.p=f;this.j=16123663;this.q=8196}k=rg.prototype;k.toString=function(){return ec(this)};k.t=function(a,b){return $a.c(this,b,null)};k.s=function(a,b,c){return null==b?this.U?this.da:c:null==this.root?c:this.root.Oa(0,nc(b),b,c)};k.gb=function(a,b,c){this.U&&(a=this.da,c=b.c?b.c(c,null,a):b.call(null,c,null,a));return Ac(c)?L.b?L.b(c):L.call(null,c):null!=this.root?this.root.Xa(b,c):c};k.H=function(){return this.k};k.L=function(){return this.g};
k.B=function(){var a=this.p;return null!=a?a:this.p=a=xc(this)};k.A=function(a,b){return Pf(this,b)};k.$a=function(){return new sg({},this.root,this.g,this.U,this.da)};k.J=function(){return ub(Qc,this.k)};k.wb=function(a,b){if(null==b)return this.U?new rg(this.k,this.g-1,this.root,!1,null,null):this;if(null==this.root)return this;var c=this.root.mb(0,nc(b),b);return c===this.root?this:new rg(this.k,this.g-1,c,this.U,this.da,null)};
k.Ka=function(a,b,c){if(null==b)return this.U&&c===this.da?this:new rg(this.k,this.U?this.g:this.g+1,this.root,!0,c,null);a=new $f;b=(null==this.root?ig:this.root).ka(0,nc(b),b,c,a);return b===this.root?this:new rg(this.k,a.o?this.g+1:this.g,b,this.U,this.da,null)};k.rb=function(a,b){return null==b?this.U:null==this.root?!1:this.root.Oa(0,nc(b),b,jd)!==jd};k.D=function(){if(0<this.g){var a=null!=this.root?this.root.lb():null;return this.U?M(new W(null,2,5,uf,[null,this.da],null),a):a}return null};
k.F=function(a,b){return new rg(b,this.g,this.root,this.U,this.da,this.p)};k.G=function(a,b){if(ed(b))return cb(this,C.a(b,0),C.a(b,1));for(var c=this,d=D(b);;){if(null==d)return c;var e=G(d);if(ed(e))c=cb(c,C.a(e,0),C.a(e,1)),d=K(d);else throw Error("conj on a map takes map entries or seqables of map entries");}};
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return this.t(null,c);case 3:return this.s(null,c,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return this.t(null,c)};a.c=function(a,c,d){return this.s(null,c,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return this.t(null,a)};k.a=function(a,b){return this.s(null,a,b)};var Qc=new rg(null,0,null,!1,null,0);rg.prototype[Ea]=function(){return uc(this)};
function sg(a,b,c,d,e){this.u=a;this.root=b;this.count=c;this.U=d;this.da=e;this.q=56;this.j=258}k=sg.prototype;k.Jb=function(a,b){if(this.u)if(null==b)this.U&&(this.U=!1,this.da=null,this.count-=1);else{if(null!=this.root){var c=new $f,d=this.root.nb(this.u,0,nc(b),b,c);d!==this.root&&(this.root=d);t(c[0])&&(this.count-=1)}}else throw Error("dissoc! after persistent!");return this};k.kb=function(a,b,c){return tg(this,b,c)};k.Sa=function(a,b){return ug(this,b)};
k.Ta=function(){var a;if(this.u)this.u=null,a=new rg(null,this.count,this.root,this.U,this.da,null);else throw Error("persistent! called twice");return a};k.t=function(a,b){return null==b?this.U?this.da:null:null==this.root?null:this.root.Oa(0,nc(b),b)};k.s=function(a,b,c){return null==b?this.U?this.da:c:null==this.root?c:this.root.Oa(0,nc(b),b,c)};k.L=function(){if(this.u)return this.count;throw Error("count after persistent!");};
function ug(a,b){if(a.u){if(b?b.j&2048||b.jc||(b.j?0:w(fb,b)):w(fb,b))return tg(a,Yf.b?Yf.b(b):Yf.call(null,b),Zf.b?Zf.b(b):Zf.call(null,b));for(var c=D(b),d=a;;){var e=G(c);if(t(e))var f=e,c=K(c),d=tg(d,function(){var a=f;return Yf.b?Yf.b(a):Yf.call(null,a)}(),function(){var a=f;return Zf.b?Zf.b(a):Zf.call(null,a)}());else return d}}else throw Error("conj! after persistent");}
function tg(a,b,c){if(a.u){if(null==b)a.da!==c&&(a.da=c),a.U||(a.count+=1,a.U=!0);else{var d=new $f;b=(null==a.root?ig:a.root).la(a.u,0,nc(b),b,c,d);b!==a.root&&(a.root=b);d.o&&(a.count+=1)}return a}throw Error("assoc! after persistent!");}function vg(a,b,c){for(var d=b;;)if(null!=a)b=c?a.left:a.right,d=Nc.a(d,a),a=b;else return d}function wg(a,b,c,d,e){this.k=a;this.stack=b;this.pb=c;this.g=d;this.p=e;this.q=0;this.j=32374862}k=wg.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.k};
k.L=function(){return 0>this.g?Q(K(this))+1:this.g};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.k)};k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};k.N=function(){return Wc(this.stack)};k.S=function(){var a=G(this.stack),a=vg(this.pb?a.right:a.left,K(this.stack),this.pb);return null!=a?new wg(null,a,this.pb,this.g-1,null):J};k.D=function(){return this};
k.F=function(a,b){return new wg(b,this.stack,this.pb,this.g,this.p)};k.G=function(a,b){return M(b,this)};wg.prototype[Ea]=function(){return uc(this)};function xg(a,b,c){return new wg(null,vg(a,null,b),b,c,null)}
function yg(a,b,c,d){return c instanceof X?c.left instanceof X?new X(c.key,c.o,c.left.ua(),new Z(a,b,c.right,d,null),null):c.right instanceof X?new X(c.right.key,c.right.o,new Z(c.key,c.o,c.left,c.right.left,null),new Z(a,b,c.right.right,d,null),null):new Z(a,b,c,d,null):new Z(a,b,c,d,null)}
function zg(a,b,c,d){return d instanceof X?d.right instanceof X?new X(d.key,d.o,new Z(a,b,c,d.left,null),d.right.ua(),null):d.left instanceof X?new X(d.left.key,d.left.o,new Z(a,b,c,d.left.left,null),new Z(d.key,d.o,d.left.right,d.right,null),null):new Z(a,b,c,d,null):new Z(a,b,c,d,null)}
function Ag(a,b,c,d){if(c instanceof X)return new X(a,b,c.ua(),d,null);if(d instanceof Z)return zg(a,b,c,d.ob());if(d instanceof X&&d.left instanceof Z)return new X(d.left.key,d.left.o,new Z(a,b,c,d.left.left,null),zg(d.key,d.o,d.left.right,d.right.ob()),null);throw Error("red-black tree invariant violation");}
var Cg=function Bg(b,c,d){d=null!=b.left?Bg(b.left,c,d):d;if(Ac(d))return L.b?L.b(d):L.call(null,d);var e=b.key,f=b.o;d=c.c?c.c(d,e,f):c.call(null,d,e,f);if(Ac(d))return L.b?L.b(d):L.call(null,d);b=null!=b.right?Bg(b.right,c,d):d;return Ac(b)?L.b?L.b(b):L.call(null,b):b};function Z(a,b,c,d,e){this.key=a;this.o=b;this.left=c;this.right=d;this.p=e;this.q=0;this.j=32402207}k=Z.prototype;k.Mb=function(a){return a.Ob(this)};k.ob=function(){return new X(this.key,this.o,this.left,this.right,null)};
k.ua=function(){return this};k.Lb=function(a){return a.Nb(this)};k.replace=function(a,b,c,d){return new Z(a,b,c,d,null)};k.Nb=function(a){return new Z(a.key,a.o,this,a.right,null)};k.Ob=function(a){return new Z(a.key,a.o,a.left,this,null)};k.Xa=function(a,b){return Cg(this,a,b)};k.t=function(a,b){return C.c(this,b,null)};k.s=function(a,b,c){return C.c(this,b,c)};k.Q=function(a,b){return 0===b?this.key:1===b?this.o:null};k.$=function(a,b,c){return 0===b?this.key:1===b?this.o:c};
k.Ua=function(a,b,c){return(new W(null,2,5,uf,[this.key,this.o],null)).Ua(null,b,c)};k.H=function(){return null};k.L=function(){return 2};k.hb=function(){return this.key};k.ib=function(){return this.o};k.La=function(){return this.o};k.Ma=function(){return new W(null,1,5,uf,[this.key],null)};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return Mc};k.R=function(a,b){return Cc.a(this,b)};k.O=function(a,b,c){return Cc.c(this,b,c)};
k.Ka=function(a,b,c){return Rc.c(new W(null,2,5,uf,[this.key,this.o],null),b,c)};k.D=function(){return Ra(Ra(J,this.o),this.key)};k.F=function(a,b){return O(new W(null,2,5,uf,[this.key,this.o],null),b)};k.G=function(a,b){return new W(null,3,5,uf,[this.key,this.o,b],null)};
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return this.t(null,c);case 3:return this.s(null,c,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return this.t(null,c)};a.c=function(a,c,d){return this.s(null,c,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return this.t(null,a)};k.a=function(a,b){return this.s(null,a,b)};Z.prototype[Ea]=function(){return uc(this)};
function X(a,b,c,d,e){this.key=a;this.o=b;this.left=c;this.right=d;this.p=e;this.q=0;this.j=32402207}k=X.prototype;k.Mb=function(a){return new X(this.key,this.o,this.left,a,null)};k.ob=function(){throw Error("red-black tree invariant violation");};k.ua=function(){return new Z(this.key,this.o,this.left,this.right,null)};k.Lb=function(a){return new X(this.key,this.o,a,this.right,null)};k.replace=function(a,b,c,d){return new X(a,b,c,d,null)};
k.Nb=function(a){return this.left instanceof X?new X(this.key,this.o,this.left.ua(),new Z(a.key,a.o,this.right,a.right,null),null):this.right instanceof X?new X(this.right.key,this.right.o,new Z(this.key,this.o,this.left,this.right.left,null),new Z(a.key,a.o,this.right.right,a.right,null),null):new Z(a.key,a.o,this,a.right,null)};
k.Ob=function(a){return this.right instanceof X?new X(this.key,this.o,new Z(a.key,a.o,a.left,this.left,null),this.right.ua(),null):this.left instanceof X?new X(this.left.key,this.left.o,new Z(a.key,a.o,a.left,this.left.left,null),new Z(this.key,this.o,this.left.right,this.right,null),null):new Z(a.key,a.o,a.left,this,null)};k.Xa=function(a,b){return Cg(this,a,b)};k.t=function(a,b){return C.c(this,b,null)};k.s=function(a,b,c){return C.c(this,b,c)};
k.Q=function(a,b){return 0===b?this.key:1===b?this.o:null};k.$=function(a,b,c){return 0===b?this.key:1===b?this.o:c};k.Ua=function(a,b,c){return(new W(null,2,5,uf,[this.key,this.o],null)).Ua(null,b,c)};k.H=function(){return null};k.L=function(){return 2};k.hb=function(){return this.key};k.ib=function(){return this.o};k.La=function(){return this.o};k.Ma=function(){return new W(null,1,5,uf,[this.key],null)};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};
k.A=function(a,b){return Ic(this,b)};k.J=function(){return Mc};k.R=function(a,b){return Cc.a(this,b)};k.O=function(a,b,c){return Cc.c(this,b,c)};k.Ka=function(a,b,c){return Rc.c(new W(null,2,5,uf,[this.key,this.o],null),b,c)};k.D=function(){return Ra(Ra(J,this.o),this.key)};k.F=function(a,b){return O(new W(null,2,5,uf,[this.key,this.o],null),b)};k.G=function(a,b){return new W(null,3,5,uf,[this.key,this.o,b],null)};
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return this.t(null,c);case 3:return this.s(null,c,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return this.t(null,c)};a.c=function(a,c,d){return this.s(null,c,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return this.t(null,a)};k.a=function(a,b){return this.s(null,a,b)};X.prototype[Ea]=function(){return uc(this)};
var Eg=function Dg(b,c,d,e,f){if(null==c)return new X(d,e,null,null,null);var g;g=c.key;g=b.a?b.a(d,g):b.call(null,d,g);if(0===g)return f[0]=c,null;if(0>g)return b=Dg(b,c.left,d,e,f),null!=b?c.Lb(b):null;b=Dg(b,c.right,d,e,f);return null!=b?c.Mb(b):null},Gg=function Fg(b,c){if(null==b)return c;if(null==c)return b;if(b instanceof X){if(c instanceof X){var d=Fg(b.right,c.left);return d instanceof X?new X(d.key,d.o,new X(b.key,b.o,b.left,d.left,null),new X(c.key,c.o,d.right,c.right,null),null):new X(b.key,
b.o,b.left,new X(c.key,c.o,d,c.right,null),null)}return new X(b.key,b.o,b.left,Fg(b.right,c),null)}if(c instanceof X)return new X(c.key,c.o,Fg(b,c.left),c.right,null);d=Fg(b.right,c.left);return d instanceof X?new X(d.key,d.o,new Z(b.key,b.o,b.left,d.left,null),new Z(c.key,c.o,d.right,c.right,null),null):Ag(b.key,b.o,b.left,new Z(c.key,c.o,d,c.right,null))},Ig=function Hg(b,c,d,e){if(null!=c){var f;f=c.key;f=b.a?b.a(d,f):b.call(null,d,f);if(0===f)return e[0]=c,Gg(c.left,c.right);if(0>f)return b=Hg(b,
c.left,d,e),null!=b||null!=e[0]?c.left instanceof Z?Ag(c.key,c.o,b,c.right):new X(c.key,c.o,b,c.right,null):null;b=Hg(b,c.right,d,e);if(null!=b||null!=e[0])if(c.right instanceof Z)if(e=c.key,d=c.o,c=c.left,b instanceof X)c=new X(e,d,c,b.ua(),null);else if(c instanceof Z)c=yg(e,d,c.ob(),b);else if(c instanceof X&&c.right instanceof Z)c=new X(c.right.key,c.right.o,yg(c.key,c.o,c.left.ob(),c.right.left),new Z(e,d,c.right.right,b,null),null);else throw Error("red-black tree invariant violation");else c=
new X(c.key,c.o,c.left,b,null);else c=null;return c}return null},Kg=function Jg(b,c,d,e){var f=c.key,g=b.a?b.a(d,f):b.call(null,d,f);return 0===g?c.replace(f,e,c.left,c.right):0>g?c.replace(f,c.o,Jg(b,c.left,d,e),c.right):c.replace(f,c.o,c.left,Jg(b,c.right,d,e))};function Lg(a,b,c,d,e){this.aa=a;this.na=b;this.g=c;this.k=d;this.p=e;this.j=418776847;this.q=8192}k=Lg.prototype;k.toString=function(){return ec(this)};
function Mg(a,b){for(var c=a.na;;)if(null!=c){var d;d=c.key;d=a.aa.a?a.aa.a(b,d):a.aa.call(null,b,d);if(0===d)return c;c=0>d?c.left:c.right}else return null}k.t=function(a,b){return $a.c(this,b,null)};k.s=function(a,b,c){a=Mg(this,b);return null!=a?a.o:c};k.gb=function(a,b,c){return null!=this.na?Cg(this.na,b,c):c};k.H=function(){return this.k};k.L=function(){return this.g};k.ab=function(){return 0<this.g?xg(this.na,!1,this.g):null};k.B=function(){var a=this.p;return null!=a?a:this.p=a=xc(this)};
k.A=function(a,b){return Pf(this,b)};k.J=function(){return new Lg(this.aa,null,0,this.k,0)};k.wb=function(a,b){var c=[null],d=Ig(this.aa,this.na,b,c);return null==d?null==R.a(c,0)?this:new Lg(this.aa,null,0,this.k,null):new Lg(this.aa,d.ua(),this.g-1,this.k,null)};k.Ka=function(a,b,c){a=[null];var d=Eg(this.aa,this.na,b,c,a);return null==d?(a=R.a(a,0),sc.a(c,a.o)?this:new Lg(this.aa,Kg(this.aa,this.na,b,c),this.g,this.k,null)):new Lg(this.aa,d.ua(),this.g+1,this.k,null)};
k.rb=function(a,b){return null!=Mg(this,b)};k.D=function(){return 0<this.g?xg(this.na,!0,this.g):null};k.F=function(a,b){return new Lg(this.aa,this.na,this.g,b,this.p)};k.G=function(a,b){if(ed(b))return cb(this,C.a(b,0),C.a(b,1));for(var c=this,d=D(b);;){if(null==d)return c;var e=G(d);if(ed(e))c=cb(c,C.a(e,0),C.a(e,1)),d=K(d);else throw Error("conj on a map takes map entries or seqables of map entries");}};
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return this.t(null,c);case 3:return this.s(null,c,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return this.t(null,c)};a.c=function(a,c,d){return this.s(null,c,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return this.t(null,a)};k.a=function(a,b){return this.s(null,a,b)};k.Hb=function(a,b){return 0<this.g?xg(this.na,b,this.g):null};
k.Ib=function(a,b,c){if(0<this.g){a=null;for(var d=this.na;;)if(null!=d){var e;e=d.key;e=this.aa.a?this.aa.a(b,e):this.aa.call(null,b,e);if(0===e)return new wg(null,Nc.a(a,d),c,-1,null);t(c)?0>e?(a=Nc.a(a,d),d=d.left):d=d.right:0<e?(a=Nc.a(a,d),d=d.right):d=d.left}else return null==a?null:new wg(null,a,c,-1,null)}else return null};k.Gb=function(a,b){return Yf.b?Yf.b(b):Yf.call(null,b)};k.Fb=function(){return this.aa};var Ng=new Lg(od,null,0,null,0);Lg.prototype[Ea]=function(){return uc(this)};
var Og=function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){a=D(a);for(var b=Ob(Qc);;)if(a){var e=K(K(a)),b=ee.c(b,G(a),Lc(a));a=e}else return Qb(b)}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}(),Pg=function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,
d)}function b(a){a:{a=T.a(Ha,a);for(var b=a.length,e=0,f=Ob(Uf);;)if(e<b)var g=e+2,f=Rb(f,a[e],a[e+1]),e=g;else{a=Qb(f);break a}a=void 0}return a}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}(),Qg=function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){a=D(a);for(var b=Ng;;)if(a){var e=K(K(a)),b=Rc.c(b,G(a),Lc(a));a=e}else return b}a.i=0;a.f=function(a){a=D(a);
return b(a)};a.d=b;return a}(),Rg=function(){function a(a,d){var e=null;if(1<arguments.length){for(var e=0,f=Array(arguments.length-1);e<f.length;)f[e]=arguments[e+1],++e;e=new F(f,0)}return b.call(this,a,e)}function b(a,b){for(var e=D(b),f=new Lg(qd(a),null,0,null,0);;)if(e)var g=K(K(e)),f=Rc.c(f,G(e),Lc(e)),e=g;else return f}a.i=1;a.f=function(a){var d=G(a);a=H(a);return b(d,a)};a.d=b;return a}();function Sg(a,b){this.Y=a;this.Z=b;this.q=0;this.j=32374988}k=Sg.prototype;k.toString=function(){return ec(this)};
k.H=function(){return this.Z};k.T=function(){var a=this.Y,a=(a?a.j&128||a.xb||(a.j?0:w(Xa,a)):w(Xa,a))?this.Y.T(null):K(this.Y);return null==a?null:new Sg(a,this.Z)};k.B=function(){return wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.Z)};k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};k.N=function(){return this.Y.N(null).hb(null)};
k.S=function(){var a=this.Y,a=(a?a.j&128||a.xb||(a.j?0:w(Xa,a)):w(Xa,a))?this.Y.T(null):K(this.Y);return null!=a?new Sg(a,this.Z):J};k.D=function(){return this};k.F=function(a,b){return new Sg(this.Y,b)};k.G=function(a,b){return M(b,this)};Sg.prototype[Ea]=function(){return uc(this)};function Tg(a){return(a=D(a))?new Sg(a,null):null}function Yf(a){return hb(a)}function Ug(a,b){this.Y=a;this.Z=b;this.q=0;this.j=32374988}k=Ug.prototype;k.toString=function(){return ec(this)};k.H=function(){return this.Z};
k.T=function(){var a=this.Y,a=(a?a.j&128||a.xb||(a.j?0:w(Xa,a)):w(Xa,a))?this.Y.T(null):K(this.Y);return null==a?null:new Ug(a,this.Z)};k.B=function(){return wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.Z)};k.R=function(a,b){return P.a(b,this)};k.O=function(a,b,c){return P.c(b,c,this)};k.N=function(){return this.Y.N(null).ib(null)};k.S=function(){var a=this.Y,a=(a?a.j&128||a.xb||(a.j?0:w(Xa,a)):w(Xa,a))?this.Y.T(null):K(this.Y);return null!=a?new Ug(a,this.Z):J};
k.D=function(){return this};k.F=function(a,b){return new Ug(this.Y,b)};k.G=function(a,b){return M(b,this)};Ug.prototype[Ea]=function(){return uc(this)};function Vg(a){return(a=D(a))?new Ug(a,null):null}function Zf(a){return ib(a)}
var Wg=function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){return t(Fe(ud,a))?A.a(function(a,b){return Nc.a(t(a)?a:Uf,b)},a):null}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}(),Xg=function(){function a(a,d){var e=null;if(1<arguments.length){for(var e=0,f=Array(arguments.length-1);e<f.length;)f[e]=arguments[e+1],++e;e=new F(f,0)}return b.call(this,a,e)}function b(a,
b){return t(Fe(ud,b))?A.a(function(a){return function(b,c){return A.c(a,t(b)?b:Uf,D(c))}}(function(b,d){var g=G(d),h=Lc(d);return nd(b,g)?Rc.c(b,g,function(){var d=S.a(b,g);return a.a?a.a(d,h):a.call(null,d,h)}()):Rc.c(b,g,h)}),b):null}a.i=1;a.f=function(a){var d=G(a);a=H(a);return b(d,a)};a.d=b;return a}();function Yg(a,b){for(var c=Uf,d=D(b);;)if(d)var e=G(d),f=S.c(a,e,Zg),c=je.a(f,Zg)?Rc.c(c,e,f):c,d=K(d);else return O(c,Vc(a))}
function $g(a,b,c){this.k=a;this.Wa=b;this.p=c;this.j=15077647;this.q=8196}k=$g.prototype;k.toString=function(){return ec(this)};k.t=function(a,b){return $a.c(this,b,null)};k.s=function(a,b,c){return bb(this.Wa,b)?b:c};k.H=function(){return this.k};k.L=function(){return Ma(this.Wa)};k.B=function(){var a=this.p;return null!=a?a:this.p=a=xc(this)};k.A=function(a,b){return ad(b)&&Q(this)===Q(b)&&Ee(function(a){return function(b){return nd(a,b)}}(this),b)};k.$a=function(){return new ah(Ob(this.Wa))};
k.J=function(){return O(bh,this.k)};k.Eb=function(a,b){return new $g(this.k,eb(this.Wa,b),null)};k.D=function(){return Tg(this.Wa)};k.F=function(a,b){return new $g(b,this.Wa,this.p)};k.G=function(a,b){return new $g(this.k,Rc.c(this.Wa,b,null),null)};
k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return this.t(null,c);case 3:return this.s(null,c,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return this.t(null,c)};a.c=function(a,c,d){return this.s(null,c,d)};return a}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return this.t(null,a)};k.a=function(a,b){return this.s(null,a,b)};var bh=new $g(null,Uf,0);$g.prototype[Ea]=function(){return uc(this)};
function ah(a){this.ma=a;this.j=259;this.q=136}k=ah.prototype;k.call=function(){function a(a,b,c){return $a.c(this.ma,b,jd)===jd?c:b}function b(a,b){return $a.c(this.ma,b,jd)===jd?null:b}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+arguments.length);};c.a=b;c.c=a;return c}();k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};
k.b=function(a){return $a.c(this.ma,a,jd)===jd?null:a};k.a=function(a,b){return $a.c(this.ma,a,jd)===jd?b:a};k.t=function(a,b){return $a.c(this,b,null)};k.s=function(a,b,c){return $a.c(this.ma,b,jd)===jd?c:b};k.L=function(){return Q(this.ma)};k.Tb=function(a,b){this.ma=fe.a(this.ma,b);return this};k.Sa=function(a,b){this.ma=ee.c(this.ma,b,null);return this};k.Ta=function(){return new $g(null,Qb(this.ma),null)};function ch(a,b,c){this.k=a;this.ja=b;this.p=c;this.j=417730831;this.q=8192}k=ch.prototype;
k.toString=function(){return ec(this)};k.t=function(a,b){return $a.c(this,b,null)};k.s=function(a,b,c){a=Mg(this.ja,b);return null!=a?a.key:c};k.H=function(){return this.k};k.L=function(){return Q(this.ja)};k.ab=function(){return 0<Q(this.ja)?Oe.a(Yf,Gb(this.ja)):null};k.B=function(){var a=this.p;return null!=a?a:this.p=a=xc(this)};k.A=function(a,b){return ad(b)&&Q(this)===Q(b)&&Ee(function(a){return function(b){return nd(a,b)}}(this),b)};k.J=function(){return new ch(this.k,Na(this.ja),0)};
k.Eb=function(a,b){return new ch(this.k,Sc.a(this.ja,b),null)};k.D=function(){return Tg(this.ja)};k.F=function(a,b){return new ch(b,this.ja,this.p)};k.G=function(a,b){return new ch(this.k,Rc.c(this.ja,b,null),null)};k.call=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return this.t(null,c);case 3:return this.s(null,c,d)}throw Error("Invalid arity: "+arguments.length);};a.a=function(a,c){return this.t(null,c)};a.c=function(a,c,d){return this.s(null,c,d)};return a}();
k.apply=function(a,b){return this.call.apply(this,[this].concat(Fa(b)))};k.b=function(a){return this.t(null,a)};k.a=function(a,b){return this.s(null,a,b)};k.Hb=function(a,b){return Oe.a(Yf,Hb(this.ja,b))};k.Ib=function(a,b,c){return Oe.a(Yf,Ib(this.ja,b,c))};k.Gb=function(a,b){return b};k.Fb=function(){return Kb(this.ja)};var eh=new ch(null,Ng,0);ch.prototype[Ea]=function(){return uc(this)};
function fh(a){a=D(a);if(null==a)return bh;if(a instanceof F&&0===a.m){a=a.e;a:{for(var b=0,c=Ob(bh);;)if(b<a.length)var d=b+1,c=c.Sa(null,a[b]),b=d;else{a=c;break a}a=void 0}return a.Ta(null)}for(d=Ob(bh);;)if(null!=a)b=a.T(null),d=d.Sa(null,a.N(null)),a=b;else return d.Ta(null)}
var gh=function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){return A.c(Ra,eh,a)}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}(),hh=function(){function a(a,d){var e=null;if(1<arguments.length){for(var e=0,f=Array(arguments.length-1);e<f.length;)f[e]=arguments[e+1],++e;e=new F(f,0)}return b.call(this,a,e)}function b(a,b){return A.c(Ra,new ch(null,Rg(a),0),b)}
a.i=1;a.f=function(a){var d=G(a);a=H(a);return b(d,a)};a.d=b;return a}();function Od(a){if(a&&(a.q&4096||a.lc))return a.name;if("string"===typeof a)return a;throw Error([z("Doesn't support name: "),z(a)].join(""));}
var ih=function(){function a(a,b,c){return(a.b?a.b(b):a.call(null,b))>(a.b?a.b(c):a.call(null,c))?b:c}var b=null,c=function(){function a(b,d,h,l){var m=null;if(3<arguments.length){for(var m=0,p=Array(arguments.length-3);m<p.length;)p[m]=arguments[m+3],++m;m=new F(p,0)}return c.call(this,b,d,h,m)}function c(a,d,e,l){return A.c(function(c,d){return b.c(a,c,d)},b.c(a,d,e),l)}a.i=3;a.f=function(a){var b=G(a);a=K(a);var d=G(a);a=K(a);var l=G(a);a=H(a);return c(b,d,l,a)};a.d=c;return a}(),b=function(b,
e,f,g){switch(arguments.length){case 2:return e;case 3:return a.call(this,b,e,f);default:var h=null;if(3<arguments.length){for(var h=0,l=Array(arguments.length-3);h<l.length;)l[h]=arguments[h+3],++h;h=new F(l,0)}return c.d(b,e,f,h)}throw Error("Invalid arity: "+arguments.length);};b.i=3;b.f=c.f;b.a=function(a,b){return b};b.c=a;b.d=c.d;return b}();function jh(a){this.e=a}jh.prototype.add=function(a){return this.e.push(a)};jh.prototype.size=function(){return this.e.length};
jh.prototype.clear=function(){return this.e=[]};
var kh=function(){function a(a,b,c){return new V(null,function(){var h=D(c);return h?M(Pe.a(a,h),d.c(a,b,Qe.a(b,h))):null},null,null)}function b(a,b){return d.c(a,a,b)}function c(a){return function(b){return function(c){return function(){function d(h,l){c.add(l);if(a===c.size()){var m=zf(c.e);c.clear();return b.a?b.a(h,m):b.call(null,h,m)}return h}function l(a){if(!t(0===c.e.length)){var d=zf(c.e);c.clear();a=Bc(b.a?b.a(a,d):b.call(null,a,d))}return b.b?b.b(a):b.call(null,a)}function m(){return b.l?
b.l():b.call(null)}var p=null,p=function(a,b){switch(arguments.length){case 0:return m.call(this);case 1:return l.call(this,a);case 2:return d.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);};p.l=m;p.b=l;p.a=d;return p}()}(new jh([]))}}var d=null,d=function(d,f,g){switch(arguments.length){case 1:return c.call(this,d);case 2:return b.call(this,d,f);case 3:return a.call(this,d,f,g)}throw Error("Invalid arity: "+arguments.length);};d.b=c;d.a=b;d.c=a;return d}(),lh=function(){function a(a,
b){return new V(null,function(){var f=D(b);if(f){var g;g=G(f);g=a.b?a.b(g):a.call(null,g);f=t(g)?M(G(f),c.a(a,H(f))):null}else f=null;return f},null,null)}function b(a){return function(b){return function(){function c(f,g){return t(a.b?a.b(g):a.call(null,g))?b.a?b.a(f,g):b.call(null,f,g):new yc(f)}function g(a){return b.b?b.b(a):b.call(null,a)}function h(){return b.l?b.l():b.call(null)}var l=null,l=function(a,b){switch(arguments.length){case 0:return h.call(this);case 1:return g.call(this,a);case 2:return c.call(this,
a,b)}throw Error("Invalid arity: "+arguments.length);};l.l=h;l.b=g;l.a=c;return l}()}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}();function mh(a,b,c){return function(d){var e=Kb(a);d=Jb(a,d);e=e.a?e.a(d,c):e.call(null,d,c);return b.a?b.a(e,0):b.call(null,e,0)}}
var nh=function(){function a(a,b,c,g,h){var l=Ib(a,c,!0);if(t(l)){var m=R.c(l,0,null);return lh.a(mh(a,g,h),t(mh(a,b,c).call(null,m))?l:K(l))}return null}function b(a,b,c){var g=mh(a,b,c),h;a:{h=[Ad,Bd];var l=h.length;if(l<=Vf)for(var m=0,p=Ob(Uf);;)if(m<l)var q=m+1,p=Rb(p,h[m],null),m=q;else{h=new $g(null,Qb(p),null);break a}else for(m=0,p=Ob(bh);;)if(m<l)q=m+1,p=Pb(p,h[m]),m=q;else{h=Qb(p);break a}h=void 0}return t(h.call(null,b))?(a=Ib(a,c,!0),t(a)?(b=R.c(a,0,null),t(g.b?g.b(b):g.call(null,b))?
a:K(a)):null):lh.a(g,Hb(a,!0))}var c=null,c=function(c,e,f,g,h){switch(arguments.length){case 3:return b.call(this,c,e,f);case 5:return a.call(this,c,e,f,g,h)}throw Error("Invalid arity: "+arguments.length);};c.c=b;c.r=a;return c}();function oh(a,b,c){this.m=a;this.end=b;this.step=c}oh.prototype.ga=function(){return 0<this.step?this.m<this.end:this.m>this.end};oh.prototype.next=function(){var a=this.m;this.m+=this.step;return a};
function ph(a,b,c,d,e){this.k=a;this.start=b;this.end=c;this.step=d;this.p=e;this.j=32375006;this.q=8192}k=ph.prototype;k.toString=function(){return ec(this)};k.Q=function(a,b){if(b<Ma(this))return this.start+b*this.step;if(this.start>this.end&&0===this.step)return this.start;throw Error("Index out of bounds");};k.$=function(a,b,c){return b<Ma(this)?this.start+b*this.step:this.start>this.end&&0===this.step?this.start:c};k.vb=!0;k.fb=function(){return new oh(this.start,this.end,this.step)};k.H=function(){return this.k};
k.T=function(){return 0<this.step?this.start+this.step<this.end?new ph(this.k,this.start+this.step,this.end,this.step,null):null:this.start+this.step>this.end?new ph(this.k,this.start+this.step,this.end,this.step,null):null};k.L=function(){if(Aa(Cb(this)))return 0;var a=(this.end-this.start)/this.step;return Math.ceil.b?Math.ceil.b(a):Math.ceil.call(null,a)};k.B=function(){var a=this.p;return null!=a?a:this.p=a=wc(this)};k.A=function(a,b){return Ic(this,b)};k.J=function(){return O(J,this.k)};
k.R=function(a,b){return Cc.a(this,b)};k.O=function(a,b,c){for(a=this.start;;)if(0<this.step?a<this.end:a>this.end){var d=a;c=b.a?b.a(c,d):b.call(null,c,d);if(Ac(c))return b=c,L.b?L.b(b):L.call(null,b);a+=this.step}else return c};k.N=function(){return null==Cb(this)?null:this.start};k.S=function(){return null!=Cb(this)?new ph(this.k,this.start+this.step,this.end,this.step,null):J};k.D=function(){return 0<this.step?this.start<this.end?this:null:this.start>this.end?this:null};
k.F=function(a,b){return new ph(b,this.start,this.end,this.step,this.p)};k.G=function(a,b){return M(b,this)};ph.prototype[Ea]=function(){return uc(this)};
var qh=function(){function a(a,b,c){return new ph(null,a,b,c,null)}function b(a,b){return e.c(a,b,1)}function c(a){return e.c(0,a,1)}function d(){return e.c(0,Number.MAX_VALUE,1)}var e=null,e=function(e,g,h){switch(arguments.length){case 0:return d.call(this);case 1:return c.call(this,e);case 2:return b.call(this,e,g);case 3:return a.call(this,e,g,h)}throw Error("Invalid arity: "+arguments.length);};e.l=d;e.b=c;e.a=b;e.c=a;return e}(),rh=function(){function a(a,b){return new V(null,function(){var f=
D(b);return f?M(G(f),c.a(a,Qe.a(a,f))):null},null,null)}function b(a){return function(b){return function(c){return function(){function g(g,h){var l=c.bb(0,c.Ra(null)+1),m=Cd(l,a);return 0===l-a*m?b.a?b.a(g,h):b.call(null,g,h):g}function h(a){return b.b?b.b(a):b.call(null,a)}function l(){return b.l?b.l():b.call(null)}var m=null,m=function(a,b){switch(arguments.length){case 0:return l.call(this);case 1:return h.call(this,a);case 2:return g.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);
};m.l=l;m.b=h;m.a=g;return m}()}(new Me(-1))}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),th=function(){function a(a,b){return new V(null,function(){var f=D(b);if(f){var g=G(f),h=a.b?a.b(g):a.call(null,g),g=M(g,lh.a(function(b,c){return function(b){return sc.a(c,a.b?a.b(b):a.call(null,b))}}(g,h,f,f),K(f)));return M(g,c.a(a,D(Qe.a(Q(g),f))))}return null},null,
null)}function b(a){return function(b){return function(c,g){return function(){function h(h,l){var m=L.b?L.b(g):L.call(null,g),p=a.b?a.b(l):a.call(null,l);ac(g,p);if(Nd(m,sh)||sc.a(p,m))return c.add(l),h;m=zf(c.e);c.clear();m=b.a?b.a(h,m):b.call(null,h,m);Ac(m)||c.add(l);return m}function l(a){if(!t(0===c.e.length)){var d=zf(c.e);c.clear();a=Bc(b.a?b.a(a,d):b.call(null,a,d))}return b.b?b.b(a):b.call(null,a)}function m(){return b.l?b.l():b.call(null)}var p=null,p=function(a,b){switch(arguments.length){case 0:return m.call(this);
case 1:return l.call(this,a);case 2:return h.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);};p.l=m;p.b=l;p.a=h;return p}()}(new jh([]),new Me(sh))}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),uh=function(){function a(a,b){for(;;)if(D(b)&&0<a){var c=a-1,g=K(b);a=c;b=g}else return null}function b(a){for(;;)if(D(a))a=K(a);else return null}var c=
null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}(),vh=function(){function a(a,b){uh.a(a,b);return b}function b(a){uh.b(a);return a}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}();
function wh(a,b,c,d,e,f,g){var h=ma;try{ma=null==ma?null:ma-1;if(null!=ma&&0>ma)return Lb(a,"#");Lb(a,c);if(D(g)){var l=G(g);b.c?b.c(l,a,f):b.call(null,l,a,f)}for(var m=K(g),p=za.b(f)-1;;)if(!m||null!=p&&0===p){D(m)&&0===p&&(Lb(a,d),Lb(a,"..."));break}else{Lb(a,d);var q=G(m);c=a;g=f;b.c?b.c(q,c,g):b.call(null,q,c,g);var s=K(m);c=p-1;m=s;p=c}return Lb(a,e)}finally{ma=h}}
var xh=function(){function a(a,d){var e=null;if(1<arguments.length){for(var e=0,f=Array(arguments.length-1);e<f.length;)f[e]=arguments[e+1],++e;e=new F(f,0)}return b.call(this,a,e)}function b(a,b){for(var e=D(b),f=null,g=0,h=0;;)if(h<g){var l=f.Q(null,h);Lb(a,l);h+=1}else if(e=D(e))f=e,fd(f)?(e=Yb(f),g=Zb(f),f=e,l=Q(e),e=g,g=l):(l=G(f),Lb(a,l),e=K(f),f=null,g=0),h=0;else return null}a.i=1;a.f=function(a){var d=G(a);a=H(a);return b(d,a)};a.d=b;return a}(),yh={'"':'\\"',"\\":"\\\\","\b":"\\b","\f":"\\f",
"\n":"\\n","\r":"\\r","\t":"\\t"};function zh(a){return[z('"'),z(a.replace(RegExp('[\\\\"\b\f\n\r\t]',"g"),function(a){return yh[a]})),z('"')].join("")}
var $=function Ah(b,c,d){if(null==b)return Lb(c,"nil");if(void 0===b)return Lb(c,"#\x3cundefined\x3e");t(function(){var c=S.a(d,wa);return t(c)?(c=b?b.j&131072||b.kc?!0:b.j?!1:w(rb,b):w(rb,b))?Vc(b):c:c}())&&(Lb(c,"^"),Ah(Vc(b),c,d),Lb(c," "));if(null==b)return Lb(c,"nil");if(b.Yb)return b.nc(c);if(b&&(b.j&2147483648||b.I))return b.v(null,c,d);if(Ba(b)===Boolean||"number"===typeof b)return Lb(c,""+z(b));if(null!=b&&b.constructor===Object){Lb(c,"#js ");var e=Oe.a(function(c){return new W(null,2,5,
uf,[Pd.b(c),b[c]],null)},gd(b));return Bh.n?Bh.n(e,Ah,c,d):Bh.call(null,e,Ah,c,d)}return b instanceof Array?wh(c,Ah,"#js ["," ","]",d,b):t("string"==typeof b)?t(ua.b(d))?Lb(c,zh(b)):Lb(c,b):Tc(b)?xh.d(c,Kc(["#\x3c",""+z(b),"\x3e"],0)):b instanceof Date?(e=function(b,c){for(var d=""+z(b);;)if(Q(d)<c)d=[z("0"),z(d)].join("");else return d},xh.d(c,Kc(['#inst "',""+z(b.getUTCFullYear()),"-",e(b.getUTCMonth()+1,2),"-",e(b.getUTCDate(),2),"T",e(b.getUTCHours(),2),":",e(b.getUTCMinutes(),2),":",e(b.getUTCSeconds(),
2),".",e(b.getUTCMilliseconds(),3),"-",'00:00"'],0))):b instanceof RegExp?xh.d(c,Kc(['#"',b.source,'"'],0)):(b?b.j&2147483648||b.I||(b.j?0:w(Mb,b)):w(Mb,b))?Nb(b,c,d):xh.d(c,Kc(["#\x3c",""+z(b),"\x3e"],0))},Ch=function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){var b=oa();if(Yc(a))b="";else{var e=z,f=new fa;a:{var g=new dc(f);$(G(a),g,b);a=D(K(a));for(var h=null,l=0,
m=0;;)if(m<l){var p=h.Q(null,m);Lb(g," ");$(p,g,b);m+=1}else if(a=D(a))h=a,fd(h)?(a=Yb(h),l=Zb(h),h=a,p=Q(a),a=l,l=p):(p=G(h),Lb(g," "),$(p,g,b),a=K(h),h=null,l=0),m=0;else break a}b=""+e(f)}return b}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}();function Bh(a,b,c,d){return wh(c,function(a,c,d){var h=hb(a);b.c?b.c(h,c,d):b.call(null,h,c,d);Lb(c," ");a=ib(a);return b.c?b.c(a,c,d):b.call(null,a,c,d)},"{",", ","}",d,D(a))}Me.prototype.I=!0;
Me.prototype.v=function(a,b,c){Lb(b,"#\x3cVolatile: ");$(this.state,b,c);return Lb(b,"\x3e")};F.prototype.I=!0;F.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};V.prototype.I=!0;V.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};wg.prototype.I=!0;wg.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};pg.prototype.I=!0;pg.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};Z.prototype.I=!0;
Z.prototype.v=function(a,b,c){return wh(b,$,"["," ","]",c,this)};Rf.prototype.I=!0;Rf.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};ch.prototype.I=!0;ch.prototype.v=function(a,b,c){return wh(b,$,"#{"," ","}",c,this)};Bf.prototype.I=!0;Bf.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};Ld.prototype.I=!0;Ld.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};Hc.prototype.I=!0;Hc.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};
rg.prototype.I=!0;rg.prototype.v=function(a,b,c){return Bh(this,$,b,c)};qg.prototype.I=!0;qg.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};Df.prototype.I=!0;Df.prototype.v=function(a,b,c){return wh(b,$,"["," ","]",c,this)};Lg.prototype.I=!0;Lg.prototype.v=function(a,b,c){return Bh(this,$,b,c)};$g.prototype.I=!0;$g.prototype.v=function(a,b,c){return wh(b,$,"#{"," ","}",c,this)};Vd.prototype.I=!0;Vd.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};Ug.prototype.I=!0;
Ug.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};X.prototype.I=!0;X.prototype.v=function(a,b,c){return wh(b,$,"["," ","]",c,this)};W.prototype.I=!0;W.prototype.v=function(a,b,c){return wh(b,$,"["," ","]",c,this)};Kf.prototype.I=!0;Kf.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};Hd.prototype.I=!0;Hd.prototype.v=function(a,b){return Lb(b,"()")};ze.prototype.I=!0;ze.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};Lf.prototype.I=!0;
Lf.prototype.v=function(a,b,c){return wh(b,$,"#queue ["," ","]",c,D(this))};pa.prototype.I=!0;pa.prototype.v=function(a,b,c){return Bh(this,$,b,c)};ph.prototype.I=!0;ph.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};Sg.prototype.I=!0;Sg.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};Fd.prototype.I=!0;Fd.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};W.prototype.sb=!0;W.prototype.tb=function(a,b){return pd.a(this,b)};Df.prototype.sb=!0;
Df.prototype.tb=function(a,b){return pd.a(this,b)};U.prototype.sb=!0;U.prototype.tb=function(a,b){return Md(this,b)};qc.prototype.sb=!0;qc.prototype.tb=function(a,b){return pc(this,b)};var Dh=function(){function a(a,d,e){var f=null;if(2<arguments.length){for(var f=0,g=Array(arguments.length-2);f<g.length;)g[f]=arguments[f+2],++f;f=new F(g,0)}return b.call(this,a,d,f)}function b(a,b,e){return a.k=T.c(b,a.k,e)}a.i=2;a.f=function(a){var d=G(a);a=K(a);var e=G(a);a=H(a);return b(d,e,a)};a.d=b;return a}();
function Eh(a){return function(b,c){var d=a.a?a.a(b,c):a.call(null,b,c);return Ac(d)?new yc(d):d}}
function Ve(a){return function(b){return function(){function c(a,c){return A.c(b,a,c)}function d(b){return a.b?a.b(b):a.call(null,b)}function e(){return a.l?a.l():a.call(null)}var f=null,f=function(a,b){switch(arguments.length){case 0:return e.call(this);case 1:return d.call(this,a);case 2:return c.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);};f.l=e;f.b=d;f.a=c;return f}()}(Eh(a))}
var Fh=function(){function a(a){return Ce.a(c.l(),a)}function b(){return function(a){return function(b){return function(){function c(f,g){var h=L.b?L.b(b):L.call(null,b);ac(b,g);return sc.a(h,g)?f:a.a?a.a(f,g):a.call(null,f,g)}function g(b){return a.b?a.b(b):a.call(null,b)}function h(){return a.l?a.l():a.call(null)}var l=null,l=function(a,b){switch(arguments.length){case 0:return h.call(this);case 1:return g.call(this,a);case 2:return c.call(this,a,b)}throw Error("Invalid arity: "+arguments.length);
};l.l=h;l.b=g;l.a=c;return l}()}(new Me(sh))}}var c=null,c=function(c){switch(arguments.length){case 0:return b.call(this);case 1:return a.call(this,c)}throw Error("Invalid arity: "+arguments.length);};c.l=b;c.b=a;return c}();function Gh(a,b){this.fa=a;this.Zb=b;this.q=0;this.j=2173173760}Gh.prototype.v=function(a,b,c){return wh(b,$,"("," ",")",c,this)};Gh.prototype.O=function(a,b,c){return wd.n(this.fa,b,c,this.Zb)};Gh.prototype.D=function(){return D(Ce.a(this.fa,this.Zb))};Gh.prototype[Ea]=function(){return uc(this)};
var Hh={};function Ih(a){if(a?a.gc:a)return a.gc(a);var b;b=Ih[n(null==a?null:a)];if(!b&&(b=Ih._,!b))throw x("IEncodeJS.-clj-\x3ejs",a);return b.call(null,a)}function Jh(a){return(a?t(t(null)?null:a.fc)||(a.yb?0:w(Hh,a)):w(Hh,a))?Ih(a):"string"===typeof a||"number"===typeof a||a instanceof U||a instanceof qc?Kh.b?Kh.b(a):Kh.call(null,a):Ch.d(Kc([a],0))}
var Kh=function Lh(b){if(null==b)return null;if(b?t(t(null)?null:b.fc)||(b.yb?0:w(Hh,b)):w(Hh,b))return Ih(b);if(b instanceof U)return Od(b);if(b instanceof qc)return""+z(b);if(dd(b)){var c={};b=D(b);for(var d=null,e=0,f=0;;)if(f<e){var g=d.Q(null,f),h=R.c(g,0,null),g=R.c(g,1,null);c[Jh(h)]=Lh(g);f+=1}else if(b=D(b))fd(b)?(e=Yb(b),b=Zb(b),d=e,e=Q(e)):(e=G(b),d=R.c(e,0,null),e=R.c(e,1,null),c[Jh(d)]=Lh(e),b=K(b),d=null,e=0),f=0;else break;return c}if($c(b)){c=[];b=D(Oe.a(Lh,b));d=null;for(f=e=0;;)if(f<
e)h=d.Q(null,f),c.push(h),f+=1;else if(b=D(b))d=b,fd(d)?(b=Yb(d),f=Zb(d),d=b,e=Q(b),b=f):(b=G(d),c.push(b),b=K(d),d=null,e=0),f=0;else break;return c}return b},Mh={};function Nh(a,b){if(a?a.ec:a)return a.ec(a,b);var c;c=Nh[n(null==a?null:a)];if(!c&&(c=Nh._,!c))throw x("IEncodeClojure.-js-\x3eclj",a);return c.call(null,a,b)}
var Ph=function(){function a(a){return b.d(a,Kc([new pa(null,1,[Oh,!1],null)],0))}var b=null,c=function(){function a(c,d){var h=null;if(1<arguments.length){for(var h=0,l=Array(arguments.length-1);h<l.length;)l[h]=arguments[h+1],++h;h=new F(l,0)}return b.call(this,c,h)}function b(a,c){var d=kd(c)?T.a(Og,c):c,e=S.a(d,Oh);return function(a,b,d,e){return function v(f){return(f?t(t(null)?null:f.uc)||(f.yb?0:w(Mh,f)):w(Mh,f))?Nh(f,T.a(Pg,c)):kd(f)?vh.b(Oe.a(v,f)):$c(f)?af.a(Oc(f),Oe.a(v,f)):f instanceof
Array?zf(Oe.a(v,f)):Ba(f)===Object?af.a(Uf,function(){return function(a,b,c,d){return function Pa(e){return new V(null,function(a,b,c,d){return function(){for(;;){var a=D(e);if(a){if(fd(a)){var b=Yb(a),c=Q(b),g=Td(c);return function(){for(var a=0;;)if(a<c){var e=C.a(b,a),h=g,l=uf,m;m=e;m=d.b?d.b(m):d.call(null,m);e=new W(null,2,5,l,[m,v(f[e])],null);h.add(e);a+=1}else return!0}()?Wd(g.ca(),Pa(Zb(a))):Wd(g.ca(),null)}var h=G(a);return M(new W(null,2,5,uf,[function(){var a=h;return d.b?d.b(a):d.call(null,
a)}(),v(f[h])],null),Pa(H(a)))}return null}}}(a,b,c,d),null,null)}}(a,b,d,e)(gd(f))}()):f}}(c,d,e,t(e)?Pd:z)(a)}a.i=1;a.f=function(a){var c=G(a);a=H(a);return b(c,a)};a.d=b;return a}(),b=function(b,e){switch(arguments.length){case 1:return a.call(this,b);default:var f=null;if(1<arguments.length){for(var f=0,g=Array(arguments.length-1);f<g.length;)g[f]=arguments[f+1],++f;f=new F(g,0)}return c.d(b,f)}throw Error("Invalid arity: "+arguments.length);};b.i=1;b.f=c.f;b.b=a;b.d=c.d;return b}();var wa=new U(null,"meta","meta",1499536964),ya=new U(null,"dup","dup",556298533),sh=new U("cljs.core","none","cljs.core/none",926646439),pe=new U(null,"file","file",-1269645878),le=new U(null,"end-column","end-column",1425389514),sa=new U(null,"flush-on-newline","flush-on-newline",-151457939),ne=new U(null,"column","column",2078222095),ua=new U(null,"readably","readably",1129599760),oe=new U(null,"line","line",212345235),za=new U(null,"print-length","print-length",1931866356),me=new U(null,"end-line",
"end-line",1837326455),Oh=new U(null,"keywordize-keys","keywordize-keys",1310784252),Zg=new U("cljs.core","not-found","cljs.core/not-found",-1572889185);function Qh(a,b){var c=T.c(ih,a,b);return M(c,Ye.a(function(a){return function(b){return a===b}}(c),b))}
var Rh=function(){function a(a,b){return Q(a)<Q(b)?A.c(Nc,b,a):A.c(Nc,a,b)}var b=null,c=function(){function a(c,d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return b.call(this,c,d,l)}function b(a,c,d){a=Qh(Q,Nc.d(d,c,Kc([a],0)));return A.c(af,G(a),H(a))}a.i=2;a.f=function(a){var c=G(a);a=K(a);var d=G(a);a=H(a);return b(c,d,a)};a.d=b;return a}(),b=function(b,e,f){switch(arguments.length){case 0:return bh;case 1:return b;
case 2:return a.call(this,b,e);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.l=function(){return bh};b.b=function(a){return a};b.a=a;b.d=c.d;return b}(),Sh=function(){function a(a,b){for(;;)if(Q(b)<Q(a)){var c=a;a=b;b=c}else return A.c(function(a,b){return function(a,c){return nd(b,c)?a:Xc.a(a,c)}}(a,b),a,a)}var b=null,c=function(){function a(b,
d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return c.call(this,b,d,l)}function c(a,d,e){a=Qh(function(a){return-Q(a)},Nc.d(e,d,Kc([a],0)));return A.c(b,G(a),H(a))}a.i=2;a.f=function(a){var b=G(a);a=K(a);var d=G(a);a=H(a);return c(b,d,a)};a.d=c;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return b;case 2:return a.call(this,b,e);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-
2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.b=function(a){return a};b.a=a;b.d=c.d;return b}(),Th=function(){function a(a,b){return Q(a)<Q(b)?A.c(function(a,c){return nd(b,c)?Xc.a(a,c):a},a,a):A.c(Xc,a,b)}var b=null,c=function(){function a(b,d,h){var l=null;if(2<arguments.length){for(var l=0,m=Array(arguments.length-2);l<m.length;)m[l]=arguments[l+2],++l;l=new F(m,0)}return c.call(this,b,d,l)}function c(a,d,
e){return A.c(b,a,Nc.a(e,d))}a.i=2;a.f=function(a){var b=G(a);a=K(a);var d=G(a);a=H(a);return c(b,d,a)};a.d=c;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return b;case 2:return a.call(this,b,e);default:var g=null;if(2<arguments.length){for(var g=0,h=Array(arguments.length-2);g<h.length;)h[g]=arguments[g+2],++g;g=new F(h,0)}return c.d(b,e,g)}throw Error("Invalid arity: "+arguments.length);};b.i=2;b.f=c.f;b.b=function(a){return a};b.a=a;b.d=c.d;return b}();
function Uh(a,b){return A.c(function(b,d){var e=R.c(d,0,null),f=R.c(d,1,null);return nd(a,e)?Rc.c(b,f,S.a(a,e)):b},T.c(Sc,a,Tg(b)),b)}function Vh(a,b){return A.c(function(a,d){var e=Yg(d,b);return Rc.c(a,e,Nc.a(S.c(a,e,bh),d))},Uf,a)}function Wh(a){return A.c(function(a,c){var d=R.c(c,0,null),e=R.c(c,1,null);return Rc.c(a,e,d)},Uf,a)}
var Xh=function(){function a(a,b,c){a=Q(a)<=Q(b)?new W(null,3,5,uf,[a,b,Wh(c)],null):new W(null,3,5,uf,[b,a,c],null);b=R.c(a,0,null);c=R.c(a,1,null);var g=R.c(a,2,null),h=Vh(b,Vg(g));return A.c(function(a,b,c,d,e){return function(f,g){var h=function(){var a=Uh(Yg(g,Tg(d)),d);return e.b?e.b(a):e.call(null,a)}();return t(h)?A.c(function(){return function(a,b){return Nc.a(a,Wg.d(Kc([b,g],0)))}}(h,a,b,c,d,e),f,h):f}}(a,b,c,g,h),bh,c)}function b(a,b){if(D(a)&&D(b)){var c=Sh.a(fh(Tg(G(a))),fh(Tg(G(b)))),
g=Q(a)<=Q(b)?new W(null,2,5,uf,[a,b],null):new W(null,2,5,uf,[b,a],null),h=R.c(g,0,null),l=R.c(g,1,null),m=Vh(h,c);return A.c(function(a,b,c,d,e){return function(f,g){var h=function(){var b=Yg(g,a);return e.b?e.b(b):e.call(null,b)}();return t(h)?A.c(function(){return function(a,b){return Nc.a(a,Wg.d(Kc([b,g],0)))}}(h,a,b,c,d,e),f,h):f}}(c,g,h,l,m),bh,l)}return bh}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error("Invalid arity: "+
arguments.length);};c.a=b;c.c=a;return c}();r("mori.apply",T);r("mori.apply.f2",T.a);r("mori.apply.f3",T.c);r("mori.apply.f4",T.n);r("mori.apply.f5",T.r);r("mori.apply.fn",T.K);r("mori.count",Q);r("mori.distinct",function(a){return function c(a,e){return new V(null,function(){return function(a,d){for(;;){var e=a,l=R.c(e,0,null);if(e=D(e))if(nd(d,l))l=H(e),e=d,a=l,d=e;else return M(l,c(H(e),Nc.a(d,l)));else return null}}.call(null,a,e)},null,null)}(a,bh)});r("mori.empty",Oc);r("mori.first",G);r("mori.second",Lc);r("mori.next",K);
r("mori.rest",H);r("mori.seq",D);r("mori.conj",Nc);r("mori.conj.f0",Nc.l);r("mori.conj.f1",Nc.b);r("mori.conj.f2",Nc.a);r("mori.conj.fn",Nc.K);r("mori.cons",M);r("mori.find",function(a,b){return null!=a&&bd(a)&&nd(a,b)?new W(null,2,5,uf,[b,S.a(a,b)],null):null});r("mori.nth",R);r("mori.nth.f2",R.a);r("mori.nth.f3",R.c);r("mori.last",function(a){for(;;){var b=K(a);if(null!=b)a=b;else return G(a)}});r("mori.assoc",Rc);r("mori.assoc.f3",Rc.c);r("mori.assoc.fn",Rc.K);r("mori.dissoc",Sc);
r("mori.dissoc.f1",Sc.b);r("mori.dissoc.f2",Sc.a);r("mori.dissoc.fn",Sc.K);r("mori.getIn",cf);r("mori.getIn.f2",cf.a);r("mori.getIn.f3",cf.c);r("mori.updateIn",df);r("mori.updateIn.f3",df.c);r("mori.updateIn.f4",df.n);r("mori.updateIn.f5",df.r);r("mori.updateIn.f6",df.P);r("mori.updateIn.fn",df.K);r("mori.assocIn",function Yh(b,c,d){var e=R.c(c,0,null);return(c=Ed(c))?Rc.c(b,e,Yh(S.a(b,e),c,d)):Rc.c(b,e,d)});r("mori.fnil",Ke);r("mori.fnil.f2",Ke.a);r("mori.fnil.f3",Ke.c);r("mori.fnil.f4",Ke.n);
r("mori.disj",Xc);r("mori.disj.f1",Xc.b);r("mori.disj.f2",Xc.a);r("mori.disj.fn",Xc.K);r("mori.pop",function(a){return null==a?null:mb(a)});r("mori.peek",Wc);r("mori.hash",nc);r("mori.get",S);r("mori.get.f2",S.a);r("mori.get.f3",S.c);r("mori.hasKey",nd);r("mori.isEmpty",Yc);r("mori.reverse",Jd);r("mori.take",Pe);r("mori.take.f1",Pe.b);r("mori.take.f2",Pe.a);r("mori.drop",Qe);r("mori.drop.f1",Qe.b);r("mori.drop.f2",Qe.a);r("mori.takeNth",rh);r("mori.takeNth.f1",rh.b);r("mori.takeNth.f2",rh.a);
r("mori.partition",bf);r("mori.partition.f2",bf.a);r("mori.partition.f3",bf.c);r("mori.partition.f4",bf.n);r("mori.partitionAll",kh);r("mori.partitionAll.f1",kh.b);r("mori.partitionAll.f2",kh.a);r("mori.partitionAll.f3",kh.c);r("mori.partitionBy",th);r("mori.partitionBy.f1",th.b);r("mori.partitionBy.f2",th.a);r("mori.iterate",function Zh(b,c){return M(c,new V(null,function(){return Zh(b,b.b?b.b(c):b.call(null,c))},null,null))});r("mori.into",af);r("mori.into.f2",af.a);r("mori.into.f3",af.c);
r("mori.merge",Wg);r("mori.mergeWith",Xg);r("mori.subvec",Cf);r("mori.subvec.f2",Cf.a);r("mori.subvec.f3",Cf.c);r("mori.takeWhile",lh);r("mori.takeWhile.f1",lh.b);r("mori.takeWhile.f2",lh.a);r("mori.dropWhile",Re);r("mori.dropWhile.f1",Re.b);r("mori.dropWhile.f2",Re.a);r("mori.groupBy",function(a,b){return ce(A.c(function(b,d){var e=a.b?a.b(d):a.call(null,d);return ee.c(b,e,Nc.a(S.c(b,e,Mc),d))},Ob(Uf),b))});r("mori.interpose",function(a,b){return Qe.a(1,Ue.a(Se.b(a),b))});r("mori.interleave",Ue);
r("mori.interleave.f2",Ue.a);r("mori.interleave.fn",Ue.K);r("mori.concat",ae);r("mori.concat.f0",ae.l);r("mori.concat.f1",ae.b);r("mori.concat.f2",ae.a);r("mori.concat.fn",ae.K);function $e(a){return a instanceof Array||cd(a)}r("mori.flatten",function(a){return Xe.a(function(a){return!$e(a)},H(Ze(a)))});r("mori.lazySeq",function(a){return new V(null,a,null,null)});r("mori.keys",Tg);r("mori.selectKeys",Yg);r("mori.vals",Vg);r("mori.primSeq",Jc);r("mori.primSeq.f1",Jc.b);r("mori.primSeq.f2",Jc.a);
r("mori.map",Oe);r("mori.map.f1",Oe.b);r("mori.map.f2",Oe.a);r("mori.map.f3",Oe.c);r("mori.map.f4",Oe.n);r("mori.map.fn",Oe.K);
r("mori.mapIndexed",function(a,b){return function d(b,f){return new V(null,function(){var g=D(f);if(g){if(fd(g)){for(var h=Yb(g),l=Q(h),m=Td(l),p=0;;)if(p<l)Xd(m,function(){var d=b+p,f=C.a(h,p);return a.a?a.a(d,f):a.call(null,d,f)}()),p+=1;else break;return Wd(m.ca(),d(b+l,Zb(g)))}return M(function(){var d=G(g);return a.a?a.a(b,d):a.call(null,b,d)}(),d(b+1,H(g)))}return null},null,null)}(0,b)});r("mori.mapcat",We);r("mori.mapcat.f1",We.b);r("mori.mapcat.fn",We.K);r("mori.reduce",A);
r("mori.reduce.f2",A.a);r("mori.reduce.f3",A.c);r("mori.reduceKV",function(a,b,c){return null!=c?xb(c,a,b):b});r("mori.keep",Le);r("mori.keep.f1",Le.b);r("mori.keep.f2",Le.a);r("mori.keepIndexed",Ne);r("mori.keepIndexed.f1",Ne.b);r("mori.keepIndexed.f2",Ne.a);r("mori.filter",Xe);r("mori.filter.f1",Xe.b);r("mori.filter.f2",Xe.a);r("mori.remove",Ye);r("mori.remove.f1",Ye.b);r("mori.remove.f2",Ye.a);r("mori.some",Fe);r("mori.every",Ee);r("mori.equals",sc);r("mori.equals.f1",sc.b);
r("mori.equals.f2",sc.a);r("mori.equals.fn",sc.K);r("mori.range",qh);r("mori.range.f0",qh.l);r("mori.range.f1",qh.b);r("mori.range.f2",qh.a);r("mori.range.f3",qh.c);r("mori.repeat",Se);r("mori.repeat.f1",Se.b);r("mori.repeat.f2",Se.a);r("mori.repeatedly",Te);r("mori.repeatedly.f1",Te.b);r("mori.repeatedly.f2",Te.a);r("mori.sort",sd);r("mori.sort.f1",sd.b);r("mori.sort.f2",sd.a);r("mori.sortBy",td);r("mori.sortBy.f2",td.a);r("mori.sortBy.f3",td.c);r("mori.intoArray",Ia);r("mori.intoArray.f1",Ia.b);
r("mori.intoArray.f2",Ia.a);r("mori.subseq",nh);r("mori.subseq.f3",nh.c);r("mori.subseq.f5",nh.r);r("mori.dedupe",Fh);r("mori.dedupe.f0",Fh.l);r("mori.dedupe.f1",Fh.b);r("mori.transduce",wd);r("mori.transduce.f3",wd.c);r("mori.transduce.f4",wd.n);r("mori.eduction",function(a,b){return new Gh(a,b)});r("mori.sequence",Ce);r("mori.sequence.f1",Ce.b);r("mori.sequence.f2",Ce.a);r("mori.sequence.fn",Ce.K);r("mori.completing",vd);r("mori.completing.f1",vd.b);r("mori.completing.f2",vd.a);r("mori.list",Kd);
r("mori.vector",Af);r("mori.hashMap",Pg);r("mori.set",fh);r("mori.sortedSet",gh);r("mori.sortedSetBy",hh);r("mori.sortedMap",Qg);r("mori.sortedMapBy",Rg);r("mori.queue",function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){return af.a?af.a(Mf,a):af.call(null,Mf,a)}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}());r("mori.keyword",Pd);r("mori.keyword.f1",Pd.b);
r("mori.keyword.f2",Pd.a);r("mori.symbol",rc);r("mori.symbol.f1",rc.b);r("mori.symbol.f2",rc.a);r("mori.zipmap",function(a,b){for(var c=Ob(Uf),d=D(a),e=D(b);;)if(d&&e)c=ee.c(c,G(d),G(e)),d=K(d),e=K(e);else return Qb(c)});r("mori.isList",function(a){return a?a.j&33554432||a.wc?!0:a.j?!1:w(Eb,a):w(Eb,a)});r("mori.isSeq",kd);r("mori.isVector",ed);r("mori.isMap",dd);r("mori.isSet",ad);r("mori.isKeyword",function(a){return a instanceof U});r("mori.isSymbol",function(a){return a instanceof qc});
r("mori.isCollection",$c);r("mori.isSequential",cd);r("mori.isAssociative",bd);r("mori.isCounted",Ec);r("mori.isIndexed",Fc);r("mori.isReduceable",function(a){return a?a.j&524288||a.Sb?!0:a.j?!1:w(vb,a):w(vb,a)});r("mori.isSeqable",ld);r("mori.isReversible",Id);r("mori.union",Rh);r("mori.union.f0",Rh.l);r("mori.union.f1",Rh.b);r("mori.union.f2",Rh.a);r("mori.union.fn",Rh.K);r("mori.intersection",Sh);r("mori.intersection.f1",Sh.b);r("mori.intersection.f2",Sh.a);r("mori.intersection.fn",Sh.K);
r("mori.difference",Th);r("mori.difference.f1",Th.b);r("mori.difference.f2",Th.a);r("mori.difference.fn",Th.K);r("mori.join",Xh);r("mori.join.f2",Xh.a);r("mori.join.f3",Xh.c);r("mori.index",Vh);r("mori.project",function(a,b){return fh(Oe.a(function(a){return Yg(a,b)},a))});r("mori.mapInvert",Wh);r("mori.rename",function(a,b){return fh(Oe.a(function(a){return Uh(a,b)},a))});r("mori.renameKeys",Uh);r("mori.isSubset",function(a,b){return Q(a)<=Q(b)&&Ee(function(a){return nd(b,a)},a)});
r("mori.isSuperset",function(a,b){return Q(a)>=Q(b)&&Ee(function(b){return nd(a,b)},b)});r("mori.notEquals",je);r("mori.notEquals.f1",je.b);r("mori.notEquals.f2",je.a);r("mori.notEquals.fn",je.K);r("mori.gt",Ad);r("mori.gt.f1",Ad.b);r("mori.gt.f2",Ad.a);r("mori.gt.fn",Ad.K);r("mori.gte",Bd);r("mori.gte.f1",Bd.b);r("mori.gte.f2",Bd.a);r("mori.gte.fn",Bd.K);r("mori.lt",yd);r("mori.lt.f1",yd.b);r("mori.lt.f2",yd.a);r("mori.lt.fn",yd.K);r("mori.lte",zd);r("mori.lte.f1",zd.b);r("mori.lte.f2",zd.a);
r("mori.lte.fn",zd.K);r("mori.compare",od);r("mori.partial",Je);r("mori.partial.f1",Je.b);r("mori.partial.f2",Je.a);r("mori.partial.f3",Je.c);r("mori.partial.f4",Je.n);r("mori.partial.fn",Je.K);r("mori.comp",Ie);r("mori.comp.f0",Ie.l);r("mori.comp.f1",Ie.b);r("mori.comp.f2",Ie.a);r("mori.comp.f3",Ie.c);r("mori.comp.fn",Ie.K);
r("mori.pipeline",function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){function b(a,c){return c.b?c.b(a):c.call(null,a)}return A.a?A.a(b,a):A.call(null,b,a)}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}());
r("mori.curry",function(){function a(a,d){var e=null;if(1<arguments.length){for(var e=0,f=Array(arguments.length-1);e<f.length;)f[e]=arguments[e+1],++e;e=new F(f,0)}return b.call(this,a,e)}function b(a,b){return function(e){return T.a(a,M.a?M.a(e,b):M.call(null,e,b))}}a.i=1;a.f=function(a){var d=G(a);a=H(a);return b(d,a)};a.d=b;return a}());
r("mori.juxt",function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){return function(){function b(a){var c=null;if(0<arguments.length){for(var c=0,d=Array(arguments.length-0);c<d.length;)d[c]=arguments[c+0],++c;c=new F(d,0)}return e.call(this,c)}function e(b){var d=function(){function d(a){return T.a(a,b)}return Oe.a?Oe.a(d,a):Oe.call(null,d,a)}();return Ia.b?Ia.b(d):Ia.call(null,
d)}b.i=0;b.f=function(a){a=D(a);return e(a)};b.d=e;return b}()}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}());
r("mori.knit",function(){function a(a){var d=null;if(0<arguments.length){for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;d=new F(e,0)}return b.call(this,d)}function b(a){return function(b){var e=function(){function e(a,b){return a.b?a.b(b):a.call(null,b)}return Oe.c?Oe.c(e,a,b):Oe.call(null,e,a,b)}();return Ia.b?Ia.b(e):Ia.call(null,e)}}a.i=0;a.f=function(a){a=D(a);return b(a)};a.d=b;return a}());r("mori.sum",xd);r("mori.sum.f0",xd.l);r("mori.sum.f1",xd.b);
r("mori.sum.f2",xd.a);r("mori.sum.fn",xd.K);r("mori.inc",function(a){return a+1});r("mori.dec",function(a){return a-1});r("mori.isEven",Ge);r("mori.isOdd",function(a){return!Ge(a)});r("mori.each",function(a,b){for(var c=D(a),d=null,e=0,f=0;;)if(f<e){var g=d.Q(null,f);b.b?b.b(g):b.call(null,g);f+=1}else if(c=D(c))fd(c)?(e=Yb(c),c=Zb(c),d=e,e=Q(e)):(d=g=G(c),b.b?b.b(d):b.call(null,d),c=K(c),d=null,e=0),f=0;else return null});r("mori.identity",ud);
r("mori.constantly",function(a){return function(){function b(b){if(0<arguments.length)for(var d=0,e=Array(arguments.length-0);d<e.length;)e[d]=arguments[d+0],++d;return a}b.i=0;b.f=function(b){D(b);return a};b.d=function(){return a};return b}()});r("mori.toJs",Kh);
r("mori.toClj",function(){function a(a,b){return Ph.d(a,Kc([Oh,b],0))}function b(a){return Ph.b(a)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error("Invalid arity: "+arguments.length);};c.b=b;c.a=a;return c}());r("mori.configure",function(a,b){switch(a){case "print-length":return la=b;case "print-level":return ma=b;default:throw Error([z("No matching clause: "),z(a)].join(""));}});r("mori.meta",Vc);r("mori.withMeta",O);
r("mori.varyMeta",ie);r("mori.varyMeta.f2",ie.a);r("mori.varyMeta.f3",ie.c);r("mori.varyMeta.f4",ie.n);r("mori.varyMeta.f5",ie.r);r("mori.varyMeta.f6",ie.P);r("mori.varyMeta.fn",ie.K);r("mori.alterMeta",Dh);r("mori.resetMeta",function(a,b){return a.k=b});V.prototype.inspect=function(){return this.toString()};F.prototype.inspect=function(){return this.toString()};Hc.prototype.inspect=function(){return this.toString()};wg.prototype.inspect=function(){return this.toString()};pg.prototype.inspect=function(){return this.toString()};
qg.prototype.inspect=function(){return this.toString()};Fd.prototype.inspect=function(){return this.toString()};Ld.prototype.inspect=function(){return this.toString()};Hd.prototype.inspect=function(){return this.toString()};W.prototype.inspect=function(){return this.toString()};Vd.prototype.inspect=function(){return this.toString()};Bf.prototype.inspect=function(){return this.toString()};Df.prototype.inspect=function(){return this.toString()};Z.prototype.inspect=function(){return this.toString()};
X.prototype.inspect=function(){return this.toString()};pa.prototype.inspect=function(){return this.toString()};rg.prototype.inspect=function(){return this.toString()};Lg.prototype.inspect=function(){return this.toString()};$g.prototype.inspect=function(){return this.toString()};ch.prototype.inspect=function(){return this.toString()};ph.prototype.inspect=function(){return this.toString()};U.prototype.inspect=function(){return this.toString()};qc.prototype.inspect=function(){return this.toString()};
Lf.prototype.inspect=function(){return this.toString()};Kf.prototype.inspect=function(){return this.toString()};r("mori.mutable.thaw",function(a){return Ob(a)});r("mori.mutable.freeze",ce);r("mori.mutable.conj",de);r("mori.mutable.conj.f0",de.l);r("mori.mutable.conj.f1",de.b);r("mori.mutable.conj.f2",de.a);r("mori.mutable.conj.fn",de.K);r("mori.mutable.assoc",ee);r("mori.mutable.assoc.f3",ee.c);r("mori.mutable.assoc.fn",ee.K);r("mori.mutable.dissoc",fe);r("mori.mutable.dissoc.f2",fe.a);r("mori.mutable.dissoc.fn",fe.K);r("mori.mutable.pop",function(a){return Ub(a)});r("mori.mutable.disj",ge);
r("mori.mutable.disj.f2",ge.a);r("mori.mutable.disj.fn",ge.K);;return this.mori;}.call({});});

},{}],"serialize/exportcsv":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var BreedReference, ExportedColorNum, ExportedCommandLambda, ExportedLinkSet, ExportedPatchSet, ExportedRGB, ExportedRGBA, ExportedReporterLambda, ExportedTurtleSet, ExtensionsHandler, JSType, LinkReference, NobodyReference, PatchReference, TurtleReference, allPlotsDataToCSV, exceptions, flatMap, fold, formatAgentRef, formatAgents, formatAny, formatBoolean, formatBreedRef, formatColor, formatDate, formatDrawingData, formatFloat, formatGlobals, formatKeys, formatLinkRef, formatList, formatMetadata, formatMiniGlobals, formatNumber, formatPair, formatPatchRef, formatPensData, formatPlain, formatPlotData, formatPointsData, formatString, formatStringInner, formatTurtleRef, formatValues, id, isEmpty, joinCommaed, keys, map, mapMaybe, maxBy, maybe, onNextLineIfNotEmpty, pairs, pipeline, plotDataToCSV, rangeUntil, rawPlotToCSV, schemafyAny, schemafyLink, schemafyPatch, schemafyTurtle, tee, toObject, unique, values, worldDataToCSV;

  JSType = require('util/jstype');

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({flatMap, isEmpty, map, maxBy, toObject, unique} = require('brazierjs/array'));

  ({id, pipeline, tee} = require('brazierjs/function'));

  ({
    fold,
    map: mapMaybe,
    maybe
  } = require('brazierjs/maybe'));

  ({rangeUntil} = require('brazierjs/number'));

  ({keys, pairs, values} = require('brazierjs/object'));

  ExtensionsHandler = require('../engine/core/world/extensionshandler');

  formatFloat = require('util/formatfloat');

  ({BreedReference, ExportedColorNum, ExportedCommandLambda, ExportedLinkSet, ExportedPatchSet, ExportedReporterLambda, ExportedRGB, ExportedRGBA, ExportedTurtleSet, LinkReference, NobodyReference, PatchReference, TurtleReference} = require('./exportstructures'));

  // (String) => String
  onNextLineIfNotEmpty = function(x) {
    if (isEmpty(x)) {
      return '';
    } else {
      return '\n' + x;
    }
  };

  // (Array[String]) => String
  joinCommaed = function(x) {
    return x.join(',');
  };

  // (String) => String
  formatPlain = function(str) {
    return '"' + str + '"';
  };

  // (String) => String
  formatStringInner = function(str) {
    return '""' + str.replace(/\n/g, "\\n").replace(/"/g, '\\""') + '""';
  };

  // (String) => String
  formatString = function(str) {
    return formatPlain(formatStringInner(str));
  };

  // (Boolean) => String
  formatBoolean = function(bool) {
    return formatPlain(bool);
  };

  // (Number) => String
  formatNumber = function(num) {
    return formatPlain(formatFloat(num));
  };

  // (BreedReference) => String
  formatBreedRef = function({breedName}) {
    var lowered;
    lowered = breedName.toLowerCase();
    if (lowered === "turtles" || lowered === "patches" || lowered === "links") {
      return `{all-${lowered}}`;
    } else {
      return `{breed ${lowered}}`;
    }
  };

  // [T] @ ((T, (T) => String)) => String
  formatPair = function([value, formatter]) {
    return formatter(value);
  };

  // (TurtleReference) => String
  formatTurtleRef = function({
      breed: {singular},
      id: turtleID
    }) {
    return `{${singular.toLowerCase()} ${turtleID}}`;
  };

  // (PatchReference) => String
  formatPatchRef = function({pxcor, pycor}) {
    return `{patch ${pxcor} ${pycor}}`;
  };

  // (LinkReference) => String
  formatLinkRef = function({
      breed: {singular},
      id1,
      id2
    }) {
    return `{${singular.toLowerCase()} ${id1} ${id2}}`;
  };

  // (AgentReference) => String
  formatAgentRef = function(ref) {
    if (ref === NobodyReference) {
      return "nobody";
    } else if (ref instanceof LinkReference) {
      return formatLinkRef(ref);
    } else if (ref instanceof PatchReference) {
      return formatPatchRef(ref);
    } else if (ref instanceof TurtleReference) {
      return formatTurtleRef(ref);
    } else {
      throw exceptions.internal(`Unknown agent reference: ${JSON.stringify(ref)}`);
    }
  };

  // (Array[_], (Any) => String) => String
  formatList = function(xs, formatter) {
    return `[${xs.map(function(x) {
      return formatter(x);
    }).join(" ")}]`;
  };

  // (ExportedColor) => String
  formatColor = function(color) {
    if (color instanceof ExportedColorNum) {
      return formatNumber(color.value);
    } else if (color instanceof ExportedRGB) {
      return formatPlain(formatList([color.r, color.g, color.b], formatFloat));
    } else if (color instanceof ExportedRGBA) {
      return formatPlain(formatList([color.r, color.g, color.b, color.a], formatFloat));
    } else {
      throw exceptions.internal(`Unknown color: ${JSON.stringify(color)}`);
    }
  };

  // (ExtensionsFormatter, Boolean) => (Any) => String
  formatAny = function(extensionFormatter, isOuterValue = true) {
    return function(any) {
      var formatter;
      // (Any) => String
      formatter = function(x) {
        var exportInnerLink, exportInnerPatch, exportInnerTurtle, type;
        type = JSType(x);
        if (type.isArray()) {
          return formatList(x, formatter);
        } else if (type.isBoolean()) {
          return x;
        } else if (type.isNumber()) {
          return formatFloat(x);
        } else if (type.isString()) {
          return formatStringInner(x);
        } else if (x instanceof BreedReference) {
          return formatBreedRef(x);
        } else if (x === NobodyReference) {
          return "nobody";
        } else if (x instanceof LinkReference) {
          return formatLinkRef(x);
        } else if (x instanceof PatchReference) {
          return formatPatchRef(x);
        } else if (x instanceof TurtleReference) {
          return formatTurtleRef(x);
        } else if (x instanceof ExportedCommandLambda) {
          return `(anonymous command: ${x.source.replace(/"/g, '""')})`;
        } else if (x instanceof ExportedReporterLambda) {
          return `(anonymous reporter: ${x.source.replace(/"/g, '""')})`;
        } else if (x instanceof ExportedLinkSet) {
          exportInnerLink = function({
              breed: {plural},
              id1,
              id2
            }) {
            return ` [${id1} ${id2} ${formatBreedRef(new BreedReference(plural))}]`;
          };
          return `{links${x.references.map(exportInnerLink).join("")}}`;
        } else if (x instanceof ExportedPatchSet) {
          exportInnerPatch = function({pxcor, pycor}) {
            return ` [${pxcor} ${pycor}]`;
          };
          return `{patches${x.references.map(exportInnerPatch).join("")}}`;
        } else if (x instanceof ExportedTurtleSet) {
          exportInnerTurtle = function(ref) {
            return ` ${ref.id}`;
          };
          return `{turtles${x.references.map(exportInnerTurtle).join("")}}`;
        } else if (extensionFormatter.canHandle(x)) {
          return extensionFormatter.formatPlaceholder(x, formatter);
        } else {
          throw exceptions.internal(`I don't know how to CSVify this: ${JSON.stringify(x)}`);
        }
      };
      if (any == null) {
        return "";
      } else if (isOuterValue) {
        return formatPlain(formatter(any));
      } else {
        return formatter(any);
      }
    };
  };

  // (Object[String]) => String
  formatKeys = pipeline(keys, map(formatPlain), joinCommaed);

  formatValues = pipeline(values, map(formatPair), joinCommaed);

  // (Object[Any]) => String

  // ((Any) => String) => (ExportedTurtle) => Object[(Any, (Any) => String)]
  schemafyTurtle = function(formatAnyValue) {
    return function({who, color, heading, xcor, ycor, shape, label, labelColor, breed, isHidden, size, penSize, penMode}) {
      var formatWrapped;
      formatWrapped = pipeline(formatBreedRef, formatPlain);
      return {
        "who": [who, formatNumber],
        "color": [color, formatColor],
        "heading": [heading, formatNumber],
        "xcor": [xcor, formatNumber],
        "ycor": [ycor, formatNumber],
        "shape": [shape, formatString],
        "label": [label, formatAnyValue],
        "label-color": [labelColor, formatColor],
        "breed": [breed, formatWrapped],
        "hidden?": [isHidden, formatBoolean],
        "size": [size, formatNumber],
        "pen-size": [penSize, formatNumber],
        "pen-mode": [penMode, formatString]
      };
    };
  };

  // ((Any) => String) => (ExportedPatch) => Object[(Any, (Any) => String)]
  schemafyPatch = function(formatAnyValue) {
    return function({pxcor, pycor, pcolor, plabel, plabelColor}) {
      return {
        "pxcor": [pxcor, formatNumber],
        "pycor": [pycor, formatNumber],
        "pcolor": [pcolor, formatColor],
        "plabel": [plabel, formatAnyValue],
        "plabel-color": [plabelColor, formatColor]
      };
    };
  };

  // ((Any) => String) => (ExportedLink) => Object[(Any, (Any) => String)]
  schemafyLink = function(formatAnyValue) {
    return function({end1, end2, color, label, labelColor, isHidden, breed, thickness, shape, tieMode}) {
      var formatWrappedBreed, formatWrappedTurtle;
      formatWrappedBreed = pipeline(formatBreedRef, formatPlain);
      formatWrappedTurtle = pipeline(formatTurtleRef, formatPlain);
      return {
        "end1": [end1, formatWrappedTurtle],
        "end2": [end2, formatWrappedTurtle],
        "color": [color, formatColor],
        "label": [label, formatAnyValue],
        "label-color": [labelColor, formatColor],
        "hidden?": [isHidden, formatBoolean],
        "breed": [breed, formatWrappedBreed],
        "thickness": [thickness, formatNumber],
        "shape": [shape, formatString],
        "tie-mode": [tieMode, formatString]
      };
    };
  };

  // ((Any) => String) => (Object[Any]) => Object[(Any, (Any) => String)]
  schemafyAny = function(formatAnyValue) {
    return pipeline(pairs, map(function([k, v]) {
      return [k, [v, formatAnyValue]];
    }), toObject);
  };

  // Based on le_m's solution at https://codereview.stackexchange.com/a/164141/139601
  // (Date) => String
  formatDate = function(date) {
    var day, format, hour, milli, minute, month, second, tzOffset1, tzOffset2, tzSign, year;
    format = function(value, precision) {
      return value.toString().padStart(precision, '0');
    };
    month = format(date.getMonth() + 1, 2);
    day = format(date.getDate(), 2);
    year = format(date.getFullYear(), 4);
    hour = format(date.getHours(), 2);
    minute = format(date.getMinutes(), 2);
    second = format(date.getSeconds(), 2);
    milli = format(date.getMilliseconds(), 3);
    tzSign = format((date.getTimezoneOffset() > 0 ? '-' : '+'), 0);
    tzOffset1 = format(Math.abs(date.getTimezoneOffset() / 60), 2);
    tzOffset2 = format(Math.abs(date.getTimezoneOffset() % 60), 2);
    return `${month}/${day}/${year} ${hour}:${minute}:${second}:${milli} ${tzSign}${tzOffset1}${tzOffset2}`;
  };

  // (ExportedGlobals, (Any) => String) => String
  formatGlobals = function({linkDirectedness, maxPxcor, maxPycor, minPxcor, minPycor, nextWhoNumber, perspective, subject, ticks, codeGlobals}, formatAnyValue) {
    var builtins, formatDirectedness, formatPerspective, formatSubject, globals;
    formatPerspective = function(p) {
      return formatNumber((function() {
        switch (p.toLowerCase()) {
          case 'observe':
            return 0;
          case 'ride':
            return 1;
          case 'follow':
            return 2;
          case 'watch':
            return 3;
          default:
            throw exceptions.internal(`Unknown perspective: ${JSON.stringify(x)}`);
        }
      })());
    };
    formatDirectedness = pipeline((function(s) {
      return s.toUpperCase();
    }), formatString);
    formatSubject = pipeline(formatAgentRef, formatPlain);
    builtins = {
      'min-pxcor': [minPxcor, formatNumber],
      'max-pxcor': [maxPxcor, formatNumber],
      'min-pycor': [minPycor, formatNumber],
      'max-pycor': [maxPycor, formatNumber],
      'perspective': [perspective, formatPerspective],
      'subject': [subject, formatSubject],
      'nextIndex': [nextWhoNumber, formatNumber],
      'directed-links': [linkDirectedness, formatDirectedness],
      'ticks': [ticks, formatNumber]
    };
    globals = Object.assign(builtins, schemafyAny(formatAnyValue)(codeGlobals));
    return `${formatPlain('GLOBALS')}
${formatKeys(globals)}
${formatValues(globals)}`;
  };

  // (Object[Any], (Any) => String) => String
  formatMiniGlobals = function(miniGlobals, formatAnyValue) {
    return `${formatPlain('MODEL SETTINGS')}
${formatKeys(miniGlobals)}
${formatValues(schemafyAny(formatAnyValue)(miniGlobals))}`;
  };

  // (Metadata) => String
  formatMetadata = function({version, filename, date}) {
    return `export-world data (NetLogo Web ${version})
${filename}
${formatPlain(formatDate(date))}`;
  };

  // [T <: ExportedAgent] @ (Array[T], (T) => Object[(Any, (Any) => String)], Array[String], Array[String]) => String
  formatAgents = function(agents, schemafy, builtinsNames, ownsNames, formatAnyValue) {
    var keysRow, valuesRows;
    keysRow = pipeline(unique, map(formatPlain), joinCommaed)(builtinsNames.concat(ownsNames));
    valuesRows = agents.map(function(agent) {
      var base, extras, lookup;
      lookup = function(key) {
        var ref1;
        return ((ref1 = agent.breedsOwns) != null ? ref1 : agent.patchesOwns)[key];
      };
      base = schemafy(agent);
      extras = pipeline(map(tee(id)(lookup)), toObject, schemafyAny(formatAnyValue))(ownsNames);
      return formatValues(Object.assign(base, extras));
    }).join('\n');
    return `${keysRow}${onNextLineIfNotEmpty(valuesRows)}`;
  };

  // (ExportedPlot) => String
  formatPlotData = function({currentPenNameOrNull, isAutoPlotX, isAutoPlotY, isLegendOpen, name, pens, xMax, xMin, yMax, yMin}) {
    var convertedPlot, currentPenStr, isAutoplot;
    currentPenStr = currentPenNameOrNull != null ? currentPenNameOrNull : '';
    isAutoplot = isAutoPlotX && isAutoPlotY;
    convertedPlot = {
      'x min': [xMin, formatNumber],
      'x max': [xMax, formatNumber],
      'y min': [yMin, formatNumber],
      'y max': [yMax, formatNumber],
      'autoplot?': [isAutoplot, formatBoolean],
      'current pen': [currentPenStr, formatString],
      'legend open?': [isLegendOpen, formatBoolean],
      'number of pens': [pens.length, formatNumber]
    };
    return `${formatString(name)}
${formatKeys(convertedPlot)}
${formatValues(convertedPlot)}

${formatPensData(pens)}

${formatPointsData(pens)}`;
  };

  // (Array[ExportedPen]) => String
  formatPensData = function(pens) {
    var convertPen, convertedPens, formatPenMode, pensKeys, pensValues;
    formatPenMode = function(x) {
      return formatNumber((function() {
        switch (x.toLowerCase()) {
          case 'line':
            return 0;
          case 'bar':
            return 1;
          case 'point':
            return 2;
          default:
            throw exceptions.internal(`Unknown pen mode: ${JSON.stringify(x)}`);
        }
      })());
    };
    convertPen = function({color, interval, isPenDown, mode, name, x}) {
      return {
        'pen name': [name, formatString],
        'pen down?': [isPenDown, formatBoolean],
        'mode': [mode, formatPenMode],
        'interval': [interval, formatNumber],
        'color': [color, formatNumber],
        'x': [x, formatNumber]
      };
    };
    convertedPens = pens.map(convertPen);
    pensKeys = formatKeys(convertPen({}));
    pensValues = convertedPens.map(pipeline(values, map(formatPair))).join('\n');
    return `${pensKeys}${onNextLineIfNotEmpty(pensValues)}`;
  };

  // (Array[ExportedPen]) => String
  formatPointsData = function(pens) {
    var baseKeys, convertPoint, formatRow, longest, penNames, penPointsRows, pointKeys, pointValues, transposed;
    convertPoint = function({x, y, color, isPenDown}) {
      return {
        'x': [x, formatNumber],
        'y': [y, formatNumber],
        'color': [color, formatNumber],
        'pen down?': [isPenDown, formatBoolean]
      };
    };
    penNames = pens.map(function(pen) {
      return formatString(pen.name);
    }).join(',,,,');
    baseKeys = keys(convertPoint({})).map(formatPlain);
    pointKeys = flatMap(function() {
      return baseKeys;
    })(rangeUntil(0)(pens.length)).join(',');
    penPointsRows = pens.map(function(pen) {
      return pen.points.map(pipeline(convertPoint, values));
    });
    formatRow = function(row) {
      return row.map(pipeline(maybe, fold(function() {
        return ['', '', '', ''];
      })(map(formatPair)))).join(',');
    };
    longest = pipeline(maxBy(function(a) {
      return a.length;
    }), fold(function() {
      return [];
    })(id));
    transposed = function(arrays) {
      return (longest(arrays)).map(function(_, i) {
        return arrays.map(function(array) {
          return array[i];
        });
      });
    };
    pointValues = transposed(penPointsRows).map(formatRow).join('\n');
    return `${penNames}
${pointKeys}${onNextLineIfNotEmpty(pointValues)}`;
  };

  // (ExportPlotData, Array[ExtensionPorter]) => String
  plotDataToCSV = function({metadata, miniGlobals, plot}, extensionPorters) {
    var extensionFormatter;
    extensionFormatter = ExtensionsHandler.makeFormatter(extensionPorters);
    return `${formatMetadata(metadata)}

${formatMiniGlobals(miniGlobals, formatAny(extensionFormatter))}

${formatPlotData(plot)}`;
  };

  // (ExportedPlot) => String
  rawPlotToCSV = function(plot) {
    return `${formatPlotData(plot)}\n`;
  };

  // (ExportAllPlotsData) => String
  allPlotsDataToCSV = function({metadata, miniGlobals, plots}, extensionPorters) {
    var extensionFormatter;
    extensionFormatter = ExtensionsHandler.makeFormatter(extensionPorters);
    return `${formatMetadata(metadata)}

${formatMiniGlobals(miniGlobals, formatAny(extensionFormatter))}

${plots.map(formatPlotData).join("\n")}`;
  };

  // ((Number, String)) => String
  formatDrawingData = function([patchSize, drawing]) {
    var formatted, patchSizeStr;
    formatted = formatFloat(patchSize);
    patchSizeStr = Number.isInteger(patchSize) ? `${formatted}.0` : formatted;
    return `${formatPlain('DRAWING')}
${formatPlain(patchSizeStr)}${onNextLineIfNotEmpty(drawing === "" ? "" : formatPlain(drawing))}`;
  };

  // (Array[String], Array[String], Array[String], Array[String], Array[String], Array[ExtensionPorter]) => (ExportWorldData) => String
  worldDataToCSV = function(allTurtlesOwnsNames, allLinksOwnsNames, patchBuiltins, turtleBuiltins, linkBuiltins, extensionPorters) {
    return function(worldData) {
      var allPatchesOwnsNames, currentPlotName, currentPlotNameOrNull, drawingDataMaybe, drawingStr, extensionFormatter, extensions, extensionsCSV, formatAnyValue, globals, isOuterValue, links, linksStr, metadata, obnoxiousPlotCSV, output, patches, patchesStr, plotCSV, plotManager, plots, randomState, turtles, turtlesStr;
      extensionFormatter = ExtensionsHandler.makeFormatter(extensionPorters);
      ({metadata, randomState, globals, patches, turtles, links, plotManager, drawingDataMaybe, output, extensions} = worldData);
      // Patches don't have a breed in the breed manager, and they all use the same exact set of vars,
      // so the best place to get the vars is from a patch, itself, and there must always be at least
      // one patch (`patch 0 0`), so we take the first patch and its varnames. --JAB (12/16/17)
      allPatchesOwnsNames = Object.keys(patches[0].patchesOwns);
      formatAnyValue = formatAny(extensionFormatter);
      patchesStr = formatAgents(patches, schemafyPatch(formatAnyValue), patchBuiltins, allPatchesOwnsNames, formatAnyValue);
      turtlesStr = formatAgents(turtles, schemafyTurtle(formatAnyValue), turtleBuiltins, allTurtlesOwnsNames, formatAnyValue);
      linksStr = formatAgents(links, schemafyLink(formatAnyValue), linkBuiltins, allLinksOwnsNames, formatAnyValue);
      ({currentPlotNameOrNull, plots} = plotManager);
      currentPlotName = currentPlotNameOrNull != null ? currentPlotNameOrNull : '';
      plotCSV = plots.map(formatPlotData).join('\n\n');
      obnoxiousPlotCSV = plotCSV.length > 0 ? plotCSV + "\n" : plotCSV;
      drawingStr = pipeline(mapMaybe(formatDrawingData), fold(function() {
        return "";
      })(id))(drawingDataMaybe);
      extensionsCSV = extensionFormatter.format(extensions, formatAny(extensionFormatter, isOuterValue = false));
      return `${formatMetadata(metadata)}

${formatPlain('RANDOM STATE')}
${formatPlain(randomState)}

${formatGlobals(globals, formatAnyValue)}

${formatPlain('TURTLES')}
${turtlesStr}

${formatPlain('PATCHES')}
${patchesStr}

${formatPlain('LINKS')}
${linksStr}
${drawingStr}

${formatPlain('OUTPUT')}${onNextLineIfNotEmpty(output === "" ? "" : formatString(output))}
${formatPlain('PLOTS')}
${formatPlain(currentPlotName)}${onNextLineIfNotEmpty(obnoxiousPlotCSV)}
${formatPlain('EXTENSIONS')}
${onNextLineIfNotEmpty(extensionsCSV)}\n\n`;
    };
  };

  module.exports = {allPlotsDataToCSV, plotDataToCSV, rawPlotToCSV, worldDataToCSV};

}).call(this);

},{"../engine/core/world/extensionshandler":"engine/core/world/extensionshandler","./exportstructures":"serialize/exportstructures","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/maybe":"brazier/maybe","brazierjs/number":"brazier/number","brazierjs/object":"brazier/object","util/exception":"util/exception","util/formatfloat":"util/formatfloat","util/jstype":"util/jstype"}],"serialize/exportstructures":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise

  // Did I *need* to create two dozen different classes for all of this stuff?  No, of course not.
  // *However*, I wanted to document/codify somewhere what the types of these different structures
  // are, and this, to me, seemed to be the most effective way of doing that.  So, please, pardon
  // the noise.  I'm merely trying to help. --JAB (12/10/17)
  var AgentReference, ExportedAgent, ExportedAgentSet, ExportedColor, ExportedExtension;

  module.exports.BreedNamePair = class {
    // (String, String)
    constructor(singular, plural) {
      this.singular = singular;
      this.plural = plural;
    }

  };

  ExportedColor = class ExportedColor {};

  module.exports.ExportedColor = ExportedColor;

  module.exports.ExportedRGB = class extends ExportedColor {
    // (Number, Number, Number)
    constructor(r, g, b) {
      super();
      this.r = r;
      this.g = g;
      this.b = b;
    }

  };

  module.exports.ExportedRGBA = class extends ExportedColor {
    // (Number, Number, Number, Number)
    constructor(r, g, b, a = 255) {
      super();
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
    }

  };

  module.exports.ExportedColorNum = class extends ExportedColor {
    // (Number)
    constructor(value) {
      super();
      this.value = value;
    }

  };

  module.exports.ExportedGlobals = class {
    // ( String, Number, Number, Number, Number, Number
    // , String, AgentReference, Number, Object[Any])
    constructor(linkDirectedness, maxPxcor, maxPycor, minPxcor, minPycor, nextWhoNumber, perspective, subject, ticks, codeGlobals) {
      this.linkDirectedness = linkDirectedness;
      this.maxPxcor = maxPxcor;
      this.maxPycor = maxPycor;
      this.minPxcor = minPxcor;
      this.minPycor = minPycor;
      this.nextWhoNumber = nextWhoNumber;
      this.perspective = perspective;
      this.subject = subject;
      this.ticks = ticks;
      this.codeGlobals = codeGlobals;
    }

  };

  module.exports.ExportedCommandLambda = class {
    // (String)
    constructor(source) {
      this.source = source;
    }

  };

  module.exports.ExportedReporterLambda = class {
    // (String)
    constructor(source) {
      this.source = source;
    }

  };

  module.exports.ExportedPoint = class {
    // (Number, Number, Boolean, Number)
    constructor(x, y, isPenDown, color) {
      this.x = x;
      this.y = y;
      this.isPenDown = isPenDown;
      this.color = color;
    }

  };

  module.exports.ExportedPen = class {
    // (Number, Number, Boolean, String, String, Array[ExportedPoint], Number)
    constructor(color, interval, isPenDown, mode, name, points, x) {
      this.color = color;
      this.interval = interval;
      this.isPenDown = isPenDown;
      this.mode = mode;
      this.name = name;
      this.points = points;
      this.x = x;
    }

  };

  module.exports.ExportedPlot = class {
    // ( String, Boolean, Boolean, Boolean, String, Array[ExportedPen]
    // , Number, Number, Number, Number)
    constructor(currentPenNameOrNull, isAutoPlotX, isAutoPlotY, isLegendOpen, name, pens, xMax, xMin, yMax, yMin) {
      this.currentPenNameOrNull = currentPenNameOrNull;
      this.isAutoPlotX = isAutoPlotX;
      this.isAutoPlotY = isAutoPlotY;
      this.isLegendOpen = isLegendOpen;
      this.name = name;
      this.pens = pens;
      this.xMax = xMax;
      this.xMin = xMin;
      this.yMax = yMax;
      this.yMin = yMin;
    }

  };

  module.exports.ExportedPlotManager = class {
    // (String, Array[ExportedPlot])
    constructor(currentPlotNameOrNull, plots) {
      this.currentPlotNameOrNull = currentPlotNameOrNull;
      this.plots = plots;
    }

  };

  module.exports.BreedReference = class {
    // (String)
    constructor(breedName) {
      this.breedName = breedName;
    }

  };

  AgentReference = class AgentReference {
    // (String)
    constructor(referenceType) {
      this.referenceType = referenceType;
    }

  };

  module.exports.AgentReference = AgentReference;

  module.exports.LinkReference = class extends AgentReference {
    // (BreedNamePair, Number, Number)
    constructor(breed, id1, id2) {
      super("link");
      this.breed = breed;
      this.id1 = id1;
      this.id2 = id2;
    }

  };

  module.exports.PatchReference = class extends AgentReference {
    // (Number, Number)
    constructor(pxcor, pycor) {
      super("patch");
      this.pxcor = pxcor;
      this.pycor = pycor;
    }

  };

  module.exports.TurtleReference = class extends AgentReference {
    // (BreedNamePair, Number)
    constructor(breed, id) {
      super("turtle");
      this.breed = breed;
      this.id = id;
    }

  };

  module.exports.NobodyReference = new AgentReference("nobody");

  ExportedAgent = class ExportedAgent {
    // (String)
    constructor(agentType) {
      this.agentType = agentType;
    }

  };

  module.exports.ExportedAgent = ExportedAgent;

  module.exports.ExportedLink = class extends ExportedAgent {
    // ( TurtleReference, TurtleReference, ExportedColor, String, ExportedColor, Boolean
    // , BreedReference, Number, String, String, Object[Any])
    constructor(end1, end2, color, label, labelColor, isHidden, breed, thickness, shape, tieMode, breedsOwns) {
      super("link");
      this.end1 = end1;
      this.end2 = end2;
      this.color = color;
      this.label = label;
      this.labelColor = labelColor;
      this.isHidden = isHidden;
      this.breed = breed;
      this.thickness = thickness;
      this.shape = shape;
      this.tieMode = tieMode;
      this.breedsOwns = breedsOwns;
    }

  };

  module.exports.ExportedPatch = class extends ExportedAgent {
    // (Number, Number, ExportedColor, String, ExportedColor, Object[Any])
    constructor(pxcor, pycor, pcolor, plabel, plabelColor, patchesOwns) {
      super("patch");
      this.pxcor = pxcor;
      this.pycor = pycor;
      this.pcolor = pcolor;
      this.plabel = plabel;
      this.plabelColor = plabelColor;
      this.patchesOwns = patchesOwns;
    }

  };

  module.exports.ExportedTurtle = class extends ExportedAgent {
    // ( Number, ExportedColor, Number, Number, Number, String, String, ExportedColor, BreedReference
    // , Boolean, Number, Number, String, Object[Any])
    constructor(who, color, heading, xcor, ycor, shape, label, labelColor, breed, isHidden, size, penSize, penMode, breedsOwns) {
      super("turtle");
      this.who = who;
      this.color = color;
      this.heading = heading;
      this.xcor = xcor;
      this.ycor = ycor;
      this.shape = shape;
      this.label = label;
      this.labelColor = labelColor;
      this.breed = breed;
      this.isHidden = isHidden;
      this.size = size;
      this.penSize = penSize;
      this.penMode = penMode;
      this.breedsOwns = breedsOwns;
    }

  };

  ExportedAgentSet = class ExportedAgentSet {
    // (String)
    constructor(agentSetType) {
      this.agentSetType = agentSetType;
    }

  };

  module.exports.ExportedAgentSet = ExportedAgentSet;

  module.exports.ExportedLinkSet = class extends ExportedAgentSet {
    // (Array[LinkReference])
    constructor(references) {
      super("linkset");
      this.references = references;
    }

  };

  module.exports.ExportedPatchSet = class extends ExportedAgentSet {
    // (Array[PatchReference])
    constructor(references) {
      super("patchset");
      this.references = references;
    }

  };

  module.exports.ExportedTurtleSet = class extends ExportedAgentSet {
    // (Array[TurtleReference])
    constructor(references) {
      super("turtleset");
      this.references = references;
    }

  };

  ExportedExtension = class ExportedExtension {
    // (String)
    constructor(extensionName1) {
      this.extensionName = extensionName1;
    }

  };

  module.exports.ExportedExtension = ExportedExtension;

  module.exports.ExportedSimpleExtension = class extends ExportedExtension {
    // (String, Array[ExportedExtensionObject])
    constructor(extensionName, objects) {
      super(extensionName);
      this.objects = objects;
    }

  };

  module.exports.ExportedExtensionObject = class {
    // (String, String, Any)
    constructor(extensionName1, subType, data) {
      this.extensionName = extensionName1;
      this.subType = subType;
      this.data = data;
    }

  };

  module.exports.Metadata = class {
    // (String, String, Date)
    constructor(version, filename, date) {
      this.version = version;
      this.filename = filename;
      this.date = date;
    }

  };

  module.exports.ExportWorldData = class {
    // ( Metadata, String, ExportedGlobals, Array[ExportedPatch], Array[ExportedTurtle]
    // , Array[ExportedLink], Maybe[(Number, String)], String, ExportedPlotManager, Array[ExportedExtension])
    constructor(metadata, randomState, globals, patches, turtles, links, drawingDataMaybe, output, plotManager, extensions) {
      this.metadata = metadata;
      this.randomState = randomState;
      this.globals = globals;
      this.patches = patches;
      this.turtles = turtles;
      this.links = links;
      this.drawingDataMaybe = drawingDataMaybe;
      this.output = output;
      this.plotManager = plotManager;
      this.extensions = extensions;
    }

  };

  module.exports.ExportPlotData = class {
    // (Metadata, Object[Any], ExportedPlot)
    constructor(metadata, miniGlobals, plot) {
      this.metadata = metadata;
      this.miniGlobals = miniGlobals;
      this.plot = plot;
    }

  };

  module.exports.ExportAllPlotsData = class {
    // (Metadata, Object[Any], Array[Plot])
    constructor(metadata, miniGlobals, plots) {
      this.metadata = metadata;
      this.miniGlobals = miniGlobals;
      this.plots = plots;
    }

  };

}).call(this);

},{}],"serialize/importcsv":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ExportWorldData, ExportedColorNum, ExportedExtension, ExportedGlobals, ExportedLink, ExportedPatch, ExportedPen, ExportedPlot, ExportedPlotManager, ExportedPoint, ExportedRGB, ExportedRGBA, ExportedTurtle, ExtensionsHandler, JSType, Metadata, arrayParse, buckets, csvNameToSaneName, drawingParse, exceptions, extensionParse, extractGlobals, fold, foldl, globalParse, id, identity, maybe, nameToSchema, parse, parseAgentRefMaybe, parseAndExtract, parseAny, parseBool, parseBreed, parseColor, parseDate, parsePenMode, parsePerspective, parseString, parseStringMaybe, parseTurtleRefMaybe, parseVersion, plotParse, singletonParse, toExportedColor, toExportedGlobals, toExportedLink, toExportedPatch, toExportedPen, toExportedPlot, toExportedPlotManager, toExportedPoint, toExportedTurtle,
    indexOf = [].indexOf;

  parse = require('csv-parse/lib/sync');

  JSType = require('util/jstype');

  ({parseAgentRefMaybe, parseAny, parseBool, parseBreed, parseString, parseTurtleRefMaybe} = require('./readexportedvalue'));

  ExtensionsHandler = require('../engine/core/world/extensionshandler');

  ({ExportedColorNum, ExportedExtension, ExportedGlobals, ExportedLink, ExportedPatch, ExportedPen, ExportedPlot, ExportedPlotManager, ExportedPoint, ExportedRGB, ExportedRGBA, ExportedTurtle, ExportWorldData, Metadata} = require('./exportstructures'));

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({foldl} = require('brazierjs/array'));

  ({id} = require('brazierjs/function'));

  ({fold, maybe} = require('brazierjs/maybe'));

  // type ImpObj    = Object[Any]
  // type Row       = Array[String]
  // type Parser[T] = (Array[Row], Schema) => T
  // type Schema    = Object[(String) => Any]

  // (String) => String
  csvNameToSaneName = function(csvName) {
    var camelCased, firstLetter, lowered, qMatch, remainder, replaceAll;
    if (csvName !== "nextIndex") {
      replaceAll = function(str, regex, f) {
        var fullMatch, group, index, match, postfix, prefix;
        match = str.match(regex);
        if (match != null) {
          ({
            0: fullMatch,
            1: group,
            index
          } = match);
          prefix = str.slice(0, index);
          postfix = str.slice(index + fullMatch.length);
          return replaceAll(`${prefix}${f(group)}${postfix}`, regex, f);
        } else {
          return str;
        }
      };
      lowered = csvName.toLowerCase();
      camelCased = replaceAll(lowered, /[ \-]+([a-z0-9])/, function(str) {
        return str.toUpperCase();
      });
      qMatch = camelCased.match(/^(\w)(.*)\?$/);
      if (qMatch != null) {
        ({
          1: firstLetter,
          2: remainder
        } = qMatch);
        return `is${firstLetter.toUpperCase()}${remainder}`;
      } else {
        return camelCased;
      }
    } else {
      return csvName;
    }
  };

  // (String|(Number, Number, Number)|(Number, Number, Number, Number)) => ExportedColor
  toExportedColor = function(color) {
    var a, b, g, r;
    if (JSType(color).isNumber()) {
      return new ExportedColorNum(color);
    } else if (JSType(color).isArray()) {
      [r, g, b, a] = color;
      if (a != null) {
        return new ExportedRGBA(r, g, b, a);
      } else {
        return new ExportedRGB(r, g, b);
      }
    } else {
      throw exceptions.internal(`Unrecognized CSVified color: ${JSON.stringify(color)}`);
    }
  };

  // (Object[Any]) => ExportedGlobals
  toExportedGlobals = function({directedLinks, maxPxcor, maxPycor, minPxcor, minPycor, nextIndex, perspective, subject, ticks}, codeGlobals) {
    return new ExportedGlobals(directedLinks, maxPxcor, maxPycor, minPxcor, minPycor, nextIndex, perspective, subject, ticks, codeGlobals);
  };

  // (Object[Any]) => ExportedLink
  toExportedLink = function({breed, color, end1, end2, isHidden, labelColor, label, shape, thickness, tieMode, extraVars}) {
    return new ExportedLink(end1, end2, toExportedColor(color), label, toExportedColor(labelColor), isHidden, breed, thickness, shape, tieMode, extraVars);
  };

  // (Object[Any]) => ExportedPatch
  toExportedPatch = function({pcolor, plabelColor, plabel, pxcor, pycor, extraVars}) {
    return new ExportedPatch(pxcor, pycor, toExportedColor(pcolor), plabel, toExportedColor(plabelColor), extraVars);
  };

  // (Object[Any]) => ExportedTurtle
  toExportedTurtle = function({breed, color, heading, isHidden, labelColor, label, penMode, penSize, shape, size, who, xcor, ycor, extraVars}) {
    return new ExportedTurtle(who, toExportedColor(color), heading, xcor, ycor, shape, label, toExportedColor(labelColor), breed, isHidden, size, penSize, penMode, extraVars);
  };

  // (Object[Any]) => ExportedPoint
  toExportedPoint = function({x, y, isPenDown, color}) {
    return new ExportedPoint(x, y, isPenDown, color);
  };

  // (Object[Any]) => ExportedPen
  toExportedPen = function({color, interval, isPenDown, mode, penName, points, x}) {
    return new ExportedPen(color, interval, isPenDown, mode, penName, points.map(toExportedPoint), x);
  };

  // (Object[Any]) => ExportedPlot
  toExportedPlot = function({currentPen, isAutoplot, isLegendOpen, name, pens, xMax, xMin, yMax, yMin}) {
    return new ExportedPlot(fold(function() {
      return null;
    })(id)(currentPen), isAutoplot, isAutoplot, isLegendOpen, name, pens.map(toExportedPen), xMax, xMin, yMax, yMin);
  };

  // (Object[Any]) => ExportedPlotManager
  toExportedPlotManager = function({
      default: defaultOrNull,
      plots
    }) {
    return new ExportedPlotManager(defaultOrNull, plots.map(toExportedPlot));
  };

  // START SCHEMA STUFF

  // Only used to mark things that we should delay converting until later --JAB (4/6/17)
  // [T] @ (T) => T
  identity = function(x) {
    return x;
  };

  // (String) => String|(Number, Number, Number)|(Number, Number, Number, Number)
  parseColor = function(x) {
    var unpossible;
    unpossible = function() {
      throw exceptions.internal("Why is this even getting called?  We shouldn't be parsing breed names where colors are expected.");
    };
    return parseAny(unpossible, unpossible, {
      matchesPlaceholder: function() {
        return false;
      }
    })(x);
  };

  // (String) => Number
  parseDate = function(x) {
    var _, millis, postfix, prefix;
    [_, prefix, millis, postfix] = x.match(/(.*):(\d+) (.*)/);
    return new Date(Date.parse(`${prefix} ${postfix}`) + parseInt(millis));
  };

  // (String) => Maybe[String]
  parseStringMaybe = function(x) {
    var value;
    value = parseString(x);
    return maybe(value === "" ? null : value);
  };

  parsePenMode = function(x) {
    switch (parseInt(x)) {
      case 0:
        return 'line';
      case 1:
        return 'bar';
      case 2:
        return 'point';
      default:
        throw exceptions.internal(`Unknown pen mode: ${x}`);
    }
  };

  // (String) => String
  parsePerspective = function(x) {
    switch (parseInt(x)) {
      case 0:
        return 'observe';
      case 1:
        return 'ride';
      case 2:
        return 'follow';
      case 3:
        return 'watch';
      default:
        throw exceptions.internal(`Unknown perspective number: ${x}`);
    }
  };

  // (String) => String
  parseVersion = function(x) {
    return x.match(/export-world data \([^\)]+\)/)[1];
  };

  // [T] @ (String) => ((String) => Maybe[T]) => ((String) => T)
  parseAndExtract = function(typeOfEntry) {
    return function(f) {
      return function(x) {
        return fold(function(x) {
          throw exceptions.internal(`Unable to parse ${typeOfEntry}: ${JSON.stringify(x)}`);
        })(id)(f(x));
      };
    };
  };

  // ((String) => String, (String) => String, ExtensionsReader) => Object[Schema]
  nameToSchema = function(singularToPlural, pluralToSingular, extensionReader) {
    var parseAgentLocal, parseAnyLocal, parseTurtleLocal;
    parseAnyLocal = parseAny(singularToPlural, pluralToSingular, extensionReader);
    parseAgentLocal = parseAndExtract("agent ref")(parseAgentRefMaybe(singularToPlural));
    parseTurtleLocal = parseAndExtract("turtle ref")(parseTurtleRefMaybe(singularToPlural));
    return {
      plots: {
        color: parseFloat,
        currentPen: parseStringMaybe,
        interval: parseFloat,
        isAutoplot: parseBool,
        isLegendOpen: parseBool,
        isPenDown: parseBool,
        mode: parsePenMode,
        penName: parseString,
        xMax: parseFloat,
        xMin: parseFloat,
        x: parseFloat,
        yMax: parseFloat,
        yMin: parseFloat,
        y: parseFloat
      },
      randomState: {
        value: identity
      },
      globals: {
        directedLinks: parseString,
        minPxcor: parseInt,
        maxPxcor: parseInt,
        minPycor: parseInt,
        maxPycor: parseInt,
        nextIndex: parseInt,
        perspective: parsePerspective,
        subject: parseAgentLocal,
        ticks: parseFloat
      },
      turtles: {
        breed: parseBreed,
        color: parseColor,
        heading: parseFloat,
        isHidden: parseBool,
        labelColor: parseColor,
        label: parseAnyLocal,
        penMode: parseString,
        penSize: parseFloat,
        shape: parseString,
        size: parseFloat,
        who: parseInt,
        xcor: parseFloat,
        ycor: parseFloat
      },
      patches: {
        pcolor: parseColor,
        plabelColor: parseColor,
        plabel: parseAnyLocal,
        pxcor: parseInt,
        pycor: parseInt
      },
      links: {
        breed: parseBreed,
        color: parseColor,
        end1: parseTurtleLocal,
        end2: parseTurtleLocal,
        isHidden: parseBool,
        labelColor: parseColor,
        label: parseAnyLocal,
        shape: parseString,
        thickness: parseFloat,
        tieMode: parseString
      },
      output: {
        value: parseString
      },
      extensions: {}
    };
  };

  // END SCHEMA STUFF

  // START PARSER STUFF

  // Parser[String]
  singletonParse = function(x, schema) {
    var ref;
    if (((ref = x[0]) != null ? ref[0] : void 0) != null) {
      return schema.value(x[0][0]);
    } else {
      return '';
    }
  };

  // ((String) => String, (String) => String, ExtensionsReader) => Parser[Array[ImpObj]]
  arrayParse = function(singularToPlural, pluralToSingular, extensionReader) {
    return function([keys, ...rows], schema) {
      var f;
      f = function(acc, row) {
        var index, j, len, obj, rawKey, saneKey, value;
        obj = {
          extraVars: {}
        };
        for (index = j = 0, len = keys.length; j < len; index = ++j) {
          rawKey = keys[index];
          saneKey = csvNameToSaneName(rawKey);
          value = row[index];
          if (schema[saneKey] != null) {
            obj[saneKey] = schema[saneKey](value);
          } else if (value !== "") { // DO NOT USE `saneKey`!  Do not touch user global names! --JAB (8/2/17)
            obj.extraVars[rawKey] = parseAny(singularToPlural, pluralToSingular, extensionReader)(value);
          }
        }
        return acc.concat([obj]);
      };
      return foldl(f)([])(rows);
    };
  };

  // ((String) => String, (String) => String, ExtensionsReader) => Parser[ImpObj]
  globalParse = function(singularToPlural, pluralToSingular, extensionReader) {
    return function(csvBucket, schema) {
      return arrayParse(singularToPlural, pluralToSingular, extensionReader)(csvBucket, schema)[0];
    };
  };

  // Parser[ImpObj]
  plotParse = function(csvBucket, schema) {
    var csvIndex, j, length, output, parseEntity, penCount, penIndex, plot, point, pointsIndex, ref, ref1, ref2;
    parseEntity = function(acc, rowIndex, upperBound, valueRowOffset, valueColumnOffset) {
      var columnIndex, columnName, j, ref, ref1, value;
      for (columnIndex = j = 0, ref = upperBound; (0 <= ref ? j < ref : j > ref); columnIndex = 0 <= ref ? ++j : --j) {
        columnName = csvNameToSaneName(csvBucket[rowIndex][columnIndex]);
        value = csvBucket[rowIndex + valueRowOffset][columnIndex + valueColumnOffset];
        acc[columnName] = ((ref1 = schema[columnName]) != null ? ref1 : parseInt)(value);
      }
      return acc;
    };
    output = {
      default: (ref = (ref1 = csvBucket[0]) != null ? ref1[0] : void 0) != null ? ref : null,
      plots: []
    };
    // Iterate over every plot
    csvIndex = 1;
    while (csvIndex < csvBucket.length) {
      plot = parseEntity({
        name: parseString(csvBucket[csvIndex++][0])
      }, csvIndex, csvBucket[csvIndex].length, 1, 0);
      penCount = plot.numberOfPens;
      delete plot.penCount;
      csvIndex += 2;
      plot.pens = (function() {
        var results = [];
        for (var j = 0; 0 <= penCount ? j < penCount : j > penCount; 0 <= penCount ? j++ : j--){ results.push(j); }
        return results;
      }).apply(this).map(function(i) {
        return parseEntity({
          points: []
        }, csvIndex, csvBucket[csvIndex].length, 1 + i, 0);
      });
      csvIndex += 2 + penCount;
      // For each pen, parsing of the list of points associated with the pen
      pointsIndex = 1;
      while (csvIndex + pointsIndex < csvBucket.length && csvBucket[csvIndex + pointsIndex].length !== 1) {
        length = csvBucket[csvIndex].length / penCount;
        for (penIndex = j = 0, ref2 = penCount; (0 <= ref2 ? j < ref2 : j > ref2); penIndex = 0 <= ref2 ? ++j : --j) {
          if (csvBucket[csvIndex + pointsIndex][penIndex * length] !== '') {
            point = parseEntity({}, csvIndex, length, pointsIndex, penIndex * length);
            plot.pens[penIndex].points.push(point);
          }
        }
        pointsIndex++;
      }
      csvIndex += pointsIndex;
      output.plots.push(plot);
    }
    return output;
  };

  // (Array[String]) => Parser[Map[String, Array[String]]]
  extensionParse = function(extensionNames) {
    return function(csvBucket, schema) {
      var current, first, index, j, line, output, ref;
      if (csvBucket.length === 0) {
        return {};
      }
      [first] = csvBucket[0];
      if (!extensionNames.includes(first.toUpperCase())) {
        throw exceptions.internal("Extension section must start with an extension name.");
      }
      output = {};
      current = [];
      output[first] = current;
      for (index = j = 1, ref = csvBucket.length; (1 <= ref ? j < ref : j > ref); index = 1 <= ref ? ++j : --j) {
        [line] = csvBucket[index];
        if (extensionNames.includes(line.toUpperCase())) {
          current = [];
          output[line] = current;
        } else {
          current.push(line);
        }
      }
      return output;
    };
  };

  // Parser[(Number, String)]
  drawingParse = function(csvBucket, schema) {
    var base64Str, patchSizeStr;
    if (csvBucket.length === 0) {
      return "";
    } else if (csvBucket.length === 2) {
      [[patchSizeStr], [base64Str]] = csvBucket;
      return [parseFloat(patchSizeStr), base64Str];
    } else {
      throw exceptions.internal("NetLogo Web cannot parse `export-world` drawings from before NetLogo 6.1.");
    }
  };

  // ((String) => String, (String) => String, ExtensionsReader) => Object[Parser[Any]]
  buckets = function(singularToPlural, pluralToSingular, extensionReader) {
    return {
      extensions: extensionParse(extensionReader.extensionNames),
      drawing: drawingParse,
      globals: globalParse(singularToPlural, pluralToSingular, extensionReader),
      links: arrayParse(singularToPlural, pluralToSingular, extensionReader),
      output: singletonParse,
      patches: arrayParse(singularToPlural, pluralToSingular, extensionReader),
      plots: plotParse,
      randomState: singletonParse,
      turtles: arrayParse(singularToPlural, pluralToSingular, extensionReader)
    };
  };

  // END PARSER STUFF

  // (ImpObj, Array[String]) => (ImpObj, Object[String])
  extractGlobals = function(globals, knownNames) {
    var builtIn, key, user, value;
    builtIn = {};
    user = {};
    for (key in globals) {
      value = globals[key];
      if (indexOf.call(knownNames, key) >= 0) {
        builtIn[key] = value;
      } else {
        user[key] = value;
      }
    }
    return [builtIn, user];
  };

  // ((String) => String, (String) => String, Array[ExtensionPorter]) => (String) => WorldState
  module.exports = function(singularToPlural, pluralToSingular, extensionPorters) {
    return function(csvText) {
      var _, bucketParser, bucketToRows, buckies, builtInGlobals, clusterRows, codeGlobals, dateRow, drawing, extensionReader, extensions, filenameRow, getSchema, globals, links, name, outExtensions, outGlobals, outLinks, outMetadata, outPatches, outPlotManager, outTurtles, output, parseAnyLocal, parsedCSV, patches, plots, randomState, titleRow, turtles, world;
      extensionReader = ExtensionsHandler.makeReader(extensionPorters);
      buckies = buckets(singularToPlural, pluralToSingular, extensionReader);
      getSchema = nameToSchema(singularToPlural, pluralToSingular, extensionReader);
      parsedCSV = parse(csvText, {
        comment: '#',
        max_record_size: 1e12,
        skip_empty_lines: true,
        relax_column_count: true
      });
      clusterRows = function([acc, latestRows], row) {
        var ex, rows, saneName;
        saneName = (function() {
          try {
            if (row.length === 1) {
              return csvNameToSaneName(row[0]);
            } else {
              return void 0;
            }
          } catch (error) {
            ex = error;
            return void 0;
          }
        })();
        if ((saneName != null) && saneName in buckies) {
          rows = [];
          acc[saneName] = rows;
          return [acc, rows];
        } else if (latestRows != null) {
          latestRows.push(row);
          return [acc, latestRows];
        } else {
          return [acc, latestRows];
        }
      };
      [bucketToRows, _] = foldl(clusterRows)([{}, void 0])(parsedCSV);
      world = {};
      for (name in buckies) {
        bucketParser = buckies[name];
        if (bucketToRows[name] != null) {
          world[name] = bucketParser(bucketToRows[name], getSchema[name]);
        }
      }
      titleRow = parsedCSV[0][0];
      filenameRow = parsedCSV[1][0];
      dateRow = parsedCSV[2][0];
      ({globals, randomState, turtles, patches, links, drawing, output, plots, extensions} = world);
      codeGlobals = globals.extraVars;
      delete globals.extraVars;
      builtInGlobals = globals;
      outMetadata = new Metadata(parseVersion(titleRow), filenameRow, parseDate(dateRow));
      outGlobals = toExportedGlobals(builtInGlobals, codeGlobals);
      outPatches = patches.map(toExportedPatch);
      outTurtles = turtles.map(toExportedTurtle);
      outLinks = links.map(toExportedLink);
      outPlotManager = toExportedPlotManager(plots);
      parseAnyLocal = parseAny(singularToPlural, pluralToSingular, extensionReader);
      outExtensions = extensionReader.readExtensions(extensions, parseAnyLocal);
      return new ExportWorldData(outMetadata, randomState, outGlobals, outPatches, outTurtles, outLinks, maybe(drawing), output, outPlotManager, outExtensions);
    };
  };

}).call(this);

},{"../engine/core/world/extensionshandler":"engine/core/world/extensionshandler","./exportstructures":"serialize/exportstructures","./readexportedvalue":"serialize/readexportedvalue","brazierjs/array":"brazier/array","brazierjs/function":"brazier/function","brazierjs/maybe":"brazier/maybe","csv-parse/lib/sync":11,"util/exception":"util/exception","util/jstype":"util/jstype"}],"serialize/readexportedvalue":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var BreedNamePair, BreedReference, ExportedCommandLambda, ExportedLinkSet, ExportedPatchSet, ExportedReporterLambda, ExportedTurtleSet, LinkReference, NobodyReference, None, PatchReference, TurtleReference, exceptions, firstIndexOfUnescapedQuote, fold, isSomething, mapMaybe, match, maybe, parseBreedMaybe, parseGeneric, parseInnerLink, parseLinkRefMaybe, parseList, parsePatchRefMaybe, parseTurtleRefMaybe, readAgenty, tryParsers;

  ({BreedNamePair, BreedReference, ExportedCommandLambda, ExportedLinkSet, ExportedPatchSet, ExportedReporterLambda, ExportedTurtleSet, LinkReference, NobodyReference, PatchReference, TurtleReference} = require('./exportstructures'));

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  ({
    fold,
    isSomething,
    map: mapMaybe,
    maybe,
    None
  } = require('brazier/maybe'));

  // (String) => Number
  firstIndexOfUnescapedQuote = function(str) {
    var index;
    index = str.indexOf('"');
    if (index > 0) {
      if (str[index - 1] !== "\\") {
        return index;
      } else {
        return 1 + index + firstIndexOfUnescapedQuote(str.slice(index + 1));
      }
    } else {
      return index;
    }
  };

  // (String, (String) => Any, (String) => Any, ExtensionsReader) => Array[Any]
  parseList = function() {
    var parseListHelper;
    parseListHelper = function(list, readValue, readAgentLike, extensionReader) {
      var parseInner;
      parseInner = function(contents, acc = [], accIndex = 0) {
        var endIndex, index, item, placeholder, placeholderMatch, recurse, rightIndex, spaceIndex, strFrom, strIndex, strUntil, tempered;
        strIndex = function(char) {
          return contents.indexOf(char);
        };
        strFrom = function(index) {
          return contents.slice(index);
        };
        strUntil = function(index) {
          return contents.slice(0, index);
        };
        tempered = function(index) {
          return index + (contents[index + 1] === ']' ? 1 : 2);
        };
        recurse = function(nextIndex, item) {
          return parseInner(strFrom(nextIndex), acc.concat([item]), accIndex + nextIndex);
        };
        if (!(contents.startsWith('(anonymous command:') || contents.startsWith('(anonymous reporter:'))) {
          switch (contents[0]) {
            case ']': // End of list
              return [acc, accIndex + 1];
            case '[': // Start of list
              [item, endIndex] = parseListHelper(contents, readValue, readAgentLike, extensionReader);
              return recurse(tempered(endIndex), item);
            case '{': // Start of agent/agentset or extension placeholder
              if (contents[1] === '{') {
                index = strIndex('}}') + 1;
                placeholder = strUntil(index + 1);
                placeholderMatch = extensionReader.matchesPlaceholder(placeholder);
                if (placeholderMatch == null) {
                  throw exceptions.internal("This looks like an extension object, but it's not?");
                }
                return recurse(tempered(index), extensionReader.readPlaceholder(placeholderMatch));
              } else {
                index = strIndex('}');
                return recurse(tempered(index), readAgentLike(strUntil(index + 1)));
              }
              break;
            case '"': // Start of string
              index = firstIndexOfUnescapedQuote(strFrom(1)) + 1;
              return recurse(tempered(index), readValue(strUntil(index + 1)));
            default:
              rightIndex = strIndex(']'); // End of next item, if there's no item after it
              spaceIndex = strIndex(' '); // Separator between next item and the one after
              if (rightIndex < spaceIndex || spaceIndex < 0) {
                return recurse(rightIndex, readValue(strUntil(rightIndex)));
              } else {
                return recurse(spaceIndex + 1, readValue(strUntil(spaceIndex)));
              }
          }
        } else {
          throw exceptions.internal("Importing a list of anonymous procedures?  Not happening!");
        }
      };
      if (list[0] === '[') {
        return parseInner(list.slice(1));
      } else {
        throw exceptions.internal(`Not a valid list: ${list}`);
      }
    };
    return parseListHelper(...arguments)[0];
  };

  // (Regex, String, String) => RegexMatch
  match = function(regex, str) {
    var result;
    result = str.match(regex);
    if (result != null) {
      return result;
    } else {
      throw exceptions.internal(`Could not match regex ${regex} with this string: ${str}`);
    }
  };

  // (String) => Boolean
  module.exports.parseBool = function(x) {
    return x.toLowerCase() === "true";
  };

  // (String) => BreedReference
  parseBreedMaybe = function(x) {
    switch (x) {
      case "{all-turtles}":
        return maybe(new BreedReference("TURTLES"));
      case "{all-patches}":
        return maybe(new BreedReference("PATCHES"));
      case "{all-links}":
        return maybe(new BreedReference("LINKS"));
      default:
        return parseGeneric(/{breed (.*)}/)(function([_, breedName]) {
          return new BreedReference(breedName.toLowerCase());
        })(x);
    }
  };

  // (String) => BreedReference
  module.exports.parseBreed = function(x) {
    return fold(function() {
      throw exceptions.internal(`Cannot parse as breed: ${x}`);
    })(function(x) {
      return x;
    })(parseBreedMaybe(x));
  };

  // (String) => String
  module.exports.parseString = function(str) {
    return match(/^"(.*)"$/, str)[1].replace(new RegExp('\\\\"', 'g'), '"');
  };

  // [T] @ (RegExp) => ((Array[String]) => Maybe[T]) => (String) => Maybe[T]
  parseGeneric = function(regex) {
    return function(f) {
      return function(x) {
        return mapMaybe(f)(maybe(x.match(regex)));
      };
    };
  };

  // ((String) => String) => (String) => Maybe[TurtleReference]
  parseTurtleRefMaybe = function(singularToPlural) {
    return parseGeneric(/{([^ ]+) (\d+)}/)(function([_, breedName, idStr]) {
      var breed;
      breed = new BreedNamePair(breedName, singularToPlural(breedName).toLowerCase());
      return new TurtleReference(breed, parseInt(idStr));
    });
  };

  module.exports.parseTurtleRefMaybe = parseTurtleRefMaybe;

  // (String) => Maybe[PatchReference]
  parsePatchRefMaybe = parseGeneric(/{patch ([\d-]+) ([\d-]+)}/)(function([_, xStr, yStr]) {
    return new PatchReference(parseInt(xStr), parseInt(yStr));
  });

  // ((String) => String) => (String) => Maybe[LinkReference]
  parseLinkRefMaybe = function(singularToPlural) {
    return parseGeneric(/{([^ ]+) (\d+) (\d+)}/)(function([_, breedName, end1IDStr, end2IDStr]) {
      var breed;
      breed = new BreedNamePair(breedName, singularToPlural(breedName).toLowerCase());
      return new LinkReference(breed, parseInt(end1IDStr), parseInt(end2IDStr));
    });
  };

  // [T] @ (Array[(String) => Maybe[T]]) => (String) => Maybe[T]
  tryParsers = function(parsers) {
    return function(x) {
      var i, len, parser, result;
      for (i = 0, len = parsers.length; i < len; i++) {
        parser = parsers[i];
        result = parser(x);
        if (isSomething(result)) {
          return result;
        }
      }
      return None;
    };
  };

  // ((String) => String) => (String) => Maybe[AgentReference]
  module.exports.parseAgentRefMaybe = function(singularToPlural) {
    return function(x) {
      var lowerCased, stp;
      lowerCased = x.toLowerCase();
      stp = singularToPlural;
      if (lowerCased === 'nobody') {
        return maybe(NobodyReference);
      } else {
        return tryParsers([parsePatchRefMaybe, parseLinkRefMaybe(stp), parseTurtleRefMaybe(stp)])(lowerCased);
      }
    };
  };

  // ((String) => String) => (String) => LinkReference
  parseInnerLink = function(pluralToSingular) {
    return function(x) {
      var _, breed, breedName, id1, id2, unparsedBreed;
      [_, id1, id2, unparsedBreed] = match(/\[(\d+) (\d+) (.*)/, x);
      breedName = unparsedBreed === "{all-links}" ? "links" : match(/{breed (.*)}/, unparsedBreed)[1];
      breed = new BreedNamePair(pluralToSingular(breedName), breedName.toLowerCase());
      return new LinkReference(breed, parseInt(id1), parseInt(id2));
    };
  };

  // ((String) => String, (String) => String) => (String) => Any
  readAgenty = function(singularToPlural, pluralToSingular) {
    return function(x) {
      var lowerCased, parseLinkSet, parsePatchSet, parseTurtleSet, parsedMaybe, parsers, stp;
      lowerCased = x.toLowerCase();
      stp = singularToPlural;
      parseTurtleSet = parseGeneric(/{turtles ?([^}]*)}/)(function([_, nums]) {
        var breed;
        breed = new BreedNamePair("turtle", "turtles");
        return new ExportedTurtleSet(nums.split(' ').map(function(x) {
          return parseInt(x);
        }).map(function(who) {
          return new TurtleReference(breed, who);
        }));
      });
      parsePatchSet = parseGeneric(/{patches ?([^}]*)}/)(function([_, pairs]) {
        return new ExportedPatchSet(pairs.split(/] ?/).slice(0, -1).map(function(x) {
          return x.slice(1).split(' ').map(function(x) {
            return parseInt(x);
          });
        }).map(function([x, y]) {
          return new PatchReference(x, y);
        }));
      });
      parseLinkSet = parseGeneric(/{links ?(.*)}$/)(function([_, triples]) {
        return new ExportedLinkSet(triples.split(/] ?/).slice(0, -1).map(parseInnerLink(pluralToSingular)));
      });
      parsers = [parseBreedMaybe, parseTurtleSet, parsePatchSet, parseLinkSet, parsePatchRefMaybe, parseLinkRefMaybe(stp), parseTurtleRefMaybe(stp)];
      parsedMaybe = tryParsers(parsers)(lowerCased);
      return fold(function() {
        throw exceptions.internal(`You supplied ${x}, and I don't know what the heck that is!`);
      })(function(x) {
        return x;
      })(parsedMaybe);
    };
  };

  // ((String) => String, (String) => String, ExtensionsReader) => (String) => Any
  module.exports.parseAny = function(singularToPlural, pluralToSingular, extensionReader) {
    var helper;
    helper = function(x) {
      var lowerCased, result;
      lowerCased = x.toLowerCase();
      result = (function() {
        switch (lowerCased) {
          case "e":
            return maybe(Math.E);
          case "pi":
            return maybe(Math.PI);
          case "true":
            return maybe(true);
          case "false":
            return maybe(false);
          case "nobody":
            return maybe(NobodyReference);
          case "black":
            return maybe(0);
          case "gray":
            return maybe(5);
          case "white":
            return maybe(9.9);
          case "red":
            return maybe(15);
          case "orange":
            return maybe(25);
          case "brown":
            return maybe(35);
          case "yellow":
            return maybe(45);
          case "green":
            return maybe(55);
          case "lime":
            return maybe(65);
          case "turquoise":
            return maybe(75);
          case "cyan":
            return maybe(85);
          case "sky":
            return maybe(95);
          case "blue":
            return maybe(105);
          case "violet":
            return maybe(115);
          case "magenta":
            return maybe(125);
          case "pink":
            return maybe(135);
          default:
            return None;
        }
      })();
      return fold(function() {
        var commandLambdaMatch, extensionsMatch, listMatch, parsedNum, reporterLambdaMatch, strMatch;
        listMatch = x.match(/^\[.*\]$/);
        if (listMatch != null) {
          return parseList(x, helper, readAgenty(singularToPlural, pluralToSingular), extensionReader); // If not a list
        } else {
          strMatch = x.match(/^"(.*)"$/);
          if (strMatch != null) {
            return strMatch[1].replace(new RegExp('\\\\"', 'g'), '"'); // If not a string
          } else {
            parsedNum = parseFloat(x);
            if (!Number.isNaN(parsedNum)) {
              return parsedNum; // If not a number
            } else {
              commandLambdaMatch = x.match(/\(anonymous command: (\[.*\])\)$/);
              if (commandLambdaMatch != null) {
                return new ExportedCommandLambda(commandLambdaMatch[1]);
              } else {
                reporterLambdaMatch = x.match(/\(anonymous reporter: (\[.*\])\)$/);
                if (reporterLambdaMatch != null) {
                  return new ExportedReporterLambda(reporterLambdaMatch[1]);
                } else {
                  extensionsMatch = extensionReader.matchesPlaceholder(x);
                  if (extensionsMatch != null) {
                    return extensionReader.readPlaceholder(extensionsMatch, helper); // If not an extension placeholder
                  } else {
                    return readAgenty(singularToPlural, pluralToSingular)(lowerCased);
                  }
                }
              }
            }
          }
        }
      })(function(res) {
        return res;
      })(result);
    };
    return helper;
  };

}).call(this);

},{"./exportstructures":"serialize/exportstructures","brazier/maybe":"brazier/maybe","util/exception":"util/exception"}],"shim/cloner":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var JSType, cloneFunc, foldl;

  ({foldl} = require('brazierjs/array'));

  JSType = require('util/jstype');

  // [T] @ (T) => T
  cloneFunc = function(obj) { // Stored into a variable for the sake of recursion --JAB (4/29/14)
    var basicClone, entryCopyFunc, properties;
    if (JSType(obj).isObject() && !JSType(obj).isFunction()) {
      properties = Object.getOwnPropertyNames(obj);
      entryCopyFunc = function(acc, x) {
        acc[x] = cloneFunc(obj[x]);
        return acc;
      };
      basicClone = new obj.constructor();
      return foldl(entryCopyFunc)(basicClone)(properties);
    } else {
      return obj;
    }
  };

  module.exports = cloneFunc;

}).call(this);

},{"brazierjs/array":"brazier/array","util/jstype":"util/jstype"}],"shim/engine-scala":[function(require,module,exports){
(function() {

let MersenneTwisterFast;
(function(){
'use strict';var k,aa;function m(a){this.y=a}m.prototype.toString=function(){return String.fromCharCode(this.y)};
function ba(a){switch(typeof a){case "string":return"java.lang.String";case "number":return ca(a)?a<<24>>24===a?"java.lang.Byte":a<<16>>16===a?"java.lang.Short":"java.lang.Integer":da(a)?"java.lang.Float":"java.lang.Double";case "boolean":return"java.lang.Boolean";case "undefined":return"java.lang.Void";default:return a instanceof n?"java.lang.Long":a instanceof m?"java.lang.Character":a&&a.$classData?a.$classData.name:null.yb()}}
function ea(a,b){switch(typeof a){case "string":return a===b;case "number":return Object.is(a,b);case "boolean":return a===b;case "undefined":return a===b;default:return a&&a.$classData||null===a?a.L(b):a instanceof n?b instanceof n&&a.j===b.j&&a.m===b.m:a instanceof m?b instanceof m&&(null===a?0:a.y)===b.y:p.prototype.L.call(a,b)}}
function fa(a){switch(typeof a){case "string":return ha(a);case "number":return ia(a);case "boolean":return a?1231:1237;case "undefined":return 0;default:return a&&a.$classData||null===a?a.M():a instanceof n?a.j^a.m:a instanceof m?null===a?0:a.y:p.prototype.M.call(a)}}function ja(a,b){if(0===b)throw new ka("/ by zero");return a%b|0}function la(a){return 2147483647<a?2147483647:-2147483648>a?-2147483648:a|0}var ma=0,na=new WeakMap;
function oa(a){switch(typeof a){case "string":return ha(a);case "number":return ia(a);case "bigint":var b=0;for(a<BigInt(0)&&(a=~a);a!==BigInt(0);)b^=Number(BigInt.asIntN(32,a)),a>>=BigInt(32);return b;case "boolean":return a?1231:1237;case "undefined":return 0;case "symbol":return a=a.description,void 0===a?0:ha(a);default:if(null===a)return 0;b=na.get(a);void 0===b&&(ma=b=ma+1|0,na.set(a,b));return b}}function ca(a){return"number"===typeof a&&(a|0)===a&&1/a!==1/-0}
function da(a){return"number"===typeof a&&(a!==a||Math.fround(a)===a)}function r(a){return null===a?aa:a}function p(){}p.prototype.constructor=p;function u(){}u.prototype=p.prototype;p.prototype.M=function(){return oa(this)};p.prototype.L=function(a){return this===a};p.prototype.B=function(){var a=this.M();return ba(this)+"@"+(+(a>>>0)).toString(16)};p.prototype.toString=function(){return this.B()};
function v(a){if("number"===typeof a){this.a=Array(a);for(var b=0;b<a;b++)this.a[b]=null}else this.a=a}v.prototype=new u;v.prototype.constructor=v;v.prototype.v=function(){return new v(this.a.slice())};function pa(){}pa.prototype=v.prototype;function qa(a){if("number"===typeof a){this.a=Array(a);for(var b=0;b<a;b++)this.a[b]=!1}else this.a=a}qa.prototype=new u;qa.prototype.constructor=qa;qa.prototype.v=function(){return new qa(this.a.slice())};
function ra(a){this.a="number"===typeof a?new Uint16Array(a):a}ra.prototype=new u;ra.prototype.constructor=ra;ra.prototype.v=function(){return new ra(this.a.slice())};function sa(a){this.a="number"===typeof a?new Int8Array(a):a}sa.prototype=new u;sa.prototype.constructor=sa;sa.prototype.v=function(){return new sa(this.a.slice())};function ta(a){this.a="number"===typeof a?new Int16Array(a):a}ta.prototype=new u;ta.prototype.constructor=ta;ta.prototype.v=function(){return new ta(this.a.slice())};
function w(a){this.a="number"===typeof a?new Int32Array(a):a}w.prototype=new u;w.prototype.constructor=w;w.prototype.v=function(){return new w(this.a.slice())};function ua(a){if("number"===typeof a){this.a=Array(a);for(var b=0;b<a;b++)this.a[b]=aa}else this.a=a}ua.prototype=new u;ua.prototype.constructor=ua;ua.prototype.v=function(){return new ua(this.a.slice())};function va(a){this.a="number"===typeof a?new Float32Array(a):a}va.prototype=new u;va.prototype.constructor=va;va.prototype.v=function(){return new va(this.a.slice())};
function wa(a){this.a="number"===typeof a?new Float64Array(a):a}wa.prototype=new u;wa.prototype.constructor=wa;wa.prototype.v=function(){return new wa(this.a.slice())};function xa(){this.W=void 0;this.R=this.u=null;this.S=0;this.Za=null;this.K="";this.O=this.Q=void 0;this.name="";this.ia=!1;this.T=void 0}function x(a,b,c,d){var e=new xa;e.u={};e.Za=a;e.K=b;e.O=f=>f===e;e.name=c;e.ia=!0;e.T=()=>!1;void 0!==d&&(e.Q=ya(e,d));return e}
function z(a,b,c,d){var e=new xa,f=Object.getOwnPropertyNames(c)[0];e.u=c;e.K="L"+b+";";e.O=g=>!!g.u[f];e.name=b;e.T=d||(g=>!!(g&&g.$classData&&g.$classData.u[f]));"number"!==typeof a&&(a.prototype.$classData=e);return e}function ya(a,b,c){var d=new xa;b.prototype.$classData=d;var e="["+a.K;d.W=b;d.u={ja:1,d:1};d.R=a;d.S=1;d.K=e;d.name=e;d.O=c||(f=>d===f);d.T=f=>f instanceof b;return d}
function za(a){function b(g){if("number"===typeof g){this.a=Array(g);for(var h=0;h<g;h++)this.a[h]=null}else this.a=g}var c=new xa;b.prototype=new pa;b.prototype.constructor=b;b.prototype.v=function(){return new b(this.a.slice())};b.prototype.$classData=c;var d=a.R||a,e=a.S+1;a="["+a.K;c.W=b;c.u={ja:1,d:1};c.R=d;c.S=e;c.K=a;c.name=a;var f=g=>{var h=g.S;return h===e?d.O(g.R):h>e&&d===A};c.O=f;c.T=g=>{g=g&&g.$classData;return!!g&&(g===c||f(g))};return c}
function Aa(){var a=Ba;a.Q||(a.Q=za(a));return a.Q}var A=new xa;A.u={};A.K="Ljava.lang.Object;";A.O=a=>!a.ia;A.name="java.lang.Object";A.T=a=>null!==a;A.Q=ya(A,v,a=>{var b=a.S;return 1===b?!a.R.ia:1<b});p.prototype.$classData=A;x(void 0,"V","void",void 0);x(!1,"Z","boolean",qa);x(0,"C","char",ra);x(0,"B","byte",sa);x(0,"S","short",ta);x(0,"I","int",w);var Ca=x(null,"J","long",ua);x(0,"F","float",va);x(0,"D","double",wa);
function Da(){this.Ea=this.Y=this.U=null;Ea=this;this.U=new ArrayBuffer(8);this.Y=new Int32Array(this.U,0,2);new Float32Array(this.U,0,2);this.Ea=new Float64Array(this.U,0,1);this.Y[0]=16909060;new Int8Array(this.U,0,8)}Da.prototype=new u;Da.prototype.constructor=Da;function Fa(a,b){var c=b|0;if(c===b&&-Infinity!==1/b)return c;a.Ea[0]=b;return(a.Y[0]|0)^(a.Y[1]|0)}z(Da,"java.lang.FloatingPointBits$",{Kb:1});var Ea;function Ga(){Ea||(Ea=new Da);return Ea}
function Ha(){this.Ga=null;Ia=this;this.Ga="undefined"!==typeof performance?performance.now?()=>+performance.now():performance.webkitNow?()=>+performance.webkitNow():()=>+(new Date).getTime():()=>+(new Date).getTime()}Ha.prototype=new u;Ha.prototype.constructor=Ha;z(Ha,"java.lang.System$NanoTime$",{Ub:1});var Ia;function Ja(){this.Z=null;Ka=this;this.Z=Object.prototype.hasOwnProperty}Ja.prototype=new u;Ja.prototype.constructor=Ja;z(Ja,"java.lang.Utils$Cache$",{Wb:1});var Ka;
function La(){Ka||(Ka=new Ja);return Ka}z(0,"java.lang.Void",{Xb:1},a=>void 0===a);function Ma(){}Ma.prototype=new u;Ma.prototype.constructor=Ma;z(Ma,"java.util.Arrays$",{Yb:1});var Na;function B(a,b){throw new Oa(b,a.k,a.b);}function Pa(a,b){for(var c="",d=b.length,e=0;e!==d;){var f=C(b,e);c=""+c+Qa(a,f);e=e+(65536<=f?2:1)|0}return c}
function Qa(a,b){var c=E(F(),b);if(128>b)switch(b){case 94:case 36:case 92:case 46:case 42:case 43:case 63:case 40:case 41:case 91:case 93:case 123:case 125:case 124:return"\\"+c;default:return 2!==(66&a.f)?c:65<=b&&90>=b?"["+c+E(F(),32+b|0)+"]":97<=b&&122>=b?"["+E(F(),-32+b|0)+c+"]":c}else return 56320===(-1024&b)?"(?:"+c+")":c}
function Ra(a){for(var b=a.k,c=b.length;;){if(a.b!==c)switch(b.charCodeAt(a.b)){case 32:case 9:case 10:case 11:case 12:case 13:a.b=1+a.b|0;continue;case 35:Sa(a);continue}break}}
function Ta(a,b,c){var d=a.k,e=d.length,f=a.b,g=f===e?46:d.charCodeAt(f);if(63===g||42===g||43===g||123===g){switch(c.charCodeAt(0)){case 94:case 36:f=!0;break;case 40:f=63===c.charCodeAt(1)&&58!==c.charCodeAt(2);break;case 92:f=c.charCodeAt(1);f=98===f||66===f;break;default:f=!1}c=f?"(?:"+c+")":c;f=a.k;var h=a.b;a.b=1+a.b|0;if(123===g){g=f.length;if(a.b===g)var l=!0;else l=f.charCodeAt(a.b),l=!(48<=l&&57>=l);for(l&&B(a,"Illegal repetition");;)if(a.b!==g?(l=f.charCodeAt(a.b),l=48<=l&&57>=l):l=!1,
l)a.b=1+a.b|0;else break;a.b===g&&B(a,"Illegal repetition");if(44===f.charCodeAt(a.b))for(a.b=1+a.b|0;;)if(a.b!==g?(l=f.charCodeAt(a.b),l=48<=l&&57>=l):l=!1,l)a.b=1+a.b|0;else break;a.b!==g&&125===f.charCodeAt(a.b)||B(a,"Illegal repetition");a.b=1+a.b|0}f=f.substring(h,a.b);if(a.b!==e)switch(d.charCodeAt(a.b)){case 43:return a.b=1+a.b|0,Ua(a,b,c,f);case 63:return a.b=1+a.b|0,""+c+f+"?";default:return""+c+f}else return""+c+f}else return c}
function Ua(a,b,c,d){for(var e=a.r.length|0,f=0;f<e;){var g=f,h=a.r[g]|0;h>b&&(a.r[g]=1+h|0);f=1+f|0}c=c.replace(F().Sa,(l,q,t)=>{if(0===(q.length%2|0))return l;t=parseInt(t,10)|0;return t>b?""+q+(1+t|0):l});a.q=1+a.q|0;return"(?:(?\x3d("+c+d+"))\\"+(1+b|0)+")"}
function Va(a){var b=a.k,c=b.length;(1+a.b|0)===c&&B(a,"\\ at end of pattern");a.b=1+a.b|0;var d=b.charCodeAt(a.b);switch(d){case 100:case 68:case 104:case 72:case 115:case 83:case 118:case 86:case 119:case 87:case 112:case 80:switch(a=Wa(a,d),b=a.ma,b){case 0:return"\\p{"+a.F+"}";case 1:return"\\P{"+a.F+"}";case 2:return"["+a.F+"]";case 3:return Xa(F(),a.F);default:throw new Ya(b);}case 98:if("b{g}"===b.substring(a.b,4+a.b|0))B(a,"\\b{g} is not supported");else if(0!==(320&a.f))Za(a,"\\b with UNICODE_CASE");
else return a.b=1+a.b|0,"\\b";break;case 66:if(0!==(320&a.f))Za(a,"\\B with UNICODE_CASE");else return a.b=1+a.b|0,"\\B";break;case 65:return a.b=1+a.b|0,"^";case 71:B(a,"\\G in the middle of a pattern is not supported");break;case 90:return a.b=1+a.b|0,"(?\x3d"+(0!==(1&a.f)?"\n":"(?:\r\n?|[\n\u0085\u2028\u2029])")+"?$)";case 122:return a.b=1+a.b|0,"$";case 82:return a.b=1+a.b|0,"(?:\r\n|[\n-\r\u0085\u2028\u2029])";case 88:B(a,"\\X is not supported");break;case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:var e=
a.b;for(d=1+e|0;;){if(d!==c){var f=b.charCodeAt(d);f=48<=f&&57>=f}else f=!1;f?(f=b.substring(e,1+d|0),f=(parseInt(f,10)|0)<=(-1+(a.r.length|0)|0)):f=!1;if(f)d=1+d|0;else break}b=b.substring(e,d);b=parseInt(b,10)|0;b>(-1+(a.r.length|0)|0)&&B(a,"numbered capturing group \x3c"+b+"\x3e does not exist");b=a.r[b]|0;a.b=d;return"(?:\\"+b+")";case 107:return a.b=1+a.b|0,a.b!==c&&60===b.charCodeAt(a.b)||B(a,"\\k is not followed by '\x3c' for named capturing group"),a.b=1+a.b|0,b=$a(a),d=a.ba,La().Z.call(d,
b)||B(a,"named capturing group \x3c"+b+"\x3e does not exit"),b=a.r[d[b]|0]|0,a.b=1+a.b|0,"(?:\\"+b+")";case 81:d=1+a.b|0;c=b.indexOf("\\E",d)|0;if(0>c)return a.b=b.length,Pa(a,b.substring(d));a.b=2+c|0;return Pa(a,b.substring(d,c));default:return Qa(a,ab(a))}}
function ab(a){var b=a.k,c=C(b,a.b);switch(c){case 48:return bb(a);case 120:return b=a.k,c=1+a.b|0,c!==b.length&&123===b.charCodeAt(c)?(c=1+c|0,b=b.indexOf("}",c)|0,0>b&&B(a,"Unclosed hexadecimal escape sequence"),c=cb(a,c,b,"hexadecimal"),a.b=1+b|0,a=c):(b=cb(a,c,2+c|0,"hexadecimal"),a.b=2+c|0,a=b),a;case 117:a:{b=a.k;var d=1+a.b|0;c=4+d|0;d=cb(a,d,c,"Unicode");a.b=c;var e=2+c|0,f=4+e|0;if(55296===(-1024&d)&&"\\u"===b.substring(c,e)&&(b=cb(a,e,f,"Unicode"),56320===(-1024&b))){a.b=f;a=(64+(1023&d)|
0)<<10|1023&b;break a}a=d}return a;case 78:B(a,"\\N is not supported");break;case 97:return a.b=1+a.b|0,7;case 116:return a.b=1+a.b|0,9;case 110:return a.b=1+a.b|0,10;case 102:return a.b=1+a.b|0,12;case 114:return a.b=1+a.b|0,13;case 101:return a.b=1+a.b|0,27;case 99:return a.b=1+a.b|0,a.b===b.length&&B(a,"Illegal control escape sequence"),b=C(b,a.b),a.b=a.b+(65536<=b?2:1)|0,64^b;default:return(65<=c&&90>=c||97<=c&&122>=c)&&B(a,"Illegal/unsupported escape sequence"),a.b=a.b+(65536<=c?2:1)|0,c}}
function bb(a){var b=a.k,c=b.length,d=a.b,e=(1+d|0)<c?-48+b.charCodeAt(1+d|0)|0:-1;(0>e||7<e)&&B(a,"Illegal octal escape sequence");var f=(2+d|0)<c?-48+b.charCodeAt(2+d|0)|0:-1;if(0>f||7<f)return a.b=2+a.b|0,e;if(3<e)return a.b=3+a.b|0,(e<<3)+f|0;b=(3+d|0)<c?-48+b.charCodeAt(3+d|0)|0:-1;if(0>b||7<b)return a.b=3+a.b|0,(e<<3)+f|0;a.b=4+a.b|0;return((e<<6)+(f<<3)|0)+b|0}
function cb(a,b,c,d){var e=a.k,f=e.length;(b===c||c>f)&&B(a,"Illegal "+d+" escape sequence");for(f=b;f<c;){var g=e.charCodeAt(f);48<=g&&57>=g||65<=g&&70>=g||97<=g&&102>=g||B(a,"Illegal "+d+" escape sequence");f=1+f|0}6<(c-b|0)?b=1114112:(b=e.substring(b,c),b=parseInt(b,16)|0);1114111<b&&B(a,"Hexadecimal codepoint is too big");return b}
function Wa(a,b){a.b=1+a.b|0;switch(b){case 100:case 68:a=F().Ma;break;case 104:case 72:a=F().Pa;break;case 115:case 83:a=F().Na;break;case 118:case 86:a=F().Qa;break;case 119:case 87:a=F().Oa;break;case 112:case 80:var c=a.k,d=a.b;if(d===c.length)c="?";else if(123===c.charCodeAt(d)){d=1+d|0;var e=c.indexOf("}",d)|0;0>e&&B(a,"Unclosed character family");a.b=e;c=c.substring(d,e)}else c=c.substring(d,1+d|0);d=F().pa;La().Z.call(d,c)||Za(a,"Unicode character family");c=2!==(66&a.f)||"Lower"!==c&&"Upper"!==
c?c:"Alpha";c=F().pa[c];a.b=1+a.b|0;a=c;break;default:throw new Ya(new m(b));}97<=b?b=a:a.la?b=a.na:(b=a,b.la||(b.na=new G(1^b.ma,b.F),b.la=!0),b=b.na);return b}
var ib=function db(a){var c=a.k,d=c.length;a.b=1+a.b|0;var e=a.b!==d&&94===c.charCodeAt(a.b);e&&(a.b=1+a.b|0);for(e=new eb(2===(66&a.f),e);a.b!==d;){var f=C(c,a.b);a:{switch(f){case 93:return a.b=1+a.b|0,a=e,c=fb(a),""===a.aa?c:"(?:"+a.aa+c+")";case 38:a.b=1+a.b|0;if(a.b!==d&&38===c.charCodeAt(a.b)){a.b=1+a.b|0;f=e;var g=fb(f);f.aa+=f.La?g+"|":"(?\x3d"+g+")";f.o="";f.g=""}else gb(a,38,d,c,e);break a;case 91:f=db(a);e.o=""===e.o?f:e.o+"|"+f;break a;case 92:switch(a.b=1+a.b|0,a.b===d&&B(a,"Illegal escape sequence"),
g=c.charCodeAt(a.b),g){case 100:case 68:case 104:case 72:case 115:case 83:case 118:case 86:case 119:case 87:case 112:case 80:f=e;g=Wa(a,g);var h=g.ma;switch(h){case 0:f.g=f.g+("\\p{"+g.F)+"}";break;case 1:f.g=f.g+("\\P{"+g.F)+"}";break;case 2:f.g=""+f.g+g.F;break;case 3:g=Xa(F(),g.F);f.o=""===f.o?g:f.o+"|"+g;break;default:throw new Ya(h);}break a;case 81:a.b=1+a.b|0;f=c.indexOf("\\E",a.b)|0;0>f&&B(a,"Unclosed character class");g=e;h=c;for(var l=f,q=a.b;q!==l;){var t=C(h,q);hb(g,t);q=q+(65536<=t?2:
1)|0}a.b=2+f|0;break a;default:gb(a,ab(a),d,c,e);break a}case 32:case 9:case 10:case 11:case 12:case 13:if(0!==(4&a.f)){a.b=1+a.b|0;break a}break;case 35:if(0!==(4&a.f)){Sa(a);break a}}a.b=a.b+(65536<=f?2:1)|0;gb(a,f,d,c,e)}}B(a,"Unclosed character class")};
function jb(a){var b=a.k,c=b.length,d=a.b;if((1+d|0)===c||63!==b.charCodeAt(1+d|0))return a.b=1+d|0,a.q=1+a.q|0,a.r.push(a.q),"("+kb(a,!0)+")";(2+d|0)===c&&B(a,"Unclosed group");var e=b.charCodeAt(2+d|0);if(58===e||61===e||33===e)return a.b=3+d|0,""+b.substring(d,3+d|0)+kb(a,!0)+")";if(60===e){(3+d|0)===c&&B(a,"Unclosed group");b=b.charCodeAt(3+d|0);if(65<=b&&90>=b||97<=b&&122>=b)return a.b=3+d|0,d=$a(a),b=a.ba,La().Z.call(b,d)&&B(a,"named capturing group \x3c"+d+"\x3e is already defined"),a.q=1+
a.q|0,a.r.push(a.q),a.ba[d]=-1+(a.r.length|0)|0,a.b=1+a.b|0,"("+kb(a,!0)+")";61!==b&&33!==b&&B(a,"Unknown look-behind group");Za(a,"Look-behind group")}else{if(62===e)return a.b=3+d|0,a.q=1+a.q|0,d=a.q,"(?:(?\x3d("+kb(a,!0)+"))\\"+d+")";B(a,"Embedded flag expression in the middle of a pattern is not supported")}}
function $a(a){for(var b=a.k,c=b.length,d=a.b;;){if(a.b!==c){var e=b.charCodeAt(a.b);e=65<=e&&90>=e||97<=e&&122>=e||48<=e&&57>=e}else e=!1;if(e)a.b=1+a.b|0;else break}a.b!==c&&62===b.charCodeAt(a.b)||B(a,"named capturing group is missing trailing '\x3e'");return b.substring(d,a.b)}
function gb(a,b,c,d,e){0!==(4&a.f)&&Ra(a);a.b!==c&&45===d.charCodeAt(a.b)?(a.b=1+a.b|0,0!==(4&a.f)&&Ra(a),a.b===c&&B(a,"Unclosed character class"),c=C(d,a.b),91===c||93===c?(hb(e,b),hb(e,45)):(a.b=a.b+(65536<=c?2:1)|0,c=92===c?ab(a):c,c<b&&B(a,"Illegal character range"),a=H(b)+"-"+H(c),e.g=56320===(-1024&b)?a+e.g:e.g+a,e.Ka&&(a=65<b?b:65,d=90>c?c:90,a<=d&&(d=32+d|0,e.g+=H(32+a|0)+"-"+H(d)),b=97<b?b:97,c=122>c?c:122,b<=c&&(c=-32+c|0,e.g+=H(-32+b|0)+"-"+H(c))))):hb(e,b)}
function lb(a,b){this.k=a;this.f=b;this.qa=!1;this.q=this.b=0;this.r=[0];this.ba={}}lb.prototype=new u;lb.prototype.constructor=lb;function Za(a,b){B(a,b+" is not supported because it requires RegExp features of ECMAScript 2018.\nIf you only target environments with ES2018+, you can enable ES2018 features with\n  scalaJSLinkerConfig ~\x3d { _.withESFeatures(_.withESVersion(ESVersion.ES2018)) }\nor an equivalent configuration depending on your build tool.")}
function kb(a,b){for(var c=a.k,d=c.length,e="";a.b!==d;){var f=C(c,a.b);a:{switch(f){case 41:return b||B(a,"Unmatched closing ')'"),a.b=1+a.b|0,e;case 124:a.qa&&!b&&B(a,"\\G is not supported when there is an alternative at the top level");a.b=1+a.b|0;e+="|";break a;case 32:case 9:case 10:case 11:case 12:case 13:if(0!==(4&a.f)){a.b=1+a.b|0;break a}break;case 35:if(0!==(4&a.f)){Sa(a);break a}break;case 63:case 42:case 43:case 123:B(a,"Dangling meta character '"+E(F(),f)+"'")}var g=a.q;switch(f){case 92:f=
Va(a);break;case 91:f=ib(a);break;case 40:f=jb(a);break;case 94:a.b=1+a.b|0;f="^";break;case 36:a.b=1+a.b|0;f="$";break;case 46:a.b=1+a.b|0;f=0!==(32&a.f)?"":0!==(1&a.f)?"\n":"\n\r\u0085\u2028\u2029";f=Xa(F(),f);break;default:a.b=a.b+(65536<=f?2:1)|0,f=Qa(a,f)}e=""+e+Ta(a,g,f)}}b&&B(a,"Unclosed group");return e}function Sa(a){for(var b=a.k,c=b.length;;){if(a.b!==c){var d=b.charCodeAt(a.b);d=!(10===d||13===d||133===d||8232===d||8233===d)}else d=!1;if(d)a.b=1+a.b|0;else break}}
z(lb,"java.util.regex.PatternCompiler",{fc:1});function mb(a){try{return RegExp("",a),!0}catch(b){return!1}}
function nb(){this.Sa=this.Ra=null;this.oa=!1;this.pa=this.Oa=this.Qa=this.Na=this.Pa=this.Ma=null;ob=this;this.Ra=RegExp("^\\(\\?([idmsuxU]*)(?:-([idmsuxU]*))?\\)");this.Sa=RegExp("(\\\\+)(\\d+)","g");this.oa=mb("us");mb("d");this.Ma=new G(2,"0-9");this.Pa=new G(2,"\t \u00a0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000");this.Na=new G(2,"\t-\r ");this.Qa=new G(2,"\n-\r\u0085\u2028\u2029");this.Oa=new G(2,"a-zA-Z_0-9");var a={};a.Lower=new G(2,"a-z");a.Upper=new G(2,"A-Z");a.ASCII=new G(2,"\x00-\u007f");
a.Alpha=new G(2,"A-Za-z");a.Digit=new G(2,"0-9");a.Alnum=new G(2,"0-9A-Za-z");a.Punct=new G(2,"!-/:-@[-`{-~");a.Graph=new G(2,"!-~");a.Print=new G(2," -~");a.Blank=new G(2,"\t ");a.Cntrl=new G(2,"\x00-\u001f\u007f");a.XDigit=new G(2,"0-9A-Fa-f");a.Space=new G(2,"\t-\r ");this.pa=a}nb.prototype=new u;nb.prototype.constructor=nb;
function pb(a,b){switch(b){case 105:return 2;case 100:return 1;case 109:return 8;case 115:return 32;case 117:return 64;case 120:return 4;case 85:return 256;default:throw qb("bad in-pattern flag");}}function Xa(a,b){return""!==b?"[^"+b+"]":F().oa?".":"[\\d\\D]"}function E(a,b){return String.fromCodePoint(b)}z(nb,"java.util.regex.PatternCompiler$",{gc:1});var ob;function F(){ob||(ob=new nb);return ob}
function fb(a){if(a.La){var b=Xa(F(),a.g);return""===a.o?b:"(?:(?!"+a.o+")"+b+")"}return""===a.g?""===a.o?"[^\\d\\D]":"(?:"+a.o+")":""===a.o?"["+a.g+"]":"(?:"+a.o+"|["+a.g+"])"}function H(a){var b=E(F(),a);return 93===a||92===a||45===a||94===a?"\\"+b:b}function eb(a,b){this.Ka=a;this.La=b;this.g=this.o=this.aa=""}eb.prototype=new u;eb.prototype.constructor=eb;
function hb(a,b){var c=H(b);a.g=56320===(-1024&b)?""+c+a.g:""+a.g+c;a.Ka&&(65<=b&&90>=b?a.g=""+a.g+E(F(),32+b|0):97<=b&&122>=b&&(a.g=""+a.g+E(F(),-32+b|0)))}z(eb,"java.util.regex.PatternCompiler$CharacterClassBuilder",{hc:1});function G(a,b){this.na=null;this.la=!1;this.ma=a;this.F=b}G.prototype=new u;G.prototype.constructor=G;z(G,"java.util.regex.PatternCompiler$CompiledCharClass",{ic:1});function rb(a){a.xa||(a.wa=StrictMath,a.xa=!0);return a.wa}function sb(){this.wa=null;this.xa=!1}
sb.prototype=new u;sb.prototype.constructor=sb;z(sb,"org.nlogo.tortoise.engine.MersenneMath$",{tb:1});var tb;function ub(){tb||(tb=new sb);return tb}function n(a,b){this.j=a;this.m=b}n.prototype=new u;n.prototype.constructor=n;n.prototype.L=function(a){return a instanceof n&&this.j===a.j&&this.m===a.m};n.prototype.M=function(){return this.j^this.m};n.prototype.B=function(){var a=I(),b=this.j,c=this.m;return c===b>>31?""+b:0>c?"-"+vb(a,-b|0,0!==b?~c:-c|0):vb(a,b,c)};
z(n,"org.scalajs.linker.runtime.RuntimeLong",{vb:1});function vb(a,b,c){return 0===(-2097152&c)?""+(4294967296*c+ +(b>>>0)):wb(a,b,c,1E9,0,2)}
function wb(a,b,c,d,e,f){var g=(0!==e?Math.clz32(e)|0:32+(Math.clz32(d)|0)|0)-(0!==c?Math.clz32(c)|0:32+(Math.clz32(b)|0)|0)|0,h=g,l=0===(32&h)?d<<h:0,q=0===(32&h)?(d>>>1|0)>>>(31-h|0)|0|e<<h:d<<h;h=b;var t=c;for(b=c=0;0<=g&&0!==(-2097152&t);){var y=h,D=t,Rc=l,ec=q;if(D===ec?(-2147483648^y)>=(-2147483648^Rc):(-2147483648^D)>=(-2147483648^ec))y=t,D=q,t=h-l|0,y=(-2147483648^t)>(-2147483648^h)?-1+(y-D|0)|0:y-D|0,h=t,t=y,32>g?c|=1<<g:b|=1<<g;g=-1+g|0;y=q>>>1|0;l=l>>>1|0|q<<31;q=y}g=t;if(g===e?(-2147483648^
h)>=(-2147483648^d):(-2147483648^g)>=(-2147483648^e))g=4294967296*t+ +(h>>>0),d=4294967296*e+ +(d>>>0),1!==f&&(q=g/d,e=q/4294967296|0,l=c,c=q=l+(q|0)|0,b=(-2147483648^q)<(-2147483648^l)?1+(b+e|0)|0:b+e|0),0!==f&&(d=g%d,h=d|0,t=d/4294967296|0);if(0===f)return a.l=b,c;if(1===f)return a.l=t,h;a=""+h;return""+(4294967296*b+ +(c>>>0))+"000000000".substring(a.length)+a}function xb(){this.l=0}xb.prototype=new u;xb.prototype.constructor=xb;
function J(a,b,c){return 0>c?-(4294967296*+((0!==b?~c:-c|0)>>>0)+ +((-b|0)>>>0)):4294967296*c+ +(b>>>0)}function yb(a,b){if(-0x7fffffffffffffff>b)return a.l=-2147483648,0;if(0x7fffffffffffffff<=b)return a.l=2147483647,-1;var c=b|0,d=b/4294967296|0;a.l=0>b&&0!==c?-1+d|0:d;return c}
function zb(a,b,c,d,e){if(0===(d|e))throw new ka("/ by zero");if(c===b>>31){if(e===d>>31)return-1!==d?(c=ja(b,d),a.l=c>>31,c):a.l=0;if(-2147483648===b&&-2147483648===d&&0===e)return a.l=0;a.l=c;return b}if(0>c)var f=-b|0,g=0!==b?~c:-c|0;else f=b,g=c;0>e?(b=-d|0,d=0!==d?~e:-e|0):(b=d,d=e);0===(-2097152&g)?0===(-2097152&d)?(b=(4294967296*g+ +(f>>>0))%(4294967296*d+ +(b>>>0)),a.l=b/4294967296|0,b|=0):(a.l=g,b=f):0===d&&0===(b&(-1+b|0))?(a.l=0,b=f&(-1+b|0)):0===b&&0===(d&(-1+d|0))?(a.l=g&(-1+d|0),b=f):
b=wb(a,f,g,b,d,1)|0;return 0>c?(c=a.l,a.l=0!==b?~c:-c|0,-b|0):b}z(xb,"org.scalajs.linker.runtime.RuntimeLong$",{wb:1});var Ab;function I(){Ab||(Ab=new xb);return Ab}function Bb(a,b,c,d,e){var f=b.s;0!==c.length&&(f.h=""+f.h+c);a=a.G();if(a.p())for(c=a.w(),f.h=""+f.h+c;a.p();)f.h=""+f.h+d,c=a.w(),f.h=""+f.h+c;0!==e.length&&(f.h=""+f.h+e);return b}function Cb(){}Cb.prototype=new u;Cb.prototype.constructor=Cb;
function Db(a,b,c){if(!(a=b===c)){if(Eb(b))a:if(Eb(c))c=Fb(b,c);else{if(c instanceof m){if("number"===typeof b){c=+b===c.y;break a}if(b instanceof n){b=r(b);a=b.m;c=c.y;c=b.j===c&&a===c>>31;break a}}c=null===b?null===c:ea(b,c)}else c=b instanceof m?Gb(b,c):null===b?null===c:ea(b,c);a=c}return a}
function Fb(a,b){if("number"===typeof a)return a=+a,"number"===typeof b?a===+b:b instanceof n?(b=r(b),a===J(I(),b.j,b.m)):!1;if(a instanceof n){var c=r(a);a=c.j;c=c.m;if(b instanceof n){b=r(b);var d=b.m;return a===b.j&&c===d}return"number"===typeof b?(b=+b,J(I(),a,c)===b):!1}return null===a?null===b:ea(a,b)}
function Gb(a,b){if(b instanceof m)return a.y===b.y;if(Eb(b)){if("number"===typeof b)return+b===a.y;if(b instanceof n){b=r(b);var c=b.m;a=a.y;return b.j===a&&c===a>>31}return null===b?null===a:ea(b,a)}return null===a&&null===b}z(Cb,"scala.runtime.BoxesRunTime$",{Yc:1});var Hb;function Ib(){Hb||(Hb=new Cb);return Hb}function Jb(){}Jb.prototype=new u;Jb.prototype.constructor=Jb;z(Jb,"scala.runtime.Scala3RunTime$",{Zc:1});var Kb;function Lb(){}Lb.prototype=new u;Lb.prototype.constructor=Lb;
function K(a,b){if(null===b)return 0;if("number"===typeof b){a=+b;b=la(a);if(b===a)a=b;else{var c=I();b=yb(c,a);c=c.l;a=J(I(),b,c)===a?b^c:Fa(Ga(),a)}return a}return b instanceof n?(a=r(b),b=new n(a.j,a.m),a=b.j,b=b.m,b===a>>31?a:a^b):fa(b)}z(Lb,"scala.runtime.Statics$",{$c:1});var Mb;function L(){Mb||(Mb=new Lb);return Mb}function Nb(){}Nb.prototype=new u;Nb.prototype.constructor=Nb;function Ob(){}Ob.prototype=Nb.prototype;
function M(a,b){a=Pb(a,b);return-430675100+Math.imul(5,a<<13|a>>>19|0)|0}function Pb(a,b){b=Math.imul(-862048943,b);b=Math.imul(461845907,b<<15|b>>>17|0);return a^b}function N(a){a=Math.imul(-2048144789,a^(a>>>16|0));a=Math.imul(-1028477387,a^(a>>>13|0));return a^(a>>>16|0)}
function Qb(a){0===(32&a.X)<<24>>24&&0===(32&a.X)<<24>>24&&(a.Ba=new w(new Int32Array([1632,1776,1984,2406,2534,2662,2790,2918,3046,3174,3302,3430,3558,3664,3792,3872,4160,4240,6112,6160,6470,6608,6784,6800,6992,7088,7232,7248,42528,43216,43264,43472,43504,43600,44016,65296,66720,68912,69734,69872,69942,70096,70384,70736,70864,71248,71360,71472,71904,72016,72784,73040,73120,73552,92768,92864,93008,120782,120792,120802,120812,120822,123200,123632,124144,125264,130032])),a.X=(32|a.X)<<24>>24);return a.Ba}
function Rb(){this.Ba=null;this.X=0}Rb.prototype=new u;Rb.prototype.constructor=Rb;z(Rb,"java.lang.Character$",{Fb:1,d:1});var Sb;function Tb(a){throw new Ub('For input string: "'+a+'"');}function Vb(){this.Ca=this.Da=null;this.I=0}Vb.prototype=new u;Vb.prototype.constructor=Vb;z(Vb,"java.lang.Double$",{Hb:1,d:1});var Wb;function Xb(a){throw new Ub('For input string: "'+a+'"');}function Yb(){}Yb.prototype=new u;Yb.prototype.constructor=Yb;
function Zb(a,b){a=null===b?0:b.length;0===a&&Xb(b);var c=b.charCodeAt(0),d=45===c,e=d?2147483648:2147483647;c=d||43===c?1:0;c>=b.length&&Xb(b);for(var f=0;c!==a;){Sb||(Sb=new Rb);var g=Sb;var h=b.charCodeAt(c);if(256>h)g=48<=h&&57>=h?-48+h|0:65<=h&&90>=h?-55+h|0:97<=h&&122>=h?-87+h|0:-1;else if(65313<=h&&65338>=h)g=-65303+h|0;else if(65345<=h&&65370>=h)g=-65335+h|0;else{Na||(Na=new Ma);a:{var l=Qb(g);for(var q=0,t=l.a.length;;){if(q===t){l=-1-q|0;break a}var y=(q+t|0)>>>1|0,D=l.a[y];D=h===D?0:h<
D?-1:1;if(0>D)t=y;else{if(0===D){l=y;break a}q=1+y|0}}}l=0>l?-2-l|0:l;0>l?g=-1:(g=h-Qb(g).a[l]|0,g=9<g?-1:g)}g=10>g?g:-1;f=10*f+g;(-1===g||f>e)&&Xb(b);c=1+c|0}return d?-f|0:f|0}z(Yb,"java.lang.Integer$",{Ob:1,d:1});var $b;function ac(){$b||($b=new Yb);return $b}function Eb(a){return"number"===typeof a||a instanceof n}function O(a,b){a.Ha=b;"[object Error]"!==Object.prototype.toString.call(a)&&(void 0===Error.captureStackTrace||Object.isSealed(a)?Error():Error.captureStackTrace(a))}
class bc extends Error{constructor(){super();this.Ha=null}ha(){return this.Ha}B(){var a=ba(this),b=this.ha();return null===b?a:a+": "+b}M(){return p.prototype.M.call(this)}L(a){return p.prototype.L.call(this,a)}get message(){var a=this.ha();return null===a?"":a}get name(){return ba(this)}toString(){return this.B()}}function cc(){var a=4294967296*+Math.random();return la(+Math.floor(a)-2147483648)}function dc(){}dc.prototype=new u;dc.prototype.constructor=dc;z(dc,"java.util.Random$",{ac:1,d:1});var fc;
function gc(a){if(null===a.ka)throw new hc("No match available");return a.ka}function ic(a,b){this.cb=a;this.bb=b;this.db=0;this.Ia=this.bb;this.Ja=0;this.ka=null}ic.prototype=new u;ic.prototype.constructor=ic;function jc(a){var b=a.cb;var c=a.Ia;var d=b.ra;d.lastIndex=a.Ja;c=d.exec(c);b=b.ra.lastIndex|0;a.Ja=null!==c?b===(c.index|0)?1+b|0:b:1+a.Ia.length|0;a.ka=c;return null!==c}function kc(a){return(gc(a).index|0)+a.db|0}function lc(a){return kc(a)+gc(a)[0].length|0}
z(ic,"java.util.regex.Matcher",{dc:1,cc:1});function mc(a,b,c,d,e){this.ra=null;this.hb=a;this.ib=d;this.jb=e;this.ra=new RegExp(c,this.ib+(this.jb?"gy":"g"));new RegExp("^(?:"+c+")$",d)}mc.prototype=new u;mc.prototype.constructor=mc;mc.prototype.B=function(){return this.hb};z(mc,"java.util.regex.Pattern",{ec:1,d:1});
function nc(){this.Ta=this.ca=0;oc=this;this.ca=ha("Seq");this.Ta=ha("Map");ha("Set");var a=pc(),b=this.Ta,c=0,d=0,e=0,f=1;for(a=a.G();a.p();){var g=a.w();g=K(L(),g);c=c+g|0;d^=g;f=Math.imul(f,1|g);e=1+e|0}b=M(b,c);b=M(b,d);b=Pb(b,f);N(b^e)}nc.prototype=new Ob;nc.prototype.constructor=nc;z(nc,"scala.util.hashing.MurmurHash3$",{mc:1,lc:1});var oc;class qc extends bc{}class rc extends bc{}function sc(){}sc.prototype=new u;sc.prototype.constructor=sc;function tc(){}tc.prototype=sc.prototype;
function uc(){this.ua=null;vc=this;this.ua=new P}uc.prototype=new u;uc.prototype.constructor=uc;z(uc,"scala.collection.Iterator$",{tc:1,sc:1,d:1});var vc;function wc(){vc||(vc=new uc);return vc}class Ya extends qc{constructor(a){super();O(this,""+a)}}z(Ya,"java.lang.AssertionError",{Bb:1,Ib:1,z:1,d:1});z(0,"java.lang.Boolean",{Cb:1,d:1,H:1,J:1},a=>"boolean"===typeof a);z(0,"java.lang.Character",{Eb:1,d:1,H:1,J:1},a=>a instanceof m);class Q extends rc{}
z(Q,"java.lang.RuntimeException",{E:1,D:1,z:1,d:1});function xc(a){a.h="";return a}function R(){this.h=null}R.prototype=new u;R.prototype.constructor=R;R.prototype.B=function(){return this.h};R.prototype.A=function(){return this.h.length};z(R,"java.lang.StringBuilder",{Tb:1,Aa:1,zb:1,d:1});function S(){}S.prototype=new u;S.prototype.constructor=S;function yc(){}yc.prototype=S.prototype;S.prototype.G=function(){return this};S.prototype.B=function(){return"\x3citerator\x3e"};
S.prototype.ya=function(a,b,c,d){return Bb(this,a,b,c,d)};function zc(a,b){var c=a.N();if(-1!==c){var d=b.N();c=-1!==d&&c!==d}else c=!1;if(c)b=!1;else a:{a=a.G();for(b=b.G();a.p()&&b.p();)if(!Db(Ib(),a.w(),b.w())){b=!1;break a}b=a.p()===b.p()}return b}class ka extends Q{constructor(a){super();O(this,a)}}z(ka,"java.lang.ArithmeticException",{Ab:1,E:1,D:1,z:1,d:1});z(0,"java.lang.Byte",{Db:1,V:1,d:1,H:1,J:1},a=>"number"===typeof a&&a<<24>>24===a&&1/a!==1/-0);
function qb(a){var b=new Ac;O(b,a);return b}class Ac extends Q{}z(Ac,"java.lang.IllegalArgumentException",{Fa:1,E:1,D:1,z:1,d:1});class hc extends Q{constructor(a){super();O(this,a)}}z(hc,"java.lang.IllegalStateException",{Lb:1,E:1,D:1,z:1,d:1});class Bc extends Q{constructor(a){super();O(this,a)}}z(Bc,"java.lang.IndexOutOfBoundsException",{Mb:1,E:1,D:1,z:1,d:1});class Cc extends Q{constructor(){super();O(this,null)}}z(Cc,"java.lang.NullPointerException",{Qb:1,E:1,D:1,z:1,d:1});
z(0,"java.lang.Short",{Sb:1,V:1,d:1,H:1,J:1},a=>"number"===typeof a&&a<<16>>16===a&&1/a!==1/-0);class Dc extends Q{constructor(a){super();O(this,a)}}z(Dc,"java.lang.UnsupportedOperationException",{Vb:1,E:1,D:1,z:1,d:1});class Ec extends Q{constructor(a){super();O(this,a)}}z(Ec,"java.util.NoSuchElementException",{Zb:1,E:1,D:1,z:1,d:1});
function T(a){this.e=null;this.c=0;this.i=null;this.t=0;this.x=!1;this.ab=a;fc||(fc=new dc);var b=cc();b=new n(cc(),b);Fc(this,b);this.e=null;this.c=0;this.i=null;this.t=0;this.x=!1;Fc(this,a)}T.prototype=new tc;T.prototype.constructor=T;function Fc(a,b){a.x=!1;a.t=0;a.e=new w(624);a.i=new w(2);a.i.a[0]=0;a.i.a[1]=-1727483681;a.e.a[0]=b.j;for(a.c=1;624>a.c;){a.e.a[a.c]=Math.imul(1812433253,a.e.a[-1+a.c|0]^(a.e.a[-1+a.c|0]>>>30|0))+a.c|0;b=a.e;var c=a.c;b.a[c]=b.a[c];a.c=1+a.c|0}}
T.prototype.nextDouble=function(){if(624<=this.c){var a=0;for(var b=this.e,c=this.i;227>a;){var d=-2147483648&b.a[a]|2147483647&b.a[1+a|0];b.a[a]=b.a[397+a|0]^(d>>>1|0)^c.a[1&d];a=1+a|0}for(;623>a;)d=-2147483648&b.a[a]|2147483647&b.a[1+a|0],b.a[a]=b.a[-227+a|0]^(d>>>1|0)^c.a[1&d],a=1+a|0;d=-2147483648&b.a[623]|2147483647&b.a[0];b.a[623]=b.a[396]^(d>>>1|0)^c.a[1&d];this.c=0}d=this.e;this.c=1+this.c|0;d=d.a[-1+this.c|0];d^=d>>>11|0;d^=-1658038656&d<<7;d^=-272236544&d<<15;if(624<=this.c){b=0;c=this.e;
for(var e=this.i;227>b;)a=-2147483648&c.a[b]|2147483647&c.a[1+b|0],c.a[b]=c.a[397+b|0]^(a>>>1|0)^e.a[1&a],b=1+b|0;for(;623>b;)a=-2147483648&c.a[b]|2147483647&c.a[1+b|0],c.a[b]=c.a[-227+b|0]^(a>>>1|0)^e.a[1&a],b=1+b|0;a=-2147483648&c.a[623]|2147483647&c.a[0];c.a[623]=c.a[396]^(a>>>1|0)^e.a[1&a];this.c=0}a=this.e;this.c=1+this.c|0;a=a.a[-1+this.c|0];a^=a>>>11|0;a^=-1658038656&a<<7;a^=-272236544&a<<15;b=(d^(d>>>18|0))>>>6|0;d=b<<27;b=b>>>5|0|b>>31<<27;c=(a^(a>>>18|0))>>>5|0;a=c>>31;c=d+c|0;return J(I(),
c,(-2147483648^c)<(-2147483648^d)?1+(b+a|0)|0:b+a|0)/9007199254740992};
T.prototype.load=function(a){F();var b=new lb("\\s",0);0!==(256&b.f)&&(b.f|=64);var c=0!==(16&b.f);if(!c){var d=F().Ra.exec(b.k);if(null!==d){var e=d[1];if(void 0!==e)for(var f=e.length,g=0;g<f;){var h=g;b.f|=pb(F(),e.charCodeAt(h));g=1+g|0}0!==(256&b.f)&&(b.f|=64);e=d[2];if(void 0!==e)for(f=e.length,g=0;g<f;)h=g,b.f&=~pb(F(),e.charCodeAt(h)),g=1+g|0;b.b=b.b+d[0].length|0}}0!==(128&b.f)&&B(b,"CANON_EQ is not supported");0!==(8&b.f)&&Za(b,"MULTILINE");0!==(256&b.f)&&Za(b,"UNICODE_CHARACTER_CLASS");
c?c=Pa(b,b.k):("\\G"===b.k.substring(b.b,2+b.b|0)&&(b.qa=!0,b.b=2+b.b|0),c=kb(b,!1));d=F().oa?"us":"u";b=new mc(b.k,b.f,c,66===(66&b.f)?d+"i":d,b.qa,-1+(b.r.length|0)|0,b.r,b.ba);if(""===a)a=new (Aa().W)([""]);else{c=new ic(b,a);b=[];for(d=0;2147483646>(b.length|0)&&jc(c);)0!==lc(c)&&(e=kc(c),b.push(a.substring(d,e))),d=lc(c);b.push(a.substring(d));for(c=b.length|0;;)if(0!==c?(a=b[-1+c|0],a=null!==a&&ea(a,"")):a=!1,a)c=-1+c|0;else break;a=new (Aa().W)(c);for(d=0;d<c;)e=d,a.a[e]=b[e],d=1+d|0}b=a.a[0];
if("0"!==b)throw a=new Q,O(a,'identifier mismatch: expected "0", got "'+b+'"'),a;this.i.a[0]=Zb(ac(),a.a[1]);this.i.a[1]=Zb(ac(),a.a[2]);this.c=Zb(ac(),a.a[3]);Wb||(Wb=new Vb);b=Wb;d=a.a[4];0===(1&b.I)<<24>>24&&0===(1&b.I)<<24>>24&&(b.Da=RegExp("^[\\x00-\\x20]*([+-]?(?:NaN|Infinity|(?:\\d+\\.?\\d*|\\.\\d+)(?:[eE][+-]?\\d+)?)[fFdD]?)[\\x00-\\x20]*$"),b.I=(1|b.I)<<24>>24);c=b.Da.exec(d);if(null!==c)b=+parseFloat(c[1]);else{0===(2&b.I)<<24>>24&&0===(2&b.I)<<24>>24&&(b.Ca=RegExp("^[\\x00-\\x20]*([+-]?)0[xX]([0-9A-Fa-f]*)\\.?([0-9A-Fa-f]*)[pP]([+-]?\\d+)[fFdD]?[\\x00-\\x20]*$"),
b.I=(2|b.I)<<24>>24);c=b.Ca.exec(d);null===c&&Tb(d);b=c[1];f=c[2];e=c[3];c=c[4];""===f&&""===e&&Tb(d);f=""+f+e;d=-(e.length<<2)|0;for(e=0;e!==f.length&&48===f.charCodeAt(e);)e=1+e|0;e=f.substring(e);if(""===e)c=0;else{g=e.length;if(f=15<g){h=!1;for(var l=15;!h&&l!==g;)48!==e.charCodeAt(l)&&(h=!0),l=1+l|0;g=h?"1":"0";g=e.substring(0,15)+g}else g=e;e=d+(f?(e.length-16|0)<<2:0)|0;d=+parseInt(g,16);c=+parseInt(c,10);c=la(c)+e|0;e=c/3|0;f=+Math.pow(2,e);c=d*f*f*+Math.pow(2,c-(e<<1)|0)}b="-"===b?-c:c}this.t=
b;b=a.a[5];if("true"===b)this.x=!0;else if("false"===b)this.x=!1;else throw a=new Q,O(a,'expected true or false, got "'+b+'"'),a;for(b=0;624>b;)this.e.a[b]=Zb(ac(),a.a[6+b|0]),b=1+b|0;if(a.a.length>(6+b|0))throw Kb||(Kb=new Jb),new Ya("assertion failed");};T.prototype.clone=function(){var a=new T(this.ab);a.e=this.e.v();a.c=this.c;a.i=this.i.v();a.t=this.t;a.x=this.x;return a};T.prototype.setSeed=function(a){a|=0;Fc(this,new n(a,a>>31))};
T.prototype.save=function(){var a="0 "+this.i.a[0]+" "+this.i.a[1]+" "+this.c+" "+(this.t===la(this.t)?this.t+".0":this.t)+" "+this.x,b=new U,c=new R;xc(c);if(null===a)throw new Cc;c.h=a;b.s=c;for(a=0;624>a;)c=b.s,c.h=""+c.h+" ",c=b.s,c.h=""+c.h+(""+this.e.a[a]),a=1+a|0;return b.s.h};
T.prototype.nextInt=function(...a){switch(a.length|0){case 0:if(624<=this.c){for(var b=0,c=this.e,d=this.i;227>b;)a=-2147483648&c.a[b]|2147483647&c.a[1+b|0],c.a[b]=c.a[397+b|0]^(a>>>1|0)^d.a[1&a],b=1+b|0;for(;623>b;)a=-2147483648&c.a[b]|2147483647&c.a[1+b|0],c.a[b]=c.a[-227+b|0]^(a>>>1|0)^d.a[1&a],b=1+b|0;a=-2147483648&c.a[623]|2147483647&c.a[0];c.a[623]=c.a[396]^(a>>>1|0)^d.a[1&a];this.c=0}a=this.e;this.c=1+this.c|0;a=a.a[-1+this.c|0];a^=a>>>11|0;a^=-1658038656&a<<7;a^=-272236544&a<<15;return a^
(a>>>18|0);case 1:a=a[0]|0;if(0>=a)throw qb("n must be positive");if((a&(-a|0))===a){if(624<=this.c){b=0;d=this.e;for(var e=this.i;227>b;)c=-2147483648&d.a[b]|2147483647&d.a[1+b|0],d.a[b]=d.a[397+b|0]^(c>>>1|0)^e.a[1&c],b=1+b|0;for(;623>b;)c=-2147483648&d.a[b]|2147483647&d.a[1+b|0],d.a[b]=d.a[-227+b|0]^(c>>>1|0)^e.a[1&c],b=1+b|0;c=-2147483648&d.a[623]|2147483647&d.a[0];d.a[623]=d.a[396]^(c>>>1|0)^e.a[1&c];this.c=0}b=this.e;this.c=1+this.c|0;c=b.a[-1+this.c|0];c^=c>>>11|0;c^=-1658038656&c<<7;c^=-272236544&
c<<15;b=a>>31;c=(c^(c>>>18|0))>>>1|0;d=c>>31;var f=65535&a;e=a>>>16|0;var g=65535&c,h=c>>>16|0,l=Math.imul(f,g);g=Math.imul(e,g);f=Math.imul(f,h);var q=(l>>>16|0)+f|0;a=(l+((g+f|0)<<16)|0)>>>31|0|((((Math.imul(a,d)+Math.imul(b,c)|0)+Math.imul(e,h)|0)+(q>>>16|0)|0)+(((65535&q)+g|0)>>>16|0)|0)<<1}else{b=0;for(c=!0;c;){if(624<=this.c){c=0;d=this.e;for(e=this.i;227>c;)b=-2147483648&d.a[c]|2147483647&d.a[1+c|0],d.a[c]=d.a[397+c|0]^(b>>>1|0)^e.a[1&b],c=1+c|0;for(;623>c;)b=-2147483648&d.a[c]|2147483647&
d.a[1+c|0],d.a[c]=d.a[-227+c|0]^(b>>>1|0)^e.a[1&b],c=1+c|0;b=-2147483648&d.a[623]|2147483647&d.a[0];d.a[623]=d.a[396]^(b>>>1|0)^e.a[1&b];this.c=0}b=this.e;this.c=1+this.c|0;b=b.a[-1+this.c|0];b^=b>>>11|0;b^=-1658038656&b<<7;b^=-272236544&b<<15;b^=b>>>18|0;c=b>>>1|0;b=ja(c,a);c=0>((c-b|0)+(-1+a|0)|0)}a=b}return a;default:throw new TypeError("No matching overload");}};
T.prototype.nextLong=function(a){a=+a;var b=I();a=new n(yb(b,a),b.l);b=a.m;if(0===b?0===a.j:0>b)throw qb("n must be positive");var c,d,e=b=0;for(c=!0;c;){if(624<=this.c){e=0;c=this.e;for(d=this.i;227>e;)b=-2147483648&c.a[e]|2147483647&c.a[1+e|0],c.a[e]=c.a[397+e|0]^(b>>>1|0)^d.a[1&b],e=1+e|0;for(;623>e;)b=-2147483648&c.a[e]|2147483647&c.a[1+e|0],c.a[e]=c.a[-227+e|0]^(b>>>1|0)^d.a[1&b],e=1+e|0;b=-2147483648&c.a[623]|2147483647&c.a[0];c.a[623]=c.a[396]^(b>>>1|0)^d.a[1&b];this.c=0}b=this.e;this.c=1+
this.c|0;b=b.a[-1+this.c|0];b^=b>>>11|0;b^=-1658038656&b<<7;b^=-272236544&b<<15;b^=b>>>18|0;if(624<=this.c){c=0;d=this.e;for(var f=this.i;227>c;)e=-2147483648&d.a[c]|2147483647&d.a[1+c|0],d.a[c]=d.a[397+c|0]^(e>>>1|0)^f.a[1&e],c=1+c|0;for(;623>c;)e=-2147483648&d.a[c]|2147483647&d.a[1+c|0],d.a[c]=d.a[-227+c|0]^(e>>>1|0)^f.a[1&e],c=1+c|0;e=-2147483648&d.a[623]|2147483647&d.a[0];d.a[623]=d.a[396]^(e>>>1|0)^f.a[1&e];this.c=0}e=this.e;this.c=1+this.c|0;e=e.a[-1+this.c|0];e^=e>>>11|0;e^=-1658038656&e<<
7;e^=-272236544&e<<15;e^=e>>>18|0;c=b;b=c>>>1|0;c=e>>>1|0|c<<31;d=b;e=c;f=d;b=I();e=zb(b,e,f,a.j,a.m);f=b.l;b=e;e=f;f=c;var g=e;c=f-b|0;d=(-2147483648^c)>(-2147483648^f)?-1+(d-g|0)|0:d-g|0;g=a.m;f=-1+a.j|0;g=-1!==f?g:-1+g|0;c=0>((-2147483648^(c+f|0))<(-2147483648^c)?1+(d+g|0)|0:d+g|0)}a=new n(b,e);return J(I(),a.j,a.m)};
T.prototype.nextGaussian=function(){if(this.x){this.x=!1;var a=this.t}else{for(var b=a=0,c=0,d=!0;d;){if(624<=this.c){b=0;c=this.e;for(d=this.i;227>b;)a=-2147483648&c.a[b]|2147483647&c.a[1+b|0],c.a[b]=c.a[397+b|0]^(a>>>1|0)^d.a[1&a],b=1+b|0;for(;623>b;)a=-2147483648&c.a[b]|2147483647&c.a[1+b|0],c.a[b]=c.a[-227+b|0]^(a>>>1|0)^d.a[1&a],b=1+b|0;a=-2147483648&c.a[623]|2147483647&c.a[0];c.a[623]=c.a[396]^(a>>>1|0)^d.a[1&a];this.c=0}a=this.e;this.c=1+this.c|0;a=a.a[-1+this.c|0];a^=a>>>11|0;a^=-1658038656&
a<<7;a^=-272236544&a<<15;a^=a>>>18|0;if(624<=this.c){c=0;d=this.e;for(var e=this.i;227>c;)b=-2147483648&d.a[c]|2147483647&d.a[1+c|0],d.a[c]=d.a[397+c|0]^(b>>>1|0)^e.a[1&b],c=1+c|0;for(;623>c;)b=-2147483648&d.a[c]|2147483647&d.a[1+c|0],d.a[c]=d.a[-227+c|0]^(b>>>1|0)^e.a[1&b],c=1+c|0;b=-2147483648&d.a[623]|2147483647&d.a[0];d.a[623]=d.a[396]^(b>>>1|0)^e.a[1&b];this.c=0}b=this.e;this.c=1+this.c|0;b=b.a[-1+this.c|0];b^=b>>>11|0;b^=-1658038656&b<<7;b^=-272236544&b<<15;b^=b>>>18|0;if(624<=this.c){d=0;e=
this.e;for(var f=this.i;227>d;)c=-2147483648&e.a[d]|2147483647&e.a[1+d|0],e.a[d]=e.a[397+d|0]^(c>>>1|0)^f.a[1&c],d=1+d|0;for(;623>d;)c=-2147483648&e.a[d]|2147483647&e.a[1+d|0],e.a[d]=e.a[-227+d|0]^(c>>>1|0)^f.a[1&c],d=1+d|0;c=-2147483648&e.a[623]|2147483647&e.a[0];e.a[623]=e.a[396]^(c>>>1|0)^f.a[1&c];this.c=0}c=this.e;this.c=1+this.c|0;c=c.a[-1+this.c|0];c^=c>>>11|0;c^=-1658038656&c<<7;c^=-272236544&c<<15;c^=c>>>18|0;if(624<=this.c){f=this.e;var g=this.i;for(e=0;227>e;)d=-2147483648&f.a[e]|2147483647&
f.a[1+e|0],f.a[e]=f.a[397+e|0]^(d>>>1|0)^g.a[1&d],e=1+e|0;for(;623>e;)d=-2147483648&f.a[e]|2147483647&f.a[1+e|0],f.a[e]=f.a[-227+e|0]^(d>>>1|0)^g.a[1&d],e=1+e|0;d=-2147483648&f.a[623]|2147483647&f.a[0];f.a[623]=f.a[396]^(d>>>1|0)^g.a[1&d];this.c=0}d=this.e;this.c=1+this.c|0;d=d.a[-1+this.c|0];d^=d>>>11|0;d^=-1658038656&d<<7;d^=-272236544&d<<15;d^=d>>>18|0;e=a>>>6|0;a=e<<27;e=e>>>5|0|e>>31<<27;f=b>>>5|0;b=f>>31;f=a+f|0;a=2*(J(I(),f,(-2147483648^f)<(-2147483648^a)?1+(e+b|0)|0:e+b|0)/9007199254740992)-
1;c=c>>>6|0;b=c<<27;c=c>>>5|0|c>>31<<27;e=d>>>5|0;d=e>>31;e=b+e|0;b=2*(J(I(),e,(-2147483648^e)<(-2147483648^b)?1+(c+d|0)|0:c+d|0)/9007199254740992)-1;c=a*a+b*b;d=1<=c||0===c}d=ub();e=ub();f=c;c=-2*+rb(e).log(f)/c;c=+rb(d).sqrt(c);this.t=b*c;this.x=!0;a*=c}return a};z(T,"org.nlogo.tortoise.engine.MersenneTwisterFast",{ub:1,$b:1,bc:1,d:1,ja:1});function P(){}P.prototype=new yc;P.prototype.constructor=P;P.prototype.p=function(){return!1};P.prototype.N=function(){return 0};
P.prototype.w=function(){throw new Ec("next on empty iterator");};z(P,"scala.collection.Iterator$$anon$19",{uc:1,mb:1,rb:1,da:1,ea:1});function ia(a){return Fa(Ga(),a)}z(0,"java.lang.Double",{Gb:1,V:1,d:1,H:1,J:1,$:1},a=>"number"===typeof a);z(0,"java.lang.Float",{Jb:1,V:1,d:1,H:1,J:1,$:1},a=>da(a));z(0,"java.lang.Integer",{Nb:1,V:1,d:1,H:1,J:1,$:1},a=>ca(a));z(0,"java.lang.Long",{Pb:1,V:1,d:1,H:1,J:1,$:1},a=>a instanceof n);class Ub extends Ac{constructor(a){super();O(this,a)}}
z(Ub,"java.lang.NumberFormatException",{Rb:1,Fa:1,E:1,D:1,z:1,d:1});function C(a,b){return a.codePointAt(b)|0}function ha(a){for(var b=0,c=1,d=-1+a.length|0;0<=d;)b=b+Math.imul(a.charCodeAt(d),c)|0,c=Math.imul(31,c),d=-1+d|0;return b}var Ba=z(0,"java.lang.String",{xb:1,d:1,H:1,Aa:1,J:1,$:1},a=>"string"===typeof a);
class Oa extends Ac{constructor(a,b,c){super();this.eb=a;this.gb=b;this.fb=c;O(this,null)}ha(){var a=this.fb,b=this.gb,c=this.eb+(0>a?"":" near index "+a)+"\n"+b;if(0<=a&&null!==b&&a<b.length){if(0>a)throw c=new Ac,O(c,null),c;a=" ".repeat(a);c=c+"\n"+a+"^"}return c}}z(Oa,"java.util.regex.PatternSyntaxException",{jc:1,Fa:1,E:1,D:1,z:1,d:1});function Gc(){}Gc.prototype=new u;Gc.prototype.constructor=Gc;function Hc(){}Hc.prototype=Gc.prototype;Gc.prototype.za=function(){return this.ga()};
Gc.prototype.ya=function(a,b,c,d){return Bb(this,a,b,c,d)};function V(a){this.P=0;this.qb=a;this.ta=0;this.P=a.A()}V.prototype=new yc;V.prototype.constructor=V;V.prototype.N=function(){return this.P};V.prototype.p=function(){return 0<this.P};V.prototype.w=function(){if(0<this.P){var a=this.qb.C(this.ta);this.ta=1+this.ta|0;this.P=-1+this.P|0;return a}return wc().ua.w()};z(V,"scala.collection.IndexedSeqView$IndexedSeqViewIterator",{rc:1,mb:1,rb:1,da:1,ea:1,d:1});function Ic(){}Ic.prototype=new Hc;
Ic.prototype.constructor=Ic;function Jc(){}Jc.prototype=Ic.prototype;Ic.prototype.B=function(){return this.ga()+"(\x3cnot computed\x3e)"};function W(){}W.prototype=new Hc;W.prototype.constructor=W;function Kc(){}Kc.prototype=W.prototype;W.prototype.L=function(a){return this===a?!0:a&&a.$classData&&a.$classData.u.va?this.sa(a):!1};
W.prototype.M=function(){oc||(oc=new nc);var a=oc;if(this&&this.$classData&&this.$classData.u.ob)a:{a=a.ca;var b=this.A();switch(b){case 0:a=N(a^0);break a;case 1:a=N(M(a,K(L(),this.C(0)))^1);break a;default:var c=K(L(),this.C(0)),d=a=M(a,c),e=K(L(),this.C(1));c=e-c|0;for(var f=2;f<b;){a=M(a,e);var g=K(L(),this.C(f));if(c!==(g-e|0)||0===c){a=M(a,g);for(f=1+f|0;f<b;)a=M(a,K(L(),this.C(f))),f=1+f|0;a=N(a^b);break a}e=g;f=1+f|0}a=N(M(M(d,c),e))}}else if(this instanceof Lc){for(a=a.ca;!this.n();)Mc();
a=N(a^0)}else a:if(b=a.ca,a=this.G(),a.p())if(d=a.w(),a.p()){e=a.w();c=K(L(),d);d=b=M(b,c);e=K(L(),e);c=e-c|0;for(f=2;a.p();){b=M(b,e);g=K(L(),a.w());if(c!==(g-e|0)||0===c){b=M(b,g);for(f=1+f|0;a.p();)b=M(b,K(L(),a.w())),f=1+f|0;a=N(b^f);break a}e=g;f=1+f|0}a=N(M(M(d,c),e))}else a=N(M(b,K(L(),d))^1);else a=N(b^0);return a};W.prototype.B=function(){var a=this.za()+"(";if(0===this.N())a=""+a+")";else{var b=this.ya,c=new U;c.s=xc(new R);a=b.call(this,c,a,", ",")").s.h}return a};
W.prototype.sa=function(a){return zc(this,a)};function Nc(){}Nc.prototype=new Jc;Nc.prototype.constructor=Nc;function Oc(){}Oc.prototype=Nc.prototype;function X(){this.fa=null}X.prototype=new Oc;X.prototype.constructor=X;function Pc(){}Pc.prototype=X.prototype;X.prototype.C=function(a){return this.fa.C(a)};X.prototype.A=function(){return this.fa.A()};X.prototype.n=function(){return this.fa.n()};function Y(a){this.fa=a}Y.prototype=new Pc;Y.prototype.constructor=Y;Y.prototype.G=function(){return new V(this)};
Y.prototype.ga=function(){return"IndexedSeqView"};Y.prototype.N=function(){return this.A()};z(Y,"scala.collection.IndexedSeqView$Id",{qc:1,xc:1,nc:1,oc:1,Ua:1,Va:1,da:1,Xa:1,ea:1,Wa:1,Bc:1,d:1,wc:1,Ya:1,pc:1,pb:1});function Qc(){}Qc.prototype=new Kc;Qc.prototype.constructor=Qc;function Sc(){}Sc.prototype=Qc.prototype;function Tc(){}Tc.prototype=new Kc;Tc.prototype.constructor=Tc;function Uc(){}Uc.prototype=Tc.prototype;function Lc(){}Lc.prototype=new Sc;Lc.prototype.constructor=Lc;
function Vc(){}k=Vc.prototype=Lc.prototype;k.ga=function(){return"LinearSeq"};k.C=function(a){if(0>a)throw new Bc(""+a);a:for(var b=a,c=this;;){if(0>=b||c.n())break a;b=-1+b|0;Wc();c=void 0}if(c.n())throw new Bc(""+a);Mc()};k.sa=function(a){var b;if(a&&a.$classData&&a.$classData.u.sb)a:for(b=this;;){if(b===a){b=!0;break a}var c;(c=b.n()||a.n())||(Ib(),Mc(),Mc(),c=!Db(0,void 0,void 0));if(c){b=b.n()&&a.n();break a}Wc();Wc();a=b=void 0}else b=zc(this,a);return b};k.n=function(){return this===pc()};
k.A=function(){for(var a=0;!this.n();)a=1+a|0,Wc();return a};k.za=function(){return"List"};k.L=function(a){if(a instanceof Lc)a:for(;;){if(this===a){var b=!0;break a}b=this.n();a=a.n();b=b||a||!Db(Ib(),Mc(),Mc())?b&&a:Wc();break a}else b=this===a?!0:a&&a.$classData&&a.$classData.u.va?this.sa(a):!1;return b};function Z(){}Z.prototype=new Vc;Z.prototype.constructor=Z;function Mc(){throw new Ec("head of empty list");}function Wc(){throw new Dc("tail of empty list");}Z.prototype.N=function(){return 0};
Z.prototype.G=function(){return wc().ua};z(Z,"scala.collection.immutable.Nil$",{Ic:1,Hc:1,Dc:1,nb:1,Ua:1,Va:1,da:1,Xa:1,ea:1,Wa:1,va:1,lb:1,$a:1,Ya:1,kb:1,Jc:1,Ec:1,Kc:1,Fc:1,sb:1,vc:1,Gc:1,zc:1,Ac:1,yc:1,Lc:1,Cc:1,d:1,kc:1});var Xc;function pc(){Xc||(Xc=new Z);return Xc}function U(){this.s=null}U.prototype=new Uc;U.prototype.constructor=U;k=U.prototype;k.ga=function(){return"IndexedSeq"};k.G=function(){return new V(new Y(this))};k.A=function(){return this.s.A()};k.N=function(){return this.s.A()};
k.B=function(){return this.s.h};k.n=function(){return 0===this.s.A()};k.C=function(a){return new m(this.s.h.charCodeAt(a))};z(U,"scala.collection.mutable.StringBuilder",{Xc:1,Mc:1,nb:1,Ua:1,Va:1,da:1,Xa:1,ea:1,Wa:1,va:1,lb:1,$a:1,Ya:1,kb:1,Vc:1,Tc:1,Wc:1,Pc:1,ja:1,Uc:1,Nc:1,Qc:1,Oc:1,Rc:1,ob:1,pb:1,Sc:1,Aa:1,d:1});aa=new n(0,0);Ca.Za=aa;MersenneTwisterFast=function(...a){if(void 0===a[0]){a=I();Ia||(Ia=new Ha);var b=yb(a,1E6*+(0,Ia.Ga)());a=new n(b,a.l)}else a=r(a[0]);return new T(new n(a.j,a.m))};
}).call(this);


  module.exports = {
    MersenneTwisterFast: MersenneTwisterFast
  };

}).call(this);
},{}],"shim/random":[function(require,module,exports){
(function (global){(function (){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  /*
  On the JVM, we use Headless' MersenneTwisterFast.
  In the browser, we use a ScalaJS implementation of it.
  We can't the ScalaJS implementation in both environments,
  because MTF relies on bit-shifting, and JVM integers have
  a different number of bits than JS integers, leading to
  different results.
  */
  var MersenneTwisterFast, getRandomSeedInt, newMersenneTwister;

  ({MersenneTwisterFast} = require('./engine-scala'));

  getRandomSeedInt = function() {
    return global.crypto.getRandomValues(new Int32Array(1))[0];
  };

  newMersenneTwister = function() {
    return new MersenneTwisterFast(getRandomSeedInt());
  };

  module.exports = {newMersenneTwister, getRandomSeedInt};

}).call(this);

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./engine-scala":"shim/engine-scala"}],"shim/strictmath":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Cloner, genEnhancedMath;

  Cloner = require('./cloner');

  // We use this outside of GraalJS --JAB (4/10/15) / JMB (11/18)
  genEnhancedMath = function() {
    var obj;
    obj = Cloner(Math);
    // For functions that are not "close enough," or that don't exist in the browser, manually define them here!
    obj.toRadians = function(degrees) {
      return degrees * Math.PI / 180;
    };
    obj.toDegrees = function(radians) {
      return radians * 180 / Math.PI;
    };
    obj.PI = function() {
      return Math.PI; // Scala forces it to be a function in Nashorn, so it's a function here --JAB (4/8/15)
    };
    return obj;
  };

  module.exports = genEnhancedMath();

}).call(this);

},{"./cloner":"shim/cloner"}],"util/abstractmethoderror":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var exceptions;

  ({
    exceptionFactory: exceptions
  } = require('util/exception'));

  // (String) => Nothing
  module.exports = function(msg) {
    throw exceptions.internal(`Illegal method call: \`${msg}\` is abstract`);
  };

}).call(this);

},{"util/exception":"util/exception"}],"util/comparator":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  module.exports = {
    NOT_EQUALS: {},
    // type Comparison = { toInt: Number }
    EQUALS: {
      toInt: 0
    },
    GREATER_THAN: {
      toInt: 1
    },
    LESS_THAN: {
      toInt: -1
    },
    // (Number, Number) => Comparison
    numericCompare: function(x, y) {
      if (x < y) {
        return this.LESS_THAN;
      } else if (x > y) {
        return this.GREATER_THAN;
      } else {
        return this.EQUALS;
      }
    },
    // (String, String) => Comparison
    stringCompare: function(x, y) {
      var comparison;
      comparison = x.localeCompare(y);
      if (comparison < 0) {
        return this.LESS_THAN;
      } else if (comparison > 0) {
        return this.GREATER_THAN;
      } else {
        return this.EQUALS;
      }
    }
  };

}).call(this);

},{}],"util/exception":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var ExceptionFactory, ExtensionException, HaltInterrupt, InternalException, NetLogoException, None, RuntimeException, factory, fold, maybe;

  ({fold, maybe, None} = require('brazierjs/maybe'));

  NetLogoException = class NetLogoException {
    constructor(message1, stackTrace1 = [], stackTraceMessage1 = "") {
      this.message = message1;
      this.stackTrace = stackTrace1;
      this.stackTraceMessage = stackTraceMessage1;
    }

  };

  HaltInterrupt = class HaltInterrupt extends NetLogoException {
    constructor() {
      super("model halted by user");
    }

  };

  // Used by extensions to represent typical runtime errors. -Jeremy B March 2021
  ExtensionException = class ExtensionException extends NetLogoException {
    constructor(message, stackTrace, stackTraceMessage) {
      super(`Extension exception: ${message}`, stackTrace, stackTraceMessage);
    }

  };

  // Meant to represent truly exceptional, unexpected circumstances internal to the engine.
  // Possibly caused by malformed state or by bugs.  -Jeremy B March 2021
  InternalException = class InternalException extends NetLogoException {};

  // Represents typical, expected runtime errors in the engine, like dividing by zero
  // or using `ask` on nobody, etc.  -Jeremy B March 2021
  RuntimeException = class RuntimeException extends NetLogoException {
    constructor(message, primitive1, stackTrace, stackTraceMessage, sourceStart1, sourceEnd1, messageKey1) {
      super(message, stackTrace, stackTraceMessage);
      this.primitive = primitive1;
      this.sourceStart = sourceStart1;
      this.sourceEnd = sourceEnd1;
      this.messageKey = messageKey1;
    }

  };

  ExceptionFactory = (function() {
    class ExceptionFactory {
      // (ProcedurePrims) => Unit
      setProcecurePrims(procedurePrims) {
        return this.procedurePrims = maybe(procedurePrims);
      }

      // (String) => String
      getStackTrace() {
        return fold(function() {
          return [];
        })(function(procs) {
          return procs.stack().trace();
        })(this.procedurePrims);
      }

      // (Array[{ type: String, name: String }]) => String
      makeStackTraceMessage(frames, primitive = "") {
        var messages, stack, start;
        start = `error while running ${primitive === "" ? "a primitive" : primitive.toUpperCase()}`;
        messages = frames.map(function(frame) {
          switch (frame.type) {
            case "command":
              return `called by procedure ${frame.name.toUpperCase()}`;
            case "reporter":
              return `called by procedure ${frame.name.toUpperCase()}`;
            case "plot":
              return `called by plot ${frame.name}`;
            default:
              return `called by ${frame.type}`;
          }
        });
        stack = messages.join("\n");
        if (stack !== "") {
          return `${start}\n${stack}`;
        } else {
          return start;
        }
      }

      // (String) => ExtensionException
      extension(message) {
        var stackFrames, stackTraceMessage;
        stackFrames = this.getStackTrace();
        stackTraceMessage = this.makeStackTraceMessage(stackFrames);
        return new ExtensionException(message, stackFrames, stackTraceMessage);
      }

      // () => HaltInterrupt
      halt() {
        return new HaltInterrupt();
      }

      // (String) => InternalException
      internal(message) {
        var stackFrames, stackTraceMessage;
        stackFrames = this.getStackTrace();
        stackTraceMessage = this.makeStackTraceMessage(stackFrames);
        return new InternalException(message, stackFrames, stackTraceMessage);
      }

      // (String, String, Maybe[Int], Maybe[Int]) => RuntimeException
      // Most of the existing call to this function have not been changed to i18n + messageKey.
      // They should be gradually switched to validator.error(). - JC 02/11/23
      runtime(message, primitive, sourceStart = None, sourceEnd = None, messageKey = None) {
        var stackFrames, stackTraceMessage;
        stackFrames = this.getStackTrace();
        stackTraceMessage = this.makeStackTraceMessage(stackFrames, primitive);
        return new RuntimeException(message, primitive, stackFrames, stackTraceMessage, sourceStart, sourceEnd, messageKey);
      }

    };

    // Having `procedurePrims` be unset and then letting the `ExceptionFactory`
    // instance essentially be a singleton means this is static/global, mutable state.
    // It's not my favorite way to handle this, but there are too many places where
    // exceptions are needed in the engine that are also essentially static
    // (`ColorModel` and the import/export code as examples) and I don't want to
    // refactor everything just to have this value available at runtime.
    // -Jeremy B March 2021
    ExceptionFactory.procedurePrims = None;

    return ExceptionFactory;

  }).call(this);

  factory = new ExceptionFactory();

  module.exports = {
    exceptionFactory: factory,
    ExtensionException,
    HaltInterrupt,
    InternalException,
    RuntimeException
  };

}).call(this);

},{"brazierjs/maybe":"brazier/maybe"}],"util/formatfloat":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var MAX_NETLOGO_INT, formatFloat;

  MAX_NETLOGO_INT = 9007199254740992;

  // (Number) => String
  formatFloat = function(num) {
    var base, maybeBase;
    // Java always includes the decimal point, so `1e+38` in JS is `1.0E38` in Java.  We can't always do
    // `toExponential(1)` as then we'd truncate things like `1.222E38` to `1.2E38`.  -Jeremy B November 2020
    base = num > MAX_NETLOGO_INT || num < -MAX_NETLOGO_INT || ((0 < num && num < 1e-3)) || ((0 > num && num > -1e-3)) ? (maybeBase = num.toExponential(), maybeBase.includes('.') ? maybeBase : num.toExponential(1)) : num.toString(); // These negative exponent numbers are when Java will switch to scientific notation --JAB (12/25/17)
    return base.replace(/e\+?/, 'E'); // Java stringifies scientific notation with 'E' and 'E-', while JS uses 'e+' and 'e-'. --JAB (12/25/17)
  };

  module.exports = formatFloat;

}).call(this);

},{}],"util/interrupts":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var DeathInterrupt, StopInterrupt, TopologyInterrupt, TowardsInterrupt, ifInterrupt, interrupts;

  DeathInterrupt = Object.freeze({
    _debugInfo: "THE-DEATH-INTERRUPT"
  });

  StopInterrupt = Object.freeze({
    _debugInfo: "THE-STOP-INTERRUPT"
  });

  TopologyInterrupt = Object.freeze({
    _debugInfo: "THE-TOPOLOGY-INTERRUPT"
  });

  TowardsInterrupt = Object.freeze({
    _debugInfo: "THE-TOWARDS-INTERRUPT"
  });

  interrupts = [DeathInterrupt, StopInterrupt, TopologyInterrupt, TowardsInterrupt];

  // (Any, Any) => Any
  ifInterrupt = function(value, defaultValue) {
    if (interrupts.includes(value)) {
      return defaultValue;
    } else {
      return value;
    }
  };

  module.exports = {ifInterrupt, DeathInterrupt, StopInterrupt, TopologyInterrupt, TowardsInterrupt};

}).call(this);

},{}],"util/iterator":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Iterator;

  module.exports = Iterator = (function() {
    class Iterator {
      
        // (Array[T]) => Iterator[T]
      constructor(_items) {
        this._items = _items;
      }

      // ((T) => Boolean) => Boolean
      all(f) {
        var i, len, ref, x;
        ref = this._items;
        for (i = 0, len = ref.length; i < len; i++) {
          x = ref[i];
          if (!f(x)) {
            return false;
          }
        }
        return true;
      }

      // (T) => Boolean
      contains(x) {
        var i, len, ref, y;
        ref = this._items;
        for (i = 0, len = ref.length; i < len; i++) {
          y = ref[i];
          if (x === y) {
            return true;
          }
        }
        return false;
      }

      // ((T) => Boolean) => Boolean
      exists(f) {
        var i, len, ref, x;
        ref = this._items;
        for (i = 0, len = ref.length; i < len; i++) {
          x = ref[i];
          if (f(x)) {
            return true;
          }
        }
        return false;
      }

      // ((T) => Boolean) => Array[T]
      filter(f) {
        var i, len, ref, results, x;
        ref = this._items;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          x = ref[i];
          if (f(x)) {
            results.push(x);
          }
        }
        return results;
      }

      // (Int) => T
      nthItem(n) {
        return this._items[n];
      }

      // [U] @ ((T) => U) => Array[U]
      map(f) {
        return this._items.map(f);
      }

      // ((T) => Unit) => Unit
      forEach(f) {
        this._items.forEach(f);
      }

      // () => Int
      size() {
        return this._items.length;
      }

      // () => Array[T]
      toArray() {
        return this._items;
      }

      // (Number, (Number, Number) => Boolean) => Boolean
      checkCount(n, check) {
        return check(this._items.length, n);
      }

    };

    Iterator.prototype._items = void 0; // [T] @ Array[T]

    return Iterator;

  }).call(this);

}).call(this);

},{}],"util/jstype":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var JSType;

  /*
  This class should be favored over Lodash when you want quick typechecking that need not be thorough.
  This was made specifically to compensate for the fact that Lodash's typechecking was swapped
  into the sorting code and caused a 25% performance hit in BZ Benchmark. --JAB (4/30/14)
  */
  JSType = class JSType {
    constructor(_x) { // (Any) => JSType
      this._x = _x;
    }

    isArray() {
      return Array.isArray(this._x);
    }

    isBoolean() {
      return typeof this._x === "boolean";
    }

    isFunction() {
      return typeof this._x === "function";
    }

    isNumber() {
      return typeof this._x === "number";
    }

    isObject() {
      return typeof this._x === "object";
    }

    isString() {
      return typeof this._x === "string";
    }

  };

  module.exports = function(x) {
    return new JSType(x);
  };

}).call(this);

},{}],"util/nlmath":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var StrictMath,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  StrictMath = require('../shim/strictmath');

  module.exports = {
    // (Number) => Number
    abs: function(n) {
      return StrictMath.abs(n);
    },
    // (Number) => Number
    acos: function(radians) {
      return StrictMath.toDegrees(StrictMath.acos(radians));
    },
    // (Number) => Number
    asin: function(radians) {
      return StrictMath.toDegrees(StrictMath.asin(radians));
    },
    // (Number, Number) => Number
    atan: function(d1, d2) {
      if (d1 === 0) {
        if (d2 > 0) {
          return 0;
        } else {
          return 180;
        }
      } else if (d2 === 0) {
        if (d1 > 0) {
          return 90;
        } else {
          return 270;
        }
      } else {
        return (StrictMath.toDegrees(StrictMath.atan2(d1, d2)) + 360) % 360;
      }
    },
    // (Number) => Number
    ceil: function(n) {
      return StrictMath.ceil(n);
    },
    // (Number) => Number
    cos: function(degrees) {
      return StrictMath.cos(StrictMath.toRadians(degrees));
    },
    // (Number, Number) => Number
    distance2_2D: function(x, y) {
      return StrictMath.sqrt(x * x + y * y);
    },
    // (Number, Number, Number, Number) => Number
    distance4_2D: function(x1, y1, x2, y2) {
      return this.distance2_2D(x1 - x2, y1 - y2);
    },
    // (Number) => Number
    exp: function(n) {
      return StrictMath.exp(n);
    },
    // (Number) => Number
    floor: function(n) {
      return StrictMath.floor(n);
    },
    // (Number) => Number
    ln: function(n) {
      return StrictMath.log(n);
    },
    // (Number, Number) => Number
    log: function(num, base) {
      return StrictMath.log(num) / StrictMath.log(base);
    },
    // (Number*) => Number
    max: function(...xs) {
      return Math.max(...xs); // Variadic `max` doesn't exist on the Java `Math` object --JAB (9/23/15)
    },
    
    // (Number*) => Number
    min: function(...xs) {
      return Math.min(...xs); // Variadic `min` doesn't exist on the Java `Math` object --JAB (9/15/15)
    },
    
    // (Number, Number) => Number
    mod: function(a, b) {
      return modulo(a, b);
    },
    // (Number) => Number
    normalizeHeading: function(heading) {
      if ((0 <= heading && heading < 360)) {
        return heading;
      } else {
        return ((heading % 360) + 360) % 360;
      }
    },
    // (Number, Number) => Number
    precision: function(n, places) {
      var multiplier, result;
      multiplier = StrictMath.pow(10, NLMath.trunc(places));
      result = StrictMath.floor(n * multiplier + .5) / multiplier;
      if (places > 0) {
        return result;
      } else {
        return StrictMath.round(result);
      }
    },
    // (Number, Number) => Number
    pow: function(base, exponent) {
      return StrictMath.pow(base, exponent);
    },
    // (Number) => Number
    round: function(n) {
      return StrictMath.round(n);
    },
    // (Number) => Number
    sin: function(degrees) {
      return StrictMath.sin(StrictMath.toRadians(degrees));
    },
    // (Number) => Number
    sqrt: function(n) {
      return StrictMath.sqrt(n);
    },
    // (Number) => Number
    squash: function(x) {
      if (StrictMath.abs(x) < 3.2e-15) {
        return 0;
      } else {
        return x;
      }
    },
    // (Number, Number) => Number
    subtractHeadings: function(h1, h2) {
      var diff;
      diff = (h1 % 360) - (h2 % 360);
      if ((-180 < diff && diff <= 180)) {
        return diff;
      } else if (diff > 0) {
        return diff - 360;
      } else {
        return diff + 360;
      }
    },
    // (Number) => Number
    tan: function(degrees) {
      return StrictMath.tan(StrictMath.toRadians(degrees));
    },
    // (Number) => Number
    toInt: function(n) {
      return n | 0;
    },
    trunc: function(n) {
      return StrictMath.trunc(n);
    }
  };

}).call(this);

},{"../shim/strictmath":"shim/strictmath"}],"util/notimplemented":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise

  // [T] @ (String, T) => () => T
  module.exports = function(name, defaultValue = {}) {
    if ((typeof console !== "undefined" && console !== null) && (console.warn != null)) {
      console.warn(`The \`${name}\` primitive has not yet been implemented.`);
    }
    return function() {
      return defaultValue;
    };
  };

}).call(this);

},{}],"util/regex":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var escapeRegEx;

  escapeRegEx = function(s) {
    return s.replace(/[\/\-\\^$*+?.()|[\]{}]/g, '\\$&');
  };

  module.exports = {escapeRegEx};

}).call(this);

},{}],"util/rng":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var RNG, newMersenneTwister;

  ({newMersenneTwister} = require('../shim/random'));

  // We need an auxiliary RNG for non-deterministic RNG events (e.g. code run within monitors),
  // so I sloppily manage what RNG is being used here.  I plan to, soon enough, clean up this
  // mess by deleting this file and replacing it with a proper context-passing system. --JAB (10/17/14)
  module.exports = RNG = (function() {
    class RNG {
      
        // () => RNG
      constructor() {
        // () => Number
        this.nextGaussian = this.nextGaussian.bind(this);
        // (Number) => Number
        this.nextInt = this.nextInt.bind(this);
        // (Number) => Number
        this.nextLong = this.nextLong.bind(this);
        // () => Number
        this.nextDouble = this.nextDouble.bind(this);
        this._mainRNG = newMersenneTwister();
        this._auxRNG = newMersenneTwister();
        this._plotRNG = this._mainRNG.clone();
        this._currentRNG = this._mainRNG;
      }

      // () => String
      exportState() {
        return this._mainRNG.save();
      }

      // (String) => Unit
      importState(state) {
        this._mainRNG.load(state);
      }

      nextGaussian() {
        return this._currentRNG.nextGaussian();
      }

      nextInt(limit) {
        return this._currentRNG.nextInt(limit);
      }

      nextLong(limit) {
        return this._currentRNG.nextLong(limit);
      }

      nextDouble() {
        return this._currentRNG.nextDouble();
      }

      // (Number) => Unit
      setSeed(seed) {
        this._currentRNG.setSeed(seed);
        if (this._currentRNG === this._mainRNG) {
          this._plotRNG.setSeed(seed);
        }
      }

      // [T] @ (() => T) => T
      withAux(f) {
        return this._withAnother(this._auxRNG)(f);
      }

      // [T] @ (() => T) => T
      withPlot(f) {
        return this._withAnother(this._plotRNG)(f);
      }

      // [T] @ (() => T) => T
      withClone(f) {
        return this._withAnother(this._mainRNG.clone())(f);
      }

      // [T] @ (Generator) => (() => T) => T
      _withAnother(rng) {
        return (f) => {
          var prevRNG, result;
          prevRNG = this._currentRNG;
          this._currentRNG = rng;
          result = (function() {
            try {
              return f();
            } finally {
              this._currentRNG = prevRNG;
            }
          }).call(this);
          return result;
        };
      }

    };

    // type Generator = { nextInt: (Number) => Number, nextLong: (Number) => Number, nextDouble: () => Number, setSeed: (Number) => Unit }
    RNG.prototype._currentRNG = void 0; // Generator

    RNG.prototype._mainRNG = void 0; // Generator

    RNG.prototype._auxRNG = void 0; // Generator

    RNG.prototype._plotRNG = void 0; // Generator

    return RNG;

  }).call(this);

}).call(this);

},{"../shim/random":"shim/random"}],"util/shufflerator":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Iterator, Shufflerator;

  Iterator = require('./iterator');

  module.exports = Shufflerator = (function() {
    class Shufflerator extends Iterator {
      
        // [T] @ (Array[T], (T) => Boolean, (Number) => Number) => Shufflerator
      constructor(items, _itemIsValid, _nextInt) {
        super(items);
        this._itemIsValid = _itemIsValid;
        this._nextInt = _nextInt;
        this._i = 0;
        this._nextOne = null;
        this._fetch();
      }

      // [U] @ ((T) => U) => Array[U]
      map(f) {
        var acc;
        acc = [];
        this.forEach(function(x) {
          return acc.push(f(x));
        });
        return acc;
      }

      // ((T) => Unit) => Unit
      forEach(f) {
        var next;
        while (this._hasNext()) {
          next = this._next();
          if (this._itemIsValid(next)) {
            f(next);
          }
        }
      }

      // [U >: T] @ ((T) => Boolean, U) => U
      find(f, dflt) {
        var next;
        while (this._hasNext()) {
          next = this._next();
          if (this._itemIsValid(next) && (f(next) === true)) {
            return next;
          }
        }
        return dflt;
      }

      // () => Array[T]
      toArray() {
        var acc;
        acc = [];
        this.forEach(function(x) {
          return acc.push(x);
        });
        return acc;
      }

      // () => Boolean
      _hasNext() {
        return this._i <= this._items.length;
      }

      // () => T
      _next() {
        var result;
        result = this._nextOne;
        this._fetch();
        return result;
      }

      /*
        I dislike this.  The fact that the items are prepolled annoys me.  But there are two problems with trying to "fix"
        that. First, fixing it involves changing JVM NetLogo/Headless.  To me, that requires a disproportionate amount of
        effort to do, relative to how likely--that is, not very likely--that this code is to be heavily worked on in the
        future.  The second problem is that it's not apparent to me how to you can make this code substantially cleaner
        without significantly hurting performance.  The very idea of a structure that statefully iterates a collection in
        a random order is difficult to put into clear computational terms.  When it needs to be done _efficiently_, that
        becomes even more of a problem.  As far as I can tell, the only efficient way to do it is like how we're doing it
        (one variable tracking the current index/offset, and an array where consumed items are thrown into the front).
        Whatever.  The whole point is that this code isn't really worth worrying myself over, since it's pretty stable.
        --JAB (7/25/14)
      */
      // () => Unit
      _fetch() {
        var randNum;
        if (this._hasNext()) {
          if (this._i < this._items.length - 1) {
            randNum = this._i + this._nextInt(this._items.length - this._i);
            this._nextOne = this._items[randNum];
            this._items[randNum] = this._items[this._i];
          } else {
            this._nextOne = this._items[this._i];
          }
          this._i++;
          if (!this._itemIsValid(this._nextOne)) {
            this._fetch();
          }
        } else {
          this._nextOne = null;
        }
      }

    };

    Shufflerator.prototype._i = void 0; // Number

    Shufflerator.prototype._nextOne = void 0; // T

    return Shufflerator;

  }).call(this);

}).call(this);

},{"./iterator":"util/iterator"}],"util/stablesort":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var rangeUntil, zip;

  ({zip} = require('brazierjs/array'));

  ({rangeUntil} = require('brazierjs/number'));

  // [T] @ (Array[(T, U)]) => ((U, T) => Int) => Array[T]
  module.exports = function(arr) {
    return function(f) {
      var pairs, sortFunc;
      sortFunc = function(x, y) {
        var result;
        // The JS `Array.sort()` implementation flips the arguments relative to what you'd expect: if you're array is [0 2 4] the first two arguments
        // to your `f` will be (2, 0).  That's not a big deal for results, but it is a big deal for getting error messages to be identical to desktop by
        // argument position.  So we flip the result back the other way with `-1 * result`.
        // -Jeremy B February 2021
        result = f(y[1], x[1]);
        if (result !== 0) {
          return -1 * result;
        } else if (x[0] < y[0]) {
          return -1;
        } else {
          return 1;
        }
      };
      pairs = zip(rangeUntil(0)(arr.length))(arr);
      return pairs.sort(sortFunc).map(function(pair) {
        return pair[1];
      });
    };
  };

}).call(this);

},{"brazierjs/array":"brazier/array","brazierjs/number":"brazier/number"}],"util/timer":[function(require,module,exports){
(function() {
  // (C) Uri Wilensky. https://github.com/NetLogo/Tortoise
  var Timer;

  module.exports = Timer = (function() {
    class Timer {
      // () => Timer
      constructor() {
        this.reset();
      }

      // () => Number
      elapsed() {
        return (Date.now() - this._startTime) / 1000;
      }

      // () => Unit
      reset() {
        this._startTime = Date.now();
      }

    };

    // Number
    Timer.prototype._startTime = void 0;

    return Timer;

  }).call(this);

}).call(this);

},{}]},{},["bootstrap"]);
